<!DOCTYPE html>
<html lang="en" class="notranslate" translate="no">

<head>
  <meta charset="UTF-8">
  <title>ClearCurve Next - Nvexx 2025</title>
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/css/bootstrap.min.css'>
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css'>
  <link rel='stylesheet'
    href='https://cdnjs.cloudflare.com/ajax/libs/simple-line-icons/2.5.5/css/simple-line-icons.min.css'>
  <link rel="stylesheet" href="./style.css">
  <meta name="googlebot" content="notranslate" />
</head>

<body data-theme="dark">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    //ALL SETTINGS GO HERE
    const nextversion = "ClearCurve Next 0.0.1 - 05-09-2025 @ 15:20";
    // ClearCurve
    let isClearCurve = true;
    // DEFAULT
    var startFrequency = 10; // End frequency for amplitude correction filters (max. 20Khz)
    var endFrequency = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // MAINS > FRONTS
    var startFrequencyF = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyF = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // MAINS > CENTER
    var startFrequencyC = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyC = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // SURROUNDS
    var startFrequencySur = 10; // Start frequency for amplitude correction filters
    var mergeFrequencySur = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // SURROUNDS > BACK/REAR
    var startFrequencySurB = 10; // Start frequency for amplitude correction filters
    var mergeFrequencySurB = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // SURROUNDS > BACK/REAR SINGLE
    var startFrequencySurBS = 10; // Start frequency for amplitude correction filters
    var mergeFrequencySurBS = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // WIDE
    var startFrequencyFW = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyFW = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // HEIGHTS > FRONT
    var startFrequencyFH = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyFH = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // HEIGHTS > SURROUND
    var startFrequencySH = 10; // Start frequency for amplitude correction filters
    var mergeFrequencySH = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // HEIGHTS > SURROUND REAR
    var startFrequencyRH = 10; // Start frequency for amplitude correction filters (max. 20Khz)
    var mergeFrequencyRH = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // TOPS > FRONT
    var startFrequencyTF = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyTF = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // TOPS > MIDDLE
    var startFrequencyTM = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyTM = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // TOPS > REAR
    var startFrequencyTR = 10; // Start frequency for amplitude correction filters (max. 20Khz)
    var mergeFrequencyTR = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // DOLBY BOUNCE > FRONT
    var startFrequencyFD = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyFD = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // DOLBY BOUNCE > SURROUND
    var startFrequencySD = 10; // Start frequency for amplitude correction filters
    var mergeFrequencySD = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // DOLBY BOUNCE > BACK
    var startFrequencyBD = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyBD = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // AURO-3D > TOP SURROUND
    var startFrequencyTS = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyTS = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // AURO-3D > CENTER HEIGHT
    var startFrequencyCH = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyCH = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // SUBWOOFER SETTINGS
    // SUBWOOFER SETTINGS
    var sw1_filterfreq_merge = 250;
    var sw2_filterfreq_merge = 250;
    var sw3_filterfreq_merge = 250;
    var sw4_filterfreq_merge = 250;
    const modelsSoS300 = ["-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011", "SR6011", "C-A110", "X3700H", "X4700H", "X6500H", "X6700H",
      "X8500H", "R-A110", "-S730H", "-S740H", "-S750H", "-S760H", "-S930H", "-S940H", "-S950H", "-S960H", "X1400H", "X1500H", "X1600H",
      "X1700H", "X2400H", "X2500H", "X2600H", "X2700H", "X3400H", "X3500H", "X3600H", "X3700H", "X4300H", "X4400H", "X4500H", "X4700H",
      "X6300H", "X6400H", "X6500H", "X6700H", "X8500H", "AV7703", "AV7704", "AV7705", "AV7706", "AV8805", "NR1608", "NR1609", "NR1710",
      "NR1711", "SR5012", "SR5013", "SR5014", "SR5015", "SR6012", "SR6013", "SR6014", "SR6015", "SR7011", "SR7012", "SR7013", "SR7015",
      "SR8012", "SR8015"];
    const micCalProb = ["-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011",
      "-S730H", "-S740H", "-S750H", "-S760H", "-S930H", "-S940H", "-S950H",
      "-S960H", "X1400H", "X1500H", "X1600H", "X1700H", "X2400H", "X2500H",
      "X2600H", "X2700H", "X3400H", "X3500H", "X3600H", "NR1608", "NR1609",
      "NR1710", "NR1711", "SR5012", "SR5013", "SR5014", "SR5015", "SR6013",
      "SR6014", "-S770H", "-S970H", "X1800H", "X2800H", "EMA 60", "MA 70s"];
    const noxo180 = ["-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011", "SR6011", "X6500H", "-S730H", "-S740H", "-S930H", "-S940H",
      "X1400H", "X1500H", "X2400H", "X2500H", "X3400H", "X3500H", "X4300H", "X4400H", "X4500H", "X6300H", "X6400H", "X6500H", "AV7703",
      "AV7704", "AV7705", "NR1608", "NR1609", "SR5012", "SR5013", "SR6012", "SR6013", "SR7011", "SR7012", "SR7013", "SR8012"];
    const models70xo = ["A-900H", "MA 70S", "-S970H", "X2800H", "-S670H", " AV 10", " AV 20", "VR-A1H", "VC-A1H", "X3800H", "X4800H",
      "EMA 30", "EMA 40", "EMA 50", "X6800H", "R-A10H", "C-A10H"];

    const baseUrl = 'http://localhost:4735/measurements', retryDelay = 500;
    let adyContents, fileName, sOs, isCirrusLogic, flDist, nChannels, nSpeakers, nSubs, noCenter;
    let targetCurvePath, targetCurveName, targetResponse, noInversion = false, swInvMsg = "";
    let bassMode = "Standard", noSub = false, subLoTrim, subHiTrim, subLoDelay, subHiDelay;
    let minXO = 40, maxXO = 250, previousDelay = null, swChannelCount = 0;
    const freqIndex = [40, 60, 80, 90, 100, 110, 120, 150, 200, 250];
    const customLevel = [], customDistance = [], customCrossover = [];
    const mSec = [], invertSub = [], commandId = [];
    const m3dBPoints = {};
    let targetLevel = 75.0; // Audyssey typically calibrates to 75 dB SPL
    let isCirrusLogictargetLevel = 78.0; // -3db
    // Advanced sorting check and correction
    let needsSorting = false;
    let expectedOrder = [];
    // MODES
    let isDarkMode = true; // start script in Darkmode 
    let isDolbymode = false; // calibrationSPL: 82, peakSPL: 105, subPeakSPL: 115 
    let isTHXmode = false; // calibrationSPL: 85, peakSPL: 105, subPeakSPL: 115
    let isIMAXmode = false; // calibrationSPL: 100, peakSPL: 100, subPeakSPL: 115
    let supportsIMAX = false; // explicit IMAX support variable
    let modeSubXOMin = 31.5; // highest low of them all
    let modeSubXOMax = 120; // highest high of them all
    let modeSpkMin = 20; // lowest low.
    let modeSpkMax = 20000; // highest high.
    // Dyslexic Mode
    let isDyslexicMode = false; // DyslexicMode off by default
    // cedia specific
    let isRP22mode = false; // calibrationSPL: 'performance-based', peakSPL: 105, subPeakSPL: 115
    let RP22subnminXO;
    let RP22submaxXO;
    let RP22subrequiredDelay;
    let RP22hasAtmos;
    let RP22hasDTSX;
    let RP22hasAURO3D;
    // CREATE ARRAY TO STORE ESTIMATED PLAYBACK LEVELS
    let estimatedPlaybackLevels = [];
    // CREATE ARRAY TO STORE ESTIMATED DISTANCES
    let estimatedDistances = [];
    // CREATE ARRAY TO STORE FINAL XO'S DISTANCES 
    let RP22BestXO = [];
    // CONDENCED VERSION
    let AdvancedFilters = false;
    let AdvancedFiltersType = "null";
    // SPEED DELAY BASED ON CPU CORES LIKE BEFORE
    // Add delay based on CPU cores ("logical")
    // Don't have to set speedDelay each time anymore!
    var cores = 1;
    const getOptimalDelay = () => {
      cores = navigator.hardwareConcurrency || 1; // Fallback to 1 if undefined
      let delay;

      if (cores <= 1) {
        delay = 256;
      } else if (cores <= 2) {
        delay = 236;
      } else if (cores <= 4) {
        delay = 216;
      } else if (cores <= 8) {
        delay = 196;
      } else if (cores <= 12) {
        delay = 176;
      } else if (cores <= 16) {
        delay = 156;
      } else if (cores <= 24) {
        delay = 136;
      } else if (cores <= 32) {
        delay = 116;
      } else {
        delay = 256;
      }
      console.warn(`Detected ${cores} logical CPU core(s). Assigned delay: ${delay}ms`);
      return delay;
    };
    let speedDelay = getOptimalDelay();
    // store more AVR default values
    let lfcSupport;
    let enMultEQType;
    let auro;
    let dolbyVersion;
    let dynamicEq;
    let dynamicVolume;
    let lfc;
    let subwooferNum;
    let subwooferLayout;
    //
    let hasHeightChannel = false;
    const heightChannelIds = ["FHL", "RHL", "SHL", "TFL", "TML", "TRL", "BDL", "FDL", "SDL", "TS", "CH"];
  </script>
  <!-- partial -->
  <script src="./script.js"></script>
  <!-- partial:index.partial.html -->
  <div class="container">
    <div class="form-container">
      <div class="form-header">
        <div class="theme-toggle">
          <!--<span class="theme-label">☀️</span>-->
          <div class="toggle-switch active" id="themeToggle">
            <div class="toggle-slider">☀️</div>
          </div>
          <!--<span class="theme-label">🌙</span>-->
        </div>

        <div class="font-toggle">
          <!--<span class="theme-label">☀️</span>-->
          <div class="toggle-switch active" id="dyslexicToggle">
            <div class="toggle-slider">🔤</div>
          </div>
          <!--<span class="theme-label">🌙</span>-->
        </div>

        <h2><img src="https://www.nvexx.nl/audyssey/nvexx_128.png" class="centerimg" alt="Nvexx logo" />ClearCurve Next
        </h2>
        <p class="text-muted">Your room curve generator</p>
        <noscript>
          <div style="color: red; padding: 10px; border: 1px solid red;">
            JavaScript is disabled in your browser. Please enable it for full functionality.
          </div>
        </noscript>
      </div>

      <div class="progress">
        <div class="progress-bar" role="progressbar" style="width: 0%"></div>
      </div>

      <div class="step-indicator">
        <div class="step-line"></div>
        <div class="step-circle active">1</div>
        <div class="step-circle">2</div>
        <div class="step-circle">3</div>
        <div class="step-circle">4</div>
        <div class="step-circle">5</div>
        <div class="step-circle">6</div>
        <div class="step-circle">7</div>
        <div class="step-circle">8</div>
        <div class="step-circle">9</div>
        <div class="step-circle">10</div>
        <div class="step-circle">11</div>
        <!--<div class="step-circle">12</div>
        <div class="step-circle">13</div>
        <div class="step-circle">14</div>-->
      </div>

      <form id="multiStepForm">
        <!-- Step 1: Basic settings 
        <div class="form-step active" data-step="1">
          <h3 class="mb-4">Basic settings</h3>
          <div class="mb-4">
            <ul>
              <li>Default settings will be used for ClearCurve Next</li>
              <ul>
                <li>Be sure to have your favorite curve set in REW</li>
              </ul>
            </ul>
          </div>
          <div class="row g-4">
            <div class="col-md-4">
              <label for="radio_home_cinema">Home Cinema (75dB)</label><br>
              <input type="radio" id="radio_home_cinema" name="cinema_type" value="75" required checked="checked"
                disabled>
            </div>
            <!-
            <div class="col-md-4">
              <label for="radio_professional_cinema">Professional Cinema (85dB)</label><br>
              <input type="radio" id="radio_professional_cinema" name="cinema_type" value="85">
            </div>
            <div class="col-md-4">
              <label for="radio_professional_cinema">Cedia RP22 mode!</label><br>
              <input type="radio" id="radio_cedia_cinema" name="cinema_type" value="85.1">
            </div>
          ->
          </div>

          <br />
          <div class="row g-4">
            <div class="col-md-4">
              <label for="radio_home_cinema">Sub inversion allowed</label><br>
              <input type="radio" id="radio_home_cinema" name="sub_inversion" value="0" required checked="checked"
                disabled>
            </div>
            <!-
            <div class="col-md-4">
              <label for="radio_professional_cinema">Sub inversion NOT! allowed!</label><br>
              <input type="radio" id="radio_professional_cinema" name="sub_inversion" value="1">
            </div>
          ->
          </div>

          <br />
          <div class="row g-4">
            <div class="col-md-4">
              <label for="radio_script_mode_auto">Fully automatic</label><br>
              <input type="radio" id="radio_script_mode_auto" name="script_mode" value="0" required checked="checked"
                disabled>
            </div>
            <!-
            <div class="col-md-4">
              <label for="radio_script_mode_manual">Manual mode (manually select the next step)</label><br>
              <input type="radio" id="radio_script_mode_manual" name="script_mode" value="1">
            </div>
          ->
          </div>

          <!-
          <br />
          <div class="row g-4">
            <h3 class="mb-4">Advanced Filters</h3>
            <div class="col-md-4">
              <label for="radio_script_af_off">Advanced Filters OFF</label><br>
              <input type="radio" id="radio_script_af_off" name="script_af" value="0" required checked="checked">
            </div>
            <div class="col-md-4">
              <label for="radio_script_af_on">Advanced Filters ON</label><br>
              <input type="radio" id="radio_script_af_on" name="script_af" value="1">
            </div>
          </div>

          <div class="row g-4">
            <div class="col-md-4">
              <label for="script_af_type">Advanced Filters Type</label><br>
              <select name="script_af_type" id="script_af_type">
                <option value="null" selected>none</option>
                <option value="DIALOGadvanced">Advanced Dialog Enhancement - CEDIA RP22</option>
                <option value="HLOSSresearch">Hearing Loss >> Research-Based Hearing Loss Compensation (presbycusis
                  patterns)</option>
                <option value="HLOSSmoderate">Hearing Loss >> Moderate Hearing Loss Compensationmoderate (mild hearing
                  loss)</option>
                <option value="HLOSSsevere">Hearing Loss >> Severe Hearing Loss Compensation (⚠️high gains)</option>
                <option value="HLOSSoriginal">Hearing Loss >> original / ClariQ Next 0.0.3 values</option>
                <option value="GAMINGcompetitive">Gaming >> Competitive Gaming EQ (Footsteps & Tactical Audio)</option>
                <option value="GAMINGimmersive">Gaming >> Immersive Gaming EQ (Cinematic Experience)</option>
                <option value="GAMINGvoice">Gaming >> Voice Chat Gaming EQ (Clear Communication)</option>
                <option value="GAMINGbalanced">Gaming >> Balanced Gaming EQ (All-Purpose)</option>
              </select>
            </div>
          </div>
         ->

          <br />
          <div class="mb-4">
            <h3 class="mb-4 warning">Usage</h3>
            <ul>
              <li>Download and install the free room correction software Room EQ Wizard (v5.40
                Beta) on
                your computer
                <ul>
                  <li class="small-bullet">Download link for the latest REW Beta version: <a
                      href="https://www.avnirvana.com/threads/rew-api-beta-releases.12981/" target="_blank">here</a>
                  </li>
                </ul>
              </li>
              <li>Choose your preffered Basic settings</li>
              <li>When done click the '[.ady]' button below to go to the next step.</li>
            </ul>
          </div>
          <div class="d-flex justify-content-end mt-4">
            <button type="button" class="btn btn-primary btn-nav next-step">.ady file</button>
          </div>
        </div>
      -->
        <!-- Step 1: Basic settings -->
        <div class="form-step active" data-step="1">
          <h3 class="mb-4">Basic settings</h3>
          <div class="mb-4">
            <ul>
              <li>Sub inversion allowed</li>
              <ul>
                <li>Can or are you willing to physically change subwoofer polarity?</li>
              </ul>
            </ul>
            <ul>
              <li>Script mode</li>
              <ul>
                <li>Full auto - the script goes through each step</li>
                <li>Manual - allows you to go through each step manually. (button clicks)</li>
              </ul>
            </ul>
          </div>

          <hr />
          <div class="row g-4">
            <div class="col-md-4">
              <label for="radio_home_cinema">Sub inversion allowed</label><br>
              <input type="radio" id="radio_home_cinema" name="sub_inversion" value="0" required checked="checked"
                disabled>
            </div>
            <!--
            <div class="col-md-4">
              <label for="radio_professional_cinema">Sub inversion NOT! allowed!</label><br>
              <input type="radio" id="radio_professional_cinema" name="sub_inversion" value="1">
            </div>
          -->
          </div>

          <hr />
          <div class="row g-4">
            <div class="col-md-4">
              <label for="radio_script_mode_auto">Fully automatic</label><br>
              <input type="radio" id="radio_script_mode_auto" name="script_mode" value="0" required checked="checked"
                disabled>
            </div>
            <!--
            <div class="col-md-4">
              <label for="radio_script_mode_manual">Manual mode (manually select the next step)</label><br>
              <input type="radio" id="radio_script_mode_manual" name="script_mode" value="1">
            </div>
          -->
          </div>

          <hr />
          <div class="row g-4">
            <h3 class="mb-4">Advanced Filters</h3>
            <div class="col-md-4">
              <label for="radio_script_af_off">Advanced Filters OFF</label><br>
              <input type="radio" id="radio_script_af_off" name="script_af" value="0" required checked="checked"
                disabled>
            </div>
            <!--
            <div class="col-md-4">
              <label for="radio_script_af_on">Advanced Filters ON</label><br>
              <input type="radio" id="radio_script_af_on" name="script_af" value="1">
            </div>
          -->
          </div>

          <div class="row g-4">
            <div class="col-md-4">
              <label for="script_af_type">Advanced Filters Type</label><br>
              <select name="script_af_type" id="script_af_type" disabled>
                <option value="null" selected>none</option>
                <option value="DIALOGadvanced">Advanced Dialog Enhancement - CEDIA RP22</option>
                <option value="HLOSSresearch">Hearing Loss >> Research-Based Hearing Loss Compensation (presbycusis
                  patterns)</option>
                <option value="HLOSSmoderate">Hearing Loss >> Moderate Hearing Loss Compensationmoderate (mild hearing
                  loss)</option>
                <option value="HLOSSsevere">Hearing Loss >> Severe Hearing Loss Compensation (⚠️high gains)</option>
                <option value="HLOSSoriginal">Hearing Loss >> original / ClariQ Next 0.0.3 values</option>
                <option value="GAMINGcompetitive">Gaming >> Competitive Gaming EQ (Footsteps & Tactical Audio)</option>
                <option value="GAMINGimmersive">Gaming >> Immersive Gaming EQ (Cinematic Experience)</option>
                <option value="GAMINGvoice">Gaming >> Voice Chat Gaming EQ (Clear Communication)</option>
                <option value="GAMINGbalanced">Gaming >> Balanced Gaming EQ (All-Purpose)</option>
              </select>
            </div>
          </div>

          <br />
          <div class="mb-4">
            <h3 class="mb-4 warning">Usage</h3>
            <ul>
              <li>Download and install the free room correction software Room EQ Wizard (v5.40
                Beta) on
                your computer
                <ul>
                  <li class="small-bullet">Download link for the latest REW Beta version: <a
                      href="https://www.avnirvana.com/threads/rew-api-beta-releases.12981/" target="_blank">here</a>
                  </li>
                </ul>
              </li>
              <li>Choose your preffered Basic settings</li>
              <li>When done click the '[.ady]' button below to go to the next step.</li>
            </ul>
          </div>
          <div class="d-flex justify-content-end mt-4">
            <button type="button" class="btn btn-primary btn-nav next-step">.ady file</button>
          </div>
        </div>

        <!-- Step 2: Professional Experience 
        <div class="form-step" data-step="2">
          <h3 class="mb-4">.ady file</h3>
          <div class="mb-4">
            <ul>
              <li>upload your .ady file here</li>
              <ul>
                <li>browse to the Audyssey calibration file (.ady) generated by the MultEQ Editor (IOS/Android) app</li>
                <li>When prompted, download and 'save' the .zip (measurements) on your computer. Make sure the zip file
                  is unblocked: right-click > properties > unblock</li>
                <li>Start REW, go to the 'EQ' / 'House Curve', and select a target curve of your choice</li>
                <li>Open the zip file and select ALL (keyboard shortcut: "CTRL+A" for Windows / "Command+A" for Mac) the
                  files in that folder</li>
                <li>Left click on the selection (inside the .zip file) and drag & drop them onto REW. Wait until all
                  measurements are imported
                  and '[SPL Adjustments →]' button is enabled</li>
              </ul>
              <li>You can also use custom measurements with ClearCurve Next!</li>
              <li>Be sure to use the same measurements you will use with with ClariQ Next!</li>
              <ul>
                <li>naming still needs to follow $0/1/2/3/4/5/6/7/8/9/10/11/12/13/14/15 etc for normal speakers</li>
                <li>naming still needs to follow SW10/11/12/13/14/15/16/17/18/19/110/111/112/113/114/115 etc for
                  subwoofers</li>
                <li>naming still needs to follow SW20/21/22/23/24/25/26/27/28/29/210/211/212/213/214/215 etc for
                  subwoofers</li>
                <li>the order in REW doesn't matter only the naming (custom sorting by ClariQ Next)</li>
              </ul>
              <li>Merge Range Selector</li>
              <ul>
                <li>once your .ady is uploaded and the measurements are loaded into REW the Merge Range Selector
                  will be availble</li>
                <ul>
                  <li>Select a "preferred range" to where the curve is merged with your speakers response</li>
                </ul>
              </ul>

            </ul>
            <li><strong class="warning">Please keep REW on 'SPL & Phase' tab and stay on this web page until
                optimization
                is
                completed!</strong></li>
            </ul>
            <br />
            <label class="form-label" id="resumeUploadlabel" for="resumeUpload">.ady Upload</label>
            <div class="file-upload" id="resumeUpload">
              <input type="file" id="resume" class="d-none" accept=".ady">
              <div class="upload-content">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor"
                  class="bi bi-cloud-upload mb-3" viewBox="0 0 16 16">
                  <path fill-rule="evenodd"
                    d="M4.406 1.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 2 5.166 4.579C14.758 4.804 16 6.137 16 7.773 16 9.569 14.502 11 12.687 11H10a.5.5 0 0 1 0-1h2.688C13.979 10 15 8.988 15 7.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 2.825 10.328 1 8 1a4.53 4.53 0 0 0-2.941 1.1c-.757.652-1.153 1.438-1.153 2.055v.448l-.445.049C2.064 4.805 1 5.952 1 7.318 1 8.785 2.23 10 3.781 10H6a.5.5 0 0 1 0 1H3.781C1.708 11 0 9.366 0 7.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383z" />
                  <path fill-rule="evenodd"
                    d="M7.646 4.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707V14.5a.5.5 0 0 1-1 0V5.707L5.354 7.854a.5.5 0 1 1-.708-.708l3-3z" />
                </svg>
                <p class="mb-1">Drag and drop your ADY here</p>
                <p class="text-muted small">or click to browse (ADY)</p>
              </div>
            </div>

            <!- Slider container - initially hidden, will be shown after .ady processing ->
            <div class="slider-container" style="display: none;">
              <h3 class="mb-4">Merge Range Selector</h3>
              <ul>
                <li>Select a "preferred range" from the index values</li>
                <ul>
                  <li>This will be the range where the curve is leading</li>
                  <li>After the set range your speaers will be leading!.</li>
                </ul>
              </ul>
              <div class="values-display">
                <div class="value-item">
                  Min: <span class="min-value" id="minValue"></span>
                </div>
                <div class="value-item">
                  Max: <span class="max-value" id="maxValue"></span>
                </div>
                <div class="range-info">
                  Range: <span id="rangeValue"></span> |
                  Indices: <span id="indicesValue"></span>
                </div>
              </div>

              <div class="slider-wrapper">
                <div class="slider-track">
                  <div class="slider-range" id="sliderRange"></div>
                </div>
                <div class="slider-handle min" id="minHandle"></div>
                <div class="slider-handle max" id="maxHandle"></div>

                <div class="slider-ticks" id="sliderTicks"></div>
              </div>
            </div>

          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">SPL Adjustments →</button>
          </div>
        </div>
      -->

        <!-- Step 2: Professional Experience -->
        <div class="form-step" data-step="2">
          <div class="mb-4" id="BMs">
            <h3 class="mb-4">Basic Measurement settings</h3>
            <ul>
              <li>Measurement mode</li>
              <ul>
                <li>Home Cinema (75dB -SPL) default</li>
                <ul>
                  <li>Subwoofer 30hz - 80Hz</li>
                  <li>Speakers 20hz - 20kHz</li>
                </ul>
                <li>Dolby mode (82dB -SPL)</li>
                <ul>
                  <li>Subwoofer 31.5hz - 120Hz</li>
                  <li>Speakers 40hz - 16kHz</li>
                </ul>
                <li>THX mode (85dB -SPL)</li>
                <ul>
                  <li>Subwoofer 20hz - 120Hz</li>
                  <li>Speakers 80hz - 20kHz</li>
                </ul>
                <li>IMAX mode (100dB -SPL)</li>
                <ul>
                  <li>Subwoofer 20hz - 70Hz</li>
                  <li>Speakers 70hz - 20kHz</li>
                  <li>AVR specific!</li>
                </ul>
                <li>Cedia RP22 mode (85dB -SPL)</li>
                <ul>
                  <li>Subwoofer -hz - -Hz / performance based</li>
                  <li>Speakers -hz - -Hz / performance based</li>
                </ul>
              </ul>
            </ul>
          </div>
          <div class="mb-4" id="adyf">
            <h3 class="mb-4">.ady file</h3>
            <ul>
              <li>upload your .ady file here</li>
              <ul>
                <li>browse to the Audyssey calibration file (.ady) generated by the MultEQ Editor (IOS/Android) app
                </li>
                <li>When prompted, download and 'save' the .zip (measurements) on your computer. Make sure the zip
                  file
                  is unblocked: right-click > properties > unblock</li>
                <li>Start REW, go to the 'EQ' / 'House Curve', and select a target curve of your choice</li>
                <li>Open the zip file and select ALL (keyboard shortcut: "CTRL+A" for Windows / "Command+A" for Mac)
                  the
                  files in that folder</li>
                <li>Left click on the selection (inside the .zip file) and drag & drop them onto REW. Wait until all
                  measurements are imported
                  and '[SPL Adjustments →]' button is enabled</li>
              </ul>
              <li>You can also use custom measurements with ClariQ Next!</li>
              <ul>
                <li>naming still needs to follow $0/1/2/3/4/5/6/7/8/9/10/11/12/13/14/15 etc for normal speakers</li>
                <li>naming still needs to follow SW10/11/12/13/14/15/16/17/18/19/110/111/112/113/114/115 etc for
                  subwoofers</li>
                <li>naming still needs to follow SW20/21/22/23/24/25/26/27/28/29/210/211/212/213/214/215 etc for
                  subwoofers</li>
                <li>the order in REW doesn't matter only the naming (custom sorting by ClariQ Next)</li>
              </ul>
              <li>Frequency Range Selector</li>
              <ul>
                <li>once your .ady is uploaded and the measurements are loaded into REW the Frequency Range Selector
                  will be availble</li>
                <ul>
                  <li>Select a "preferred range" from the frequency index values supported by your AVR</li>
                  <ul></ul>
                  <li>* The final range used will depend on your suboofer(s) capabilities</li>
                </ul>
              </ul>
            </ul>
          </div>
          <hr />
          <div class="row g-4">
            <strong class="error" id="unlock_cinema_modes">Please upload your .ady and import your measurements into
              REW</strong>
            <div class="col-md-4">
              <label for="radio_home_cinema">Home Cinema (75dB)</label><br>
              <input type="radio" id="radio_home_cinema" name="cinema_type" value="75" required checked="checked">
            </div>
            <!--
            <div class="col-md-4">
              <label for="radio_professional_cinema">Dolby mode!</label><br>
              <input type="radio" id="radio_dolby_cinema" name="cinema_type" value="85.2" disabled>
            </div>
            <div class="col-md-4">
              <label for="radio_professional_cinema">Cedia RP22 mode!</label><br>
              <input type="radio" id="radio_cedia_cinema" name="cinema_type" value="85.1" disabled>
            </div>
            <div class="col-md-4">
              <label for="radio_professional_cinema">THX mode!</label><br>
              <input type="radio" id="radio_thx_cinema" name="cinema_type" value="85.3" disabled>
            </div>
            <div class="col-md-4">
              <label for="radio_professional_cinema">IMAX mode!</label><br>
              <input type="radio" id="radio_imax_cinema" name="cinema_type" value="85.4" disabled>
            </div>
          -->
          </div>

          <hr />
          <li><strong class="warning">Please keep REW on 'SPL & Phase' tab and stay on this web page until
              optimization
              is
              completed!</strong></li>
          </ul>
          <br />
          <label class="form-label" id="resumeUploadlabel" for="resumeUpload">.ady Upload</label>
          <div class="file-upload" id="resumeUpload">
            <input type="file" id="resume" class="d-none" accept=".ady">
            <div class="upload-content">
              <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor"
                class="bi bi-cloud-upload mb-3" viewBox="0 0 16 16">
                <path fill-rule="evenodd"
                  d="M4.406 1.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 2 5.166 4.579C14.758 4.804 16 6.137 16 7.773 16 9.569 14.502 11 12.687 11H10a.5.5 0 0 1 0-1h2.688C13.979 10 15 8.988 15 7.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 2.825 10.328 1 8 1a4.53 4.53 0 0 0-2.941 1.1c-.757.652-1.153 1.438-1.153 2.055v.448l-.445.049C2.064 4.805 1 5.952 1 7.318 1 8.785 2.23 10 3.781 10H6a.5.5 0 0 1 0 1H3.781C1.708 11 0 9.366 0 7.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383z" />
                <path fill-rule="evenodd"
                  d="M7.646 4.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707V14.5a.5.5 0 0 1-1 0V5.707L5.354 7.854a.5.5 0 1 1-.708-.708l3-3z" />
              </svg>
              <p class="mb-1">Drag and drop your ADY here</p>
              <p class="text-muted small">or click to browse (ADY)</p>
            </div>
          </div>

          <!-- BED LAYER Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container bed-layer" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - BED LAYER</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li>The final range used will depend on your subwoofer(s) capabilities</li>
                <li>We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-bed"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-bed"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-bed"></span> |
                Indices: <span id="indicesValue-bed"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-bed"></div>
              </div>
              <div class="slider-handle min" id="minHandle-bed"></div>
              <div class="slider-handle max" id="maxHandle-bed"></div>

              <div class="slider-ticks" id="sliderTicks-bed"></div>
            </div>
          </div>

          <!-- HEIGHT LAYER Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container height-layer" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - HEIGHT LAYER</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li>The final range used will depend on your subwoofer(s) capabilities</li>
                <li>We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-height"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-height"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-height"></span> |
                Indices: <span id="indicesValue-height"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-height"></div>
              </div>
              <div class="slider-handle min" id="minHandle-height"></div>
              <div class="slider-handle max" id="maxHandle-height"></div>

              <div class="slider-ticks" id="sliderTicks-height"></div>
            </div>
          </div>


          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">SPL Adjustments →</button>
          </div>
        </div>

        <!-- Step 3: Portfolio & Resume -->
        <div class="form-step" data-step="3">
          <h3 class="mb-4">SPL Adjustments</h3>
          <div class="mb-4">
            <ul>
              <li>
                <span id="target-level-display">Select cinema type to see target level</span>
              </li>
              <li>Makes it easier to read in REW</li>
              <ul>
                <li>Takes into account original MJ 120dB spl offsets</li>
                <li>Takes into account original MJC 78dB spl offsets</li>
                <li>Takes into account custom measurements</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">BootUP →</button>
          </div>
        </div>

        <!-- Step 4: Additional Information -->
        <div class="form-step" data-step="4">
          <h3 class="mb-4">Bootup</h3>
          <div class="mb-4">
            <ul>
              <li>Here we go.. Be patient!</li>
              <li>Applying Audyssey microphone calibration file to measurements if needed</li>
              <li>Resets, IR windows, EQ target shape, room curve settings and equalizer to
                'Generic/Generic' for all measurements..</li>
              <li>Checking measurement names, indices and sorting</li>
              <ul>
                <li>Custom sorting if custom measurements are not correctly sorted</li>
                <li>ClariQ Next sorting, the standard REW A-Z sorting doesn't suffice!</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">GroundWorks →</button>
          </div>
        </div>

        <!-- Step 5: Additional Information -->
        <div class="form-step" data-step="5">
          <h3 class="mb-4">Groundworks</h3>
          <div class="mb-4">
            <ul>
              <li>Optimizes speaker volume & time alignment</li>
              <ul>
                <li>based on #measurement count per speaker (microphone positions)</li>
              </ul>
              <li>Aligns multi-subwoofer setups</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Speaker Calibration →</button>
          </div>
        </div>

        <!-- Step 6: Main Speaker Calibration Function -->
        <div class="form-step" data-step="6">
          <h3 class="mb-4">Speaker Calibration</h3>
          <div class="mb-4">
            <ul>
              <li>Calculates speaker(s) -3dB points against target curve</li>
              <ul>
                <li>calculates availble bandwidth</li>
                <li>sets "estimated" XO range based on available bandwidth</li>
                <ul>
                  <li>can be a bit optimisitc, can be adjusted by using the slider range</li>
                </ul>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Subwoofer Calibration →</button>
          </div>
        </div>

        <!-- Step 7: Subwoofer(s) Calibration Function -->
        <div class="form-step" data-step="7">
          <h3 class="mb-4">Subwoofer Calibration</h3>
          <div class="mb-4">
            <ul>
              <li>Calculates subwoofer(s) -3dB points against target curve</li>
              <ul>
                <li>calculates availble bandwidth</li>
                <li>sets appropriate XO range based on available bandwidth</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Generate speaker curves →</button>
          </div>
        </div>

        <!-- Step 8: Generate speaker curves -->
        <div class="form-step" data-step="8">
          <h3 class="mb-4">Generate Speaker Curves</h3>
          <div class="mb-4">
            <ul>
              <li>Generates speaker curves</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Generate subwoofer(s) curves →</button>
          </div>
        </div>

        <!-- Step 9: Generate subwoofer curves -->
        <div class="form-step" data-step="9">
          <h3 class="mb-4">Generate Subwoofer curves</h3>
          <div class="mb-4">
            <ul>
              <li>Generates subwoofer(s) curves</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Generate AVG Curves
              →</button>
          </div>
        </div>

        <!-- Step 10: Generate AVG Curves -->
        <div class="form-step" data-step="10">
          <h3 class="mb-4">Generate AVG Curves</h3>
          <div class="mb-4">
            <ul>
              <li>Generate AVG Curves</li>
              <ul>
                <li>Averaging between speaker pair(s) curves</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Finalize Room Curve →</button>
          </div>
        </div>

        <!-- Step 11: Finalize distances -->
        <div class="form-step" data-step="11">
          <h3 class="mb-4">Clean UP</h3>
          <div class="mb-4">
            <ul>
              <li>Finalize and cleaup</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <!--<button type="button" class="btn btn-primary btn-nav next-step">Finalize crossovers →</button>-->
          </div>
        </div>

        <!-- Step 12: Finalize crossovers
        <div class="form-step" data-step="12">
          <h3 class="mb-4">Finalize crossovers</h3>
          <div class="mb-4">
            <ul>
              <li>Finalize crossovers based on Usable XO range</li>
              <ul>
                <li>based on (combined subwoofer bandwidth + slider range)</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Draw expected results →</button>
          </div>
        </div>

        Step 13: Draw expected results
        <div class="form-step" data-step="13">
          <h3 class="mb-4">Draw expected results</h3>
          <div class="mb-4">
            <ul>
              <li>Generating expected final outputs for each channel.</li>
              <li>Updating REW reults to reflect the expected final outputs for each channel.</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Finalize .ady →</button>
          </div>
        </div>

         Step 14: Finalize .ady
        <div class="form-step" data-step="14">
          <h3 class="mb-4">Finalize .ady</h3>
          <div class="mb-4">
            <ul>
              <li>Constructing .ady files</li>
              <ul>
                <li>including ClariQ next: ISO 226 Acoustics — Normal equal-loudnesslevel contours</li>
                <li>applied to .ady generation</li>
              </ul>
              <li>Generating CEDIA RP22 report</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Continue →</button>
          </div>
        </div>
      -->

      </form>
      <pre id="logContainer"></pre>

      <br />
      <br />
      <div class="row g-4">
        <div class="col-md-4" style="text-align: center;">
          <!--<img src="https://www.nvexx.nl/audyssey/nvexx_128.png" class="centerimg" alt="Nvexx logo" />-->
          <p>Socials:</p>
          <a href="https://ko-fi.com/nvexx" target="_blank" style="text-decoration: none;">Ko-fi <span
              class="icon-cup"></span></a>
          &nbsp;
          <a href="https://discord.com/invite/fyVzznE" target="_blank" style="text-decoration: none;">Discord
            <svg class="w-[48px] h-[48px] text-gray-800 dark:text-white" aria-hidden="true"
              xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
              <path
                d="M18.942 5.556a16.3 16.3 0 0 0-4.126-1.3 12.04 12.04 0 0 0-.529 1.1 15.175 15.175 0 0 0-4.573 0 11.586 11.586 0 0 0-.535-1.1 16.274 16.274 0 0 0-4.129 1.3 17.392 17.392 0 0 0-2.868 11.662 15.785 15.785 0 0 0 4.963 2.521c.41-.564.773-1.16 1.084-1.785a10.638 10.638 0 0 1-1.706-.83c.143-.106.283-.217.418-.331a11.664 11.664 0 0 0 10.118 0c.137.114.277.225.418.331-.544.328-1.116.606-1.71.832a12.58 12.58 0 0 0 1.084 1.785 16.46 16.46 0 0 0 5.064-2.595 17.286 17.286 0 0 0-2.973-11.59ZM8.678 14.813a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.918 1.918 0 0 1 1.8 2.047 1.929 1.929 0 0 1-1.8 2.045Zm6.644 0a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.919 1.919 0 0 1 1.8 2.047 1.93 1.93 0 0 1-1.8 2.045Z" />
            </svg>
          </a>
          &nbsp;
          <a href="https://github.com/NvexxNL/ClariQNext" target="_blank" style="text-decoration: none;">GitHub <span
              class="icon-social-github"></span></a>
        </div>

        <div class="col-md-4" style="text-align: center;">
          <a href="https://ko-fi.com/nvexx/tip" target="_blank"><img height="74" style="border: 0px; height: 74px"
              src="https://storage.ko-fi.com/cdn/brandasset/v2/support_me_on_kofi_badge_red.png"
              alt="Support me on ko-fi.com" /></a>
        </div>

        <div class="col-md-4" style="text-align: center;">
          <a href="https://open.spotify.com/playlist/0ADi7e8brgnKkzri4qfpHS"
            style="size: 48px; font-size: 48pt; color: #1db954; text-decoration: none;" target="_blank"><span
              class="icon-social-spotify"></span></a>
          <p style="color: #1db954; ">skull's Audio System Test Tracks</p>
        </div>
      </div>

    </div>

    <script>
      function extractAdy(event) {
        console.info(`Initializing ${nextversion}`);
        const file = event.target.files[0];
        fileName = file.name;
        console.info(`Audyssey calibration '${fileName}' has been uploaded!`)
        const reader = new FileReader();
        reader.onload = async function (e) {
          adyContents = e.target.result;
          const jsonData = JSON.parse(adyContents);
          let modelName = jsonData.targetModelName;
          const model = modelName.slice(-6);
          sOs = modelsSoS300.includes(model) ? 300.00 : 343.00;
          Object.freeze(sOs);
          isCirrusLogic = micCalProb.includes(model) ? true : false;
          Object.freeze(isCirrusLogic);
          if (!noxo180.includes(model)) {
            freqIndex.push(180);
          }
          if (models70xo.includes(model)) {
            freqIndex.push(70);
          }
          freqIndex.sort(function (a, b) { return a - b; });
          Object.freeze(freqIndex);
          console.log(`Speed of sound setting has been automatically adjusted for your ${modelName} at ${sOs} m/s.`);
          const hasSWChannels = jsonData.detectedChannels.some(channel => channel.commandId && channel.commandId.startsWith("SW"));
          if (!hasSWChannels) {
            console.warn("No subwoofer detected in your calibration file. Mains will be set to Large/Full Range!");
            noSub = true;
          }
          Object.freeze(noSub);
          bassMode = jsonData.subwooferMode;
          Object.freeze(bassMode);
          //
          lfcSupport = jsonData.lfcSupport;
          Object.freeze(lfcSupport);
          enMultEQType = jsonData.enMultEQType;
          Object.freeze(enMultEQType);
          auro = jsonData.auro;
          Object.freeze(auro);
          dolbyVersion = jsonData.dolbyVersion;
          Object.freeze(dolbyVersion);
          dynamicEq = jsonData.dynamicEq;
          Object.freeze(dynamicEq);
          dynamicVolume = jsonData.dynamicVolume;
          Object.freeze(dynamicVolume);
          lfc = jsonData.lfc;
          Object.freeze(lfc);
          subwooferMode = jsonData.subwooferMode;
          Object.freeze(subwooferMode);
          subwooferNum = jsonData.subwooferNum;
          Object.freeze(subwooferNum);
          subwooferLayout = jsonData.subwooferLayout;
          Object.freeze(subwooferLayout);
          //
          noCenter = true;
          subLoTrim = Infinity;
          subHiTrim = -Infinity;
          subLoDelay = Infinity;
          subHiDelay = -Infinity;
          jsonData.detectedChannels.forEach(channel => {
            if (channel.commandId && channel.commandId === "C") {
              noCenter = false;
            }
            if (channel.commandId && channel.commandId.startsWith("SW")) {
              swChannelCount++;
              subLoTrim = Math.min(subLoTrim, parseFloat(channel.trimAdjustment));
              subHiTrim = Math.max(subHiTrim, parseFloat(channel.trimAdjustment));
              subLoDelay = Math.min(subLoDelay, parseFloat(channel.delayAdjustment));
              subHiDelay = Math.max(subHiDelay, parseFloat(channel.delayAdjustment));
              //
              channel.midrangeCompensation = true;
              channel.frequencyRangeRolloff = 250;
              if ("customCrossover" in channel) {
                delete channel.customCrossover;
              }
              if ("customSpeakerType" in channel) {
                delete channel.customSpeakerType;
              }
              if (swChannelCount === 1) {
                channel.customTargetCurvePoints = [];
              } else {
                if ("customTargetCurvePoints" in channel) {
                  delete channel.customTargetCurvePoints;
                }
              }
            } else {
              channel.customTargetCurvePoints = [];
              channel.midrangeCompensation = false;
              channel.frequencyRangeRolloff = 20000;
            }

            if (channel.commandId && heightChannelIds.includes(channel.commandId)) {
              hasHeightChannel = true;
            }

            console.info("Channel", channel.commandId);
            console.info("customEnSpeakerConnect", channel.channelReport.customEnSpeakerConnect);
            console.info("distance", channel.channelReport.distance);
            console.info("enSpeakerConnect", channel.channelReport.enSpeakerConnect);
            console.info("isReversePolarity", channel.channelReport.isReversePolarity);
            console.info("customCrossover", channel.customCrossover);
            console.info("customDistance", channel.customDistance);
            console.info("customLevel", channel.customLevel);
            console.info("customSpeakerType", channel.customSpeakerType);
            console.info("delayAdjustment", channel.delayAdjustment);
            console.info("enChannelType", channel.enChannelType);
            console.info("frequencyRangeRolloff", channel.frequencyRangeRolloff);
            console.info("isSkipMeasurement", channel.isSkipMeasurement);
            console.info("midrangeCompensation", channel.midrangeCompensation);
            console.info("trimAdjustment", channel.trimAdjustment);
            // console.info("Is subwoofer", isSubwoofer);
            // console.info("Is First Subfoower", isFirstSubwoofer);
            // console.info("NvexxIsSubwoofer", NvexxIsSubwoofer);
            console.info("");


          });
          Object.freeze(noCenter);
          Object.freeze(swChannelCount);
          subLoTrim = -12 + Math.abs(subLoTrim);
          subHiTrim = 12 - Math.abs(subHiTrim);
          Object.freeze(subLoTrim);
          Object.freeze(subHiTrim);
          subLoDelay /= sOs;
          subHiDelay /= sOs;
          Object.freeze(subLoDelay);
          Object.freeze(subHiDelay);
          flDist = getFLDistance(jsonData.detectedChannels);
          Object.freeze(flDist);
          console.info("Speaker measurements have been extracted from the uploaded calibration file.");
          // updateCheckboxStates();
          let totalMeasurements = 0;
          const zip = new JSZip();
          const { detectedChannels } = jsonData;
          const filePromises = Object.entries(detectedChannels).map(([key, detectedChannel]) => {
            const { responseData, commandId } = detectedChannel;
            return Promise.all(Object.entries(responseData).map(([arrayKey, arrayData]) => {
              const dataString = arrayData.join('\n');
              const rewHeader = `* Impulse Response data saved by REW\n0 // Peak value before normalisation\n0 // Peak index\n16384 // Response length\n2.0833333333333333E-5 // Sample interval (seconds)\n0.0 // Start time (seconds)\n78.0 // Data offset (dB)\n* Data start\n${dataString}`;
              const measurementName = `${commandId}${arrayKey}.txt`;
              zip.file(measurementName, rewHeader);
              totalMeasurements++;
            }));
          });
          Object.freeze(totalMeasurements);
          if (isCirrusLogic) {
            zip.file("_micCal.txt", micCal);
          }
          console.log(`Please save ${fileName.substring(0, fileName.lastIndexOf('.'))}_extractedMeasurements.zip file when prompted.`);
          console.info("Checking for measurements...");
          await Promise.all(filePromises.flat());
          try {
            const content = await zip.generateAsync({ type: 'blob' });
            const urlZip = URL.createObjectURL(content);
            const downloadLink = document.createElement('a');
            downloadLink.href = urlZip;
            downloadLink.download = `${fileName.substring(0, fileName.lastIndexOf('.'))}_extractedMeasurements.zip`;
            downloadLink.style.display = 'none';
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
          } catch (error) {
            console.error('Error generating or downloading zip file:', error);
          }
          let lastValidationState = null; // Track previous validation state
          let isFirstValidation = true; // Track if this is the first validation run

          const checkMeasurementCount = async () => {
            const measurements = await fetch_mREW();
            let mCount = Object.keys(measurements).length;
            if (isCirrusLogic) (mCount--);

            // Always validate measurement names against ADY file (regardless of count)
            try {
              const expectedMeasurements = new Set();

              // Extract expected measurement names from ADY
              jsonData.detectedChannels.forEach(channel => {
                const commandId = channel.commandId;  // e.g., "FL"
                const indices = Object.keys(channel.responseData); // e.g., ["0", "1", "2"]

                // Generate expected REW names: FL0, FL1, FL2
                indices.forEach(index => {
                  expectedMeasurements.add(`${commandId}${index}`);
                });
              });

              // Get actual REW measurement names
              const actualMeasurements = new Set();
              for (let i = 1; i <= mCount; i++) {
                actualMeasurements.add(measurements[i].title);
              }

              // Find discrepancies
              const missing = [...expectedMeasurements].filter(name => !actualMeasurements.has(name));
              const extra = [...actualMeasurements].filter(name => !expectedMeasurements.has(name));

              // Create current validation state for comparison
              const currentValidationState = JSON.stringify({ missing, extra, mCount });

              // Show validation messages on first run OR if state changed
              if (isFirstValidation || currentValidationState !== lastValidationState) {
                console.infoUpdate("Validating REW measurements against ADY file...");

                // Report findings
                if (missing.length === 0 && extra.length === 0) {
                  console.infoUpdate("✓ All REW measurements match ADY file expectations");
                } else {
                  if (missing.length > 0) {
                    console.warn(`⚠ Missing measurements (expected in ADY but not in REW): ${missing.join(', ')}`);
                  }
                  if (extra.length > 0) {
                    console.warn(`⚠ Extra measurements (in REW but not expected by ADY): ${extra.join(', ')}`);
                  }
                  console.warn("You can add/remove measurements in REW before continuing");
                }

                lastValidationState = currentValidationState;
                isFirstValidation = false;
              }

            } catch (error) {
              console.warn("Could not validate measurement names against ADY file:", error.message);
            }

            // Check if count matches for success logic
            if (mCount === totalMeasurements) {
              // Enhanced success logging with measurement names
              const importedMeasurements = [];
              for (let i = 1; i <= mCount; i++) {
                importedMeasurements.push(measurements[i].title);
              }

              // Original success logic
              // document.getElementById("button2").disabled = false;
              console.infoUpdate(`All ${isCirrusLogic ? mCount + 1 : mCount} measurements have now been successfully imported!`);
              console.infoUpdate(`Successfully imported measurements: ${importedMeasurements.join(', ')}`);

              // communicate with script.js
              window.measurementsImported = true;
              window.updateContinueButtonState();
              clearInterval(intervalId);
              // At the end of your extractAdy function, after freqIndex is populated:
              if (window.onMeasurementsImported) {
                window.onMeasurementsImported();
                document.getElementById("resumeUpload").disabled = true;
                document.getElementById("resumeUpload").style.display = "none";
                document.getElementById("resumeUploadlabel").style.display = "none";
              }
            } else {
              console.infoUpdate(`Expecting ${totalMeasurements} measurements`
                + (isCirrusLogic ? " and Audyssey microphone calibration file" : "") + ` to be imported into REW...`);
            }
          }
          const intervalId = setInterval(checkMeasurementCount, 1000);
        }
        reader.readAsText(file);
      }

      function SetTargetlevel() {
        const selectedRadio = document.querySelector('input[name="cinema_type"]:checked');
      }

      function SetnoInversion() {
        const selectedRadio = document.querySelector('input[name="sub_inversion"]:checked');
        if (selectedRadio.value === "1") {
          // noInversion = false; // Inversion allowed
        } else {
          // noInversion = true;  // Inversion NOT allowed
        }
      }

      // CorrectSPL Offsets in REW!
      // RUNS AT STEP 3
      async function CorrectSPL() {
        clearCommands();
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        disableBlock();
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        enableGraph();
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        enableBlock();
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        disableGraph();
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        console.log("##################");
        console.log("## CorrectSPL() ##");
        console.log("##################");
        enableGraph();
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        try {
          const measurements = await fetch_mREW();

          // Get the measurement count from the measurements object
          const measurementIds = Object.keys(measurements).filter(key => !isNaN(key));
          const mCount = measurementIds.length;

          console.log(`Found ${mCount} measurements to correct`);

          // BEFORE addmicCal
          if (parseFloat(measurements[1].splOffsetdB) == 78.0 || parseFloat(measurements[1].splOffsetdB) == 78) {
            // console.warn("Measurements are NOT made with AUDYSSEY APP!", parseFloat(measurements[1].splOffsetdB));
            console.warn("Measurements at 78.0dB MJC");
            if (targetLevel == 75) {
              if (isCirrusLogic) {
                isCirrusLogictargetLevel = 78.0;
              } else {
                isCirrusLogictargetLevel = 75.0;
              }
            } else {
              if (isCirrusLogic) {
                isCirrusLogictargetLevel = 88.0;
              } else {
                isCirrusLogictargetLevel = 85.0;
              }
            }
          } else if (parseFloat(measurements[1].splOffsetdB) == 88.0 || parseFloat(measurements[1].splOffsetdB) == 88) {
            console.warn("Measurements at 88.0dB");
            if (targetLevel == 75) {
              if (isCirrusLogic) {
                isCirrusLogictargetLevel = 78.0;
              } else {
                isCirrusLogictargetLevel = 75.0;
              }
            } else {
              if (isCirrusLogic) {
                isCirrusLogictargetLevel = 88.0;
              } else {
                isCirrusLogictargetLevel = 85.0;
              }
            }
          } else if (parseFloat(measurements[1].splOffsetdB) == 120 || parseFloat(measurements[1].splOffsetdB) == 88) {
            console.warn("Measurements at 120.0dB old MJ");
            if (targetLevel == 75) {
              if (isCirrusLogic) {
                isCirrusLogictargetLevel = 78.0;
              } else {
                isCirrusLogictargetLevel = 75.0;
              }
            } else {
              if (isCirrusLogic) {
                isCirrusLogictargetLevel = 88.0;
              } else {
                isCirrusLogictargetLevel = 85.0;
              }
            }
          } else {
            console.warn("Measurements not 78dB MJC, 88dB or 120dB MJ! Measurements actual value", parseFloat(measurements[1].splOffsetdB) + "dB");
            if (targetLevel == 75) {
              isCirrusLogictargetLevel = 75.0;
            } else {
              isCirrusLogictargetLevel = 85.0;
            }
          }


          for (let q = 1; q <= mCount; q++) {
            if (!measurements[q]) continue; // Skip if measurement doesn't exist

            const name = measurements[q].title;

            console.log(`Checking ${name} SPL offset`);

            const currentOffset = parseFloat(measurements[q].splOffsetdB);
            console.log(`Current SPL offset for ${name}: ${currentOffset} dB`);


            console.log(`Target level: ${isCirrusLogictargetLevel}dB`);
            console.log(`Current SPL offset: ${currentOffset}dB`);
            console.log(`This should result in measurements around ${isCirrusLogictargetLevel}dB`);

            const correctionOffset = isCirrusLogictargetLevel - currentOffset;
            console.log(`Applying correction offset for ${name}: ${correctionOffset} dB`);

            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                command: "Add SPL offset",
                parameters: {
                  offset: correctionOffset,
                },
              }),
            };

            try {
              const response = await fetch(`http://localhost:4735/measurements/${q}/command`, requestOptions);
              if (response.ok) {
                console.log(`✔ Successfully corrected SPL offset for ${name}`);

              } else {
                console.error(`✘ Failed to correct SPL offset for ${name}`);
              }
            } catch (error) {
              console.error(`Error correcting ${name}:`, error);
            }
          }


          for (let q = 1; q <= mCount; q++) {
            if (!measurements[q]) continue; // Skip if measurement doesn't exist
            const name = measurements[q].title;
            console.log(`Checking ${name}`);

            const PUTrequestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: name,
              }),
            };

            try {
              const response = await fetch(`http://localhost:4735/measurements/${q}`, PUTrequestOptions);
              if (response.ok) {
                console.log(`✔ Successfully corrected name ${name} for ${name}`);

              } else {
                console.error(`✘ Failed to correct name ${name} for ${name}`);
              }
            } catch (error) {
              console.error(`Error correcting name ${name}:`, error);
            }
          }

          for (let q = 1; q <= mCount; q++) {
            if (!measurements[q]) continue; // Skip if measurement doesn't exist
            const name = measurements[q].title;
            const notes = measurements[q].notes;

            console.log(`Updating notes for ${name}`);

            const PUTNAMErequestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                "notes": notes + " ," + nextversion + " name change",
              }),
            };

            try {
              const response = await fetch(`http://localhost:4735/measurements/${q}`, PUTNAMErequestOptions);
              if (response.ok) {
                console.log(`✔ Successfully added notes for ${name}`);

              } else {
                console.error(`✘ Failed add notes for ${name}`);
              }
            } catch (error) {
              console.error(`Error adding notes for ${name}:`, error);
            }
          }


        } catch (error) {
          console.error("Error fetching measurements:", error);
        }
      }

      function getadyName(fileName, suffix) {
        const dotIndex = fileName.lastIndexOf(".");
        const modifiedName = fileName.substring(0, dotIndex) + suffix;
        return modifiedName;
      }

      function getFLDistance(channels) {
        let flIndex = 0;
        for (let i = 0; i < channels.length; i++) {
          if (channels[i].commandId === "FL") {
            flIndex = i;
            break;
          }
        }
        let dist = parseFloat(channels[flIndex].channelReport.distance);
        if (isNaN(dist) || dist === 0) {
          dist = parseFloat(channels[flIndex].customDistance);
          if (isNaN(dist) || dist === 0 || dist === null) {
            // Try the distance property as a fallback
            dist = parseFloat(channels[flIndex].distance);
            if (isNaN(dist) || dist === 0 || dist === null) {
              console.warn(`No distance found for ${channels[flIndex].commandId}! Defaulting to 6m.`)
              console.warn(`To fix: Open ady in MultEQ phone app then -\nSpeaker Detection Results > Change any crossover > Save and then retry.`);
              dist = 6.00;
            }
          }
        }
        return dist;
      }

      /////////////////
      // TheCurves() //
      /////////////////
      async function TheCurves() {
        console.log("Running ClearCurve Next for Speakers...");
        let measurements = await fetch_mREW();
        const titles = {};
        let titleIndices = {};
        let mCount = Object.keys(measurements).length;
        let measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));

        // DEFINE SPEAKERS
        var BDLo; // Back Dolby Left (bounce)
        var BDRo; // Back Dolby Right (bounce)
        var Co; // Center
        var CHo; // Center Height (AURO-3D)
        var FDLo; // Front Dolby Left (bounce)
        var FDRo; // Front Dolby Right (bounce)
        var FLo; // Front Left
        var FHLo; // Front Height Left
        var FHRo; // Front Height Right
        var FWLo; // Front Wide Left
        var FWRo; // Front Wide Right
        var FRo; // Front Right
        var RHRo; // Rear Height Right
        var RHLo; // Rear Height Left
        var SBLo; // Surround Rear/Back Left
        var SBRo; // Surround Rear/Back Right
        var SLAo; // Surround Left
        var SRAo; // Surround Right
        var SBo; // Surround Back Single
        var SDLo; // Surround Dolby Left (bounce)
        var SDRo; // Surround Dolby Right (bounce)
        var SHLo; // Surround Height Left
        var SHRo; // Surround Height Right
        var TFLo; // Top Front Left
        var TFRo; // Top Front Right
        var TMLo; // Top Middle Left
        var TMRo; // Top Middle Right
        var TRLo; // Top Rear Left
        var TRRo; // Top Rear Right
        var TSo; // Top Surround (AURO-3D)
        var Curve = targetCurvePath // SpeakerCurve

        // CREATE THE CURVE FIRST
        const targetCurve = await postNext('Generate target measurement', 1);
        const targetCurveIdx = Object.keys(targetCurve.results)[0];
        const targetName = `${targetCurveName}_curve`;
        await fetch_mREW(targetCurveIdx, 'PUT', { title: targetName });
        // room curve no longer needed. keeping it enabled will only confuse on next run
        if (targetCurveName === "") { await disableRoomCurve(); }

        // Back Dolby Left (bounce)
        // Back Dolby Left (bounce)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));

        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // nname === "BDLo"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyBD,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "BDL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "BDLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("BDL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");

            var splOffsetCurve;
            var index = i;
            // endpoint for request
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            // request using the Fetch API
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                // Process the retrieved user data
                // console.log("mData:", mData);
                // console.log("mData:", mData.notes);
                // console.log("mData:", mData.title);
                // console.log("mData:", mData.splOffsetdB);
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                //// console.log("splOffsetdB", splOffsetdB);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                // console.log(match[0]);
                // console.log(match[1]);
                // console.log(match[2]);
                //// console.log("match[3]", match[3]);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                // The substituted value will be contained in the result variable
                const result = str.replace(regex, subst);
                //// console.log("Substitution result: ", result);
                //// console.log("scaled", scaled);
                //// console.log("result", result);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Back Dolby Left (bounce) DONE !!
        // Back Dolby Left (bounce) DONE !!

        // Back Dolby Right (bounce)
        // Back Dolby Right (bounce)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name === "BDRo"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyBD,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "BDR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "BDRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("BDR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");

            var splOffsetCurve;
            var index = i;
            // endpoint for request
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            // request using the Fetch API
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Back Dolby Right (bounce) DONE !!
        // Back Dolby Right (bounce) DONE !!

        // Center
        // Center
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "Co") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name === "Co"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "Co") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "Co") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyC,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "C_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "Co") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("C_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // CENTER DONE !!
        // CENTER DONE !!

        // CENTER HEIGHT (AURO-3D)
        // CENTER HEIGHT (AURO-3D)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "CHo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "CHo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "CHo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyCH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "CH_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "CHo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("CH_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // CENTER HEIGHT (AURO-3D) DONE !!
        // CENTER HEIGHT (AURO-3D) DONE !!

        // Front Dolby Left (bounce)
        // Front Dolby Left (bounce)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDLoy") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyFD,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FDL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FDLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FDL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Dolby Left (bounce) DONE !!
        // Front Dolby Left (bounce) DONE !!

        // Front Dolby Right (bounce)
        // Front Dolby Right (bounce)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name === "FDRo"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyFD,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FDR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FDRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FDR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Dolby Right (bounce) DONE !!
        // Front Dolby Right (bounce) DONE !!

        // Front Left
        // Front Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name === "FLo"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyF,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Left DONE !!
        // Front Left DONE !!

        // Front Height Left
        // Front Height Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name === "FHLo"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyFH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FHL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FHLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FHL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Height Left DONE !!
        // Front Height Left DONE !!

        // Front Height Right
        // Front Height Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyFH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FHR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FHRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FHR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Height Right DONE !!
        // Front Height Right DONE !!

        // Front Wide Left
        // Front Wide Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name === "FWLo"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyFW,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FWL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FWLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FWL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Wide Left DONE !!
        // Front Wide Left DONE !!

        // Front Wide Right
        // Front Wide Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyFW,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FWR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FWRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FWR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Wide Right DONE !!
        // Front Wide Right DONE !!

        // Front Right
        // Front Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyF,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Right DONE !!
        // Front Right DONE !!

        // Rear Height Left
        // Rear Height Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyRH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "RHL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "RHLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("RHL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Rear Height Left DONE !!
        // Rear Height Left DONE !!

        // Rear Height Right
        // Rear Height Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyRH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "RHR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "RHRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("RHR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Rear Height Right DONE !!
        // Rear Height Right DONE !!

        // Surround Rear/Back Left
        // Surround Rear/Back Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySurB,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SBL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SBLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SBL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Rear/Back Left DONE !!
        // Surround Rear/Back Left DONE !!

        // Surround Rear/Back Right
        // Surround Rear/Back Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySurB,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SBR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SBRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SBR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Rear/Back Right DONE !!
        // Surround Rear/Back Right DONE !!

        // Surround Left
        // Surround Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SLAo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SLAo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SLAo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySur,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SLA_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SLAo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SLA_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Left DONE !!
        // Surround Left DONE !!

        // Surround Right
        // Surround Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SRAo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SRAo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SRAo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySur,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SRA_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SRAo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SRA_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Right DONE !!
        // Surround Right DONE !!

        // Surround Back Single
        // Surround Back Single
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySurBS,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SB_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SBo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SB_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Back Single DONE !!
        // Surround Back Single DONE !!

        // Surround Dolby Left (bounce)
        // Surround Dolby Left (bounce)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySD,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SDL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SDLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SDL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Dolby Left (bounce) DONE !!
        // Surround Dolby Left (bounce) DONE !!

        // Surround Dolby Right (bounce)
        // Surround Dolby Right (bounce)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySD,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SDR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SDRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SDR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Dolby Right (bounce) DONE !!
        // Surround Dolby Right (bounce) DONE !!

        // Surround Height Left
        // Surround Height Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SHL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SHLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SHL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Height Left DONE !!
        // Surround Height Left DONE !!

        // Surround Height Right
        // Surround Height Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SHR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SHRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SHR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Height Right DONE !!
        // Surround Height Right DONE !!

        // Top Front Left
        // Top Front Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTF,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TFL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TFLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TFL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Front Left DONE !!
        // Top Front Left DONE !!

        // Top Front Right
        // Top Front Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTF,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TFR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TFRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TFR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Front Right DONE !!
        // Top Front Right DONE !!

        // Top Middle Left
        // Top Middle Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TMLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TMLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TMLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTM,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TML_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TMLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TML_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Middle Left DONE !!
        // Top Middle Left DONE !!

        // Top Middle Right
        // Top Middle Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TMRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TMRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TMRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTM,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TMR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TMRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TMR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Middle Right DONE !!
        // Top Middle Right DONE !!

        // Top Rear Left
        // Top Rear Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTR,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TRL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TRLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TRL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Rear Left DONE !!
        // Top Rear Left DONE !!

        // Top Rear Right
        // Top Rear Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTR,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TRR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TRRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TRR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Rear Right DONE !!
        // Top Rear Right DONE !!

        // Top Surround (AURO-3D)
        // Top Surround (AURO-3D)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TSo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TSo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TSo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTS,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TS_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TSo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TS_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Surround (AURO-3D) DONE !!
        // Top Surround (AURO-3D) DONE !!
      }

      //////////////////////////
      // TheCurvesSubwoofer() //
      //////////////////////////
      async function TheCurvesSubwoofer() {
        console.log("Running Nvexx ClearCurve Next Subwoofer...");

        let measurements = await fetch_mREW();
        const titles = {};
        let titleIndices = {};
        let mCount = Object.keys(measurements).length;
        let measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));

        // DEFINE SPEAKERS
        var SW1o; // Subwoofer
        var SW2o; // Subwoofer
        var SW3o; // Subwoofer
        var SW4o; // Subwoofer
        var SWMIXo; // Subwoofer
        var SWMIX1o; // Subwoofer
        var SWMIX2o; // Subwoofer
        var SWMIX3o; // Subwoofer
        var SWMIX4o; // Subwoofer
        var SubCurve = targetCurvePath; // SpeakerCurve

        // CREATE THE CURVE FIRST
        const targetCurve = await postNext('Generate target measurement', 1);
        const targetCurveIdx = Object.keys(targetCurve.results)[0];
        const targetName = `${targetCurveName}_curvesub`;
        await fetch_mREW(targetCurveIdx, 'PUT', { title: targetName });
        // room curve no longer needed. keeping it enabled will only confuse on next run
        if (targetCurveName === "") { await disableRoomCurve(); }

        // Subwoofer SW1
        // Subwoofer SW1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW1o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW1o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW1o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SW1_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SW1o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SW1_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SW1 DONE !!
        // Subwoofer SW1 DONE !!

        // Subwoofer SW2
        // Subwoofer SW2
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW2o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW2o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW2o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SW2_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SW2o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SW2_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SW2 DONE !!
        // Subwoofer SW2 DONE !!

        // Subwoofer SW3
        // Subwoofer SW3
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW3o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW3o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW3o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SW3_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SW3o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SW3_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SW3 DONE !!
        // Subwoofer SW3 DONE !!

        // Subwoofer SW4
        // Subwoofer SW4
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW4o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW4o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW4o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SW4_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SW4o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SW4_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SW4 DONE !!
        // Subwoofer SW4 DONE !!

        // Subwoofer SWMIX
        // Subwoofer SWMIX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIXoy") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIXo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIXo") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SWMIX_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SWMIXo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SWMIX_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SWMIX DONE !!
        // Subwoofer SWMIX DONE !!

        // Subwoofer SWMIX1
        // Subwoofer SWMIX1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX1o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX1o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX1o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SWMIX1_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SWMIX1o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SWMIX1_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SWMIX1 DONE !!
        // Subwoofer SWMIX1 DONE !!

        // Subwoofer SWMIX2
        // Subwoofer SWMIX2
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX2o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX2o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX2o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SWMIX2_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SWMIX2o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SWMIX2_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SWMIX2 DONE !!
        // Subwoofer SWMIX2 DONE !!

        // Subwoofer SWMIX3
        // Subwoofer SWMIX3
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX3o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX3o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX3o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SWMIX3_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SWMIX3o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SWMIX3_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SWMIX3 DONE !!
        // Subwoofer SWMIX3 DONE !!

        // Subwoofer SWMIX4
        // Subwoofer SWMIX4
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX4o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX4o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX4o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SWMIX4_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SWMIX4o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SWMIX4_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SWMIX4 DONE !!
        // Subwoofer SWMIX4 DONE !!
      }

      ////////////////////
      // TheCurvesAvg() //
      ////////////////////
      async function TheCurvesAvg() {
        console.log("Running ClearCurve Next Averages...");

        let measurements = await fetch_mREW();
        const titles = {};
        let titleIndices = {};
        let mCount = Object.keys(measurements).length;
        let measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));

        // DEFINE SPEAKERS
        var BDLo; // Back Dolby Left (bounce)
        var BDRo; // Back Dolby Right (bounce)
        var Co; // Center
        var CHo; // Center Height (AURO-3D)
        var FDLo; // Front Dolby Left (bounce)
        var FDRo; // Front Dolby Right (bounce)
        var FLo; // Front Left
        var FHLo; // Front Height Left
        var FHRo; // Front Height Right
        var FWLo; // Front Wide Left
        var FWRo; // Front Wide Right
        var FRo; // Front Right
        var RHRo; // Rear Height Right
        var RHLo; // Rear Height Left
        var SBLo; // Surround Rear/Back Left
        var SBRo; // Surround Rear/Back Right
        var SLAo; // Surround Left
        var SRAo; // Surround Right
        var SBo; // Surround Back Single
        var SDLo; // Surround Dolby Left (bounce)
        var SDRo; // Surround Dolby Right (bounce)
        var SHLo; // Surround Height Left
        var SHRo; // Surround Height Right
        var TFLo; // Top Front Left
        var TFRo; // Top Front Right
        var TMLo; // Top Middle Left
        var TMRo; // Top Middle Right
        var TRLo; // Top Rear Left
        var TRRo; // Top Rear Right
        var TSo; // Top Surround (AURO-3D)
        var Curve = targetCurvePath; // SpeakerCurve 
        //
        var BDLoBDRo; // Back Dolby comb curve
        var BDLoCurve; // Back Dolby L
        var BDRoCurve; // Back Dolby R
        var BDLoBDRoRMSCurve; // Back Dolby

        var FDLoFDRo; // Front Dolby comb curve
        var FDLoCurve; // Front Dolby L
        var FDRoCurve; // Front Dolby R
        var FDLoFDRoRMSCurve; // Back Dolby

        var FLoFRo; // Front Left & Right comb curve
        var FLoCurve; // Front Left & Right
        var FRoCurve; // Front Left & Right
        var FLoFRoRMSCurve; // Front Left & Right

        var FHLoFHRo; // Front Height comb curve
        var FHLoCurve; // Front Height
        var FHRoCurve; // Front Height
        var FHLoFHRoRMSCurve; // Front Height

        var FWLoFWRo; // Front Wide comb curve
        var FWLoCurve; // Front Wide
        var FWRoCurve; // Front Wide
        var FWLoFWRoRMSCurve; // Front Wide

        var RHRoRHLo; // Rear Height comb curve
        var RHLoCurve; // Rear Height
        var RHRoCurve; // Rear Height
        var RHRoRHLoRMSCurve; // Rear Height

        var SBLoSBRo; // Surround Rear/Back comb curve
        var SBLoCurve; // Surround Rear/Back
        var SBRoCurve; // Surround Rear/Back
        var SBLoSBRoRMSCurve; // Surround Rear/Back

        var SLAoSRAo; // Surround comb curve
        var SLAoCurve; // Surround
        var SRAoCurve; // Surround
        var SLAoSRAoRMSCurve; // Surround

        var SDLoSDRo; // Surround Dolby comb curve
        var SDLoCurve; // Surround Dolby
        var SDRoCurve; // Surround Dolby
        var SDLoSDRoRMSCurve; // Surround Dolby

        var SHLoSHRo; // Surround Height comb curve
        var SHLoCurve; // Surround Height
        var SHRoCurve; // Surround Height
        var SHLoSHRoRMSCurve; // Surround Height

        var TFLoTFRo; // Top Front comb curve
        var TFLoCurve; // Top Front
        var TFRoCurve; // Top Front
        var TFLoTFRoRMSCurve; // Top Front

        var TMLoTMRo; // Top Middle comb curve
        var TMLoCurve; // Top Middle
        var TMRoCurve; // Top Middle
        var TMLoTMRoRMSCurve; // Top Middle

        var TRLoTRRo; // Top Rear comb curve
        var TRLoCurve; // Top Rear
        var TRRoCurve; // Top Rear
        var TRLoTRRoRMSCurve; // Top Rear

        var CoCurve; // Center Curve
        var FLoAndFroCurve; // FL+FR_RMSAVG_Crv

        // GET ALL INDEXES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // BACK DOLBY
          if (name === "BDLo") {
            BDLo = i;
            console.warn("BDLo Index:", BDLo);
          }
          if (name === "BDRo") {
            BDRo = i;
            console.warn("BDRo Index:", BDRo);
          }
          // FRONT DOLBY
          if (name === "FDLo") {
            FDLo = i;
            console.warn("FDLo Index:", FDLo);
          }
          if (name === "FDRo") {
            FDRo = i;
            console.warn("FDRo Index:", FDRo);
          }
          // FRONT HEIGHT
          if (name === "FHLo") {
            FHLo = i;
            console.warn("FHLo Index:", FHLo);
          }
          if (name === "FHRo") {
            FHRo = i;
            console.warn("FHRo Index:", FHRo);
          }
          // FRONT WIDE
          if (name === "FWLo") {
            FWLo = i;
            console.warn("FWLo Index:", FWLo);
          }
          if (name === "FWRo") {
            FWRo = i;
            console.warn("FWRo Index:", FWRo);
          }
          // FRONT LEFT - FRONT RIGHT
          if (name === "FLo") {
            FLo = i;
            console.warn("FLo Index:", FLo);
          }
          if (name === "FRo") {
            FRo = i;
            console.warn("FRo Index:", FRo);
          }
          // REAR HEIGHT
          if (name === "RHRo") {
            RHRo = i;
            console.warn("RHRo Index:", RHRo);
          }
          if (name === "RHLo") {
            RHLo = i;
            console.warn("RHLo Index:", RHLo);
          }
          // SURROUND BACK
          if (name === "SBLo") {
            SBLo = i;
            console.warn("SBLo Index:", SBLo);
          }
          if (name === "SBRo") {
            SBRo = i;
            console.warn("SBRo Index:", SBRo);
          }
          // SURROUND
          if (name === "SLAo") {
            SLAo = i;
            console.warn("SLAo Index:", SLAo);
          }
          if (name === "SRAo") {
            SRAo = i;
            console.warn("SRAo Index:", SRAo);
          }
          // SURROUND DOLBY
          if (name === "SDLo") {
            SDLo = i;
            console.warn("SDLo Index:", SDLo);
          }
          if (name === "SDRo") {
            SDRo = i;
            console.warn("SDRo Index:", SDRo);
          }
          // SURROUND HEIGHT
          if (name === "SHLo") {
            SHLo = i;
            console.warn("SHLo Index:", SHLo);
          }
          if (name === "SHRo") {
            SHRo = i;
            console.warn("SHRo Index:", SHRo);
          }
          // TOP FRONT
          if (name === "TFLo") {
            TFLo = i;
            console.warn("TFLo Index:", TFLo);
          }
          if (name === "TFRo") {
            TFRo = i;
            console.warn("TFRo Index:", TFRo);
          }
          // TOP MIDDLE
          if (name === "TMLo") {
            TMLo = i;
            console.warn("TMLo Index:", TMLo);
          }
          if (name === "TMRo") {
            TMRo = i;
            console.warn("TMRo Index:", TMRo);
          }
          // TOP REAR
          if (name === "TRLo") {
            TRLo = i;
            console.warn("TRLo Index:", TRLo);
          }
          if (name === "TRRo") {
            TRRo = i;
            console.warn("TRRo Index:", TRRo);
          }
        }
        // debugger;

        // Back Dolby AVG > START
        // Back Dolby AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (BDLo && BDRo && typeof BDLo === 'number' && typeof BDRo === 'number') {
          // await postNext("Vector average", [BDLo, BDRo]);
          await postNext("Magn plus phase average", [BDLo, BDRo]);
        }
        // debugger;

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }
        // debugger;

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "BDL+BDR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG BDL+BDR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDL+BDR_AVG_Crv") {
            BDLoBDRo = i;
            //// console.warn("BDLoBDRo Index:", BDLoBDRo);
          }
        }

        // GET FL and FR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // BackDolbyLeft_Crv* + BackDolbyRight_Crv*
          if (name.startsWith("BDL_Crv")) {
            BDLoCurve = i;
            //// console.warn("BDLoCurve Index:", BDLoCurve);
          }
          if (name.startsWith("BDR_Crv")) {
            BDRoCurve = i;
            //// console.warn("BDRoCurve Index:", BDRoCurve);
          }
        }

        // MAKE AVG RMS
        if (BDLoCurve && BDRoCurve && typeof BDLoCurve === 'number' && typeof BDRoCurve === 'number') {
          await postNext("RMS average", [BDLoCurve, BDRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "BDL+BDR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between BDL + BDR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Back Dolby AVG > DONE
        // Back Dolby AVG > DONE

        // FrontDolby AVG > START
        // FrontDolby AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        // if (FDLo != 0 && FDRo != 0) {
        if (FDLo && FDRo && typeof FDLo === 'number' && typeof FDRo === 'number') {
          // await postNext("Vector average", [FDLo, FDRo]);
          await postNext("Magn plus phase average", [FDLo, FDRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FDL+FDR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG FDL+FDR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDL+FDR_AVG_Crv") {
            FDLoFDRo = i;
            //// console.warn("FDLoFDRo Index:", FDLoFDRo);
          }
        }

        // GET FDL and FDR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // FrontDolbyLeft_Crv* + FrontDolbyRight_Crv*
          if (name.startsWith("FDL_Crv")) {
            FDLoCurve = i;
            //// console.warn("FDLoCurve Index:", FDLoCurve);
          }
          if (name.startsWith("FDR_Crv")) {
            FDRoCurve = i;
            //// console.warn("FDRoCurve Index:", FDRoCurve);
          }
        }

        // MAKE AVG RMS
        if (FDLoCurve && FDRoCurve && typeof FDLoCurve === 'number' && typeof FDRoCurve === 'number') {
          await postNext("RMS average", [FDLoCurve, FDRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FDL+FDR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between FDL + FDR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // FrontDolby AVG > DONE
        // FrontDolby AVG > DONE

        // FRONTS LEFT & FRONT RIGHT AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        // if (FLo != 0 && FRo != 0) {
        if (FLo && FRo && typeof FLo === 'number' && typeof FRo === 'number') {
          // await postNext("Vector average", [FLo, FRo]);
          await postNext("Magn plus phase average", [FLo, FRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FL+FR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG FL+FR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FL+FR_AVG_Crv") {
            FLoFRo = i;
            //// console.warn("FLoFRo Index:", FLoFRo);
          }
        }

        // GET FL and FR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // FrontLeft_Crv* + FrontRight_Crv*
          if (name.startsWith("FL_Crv")) {
            FLoCurve = i;
            //// console.warn("FLoCurve Index:", FLoCurve);
          }
          if (name.startsWith("FR_Crv")) {
            FRoCurve = i;
            //// console.warn("FRoCurve Index:", FRoCurve);
          }
        }

        // MAKE AVG RMS
        if (FLoCurve && FRoCurve && typeof FLoCurve === 'number' && typeof FRoCurve === 'number') {
          await postNext("RMS average", [FLoCurve, FRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FL+FR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between FL + FR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // FRONTS LEFT & FRONT RIGHT AVG > DONE

        // Front Height AVG > START
        // Front Height AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        // if (FHLo != 0 && FHRo != 0) {
        if (FHLo && FHRo && typeof FHLo === 'number' && typeof FHRo === 'number') {
          // await postNext("Vector average", [FHLo, FHRo]);
          await postNext("Magn plus phase average", [FHLo, FHRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FHL+FHR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG FHL+FHR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHL+FHR_AVG_Crv") {
            FHLoFHRo = i;
            //// console.warn("FHLoFHRo Index:", FHLoFHRo);
          }
        }

        // GET FHL and FHR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // FrontHeightLeft_Crv* + FrontHeightRight_Crv*
          if (name.startsWith("FHL_Crv")) {
            FHLoCurve = i;
            //// console.warn("FHLoCurve Index:", FHLoCurve);
          }
          if (name.startsWith("FHR_Crv")) {
            FHRoCurve = i;
            //// console.warn("FHRoCurve Index:", FHRoCurve);
          }
        }

        // MAKE AVG RMS
        if (FHLoCurve && FHRoCurve && typeof FHLoCurve === 'number' && typeof FHRoCurve === 'number') {
          await postNext("RMS average", [FHLoCurve, FHRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FHL+FHR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between FHL + FHR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Front Height AVG > DONE
        // Front Height AVG > DONE

        // Front Wide AVG > START
        // Front Wide AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (FWLo && FWRo && typeof FWLo === 'number' && typeof FWRo === 'number') {
          // await postNext("Vector average", [FWLo, FWRo]);
          await postNext("Magn plus phase average", [FWLo, FWRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FWL+FWR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG FWL+FWR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWL+FWR_AVG_Crv") {
            FWLoFWRo = i;
            //// console.warn("FWLoFWRo Index:", FWLoFWRo);
          }
        }

        // GET FWL and FWR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // FrontWideLeft_Crv* + FrontWideRight_Crv*
          if (name.startsWith("FWL_Crv")) {
            FWLoCurve = i;
            //// console.warn("FWLoCurve Index:", FWLoCurve);
          }
          if (name.startsWith("FWR_Crv")) {
            FWRoCurve = i;
            //// console.warn("FWRoCurve Index:", FWRoCurve);
          }
        }

        // MAKE AVG RMS
        if (FWLoCurve && FWRoCurve && typeof FWLoCurve === 'number' && typeof FWRoCurve === 'number') {
          await postNext("RMS average", [FWLoCurve, FWRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FWL+FWR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between FWL + FWR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Front Wide AVG > DONE
        // Front Wide AVG > DONE

        // Rear Height AVG > START
        // Rear Height AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (RHLo && RHRo && typeof RHLo === 'number' && typeof RHRo === 'number') {
          // await postNext("Vector average", [RHLo, RHRo]);
          await postNext("Magn plus phase average", [RHLo, RHRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "RHL+RHR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG RHL+RHR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHL+RHR_AVG_Crv") {
            RHLoRHRo = i;
            //// console.warn("RHLoRHRo Index:", RHLoRHRo);
          }
        }

        // GET RHL and RHR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // RearHeightLeft_Crv* + RearHeightRight_Crv*
          if (name.startsWith("RHL_Crv")) {
            RHLoCurve = i;
            //// console.warn("RHLoCurve Index:", RHLoCurve);
          }
          if (name.startsWith("RHR_Crv")) {
            RHRoCurve = i;
            //// console.warn("RHRoCurve Index:", RHRoCurve);
          }
        }

        // MAKE AVG RMS
        if (RHLoCurve && RHRoCurve && typeof RHLoCurve === 'number' && typeof RHRoCurve === 'number') {
          await postNext("RMS average", [RHLoCurve, RHRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "RHL+RHR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between RHL + RHR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Rear Height AVG > DONE
        // Rear Height AVG > DONE

        // Surround Rear/Back AVG > START
        // Surround Rear/Back AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (SBLo && SBRo && typeof SBLo === 'number' && typeof SBRo === 'number') {
          // await postNext("Vector average", [SBLo, SBRo]);
          await postNext("Magn plus phase average", [SBLo, SBRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SBL+SBR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG SBL+SBR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBL+SBR_AVG_Crv") {
            SBLoSBRo = i;
            //// console.warn("SBLoSBRo Index:", SBLoSBRo);
          }
        }

        // GET SBL and SBR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // SurroundBackLeft_Crv* + SurroundBackRight_Crv*
          if (name.startsWith("SBL_Crv")) {
            SBLoCurve = i;
            //// console.warn("SBLoCurve Index:", SBLoCurve);
          }
          if (name.startsWith("SBR_Crv")) {
            SBRoCurve = i;
            //// console.warn("SBRoCurve Index:", SBRoCurve);
          }
        }

        // MAKE AVG RMS
        if (SBLoCurve && SBRoCurve && typeof SBLoCurve === 'number' && typeof SBRoCurve === 'number') {
          await postNext("RMS average", [SBLoCurve, SBRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SBL+SBR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between SBL + SBR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Surround Rear/Back AVG > DONE
        // Surround Rear/Back AVG > DONE

        // Surround AVG > START
        // Surround AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (SLAo && SRAo && typeof SLAo === 'number' && typeof SRAo === 'number') {
          // await postNext("Vector average", [SLAo, SRAo]);
          await postNext("Magn plus phase average", [SLAo, SRAo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SLA+SRA_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG SLA+SRA_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SLA+SRA_AVG_Crv") {
            SLAoSRAo = i;
            //// console.warn("SLAoSRAo Index:", SLAoSRAo);
          }
        }

        // GET SLA and SRA CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // SurroundLeft_Crv* + SurroundRight_Crv*
          if (name.startsWith("SLA_Crv")) {
            SLAoCurve = i;
            //// console.warn("SLAoCurve Index:", SLAoCurve);
          }
          if (name.startsWith("SRA_Crv")) {
            SRAoCurve = i;
            //// console.warn("SRAoCurve Index:", SRAoCurve);
          }
        }

        // MAKE AVG RMS
        if (SLAoCurve && SRAoCurve && typeof SLAoCurve === 'number' && typeof SRAoCurve === 'number') {
          await postNext("RMS average", [SLAoCurve, SRAoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SLA+SRA_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between SLA + SRA",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Surround AVG > DONE
        // Surround AVG > DONE

        // Surround Dolby AVG > START
        // Surround Dolby AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (SDLo && SDRo && typeof SDLo === 'number' && typeof SDRo === 'number') {
          // await postNext("Vector average", [SDLo, SDRo]);
          await postNext("Magn plus phase average", [SDLo, SDRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SDL+SDR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG SDL+SDR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDL+SDR_AVG_Crv") {
            SDLoSDRo = i;
            //// console.warn("SDLoSDRo Index:", SDLoSDRo);
          }
        }

        // GET SDL and SDR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // SurroundDolbyLeft_Crv* + SurroundDolbyRight_Crv*
          if (name.startsWith("SDL_Crv")) {
            SDLoCurve = i;
            //// console.warn("SDLoCurve Index:", SDLoCurve);
          }
          if (name.startsWith("SDR_Crv")) {
            SDRoCurve = i;
            //// console.warn("SDRoCurve Index:", SDRoCurve);
          }
        }

        // MAKE AVG RMS
        if (SDLoCurve && SDRoCurve && typeof SDLoCurve === 'number' && typeof SDRoCurve === 'number') {
          await postNext("RMS average", [SDLoCurve, SDRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SDL+SDR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between SDL + SDR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Surround Dolby AVG > DONE
        // Surround Dolby AVG > DONE

        // Surround Height AVG > START
        // Surround Height AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (SHLo && SHRo && typeof SHLo === 'number' && typeof SHRo === 'number') {
          // await postNext("Vector average", [SHLo, SHRo]);
          await postNext("Magn plus phase average", [SHLo, SHRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SHL+SHR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG SHL+SHR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHL+SHR_AVG_Crv") {
            SHLoSHRo = i;
            //// console.warn("SHLoSHRo Index:", SHLoSHRo);
          }
        }

        // GET SHL and SHR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // SurroundHeightLeft_Crv* + SurroundHeightRight_Crv*
          if (name.startsWith("SHL_Crv")) {
            SHLoCurve = i;
            //// console.warn("SHLoCurve Index:", SHLoCurve);
          }
          if (name.startsWith("SHR_Crv")) {
            SHRoCurve = i;
            //// console.warn("SHRoCurve Index:", SHRoCurve);
          }
        }

        // MAKE AVG RMS
        if (SHLoCurve && SHRoCurve && typeof SHLoCurve === 'number' && typeof SHRoCurve === 'number') {
          await postNext("RMS average", [SHLoCurve, SHRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SHL+SHR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between SHL + SHR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Surround Height AVG > DONE
        // Surround Height AVG > DONE

        // Top Front AVG > START
        // Top Front AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (TFLo && TFRo && typeof TFLo === 'number' && typeof TFRo === 'number') {
          // await postNext("Vector average", [TFLo, TFRo]);
          await postNext("Magn plus phase average", [TFLo, TFRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TFL+TFR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG TFL+TFR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFL+TFR_AVG_Crv") {
            TFLoTFRo = i;
            //// console.warn("TFLoTFRo Index:", TFLoTFRo);
          }
        }

        // GET TFL and TFR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // TopFrontLeft_Crv* + TopFrontRight_Crv*
          if (name.startsWith("TFL_Crv")) {
            TFLoCurve = i;
            //// console.warn("TFLoCurve Index:", TFLoCurve);
          }
          if (name.startsWith("TFR_Crv")) {
            TFRoCurve = i;
            //// console.warn("TFRoCurve Index:", TFRoCurve);
          }
        }

        // MAKE AVG RMS
        if (TFLoCurve && TFRoCurve && typeof TFLoCurve === 'number' && typeof TFRoCurve === 'number') {
          await postNext("RMS average", [TFLoCurve, TFRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TFL+TFR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between TFL + TFR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Top Front AVG > DONE
        // Top Front AVG > DONE

        // Top Middle AVG > START
        // Top Middle AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (TMLo && TMRo && typeof TMLo === 'number' && typeof TMRo === 'number') {
          // await postNext("Vector average", [TMLo, TMRo]);
          await postNext("Magn plus phase average", [TMLo, TMRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TML+TMR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG TML+TMR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TML+TMR_AVG_Crv") {
            TMLoTMRo = i;
            //// console.warn("TMLoTMRo Index:", TMLoTMRo);
          }
        }

        // GET TML and TMR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // TopMiddleLeft_Crv* + TopMiddleRight_Crv*
          if (name.startsWith("TML_Crv")) {
            TMLoCurve = i;
            //// console.warn("TMLoCurve Index:", TMLoCurve);
          }
          if (name.startsWith("TMR_Crv")) {
            TMRoCurve = i;
            //// console.warn("TMRoCurve Index:", TMRoCurve);
          }
        }

        // MAKE AVG RMS
        if (TMLoCurve && TMRoCurve && typeof TMLoCurve === 'number' && typeof TMRoCurve === 'number') {
          await postNext("RMS average", [TMLoCurve, TMRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TML+TMR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between TML + TMR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Top Middle AVG > DONE
        // Top Middle AVG > DONE

        // Top Rear AVG > START
        // Top Rear AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (TRLo && TRRo && typeof TRLo === 'number' && typeof TRRo === 'number') {
          // await postNext("Vector average", [TRLo, TRRo]);
          await postNext("Magn plus phase average", [TRLo, TRRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TRL+TRR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG TRL+TRR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRL+TRR_AVG_Crv") {
            TRLoTRRo = i;
            //// console.warn("TRLoTRRo Index:", TRLoTRRo);
          }
        }

        // GET TRL and TRR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // TopRearLeft_Crv* + TopRearRight_Crv*
          if (name.startsWith("TRL_Crv")) {
            TRLoCurve = i;
            //// console.warn("TRLoCurve Index:", TRLoCurve);
          }
          if (name.startsWith("TRR_Crv")) {
            TRRoCurve = i;
            //// console.warn("TRRoCurve Index:", TRRoCurve);
          }
        }

        // MAKE AVG RMS
        if (TRLoCurve && TRRoCurve && typeof TRLoCurve === 'number' && typeof TRRoCurve === 'number') {
          await postNext("RMS average", [TRLoCurve, TRRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TRL+TRR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between TRL + TRR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Top Rear AVG > DONE
        // Top Rear AVG > DONE

        // CENTER OPTIMIZED AVG
        // CENTER OPTIMIZED AVG
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;

          if (name.startsWith("C_Crv")) {
            CoCurve = i;
            //// console.warn("CoCurve Index:", CoCurve);
          }
          if (name.startsWith("FL+FR_RMSAVG_Crv")) {
            FLoAndFroCurve = i;
            //// console.warn("FLoAndFroCurve Index:", FLoAndFroCurve);
          }
        }

        // MAKE AVG RMS
        if (TRLoCurve && TRRoCurve && typeof TRLoCurve === 'number' && typeof TRRoCurve === 'number') {
          await postNext("RMS average", [CoCurve, FLoAndFroCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "C_OPT_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between C + FL + FR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // CENTER OPTIMIZED AVG > DONE
        // CENTER OPTIMIZED AVG > DONE

        // debugger;
        // ALL OPTIMIZED AVG
        // ALL OPTIMIZED AVG
        var hasBDL_Crv;
        var hasBDR_Crv;
        var hasC_Crv;
        var hasCH_Crv;
        var hasFDL_Crv;
        var hasFDR_Crv;
        var hasFL_Crv;
        var hasFHL_Crv;
        var hasFHR_Crv;
        var hasFWL_Crv;
        var hasFWR_Crv;
        var hasFR_Crv;
        var hasRHL_Crv;
        var hasRHR_Crv;
        var hasSBL_Crv;
        var hasSBR_Crv;
        var hasSLA_Crv;
        var hasSRA_Crv;
        var hasSB_Crv;
        var hasSDL_Crv;
        var hasSDR_Crv;
        var hasSHL_Crv;
        var hasSHR_Crv;
        var hasTFL_Crv;
        var hasTFR_Crv;
        var hasTML_Crv;
        var hasTMR_Crv;
        var hasTRL_Crv;
        var hasTRR_Crv;
        var hasTS_Crv;
        var hasSW1_Crv;
        var hasSWMIX1_Crv;

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        const allarray = [];
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;

          if (name.startsWith("BDL_Crv")) {
            hasBDL_Crv = i;
            allarray.push(hasBDL_Crv);
          }
          if (name.startsWith("BDR_Crv")) {
            hasBDR_Crv = i;
            allarray.push(hasBDR_Crv);
          }
          if (name.startsWith("C_Crv")) {
            hasC_Crv = i;
            allarray.push(hasC_Crv);
          }
          if (name.startsWith("CH_Crv")) {
            hasCH_Crv = i;
            allarray.push(hasCH_Crv);
          }
          if (name.startsWith("FDL_Crv")) {
            hasFDL_Crv = i;
            allarray.push(hasFDL_Crv);
          }
          if (name.startsWith("FDR_Crv")) {
            hasFDR_Crv = i;
            allarray.push(hasFDR_Crv);
          }
          if (name.startsWith("FL_Crv")) {
            hasFL_Crv = i;
            allarray.push(hasFL_Crv);
          }
          if (name.startsWith("FHL_Crv")) {
            hasFHL_Crv = i;
            allarray.push(hasFHL_Crv);
          }
          if (name.startsWith("FHR_Crv")) {
            hasFHR_Crv = i;
            allarray.push(hasFHR_Crv);
          }
          if (name.startsWith("FWL_Crv")) {
            hasFWL_Crv = i;
            allarray.push(hasFWL_Crv);
          }
          if (name.startsWith("FWR_Crv")) {
            hasFWR_Crv = i;
            allarray.push(hasFWR_Crv);
          }
          if (name.startsWith("FR_Crv")) {
            hasFR_Crv = i;
            allarray.push(hasFR_Crv);
          }
          if (name.startsWith("RHL_Crv")) {
            hasRHL_Crv = i;
            allarray.push(hasRHL_Crv);
          }
          if (name.startsWith("RHR_Crv")) {
            hasRHR_Crv = i;
            allarray.push(hasRHR_Crv);
          }
          if (name.startsWith("SBL_Crv")) {
            hasSBL_Crv = i;
            allarray.push(hasSBL_Crv);
          }
          if (name.startsWith("SBR_Crv")) {
            hasSBR_Crv = i;
            allarray.push(hasSBR_Crv);
          }
          if (name.startsWith("SLA_Crv")) {
            hasSLA_Crv = i;
            allarray.push(hasSLA_Crv);
          }
          if (name.startsWith("SRA_Crv")) {
            hasSRA_Crv = i;
            allarray.push(hasSRA_Crv);
          }
          if (name.startsWith("SB_Crv")) {
            hasSB_Crv = i;
            allarray.push(hasSB_Crv);
          }
          if (name.startsWith("SDL_Crv")) {
            hasSDL_Crv = i;
            allarray.push(hasSDL_Crv);
          }
          if (name.startsWith("SDR_Crv")) {
            hasSDR_Crv = i;
            allarray.push(hasSDR_Crv);
          }
          if (name.startsWith("SHL_Crv")) {
            hasSHL_Crv = i;
            allarray.push(hasSHL_Crv);
          }
          if (name.startsWith("SHR_Crv")) {
            hasSHR_Crv = i;
            allarray.push(hasSHR_Crv);
          }
          if (name.startsWith("TFL_Crv")) {
            hasTFL_Crv = i;
            allarray.push(hasTFL_Crv);
          }
          if (name.startsWith("TFR_Crv")) {
            hasTFR_Crv = i;
            allarray.push(hasTFR_Crv);
          }
          if (name.startsWith("TML_Crv")) {
            hasTML_Crv = i;
            allarray.push(hasTML_Crv);
          }
          if (name.startsWith("TMR_Crv")) {
            hasTMR_Crv = i;
            allarray.push(hasTMR_Crv);
          }
          if (name.startsWith("TRL_Crv")) {
            hasTRL_Crv = i;
            allarray.push(hasTRL_Crv);
          }
          if (name.startsWith("TRR_Crv")) {
            hasTRR_Crv = i;
            allarray.push(hasTRR_Crv);
          }
          if (name.startsWith("TS_Crv")) {
            hasTS_Crv = i;
            allarray.push(hasTS_Crv);
          }
          if (name.startsWith("SW1_Crv")) {
            hasSW1_Crv = i;
          }
          if (name.startsWith("SW2_Crv")) {
            hasSW2_Crv = i;
          }
          if (name.startsWith("SW3_Crv")) {
            hasSW3_Crv = i;
          }
          if (name.startsWith("SW4_Crv")) {
            hasSW4_Crv = i;
          }
          if (name.startsWith("SWMIX_Crv")) {
            hasSWMIX_Crv = i;
          }
          if (name.startsWith("SWMIX1_Crv")) {
            hasSWMIX1_Crv = i;
          }
          if (name.startsWith("SWMIX2_Crv")) {
            hasSWMIX2_Crv = i;
          }
          if (name.startsWith("SWMIX3_Crv")) {
            hasSWMIX3_Crv = i;
          }
          if (name.startsWith("SWMIX4_Crv")) {
            hasSWMIX4_Crv = i;
          }
        }
        // var arrayOfNumbers = allarray.map(Number);
        var myJsonString = JSON.stringify(allarray);
        // console.error(allarray);
        // MAKE AVG RMS
        await postNext(
          "RMS average",
          // myJsonString,
          allarray,
          // parseInt(allarray),
          /*
                hasBDL_Crv != 0 ? hasBDL_Crv : " ",
                hasBDR_Crv != 0 ? hasBDR_Crv : " ",
                hasC_Crv != 0 ? hasC_Crv : " ",
                hasCH_Crv != 0 ? hasCH_Crv : " ",
                hasFDL_Crv != 0 ? hasFDL_Crv : " ",
                hasFDR_Crv != 0 ? hasFDR_Crv : " ",
                hasFL_Crv != 0 ? hasFL_Crv : " ",
                hasFHL_Crv != 0 ? hasFHL_Crv : " ",
                hasFHR_Crv != 0 ? hasFHR_Crv : " ",
                hasFWL_Crv != 0 ? hasFWL_Crv : " ",
                hasFWR_Crv != 0 ? hasFWR_Crv : " ",
                hasFR_Crv != 0 ? hasFR_Crv : " ",
                hasRHL_Crv != 0 ? hasRHL_Crv : " ",
                hasRHR_Crv != 0 ? hasRHR_Crv : " ",
                hasSBL_Crv != 0 ? hasSBL_Crv : " ",
                hasSBR_Crv != 0 ? hasSBR_Crv : " ",
                hasSLA_Crv != 0 ? hasSLA_Crv : " ",
                hasSRA_Crv != 0 ? hasSRA_Crv : " ",
                hasSB_Crv != 0 ? hasSB_Crv : " ",
                hasSDL_Crv != 0 ? hasSDL_Crv : " ",
                hasSDR_Crv != 0 ? hasSDR_Crv : " ",
                hasSHL_Crv != 0 ? hasSHL_Crv : " ",
                hasSHR_Crv != 0 ? hasSHR_Crv : " ",
                hasTFL_Crv != 0 ? hasTFL_Crv : " ",
                hasTFR_Crv != 0 ? hasTFR_Crv : " ",
                hasTML_Crv != 0 ? hasTML_Crv : " ",
                hasTMR_Crv != 0 ? hasTMR_Crv : " ",
                hasTRL_Crv != 0 ? hasTRL_Crv : " ",
                hasTRR_Crv != 0 ? hasTRR_Crv : " ",
                hasTS_Crv != 0 ? hasTS_Crv : " ",
                */
        );
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "ALL_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between all speakers excluding subwoofer",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // ALL OPTIMIZED AVG > DONE
        // ALL OPTIMIZED AVG > DONE
      }

      /////////////////////////
      // TheCurvesAvgClean() //
      /////////////////////////
      async function TheCurvesClean() {
        // debugger;
        console.log("Cleaning some curves and leftovers.");

        let measurements = await fetch_mREW();
        const titles = {};
        let titleIndices = {};
        let mCount = Object.keys(measurements).length;
        let measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));

        // start removing?
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let i = mCount; i >= 1; i--) {
          if (measurements[i] && measurements[i].title) {
            const name = measurements[i].title;
            if (!name.includes("ALL_") && !name.includes("_Crv") && !name.includes("curve")) {
              try {
                await postDelete(i);
                await new Promise((resolve) => setTimeout(resolve, speedDelay));
              } catch (error) {
                console.error(`Failed to delete measurement ${i}:`, error);
              }
            }
          }
        }
        console.info("Cleaning done...");
        console.warn("Your room curve is ready for use...");
        console.warn("Go to the [ALl SPL] tab in REW >> right click somewhere on the screen");
        console.warn("and choose 'Export as txt'");
        console.warn("Be sure to check the box that says 'Do not include any comments or headers in the export'");
      }


      async function addmicCal() {
        console.info("Applying Audyssey microphone calibration file to measurements...");
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i < mCount; i++) {
          const irWindows = await fetchSafe('ir-windows', i);
          const leftW = parseFloat(irWindows.leftWindowWidthms);
          const rightW = parseFloat(irWindows.rightWindowWidthms);
          const refTime = parseFloat(irWindows.refTimems);
          await postNext('Arithmetic', [i, mCount], { function: "A * B" });
          await postSafe(`${baseUrl}/${mCount + i}/ir-windows`, { leftWindowWidthms: leftW, rightWindowWidthms: rightW, refTimems: refTime }, "Update processed");
          const name = measurements[i].title;
          await fetch_mREW(mCount + i, 'PUT', { title: name });
        }
        for (let i = mCount; i >= 1; i--) {
          await postDelete(i);
        }
        console.infoUpdate("Completed applying Audyssey microphone calibration file to measurements.");
      }

      // Add this debugging function to help troubleshoot the user's specific environment
      async function debugUserEnvironment() {
        console.log("=== USER ENVIRONMENT DEBUG ===");

        // Check REW API connectivity and version
        try {
          const rewVersion = await fetch(`http://localhost:4735/version`);
          if (rewVersion.ok) {
            const rew = await rewVersion.json();
            console.log(`REW Version: ${rew.message}`);
          } else {
            console.error(`REW Version check failed: ${rewVersion.status}`);
          }
        } catch (error) {
          console.error("REW API connection failed:", error);
        }

        // Check what postNext function actually looks like
        console.log("postNext function type:", typeof postNext);
        if (typeof postNext === 'function') {
          console.log("postNext function source (first 200 chars):", postNext.toString().substring(0, 200));
        }

        // Check baseUrl
        console.log("baseUrl:", baseUrl);

        // Test simple REW API call
        try {
          const measurements = await fetch_mREW();
          console.log("fetch_mREW successful, measurement count:", Object.keys(measurements).length);

          // Test a simple command on measurement 1 if it exists
          if (measurements[1]) {
            console.log("Testing simple command on measurement 1...");
            const testResult = await postNext('Smooth', 1, { smoothing: "1/48" });
            console.log("Simple command test successful");
          }
        } catch (error) {
          console.error("Basic REW API test failed:", error);
        }

        console.log("=== END ENVIRONMENT DEBUG ===");
      }

      // Modified addmicCal with extensive logging but keeping original logic
      async function addmicCalDebug() {
        console.info("Applying Audyssey microphone calibration file to measurements...");

        // Add environment debug for problematic user
        await debugUserEnvironment();

        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;

        console.log(`=== MICROCAL PROCESS START ===`);
        console.log(`Total measurements: ${mCount}`);
        console.log(`isCirrusLogic: ${isCirrusLogic}`);

        // Log all measurements
        for (let j = 1; j <= mCount; j++) {
          if (measurements[j]) {
            console.log(`  Measurement ${j}: ${measurements[j].title}`);
          } else {
            console.log(`  Measurement ${j}: MISSING`);
          }
        }

        for (let i = 1; i < mCount; i++) {
          if (!measurements[i]) {
            console.warn(`Skipping missing measurement ${i}`);
            continue;
          }

          console.log(`\n--- Processing ${i}/${mCount - 1}: ${measurements[i].title} ---`);

          try {
            const irWindows = await fetchSafe('ir-windows', i);
            console.log(`IR Windows retrieved for measurement ${i}`);

            const leftW = parseFloat(irWindows.leftWindowWidthms);
            const rightW = parseFloat(irWindows.rightWindowWidthms);
            const refTime = parseFloat(irWindows.refTimems);

            console.log(`IR Settings: Left=${leftW}, Right=${rightW}, Ref=${refTime}`);

            // Log exactly what we're about to send
            console.log(`About to call: postNext('Arithmetic', [${i}, ${mCount}], { function: "A * B" })`);

            // Check measurements still exist right before the call
            const preCallCheck = await fetch_mREW();
            if (!preCallCheck[i]) {
              throw new Error(`Measurement ${i} disappeared before arithmetic!`);
            }
            if (!preCallCheck[mCount]) {
              throw new Error(`Measurement ${mCount} (micCal) disappeared before arithmetic!`);
            }

            // THE ORIGINAL CALL - unchanged from working version
            const arithmeticResult = await postNext('Arithmetic', [i, mCount], { function: "A * B" });

            console.log(`✓ Arithmetic successful for measurement ${i}`);
            console.log(`Result:`, arithmeticResult);

            // Continue with original logic
            const resultIndex = Object.keys(arithmeticResult.results)[0];
            await postSafe(`${baseUrl}/${resultIndex}/ir-windows`, { leftWindowWidthms: leftW, rightWindowWidthms: rightW, refTimems: refTime }, "Update processed");
            const name = measurements[i].title;
            await fetch_mREW(resultIndex, 'PUT', { title: name });

            console.log(`✓ Completed processing measurement ${i}`);

          } catch (error) {
            console.error(`❌ FAILED processing measurement ${i} (${measurements[i].title}):`, error);

            // Additional debugging for the failed case
            console.log("=== FAILURE DEBUG ===");
            console.log("Error type:", error.constructor.name);
            console.log("Error message:", error.message);
            console.log("Error stack:", error.stack);

            // Check if measurements still exist after failure
            try {
              const postErrorCheck = await fetch_mREW();
              console.log(`Post-error measurement ${i} exists:`, !!postErrorCheck[i]);
              console.log(`Post-error measurement ${mCount} exists:`, !!postErrorCheck[mCount]);
            } catch (checkError) {
              console.log("Could not check measurements after error:", checkError);
            }

            throw error; // Re-throw to maintain original behavior
          }
        }

        console.log("\n=== CLEANUP PHASE ===");
        for (let i = mCount; i >= 1; i--) {
          console.log(`Deleting measurement ${i}`);
          await postDelete(i);
        }
        console.infoUpdate("Completed applying Audyssey microphone calibration file to measurements.");
      }

      // Fallback version that skips microcal if it fails
      async function addmicCalWithSkipOption() {
        try {
          // Try the original addmicCal first
          await addmicCalDebug();
        } catch (error) {
          console.error("❌ Microphone calibration failed:", error);

          // Ask user if they want to continue without microcal
          const skipMicCal = confirm(
            "Microphone calibration failed. This might be due to a REW version compatibility issue.\n\n" +
            "Would you like to continue WITHOUT microphone calibration?\n\n" +
            "(Click OK to skip microcal and continue, or Cancel to stop)"
          );

          if (skipMicCal) {
            console.warn("🚨 USER CHOSE TO SKIP MICROPHONE CALIBRATION");

            // Remove the microcal measurement to prevent issues later
            const measurements = await fetch_mREW();
            const mCount = Object.keys(measurements).length;

            if (measurements[mCount] && measurements[mCount].title.includes("micCal")) {
              console.log("Removing microphone calibration measurement...");
              await postDelete(mCount);
              console.log("✓ Microphone calibration measurement removed");
            }

            console.warn("⚠️ Continuing without microphone calibration - results may be less accurate");
            return; // Continue execution
          } else {
            console.error("User chose to stop due to microcal failure");
            throw error; // Re-throw to stop execution
          }
        }
      }

      async function enableRoomCurve() {
        await postSafe(`http://localhost:4735/eq/default-room-curve-settings`, {
          addRoomCurve: true, lowFreqRiseStartHz: 630, lowFreqRiseEndHz: 100, lowFreqRiseSlopedBPerOctave: 0.8,
          highFreqFallStartHz: 630, highFreqFallSlopedBPerOctave: 0.8
        }, "Update processed");
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i <= mCount; i++) {
          await postSafe(`${baseUrl}/${i}/room-curve-settings`, {
            addRoomCurve: true, lowFreqRiseStartHz: 630, lowFreqRiseEndHz: 100, lowFreqRiseSlopedBPerOctave: 0.8,
            highFreqFallStartHz: 630, highFreqFallSlopedBPerOctave: 0.8
          }, "Update processed");
        }
      }

      async function disableRoomCurve() {
        await postSafe(`http://localhost:4735/eq/default-room-curve-settings`, { addRoomCurve: false }, "Update processed");
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i <= mCount; i++) {
          await postSafe(`${baseUrl}/${i}/room-curve-settings`, { addRoomCurve: false }, "Update processed");
        }
      }

      function logCustomizations() {
        console.info(`****************************************************************************************************`);
        console.log("Optimization parameters:")
        if (targetCurveName === "") {
          console.info("  No target curve - 'ClariQ Next' - will EQ to a gentle downward slope & enable Dynamic EQ.");
        } else {
          console.info(`  Active target curve: ${targetCurveName}.`);
        }

        if (targetLevel == 75) {
          console.info(`  Target level set to ${targetLevel}dB`);
        } else {
          console.warn(`  Target level set to ${targetLevel}dB`);
        }

        if (isRP22mode == true || isRP22mode == 1) {
          console.warn(`  CEDIA RP22 mode set to ${isRP22mode}`);
        } else {
          console.info(`  CEDIA RP22 mode set to ${isRP22mode}`);
        }

        if (freqIndex.includes(180)) {
          console.info("  AVR supports 180Hz");
        }
        if (freqIndex.includes(70)) {
          console.info("  AVR 'supports' IMAX 70Hz");
        }

        if (noInversion) {
          console.warn(`  Subwoofer polarity inversion allowed: No.`);
        } else {
          console.info(`  Subwoofer polarity inversion allowed: Yes.`);
        }

        if (AdvancedFilters == true || AdvancedFilters == 1) {
          console.warn(`  Advanced Filters: ${AdvancedFilters}`);
        } else {
          console.info(`  Advanced Filters: ${AdvancedFilters}`);
        }

        if (AdvancedFilters == true && AdvancedFiltersType == "null") {
          console.info(`  Advanced Filters Type: none`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "DIALOGadvanced") {
          console.warn(`  Advanced Filters Type: Advanced Dialog Enhancement CEDIA RP22`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSresearch") {
          console.warn(`  Advanced Filters Type: Research-Based Hearing Loss Compensation`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSmoderate") {
          console.warn(`  Advanced Filters Type: Moderate Hearing Loss Compensation`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSsevere") {
          console.warn(`  Advanced Filters Type: Severe Hearing Loss Compensation`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSoriginal") {
          console.warn(`  Advanced Filters Type: Original 0.0.3 Hearing Loss Compensation`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGcompetitive") {
          console.warn(`  Advanced Filters Type: Competitive Gaming EQ (Footsteps & Tactical Audio)`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGimmersive") {
          console.warn(`  Advanced Filters Type: Immersive Gaming EQ (Cinematic Experience)`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGvoice") {
          console.warn(`  Advanced Filters Type: Voice Chat Gaming EQ (Clear Communication)`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGbalanced") {
          console.infwarno(`  Advanced Filters Type: Balanced Gaming EQ (All-Purpose)`);
        }

        if (needsSorting) {
          console.warn(`  Measurements are custom sorted`);
        } else {
          console.info(`  Measurements are default sorted`);
        }
        console.info(`  Version: ${nextversion}`)
        console.info(`****************************************************************************************************`);
      }

      async function bootUp() {
        console.info("Resetting IR windows, equalizer & target settings for all measurements");
        const measurements = await fetch_mREW();
        const titles = {}; let titleIndices = {};
        let mCount = Object.keys(measurements).length;

        console.info(`Starting processing of ${mCount} measurements...`);
        for (let q = 1; q <= mCount; q++) {
          console.infoUpdate(`Counting measurement ${q} of ${mCount}`);
        }

        if (mCount > 100) {
          console.warn(`large amount of measurements found ${mCount} REW may seem unresponsive for some time`)
          console.warn(`Please be patient`)
        }

        if (!mCount) { console.error(`There are no measurements in REW!`); throw new Error; }
        if (isCirrusLogic) { mCount--; };
        let baseMessage = "Resetting IR windows, EQ type, target shape and smoothing for all measurements..."
        for (let q = 1; q <= mCount; q++) {
          await postSafe(`${baseUrl}/${q}/ir-windows`, { leftWindowType: "Rectangular", rightWindowType: "Rectangular" }, "Update processed");
          await new Promise((resolve) => setTimeout(resolve, speedDelay / 2));
          await postSafe(`${baseUrl}/${q}/equaliser`, { manufacturer: "Generic", model: "Generic" }, "Equaliser selected");
          await new Promise((resolve) => setTimeout(resolve, speedDelay / 2));
          await postSafe(`${baseUrl}/${q}/target-settings`, { shape: "None" }, "Update processed");
          await new Promise((resolve) => setTimeout(resolve, speedDelay / 2));
          await postNext('Smooth', q, { smoothing: "1/48" });
          await new Promise((resolve) => setTimeout(resolve, speedDelay / 2));
          console.infoUpdate(`${baseMessage} (${q}/${mCount})`);
        }
        await console.infoUpdate("Resetting default equalizer to 'Generic/Generic'...");
        await postSafe(`http://localhost:4735/eq/default-equaliser`, { manufacturer: "Generic", model: "Generic" }, "Default equaliser changed");
        await new Promise((resolve) => setTimeout(resolve, speedDelay / 2));
        const firstTitle = measurements[1].title;

        console.infoUpdate(`Checking measurement names, indices and sorting...`);

        // First pass: build titleIndices using current version's logic
        for (let i = 1; i <= mCount; i++) {
          const title = measurements[i].title;
          const titleKey = title.replace(/\d+/g, '');
          if (!/^\D+(\d+)?$/.test(titleKey)) {
            console.error(`Speaker name ${titleKey} does not end with a numeric index.`);
            throw new Error;
          }
          if (!titles[titleKey]) {
            titles[titleKey] = true;
            titleIndices[titleKey] = [];
          }
          const matchResult = title.match(/\d+/);
          if (matchResult && matchResult.length > 0) {
            titleIndices[titleKey].push(parseInt(matchResult[0]));
          } else {
            console.error(`No indices found in speaker name: ${title}`);
            throw new Error;
          }
        }

        // Build expected order: regular speakers first, then subwoofers
        const regularGroups = Object.keys(titleIndices).filter(key => !key.startsWith('SW')).sort();
        const swGroups = Object.keys(titleIndices).filter(key => key.startsWith('SW')).sort();

        for (const groupKey of [...regularGroups, ...swGroups]) {
          for (const index of titleIndices[groupKey].sort((a, b) => a - b)) {
            expectedOrder.push(groupKey + index);
          }
        }

        // Check if current REW order matches expected order
        for (let i = 1; i <= mCount; i++) {
          if (measurements[i].title !== expectedOrder[i - 1]) {
            needsSorting = true;
            console.info(`Order mismatch at position ${i}: found "${measurements[i].title}", expected "${expectedOrder[i - 1]}"`);
            break;
          }
        }

        if (needsSorting) {
          console.infoUpdate("Measurements need reordering. Performing manual sort for proper numeric ordering...");
          disableGraph();
          try {
            // Get current measurements
            const currentMeasurements = await fetch_mREW();
            const currentMCount = Object.keys(currentMeasurements).length - (isCirrusLogic ? 1 : 0);

            // Parse all measurements and group them
            const measurementGroups = {};
            for (let i = 1; i <= currentMCount; i++) {
              const name = currentMeasurements[i].title;
              const titleKey = name.replace(/\d+/g, '');
              const matchResult = name.match(/\d+/);
              if (matchResult && matchResult.length > 0) {
                const groupKey = titleKey;
                const index = parseInt(matchResult[0]);

                if (!measurementGroups[groupKey]) {
                  measurementGroups[groupKey] = [];
                }
                measurementGroups[groupKey].push({
                  originalIndex: i,
                  name: name,
                  index: index
                });
              } else {
                console.error(`No indices found in speaker name: ${name}`);
                throw new Error;
              }
            }

            // Sort each group numerically by index
            const sortedGroups = {};
            for (const groupKey in measurementGroups) {
              sortedGroups[groupKey] = measurementGroups[groupKey].sort((a, b) => a.index - b.index);
            }

            // Determine copy order: regular speakers first, then SW groups
            const copyOrder = [];
            const regularGroups = Object.keys(sortedGroups).filter(key => !key.startsWith('SW')).sort();
            const swGroups = Object.keys(sortedGroups).filter(key => key.startsWith('SW')).sort();

            for (const groupKey of [...regularGroups, ...swGroups]) {
              copyOrder.push(...sortedGroups[groupKey]);
            }

            console.infoUpdate(`Copying ${copyOrder.length} measurements in correct numeric order...`);

            // Copy all measurements in the correct order
            for (let i = 0; i < copyOrder.length; i++) {
              const measurement = copyOrder[i];
              await postSafe(`http://localhost:4735/measurements/${measurement.originalIndex}/command`, { command: "Response copy" }, "Completed");
              await new Promise((resolve) => setTimeout(resolve, speedDelay || 100));
              console.infoUpdate(`Copying measurements... (${i + 1}/${copyOrder.length})`);
            }

            console.infoUpdate("Removing original measurements...");

            // Delete all original measurements (backwards to avoid index shifting)
            for (let i = currentMCount; i >= 1; i--) {
              await postDelete(i);
              await new Promise((resolve) => setTimeout(resolve, speedDelay || 100));
              console.infoUpdate(`Removing original measurements... (${currentMCount - i + 1}/${currentMCount})`);
            }

            console.infoUpdate("Renaming copied measurements to remove '-copy' suffixes...");

            // Re-fetch to get the remaining measurements (all should be -copy versions now)
            const copiedMeasurements = await fetch_mREW();
            const newMCount = Object.keys(copiedMeasurements).length - (isCirrusLogic ? 1 : 0);

            // Rename all measurements that have "-copy" suffix
            for (let q = 1; q <= newMCount; q++) {
              const name = copiedMeasurements[q].title;
              if (name.endsWith("-copy")) {
                const newname = name.replace(/-copy/gim, "");
                const requestOptions = {
                  method: "PUT",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ title: newname }),
                };
                await fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
                await new Promise((resolve) => setTimeout(resolve, speedDelay || 100));
                console.infoUpdate(`Renaming measurements... (${q}/${newMCount})`);
              }
            }

            console.infoUpdate("Manual sorting completed. Re-fetching measurement data...");

            // Re-fetch and rebuild measurement data
            const sortedMeasurements = await fetch_mREW();
            mCount = Object.keys(sortedMeasurements).length;
            if (isCirrusLogic) { mCount--; };

            // Clear and rebuild the titles and indices with sorted data
            Object.keys(titles).forEach(key => delete titles[key]);
            Object.keys(titleIndices).forEach(key => delete titleIndices[key]);

            for (let i = 1; i <= mCount; i++) {
              const title = sortedMeasurements[i].title;
              const titleKey = title.replace(/\d+/g, '');

              if (!titles[titleKey]) {
                titles[titleKey] = true;
                titleIndices[titleKey] = [];
              }

              const matchResult = title.match(/\d+/);
              if (matchResult && matchResult.length > 0) {
                titleIndices[titleKey].push(parseInt(matchResult[0]));
              }
            };

            // console.infoUpdate("Manual sorting and re-indexing completed successfully.");
            console.infoUpdate("ClariQ Next sorting and re-indexing completed successfully.");
            enableGraph();

          } catch (error) {
            // console.error("Failed to perform manual sorting:", error);
            // console.error("Please manually sort measurements in REW and run the script again.");
            console.error("Failed to perform ClariQ Next sorting:", error);
            console.error("Please report your issue on discord!");
            throw new Error;
          }
        }

        // Continue with rest of original logic
        nSpeakers = 0;
        nSubs = 0;
        for (const titleKey in titleIndices) {
          const indices = titleIndices[titleKey];
          if (indices[0] != Math.min(...indices)) {
            console.error(`MLP measurement needs to be the first measurement for ${titleKey} channel!`);
            throw new Error;
          }
          if (titleKey === "SWMIX") {
            nSubs = 1;
          }
          else if (titleKey.startsWith("SW")) {
            for (let i = 0; i < titleIndices[titleKey].length; i++) {
              swIdx = String(titleIndices[titleKey][i]);
              if (swIdx.length === 2 && swIdx.endsWith("0")) {
                nSubs++;
              }
            }
          }
          else {
            nSpeakers++;
          }
        }
        Object.freeze(nSpeakers);
        Object.freeze(nSubs);
        nChannels = Object.keys(titles).length;
        Object.freeze(nChannels);
        const rewVersion = await fetch(`http://localhost:4735/version`);
        if (rewVersion.ok) {
          const rew = await rewVersion.json();
          console.infoUpdate(`Integrity checks completed successfully. Running Room EQ Wizard version ${rew.message}`);
        }
        else {
          console.error('There seems to be a problem with REW installation!');
          throw new Error;
        }

        // BEFORE addmicCal
        if (parseFloat(measurements[1].splOffsetdB) < isCirrusLogictargetLevel) {
          console.log(`BEFORE addmicCal >> LESS < ${isCirrusLogictargetLevel} - parseFloat(measurements[1].splOffsetdB",`, parseFloat(measurements[1].splOffsetdB));
        } else if (parseFloat(measurements[1].splOffsetdB) > isCirrusLogictargetLevel) {
          console.log(`BEFORE addmicCal >> GREATER > ${isCirrusLogictargetLevel} - parseFloat(measurements[1].splOffsetdB",`, parseFloat(measurements[1].splOffsetdB));
        } else {
          console.log(`BEFORE addmicCal >> EQUAL = ${isCirrusLogictargetLevel} - parseFloat(measurements[1].splOffsetdB",`, parseFloat(measurements[1].splOffsetdB));
        }

        /*
        if (isCirrusLogic) { await addmicCal(); } // only apply if all sanity checks pass
        */
        // In bootUp function, before the addmicCal call:
        if (isCirrusLogic) {
          try {
            await addmicCal();
          } catch (error) {
            console.error("Microphone calibration failed:", error);
            const skipMicCal = confirm("Microphone calibration failed. Continue without it?");
            if (skipMicCal) {
              // Remove microcal measurement and continue
              const measurements = await fetch_mREW();
              const mCount = Object.keys(measurements).length;
              await postDelete(mCount);
              console.warn("Continuing without microphone calibration");
            } else {
              throw error;
            }
          }
        }

        const nmeasurements = await fetch_mREW();
        const ntitles = {}; let ntitleIndices = {};
        let nmCount = Object.keys(nmeasurements).length;
        // Rename all measurements that have "-copy" suffix
        for (let q = 1; q <= nmCount; q++) {
          // AFTER addmicCal
          if (parseFloat(nmeasurements[q].splOffsetdB) < isCirrusLogictargetLevel) {
            console.log(`AFTER addmicCal >> LESS < ${isCirrusLogictargetLevel} - parseFloat(nmeasurements[q].splOffsetdB",`, parseFloat(nmeasurements[q].splOffsetdB));
          } else if (parseFloat(nmeasurements[q].splOffsetdB) > isCirrusLogictargetLevel) {
            console.log(`AFTER addmicCal >> GREATER > ${isCirrusLogictargetLevel} - parseFloat(nmeasurements[q].splOffsetdB",`, parseFloat(nmeasurements[q].splOffsetdB));
          } else {
            console.log(`AFTER addmicCal >> EQUAL = ${isCirrusLogictargetLevel} - parseFloat(nmeasurements[q].splOffsetdB",`, parseFloat(nmeasurements[q].splOffsetdB));
          }
        }

        const tcResponse = await fetch('http://localhost:4735/eq/house-curve');
        if (tcResponse.ok) {
          const target = await tcResponse.json();
          targetCurvePath = String(target);
          if (target && targetCurvePath) {
            targetCurveName = targetCurvePath.replace(/^.*[\\/]/, '').split(".")[0];
            Object.freeze(targetCurveName);
            Object.freeze(targetCurvePath);
            await disableRoomCurve();
            await postSafe(`http://localhost:4735/eq/house-curve`, targetCurvePath, "House curve set");
          }
          else {
            targetCurveName = "";
            await enableRoomCurve();
          }
          // await fetchSafe('target-level', 1, 75.0);
          await fetchSafe('target-level', 1, targetLevel)
          const targetCurve = await postNext('Generate target measurement', 1);
          const targetCurveIdx = Object.keys(targetCurve.results)[0];
          targetResponse = await fetchSafe(`frequency-response?smoothing=1%2F48&ppo=96`, targetCurveIdx);
          Object.freeze(targetResponse); // ensure it doesn't change once optimization starts
          await postDelete(targetCurveIdx);
        }
        else {
          console.error(`Failed to fetch target curve, please make sure to have started REW API server! HTTP status code: ${tcResponse.status}.`);
          throw new Error;
        }
        const indicesCounts = Object.values(titleIndices).map(indices => indices.length);
        const isIndicesEqual = indicesCounts.every(count => count === indicesCounts[0]);
        if (!isIndicesEqual) {
          const problemG = [];
          for (const [titleKey, indices] of Object.entries(titleIndices)) {
            if (indices.length !== indicesCounts[0]) {
              problemG.push(titleKey);
            }
          }
          if (problemG.some(group => group.startsWith('SW')) && bassMode === "Directional") {
            console.info(`'Directional bass' mode with '${nSubs}' subwoofers detected!`);
          } else {
            console.error('Speaker names have different numbers of indices.');
            throw new Error();
          }
        }
        logCustomizations();
        return;
      }

      function getDelayHeadroom(startIdx, endIdx) {
        const minM = Math.min(...mSec.slice(startIdx, endIdx + 1));
        const maxM = Math.max(...mSec.slice(startIdx, endIdx + 1));
        const limInsec = 6 / sOs;
        const msecMin = maxM - limInsec;
        const msecMax = minM + limInsec;
        const maxNegative = msecMin * 1000;
        const maxPositive = msecMax * 1000;
        if (maxNegative > maxPositive) {
          console.error("Ran out of delay range!");
          throw new Error;
        }
        return [maxNegative, maxPositive];
      }

      // returns range that "thisDelay" can be shifted by
      function getDelayRangeOf(thisDelay, startIdx, endIdx) {
        const [maxNegative, maxPositive] = getDelayHeadroom(startIdx, endIdx);
        const delayms = thisDelay * 1000;
        let loDelay = Infinity, hiDelay = -Infinity;
        if (thisDelay < 0) {
          loDelay = maxNegative - delayms;
          hiDelay = maxPositive;
        }
        else {
          loDelay = maxNegative;
          hiDelay = maxPositive - delayms;
        }
        if (loDelay > hiDelay) {
          console.error("Ran out of delay range!");
          throw new Error;
        }
        return [loDelay, hiDelay];
      }

      function getDelayRangeOfFinalSub() {
        let [loDelay, hiDelay] = getDelayRangeOf(mSec[nChannels]);
        // directional subwoofer delay(s)
        if (bassMode === "Directional") {
          const loDelaySub = Math.min(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          const hiDelaySub = Math.max(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          [loDelay,] = getDelayRangeOf(loDelaySub, 1, nSpeakers);
          [, hiDelay] = getDelayRangeOf(hiDelaySub, 1, nSpeakers);
        }
        // standard bass relative delay(s)
        else {
          [loDelay,] = getDelayRangeOf(mSec[nChannels] + subLoDelay, 1, nSpeakers);
          [, hiDelay] = getDelayRangeOf(mSec[nChannels] + subHiDelay, 1, nSpeakers);
        }
        if (loDelay > hiDelay) {
          console.error("Ran out of delay range!");
          throw new Error;
        }
        return [loDelay, hiDelay];
      }

      async function groundWorks() {
        let measurements = await fetch_mREW();
        let mCount = Object.keys(measurements).length;
        // move sub measurements to the bottom of the list in REW
        for (let i = 1; i <= mCount; i++) {
          const name = measurements[i].title;
          if (name.startsWith("SW")) {
            await postSafe(`${baseUrl}/${i}/command`, { command: "Response copy" }, "Completed");
          }
        }
        for (let i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SW")) { await postDelete(i); }
        }
        const micPositions = mCount / (nSpeakers + nSubs);
        /*
        if (bassMode != "Directional" && swChannelCount > 1) { console.info(`'Standard bass' mode with '${swChannelCount}' subwoofers detected.`); }
        if (bassMode != "Directional" && swChannelCount === 1) { console.info(`'Standard bass' mode with '${swChannelCount}' subwoofer detected.`); }
        */
        if (bassMode != "Directional" && swChannelCount > 1) {
          bassMode = "Standard";
          console.info(`'Standard bass' mode with '${swChannelCount}' subwoofers detected.`);
        }

        if (bassMode != "Directional" && swChannelCount === 1) {
          bassMode = "Standard";
          console.info(`'Standard bass' mode with '${swChannelCount}' subwoofer detected.`);
        }

        console.log(`Optimizing speaker volume & time alignment using <${micPositions}> different microphone positions...`);
        console.info(`Starting...`);
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        let count = 1;
        let title = {};
        for (let i = 1; i <= mCount; i += micPositions) {
          console.infoUpdate(`Computing optimal spatial averaging configuration for speaker #${(i - 1) / micPositions + 1}`)
          const indices = Array.from({ length: micPositions }, (_, j) => i + j);
          if (micPositions > 1) {
            await postNext('Cross corr align', indices);
          }
          mSec[count] = parseFloat(measurements[i].cumulativeIRShiftSeconds);
          title[count] = measurements[i].title.slice(0, -1) + "o";
          if (title[count].startsWith("SW")) { title[count] = title[count].slice(0, -6) + "o"; }
          // trim determination using the MLP measurement
          if (title[count].startsWith("SW")) {
            customLevel[count] = await getSubTrim(i);
          }
          else {
            customLevel[count] = await getSpeakerTrim(i);
          }
          // level match all other positions to MLP & average
          await alignVol2MLP(indices, i);
          if (micPositions === 1) {
            await postSafe(`${baseUrl}/${i}/command`, { command: "Response copy" }, "Completed"); // nothing to average
          }
          else {
            await postNext('Magn plus phase average', indices); // do not use VA, it reduces SPL!
          }
          // the "o" measurement
          const idx = mCount + count;
          await fetch_mREW(idx, 'PUT', { title: title[count] });
          // align "o" measurement to target curve
          let volAdjust = parseFloat(customLevel[count]);
          await postNext('Add SPL offset', idx, { offset: volAdjust });
          // go to next channel
          count++;
        }
        console.infoUpdate("Deleting processed measurements...");
        for (let i = mCount; i >= 1; i--) {
          await postDelete(i);
        }
        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          commandId[i] = title[i].slice(0, -1);
        }
        console.infoUpdate("Time aligning speakers...");
        // align speakers but leave subwoofers alone. ANY align command messes up subwoofer IR alignment
        const spIndices = Array.from({ length: nSpeakers }, (_, j) => j + 1);
        await postNext('Time align', spIndices);
        measurements = await fetch_mREW();
        // calculate audyssey IR start delay
        let totalIRShift = 0;
        for (let i = 1; i <= nSpeakers; i++) {
          totalIRShift += parseFloat(measurements[i].cumulativeIRShiftSeconds);
        }
        // determine relative delays and remove audyssey IR start delay
        const IRStartDelay = totalIRShift / nSpeakers;
        for (let i = 1; i <= nSpeakers; i++) {
          mSec[i] -= (parseFloat(measurements[i].cumulativeIRShiftSeconds) - IRStartDelay);
        }

        normalizeTrimLevels();

        console.infoUpdate("Completed averaging, volume & time alignment!");
        // no need to go further without subwoofer
        if (noSub) { return; }
        // remove audyssey IR start delay from subwoofers
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          await postNext('Offset t=0', i, { offset: IRStartDelay, unit: "seconds" });
        }
        if (bassMode === "Directional") {
          console.warn("Your system will now be converted to 'standard bass' mode for a better sound experience...");
          await directional2standard();
          console.warn("Conversion from 'directional bass' mode to 'standard bass' mode completed.")
        }
        else {
          // normalize standard bass subwoofer median IR to t=0
          const IROffset = (subLoDelay + subHiDelay) / 2;
          await postNext('Offset t=0', nChannels, { offset: IROffset, unit: "seconds" });
          mSec[nChannels] -= IROffset;
        }
        // align final subwoofer median IR to median IR of speakers
        // note: this ensures min/max delays are negative/positive, otherwise REW crashes
        const loSPDelay = Math.min(...mSec.slice(1, nSpeakers + 1));
        const hiSPDelay = Math.max(...mSec.slice(1, nSpeakers + 1));
        const medianSPDelay = (loSPDelay + hiSPDelay) / 2;
        await postNext('Offset t=0', nChannels, { offset: -medianSPDelay, unit: "seconds" });
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          mSec[i] += medianSPDelay;
        }
        // done with groundworks and log
        const [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        console.info(`Available bass system volume adjustment range → { ${subLoTrim}dB : ${subHiTrim}dB }`);
        console.info(`Total subwoofer 'delay headroom' available → ${(hiDelay - loDelay).toFixed(2)}ms`);
        const dynamicBassFilldB = await getDynamicBassFill(nChannels);
        if (dynamicBassFilldB != 0) {
          console.warn(`***Adding ${dynamicBassFilldB}dB dynamic bass fill to compensate for dips!***`);
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += dynamicBassFilldB;
            console.info(`${commandId[i].padStart(3, ".")} - shifted: ${customLevel[i] - dynamicBassFilldB}dB → ${customLevel[i]}dB`);
          }
          await postNext('Add SPL offset', nChannels, { offset: dynamicBassFilldB });
        }
      }

      async function getALOffset(idx, isSub) {
        const fltResponse = await fetchSafe('frequency-response?smoothing=1%2F1&ppo=96', idx);
        const fltArray = isSub ? await response2array(fltResponse, 30, 80) : await response2array(fltResponse, 500, 2000);
        const offset = fltArray.reduce((acc, val) => acc + val, 0) / fltArray.length;
        return offset;
      }

      async function generateFilters() {
        console.log(`Generating min. phase EQ filters...`);

        // ===== FILTER CONFIGURATION =====
        // Set these variables to enable different filter types:

        // Hearing loss compensation: "research", "moderate", "severe", "original", or null
        // const hearingLossType = "research";

        // Gaming EQ optimization: "competitive", "immersive", "voice", "balanced", or null  
        // - "competitive": Optimized for footsteps, gunshots, tactical audio (FPS games)
        // - "immersive": Cinematic experience with enhanced atmosphere (RPG/Adventure) 
        // - "voice": Clear voice chat communication with game audio
        // - "balanced": All-purpose gaming enhancement
        // const gamingEQType = "competitive";

        // Dialog enhancement: controlled by existing RP22DialogEnhancementFilter boolean

        // Smart filter creation helper - handles REW API parameter requirements
        const createREWFilter = (index, type, frequency, gaindB = 0, q = 1.0) => ({
          index,
          type,
          enabled: true,
          isAuto: false,
          frequency,
          ...(type !== "HP" && { gaindB }), // All except HP have gaindB
          ...(type === "PK" && { q })        // Only PK filters have q
        });

        const getAdvancedFilters = (type) => {
          switch (type) {
            case "DIALOGadvanced":
              return {
                filters: [
                  createREWFilter(16, "PK", 1600, 2.5, 1.2),   // Peak speech intelligibility
                  createREWFilter(17, "PK", 3000, 3.0, 1.5),   // Critical consonant clarity
                  createREWFilter(18, "PK", 800, 1.5, 0.8),    // Speech warmth and body
                  createREWFilter(19, "PK", 4500, 2.0, 1.8),   // Upper consonant definition
                  createREWFilter(20, "HS", 5000, -1.0)        // Sibilance control
                ],
                description: "Advanced Dialog Enhancement CEDIA RP22",
                targets: [
                  "- 800Hz: +1.5dB (Speech warmth and body)",
                  "- 1.6kHz: +2.5dB (Peak speech intelligibility",
                  "- 3kHz: +3.0dB (Critical consonant clarity)",
                  "- 4.5kHz: +2.0dB (Upper consonant definition)",
                  "- 5kHz+: -1.0dB (Sibilance control)"
                ]
              };


            case "HLOSSresearch":
              return {
                filters: [
                  createREWFilter(11, "PK", 2000, 2.0, 1.0),   // Presbycusis difficulty onset
                  createREWFilter(12, "PK", 4000, 4.0, 1.2),   // Critical consonant clarity
                  createREWFilter(13, "PK", 6000, 6.0, 1.5),   // Major presbycusis loss frequency  
                  createREWFilter(14, "HS", 8000, 4.0)         // High-frequency presbycusis
                ],
                description: "Research-Based Hearing Loss Compensation",
                targets: [
                  "- 2kHz: +2.0dB (Presbycusis difficulty onset)",
                  "- 4kHz: +4.0dB (Critical consonant clarity)",
                  "- 6kHz: +6.0dB (Major presbycusis loss frequency)",
                  "- 8kHz+: +4.0dB (High-frequency compensation)"
                ]
              };

            case "HLOSSmoderate":
              return {
                filters: [
                  createREWFilter(11, "HP", 80),                // Remove low-frequency masking
                  createREWFilter(12, "PK", 2500, 3.0, 1.0),   // Speech intelligibility range
                  createREWFilter(13, "PK", 4000, 5.0, 1.3),   // 4kHz notch compensation
                  createREWFilter(14, "HS", 6000, 3.0)         // General high-frequency lift
                ],
                description: "Moderate Hearing Loss Compensation",
                targets: [
                  "- 80Hz: High-pass filter (remove masking)",
                  "- 2.5kHz: +3.0dB (Speech intelligibility)",
                  "- 4kHz: +5.0dB (Notch compensation)",
                  "- 6kHz+: +3.0dB (High-frequency lift)"
                ]
              };

            case "HLOSSsevere":
              return {
                filters: [
                  createREWFilter(11, "HP", 100),              // Aggressive low-cut
                  createREWFilter(12, "PK", 2000, 6.0, 1.0),   // Strong speech boost
                  createREWFilter(13, "PK", 4000, 10.0, 1.5),  // Maximum 4kHz compensation
                  createREWFilter(14, "PK", 6000, 12.0, 1.5),  // Strong 6kHz boost
                  createREWFilter(15, "HS", 8000, 8.0)         // Aggressive high-frequency
                ],
                description: "Severe Hearing Loss Compensation",
                targets: [
                  "- 100Hz: High-pass filter (aggressive low-cut)",
                  "- 2kHz: +6.0dB (Strong speech boost)",
                  "- 4kHz: +10.0dB (Maximum compensation)",
                  "- 6kHz: +12.0dB (Strong high-frequency boost)",
                  "- 8kHz+: +8.0dB (Aggressive compensation)"
                ]
              };

            case "HLOSSoriginal":
              return {
                filters: [
                  createREWFilter(11, "PK", 1000, 1.5, 0.9),   // Speech body and presence
                  createREWFilter(12, "PK", 2500, 3.0, 1.2),   // Consonant intelligibility
                  createREWFilter(13, "PK", 4000, 4.0, 1.5),   // High consonant clarity boost
                  createREWFilter(14, "PK", 6000, 3.0, 1.8),   // Upper speech and sibilant detail
                  createREWFilter(15, "HS", 8000, 2.0)         // High frequency audibility
                ],
                description: "Original 0.0.3 Hearing Loss Compensation",
                targets: [
                  "- 1kHz: +1.5dB (Speech body and presence)",
                  "- 2.5kHz: +3.0dB (Consonant intelligibility)",
                  "- 4kHz: +4.0dB (High consonant clarity boost)",
                  "- 6kHz: +3.0dB (Upper speech and sibilant detail)",
                  "- 8kHz+: +2.0dB (High frequency audibility)"
                ]
              };

            case "GAMINGcompetitive":
              return {
                filters: [
                  // createREWFilter(5, "HP", 60),            // Remove low-frequency rumble
                  createREWFilter(6, "PK", 400, -2.0, 1.0),   // Reduce muddiness that masks footsteps
                  createREWFilter(7, "PK", 2000, 3.0, 1.2),   // Boost footstep frequency range
                  createREWFilter(8, "PK", 4000, 4.0, 1.5),   // Critical footstep/gunshot clarity
                  createREWFilter(9, "PK", 8000, 3.0, 1.8),   // High-frequency tactical sounds
                  createREWFilter(10, "HS", 10000, 2.0)       // Enhance detail/positioning cues
                ],
                description: "Competitive Gaming EQ (Footsteps & Tactical Audio)",
                targets: [
                  // "- 60Hz: High-pass (remove rumble that masks footsteps)",
                  "- 400Hz: -2.0dB (reduce muddiness)",
                  "- 2kHz: +3.0dB (footstep detection range)",
                  "- 4kHz: +4.0dB (critical footsteps & gunshots)",
                  "- 8kHz: +3.0dB (tactical audio positioning)",
                  "- 10kHz+: +2.0dB (detail & directional cues)"
                ]
              };

            case "GAMINGimmersive":
              return {
                filters: [
                  createREWFilter(5, "PK", 80, 2.0, 0.8),     // Enhanced bass for explosions/atmosphere
                  createREWFilter(6, "PK", 200, 3.0, 1.0),    // Low-mid warmth and impact
                  createREWFilter(7, "PK", 1000, 1.0, 0.9),   // Balanced mid-range
                  createREWFilter(8, "PK", 3000, 2.0, 1.2),   // Speech and effects clarity
                  createREWFilter(9, "PK", 6000, 1.5, 1.5),   // Detail without harshness
                  createREWFilter(10, "HS", 8000, 1.0)        // Subtle air and openness
                ],
                description: "Immersive Gaming EQ (Cinematic Experience)",
                targets: [
                  "- 80Hz: +2.0dB (bass impact for explosions)",
                  "- 200Hz: +3.0dB (warmth and atmosphere)",
                  "- 1kHz: +1.0dB (balanced mid-range)",
                  "- 3kHz: +2.0dB (speech and effects clarity)",
                  "- 6kHz: +1.5dB (detail without fatigue)",
                  "- 8kHz+: +1.0dB (subtle air and space)"
                ]
              };

            case "GAMINGvoice":
              return {
                filters: [
                  // createREWFilter(5, "HP", 100),           // Remove low-frequency noise
                  createREWFilter(6, "PK", 300, -1.0, 1.0),   // Reduce boom in voice
                  createREWFilter(7, "PK", 1500, 3.0, 1.0),   // Core voice intelligibility
                  createREWFilter(8, "PK", 3000, 4.0, 1.5),   // Voice clarity and consonants
                  createREWFilter(9, "PK", 5000, 2.0, 2.0),   // Voice presence without sibilance
                  createREWFilter(10, "HS", 8000, -1.0)       // Reduce harshness
                ],
                description: "Voice Chat Gaming EQ (Clear Communication)",
                targets: [
                  // "- 100Hz: High-pass (remove voice noise)",
                  "- 300Hz: -1.0dB (reduce voice boom)",
                  "- 1.5kHz: +3.0dB (core voice intelligibility)",
                  "- 3kHz: +4.0dB (voice clarity & consonants)",
                  "- 5kHz: +2.0dB (presence without sibilance)",
                  "- 8kHz+: -1.0dB (reduce harshness)"
                ]
              };

            case "GAMINGbalanced":
              return {
                filters: [
                  // createREWFilter(5, "HP", 40),            // Gentle low-cut
                  createREWFilter(6, "PK", 150, 1.0, 0.8),    // Subtle bass enhancement
                  createREWFilter(7, "PK", 1000, 1.5, 1.0),   // Mid-range presence
                  createREWFilter(8, "PK", 3000, 2.0, 1.3),   // Speech/effects balance
                  createREWFilter(9, "PK", 6000, 1.5, 1.5),   // Detail and clarity
                  createREWFilter(10, "HS", 10000, 1.0)       // Subtle high-end extension
                ],
                description: "Balanced Gaming EQ (All-Purpose)",
                targets: [
                  // "- 40Hz: High-pass (gentle low-cut)",
                  "- 150Hz: +1.0dB (subtle bass enhancement)",
                  "- 1kHz: +1.5dB (mid-range presence)",
                  "- 3kHz: +2.0dB (speech & effects balance)",
                  "- 6kHz: +1.5dB (detail and clarity)",
                  "- 10kHz+: +1.0dB (subtle high-end)"
                ]
              };

            default:
              return null;
          }
        };

        for (let i = 1; i <= nChannels; i++) {
          console.info(`${commandId[i].padStart(3, ".")} - equalizing channel...`);
          const isSub = commandId[i].startsWith("SW");

          // line up speaker response to target similar to REW, but don't affect subwoofer
          const tcLevelOffset = isSub ? 0 : await getTrim(i, 200, 2000);
          await fetchSafe('target-level', i, targetLevel - tcLevelOffset);

          await postNext('Smooth', i, { smoothing: "Var" });
          await postSafe(`${baseUrl}/${i}/target-settings`, {
            shape: isSub ? "Subwoofer" : "Full range",
            lowFreqCutoffHz: (isSub && m3dBPoints[i][0] === 10) ? 0 : m3dBPoints[i][0],
            lowFreqSlopedBPerOctave: 48, // steep slope to EQ without effect and keep REW happy
            bassManagementCutoffHz: (isSub && m3dBPoints[i][1] === 320) ? 20000 : m3dBPoints[i][1],
            bassManagementSlopedBPerOctave: 48 // steep slope to EQ without effect and keep REW happy
          }, "Update processed");

          await postSafe(`http://localhost:4735/eq/match-target-settings`, {
            startFrequency: m3dBPoints[i][0],
            endFrequency: m3dBPoints[i][1],
            individualMaxBoostdB: isSub ? 6 : 3,
            overallMaxBoostdB: isSub ? 3 : 0,
            flatnessTargetdB: 1,
            allowNarrowFiltersBelow200Hz: true,
            varyQAbove200Hz: false,
            allowLowShelf: isSub,
            lowShelfMin: -6,
            lowShelfMax: 6,
            allowHighShelf: !isSub,
            highShelfMin: -6,
            highShelfMax: 6
          }, "Update processed");

          try {
            await postNext('Match target', i);
          }
          catch (error) {
            // not really an issue if it fails
            console.debug(`${commandId[i]} could not be equalized!`);
          }

          // Apply Advanced Filters (if enabled, has a type other than null and is not subwoofer) 
          if (AdvancedFilters && AdvancedFiltersType !== "null" && commandId[i] !== "SW" && commandId[i] !== "SW1" && commandId[i] !== "SWMIX") {

            // For DIALOGadvanced, ONLY apply to center channel
            if (AdvancedFiltersType === "DIALOGadvanced") {
              if (commandId[i] === "C") {
                // Apply DIALOGadvanced filter to center channel
                const AdvanedFiltersConfig = getAdvancedFilters(AdvancedFiltersType);

                if (AdvanedFiltersConfig) {
                  console.log(`APPLYING ${AdvanedFiltersConfig.description} to:`, commandId[i]);
                  console.info("Gaming optimization targets:");

                  // Apply filters sequentially with delays
                  for (let j = 0; j < AdvanedFiltersConfig.filters.length; j++) {
                    await postSafe(`${baseUrl}/${i}/filters`, {
                      filters: [AdvanedFiltersConfig.filters[j]]
                    }, "Filters set");
                    await new Promise((resolve) => setTimeout(resolve, speedDelay / 2));
                  }

                  // Log all targets
                  AdvanedFiltersConfig.targets.forEach(target => console.info(target));

                  console.log(`${AdvanedFiltersConfig.description} applied successfully`);
                }
              }
              // If not center channel, do nothing (skip)
            } else {
              // For all other filter types, apply to all non-subwoofer channels
              const AdvanedFiltersConfig = getAdvancedFilters(AdvancedFiltersType);

              if (AdvanedFiltersConfig) {
                console.log(`APPLYING ${AdvanedFiltersConfig.description} to:`, commandId[i]);
                console.info("Gaming optimization targets:");

                // Apply filters sequentially with delays
                for (let j = 0; j < AdvanedFiltersConfig.filters.length; j++) {
                  await postSafe(`${baseUrl}/${i}/filters`, {
                    filters: [AdvanedFiltersConfig.filters[j]]
                  }, "Filters set");
                  await new Promise((resolve) => setTimeout(resolve, speedDelay / 2));
                }

                // Log all targets
                AdvanedFiltersConfig.targets.forEach(target => console.info(target));

                console.log(`${AdvanedFiltersConfig.description} applied successfully`);
              }
            }
          }

          // generate filters & auto level it
          const filter = await postNext('Generate filters measurement', i);
          const filterIdx = Object.keys(filter.results)[0];
          const filterName = `${commandId[i]}-filters`;
          await fetch_mREW(filterIdx, 'PUT', { title: filterName });
          const ALOffset = await getALOffset(filterIdx, isSub);
          await postNext('Add SPL offset', filterIdx, { offset: -ALOffset });

          // generate predicted equalized response using the auto leveled filter
          const eqResponse = await postNext('Arithmetic', [i, filterIdx], { function: "A * B" });
          const eqResponseIdx = Object.keys(eqResponse.results)[0];
          const eqResponseName = `${commandId[i]}-equalized`;
          await fetch_mREW(eqResponseIdx, 'PUT', { title: eqResponseName });

          // compensate equalized response & trims for auto level as well as tc level offset
          let logUpdate = `${commandId[i].padStart(3, ".")} - equalized`;
          const trimOffset = tcLevelOffset + Math.round(ALOffset * 2) / 2; //round to nearest 0.5

          if (trimOffset != 0) {
            await postNext('Add SPL offset', i, { offset: trimOffset }); // offset "o"
            await postNext('Add SPL offset', eqResponseIdx, { offset: trimOffset }); // offset "-equalized"
            const customLevelOriginal = customLevel[i];
            if (isSub) {
              for (let j = nSpeakers + 1; j <= nSpeakers + nSubs; j++) {
                customLevel[j] += trimOffset;
              }
            }
            else {
              customLevel[i] += trimOffset;
            }
            logUpdate += ` | auto-level offset: ${customLevelOriginal}dB → ${customLevel[i]}dB (${trimOffset}dB)`;
          }
          console.infoUpdate(logUpdate);
        }

        // clean up EQ params
        for (let i = nChannels + 1; i <= nChannels * 3; i++) {
          await postSafe(`${baseUrl}/${i}/target-settings`, { shape: "None" }, "Update processed");
        }
      }

      function finalizeTrims() {
        console.log("DEBUG!!!! Raw customLevel values before sanity check:", customLevel.slice(1, nSpeakers + nSubs + 1));
        console.log("These look like absolute SPL measurements (sound pressure level readings), not relative trim adjustments!")
        sanityCheckSpeakerTrims();
        console.log("Final speaker" + (noSub ? "" : " & subwoofer") + " trims:")
        for (let i = 1; i <= nSpeakers; i++) {
          const customLevelOriginal = customLevel[i];
          customLevel[i] = Math.max(-12, customLevel[i]);
          customLevel[i] = Math.min(customLevel[i], 12);
          if (customLevelOriginal != customLevel[i]) {
            console.warn(`${commandId[i].padStart(3, ".")} required volume adjustment beyond hardware limits - shifted: ${customLevelOriginal}dB → ${customLevel[i]}dB`);
          }
          else {
            console.info(`${commandId[i].padStart(3, ".")} - applied adjustment: ${customLevel[i]}dB`);
          }
        }
        if (noSub) { return; } // no need to go further without subwoofer
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          const customLevelOriginal = customLevel[i];
          customLevel[i] = Math.max(subLoTrim, customLevel[i]);
          customLevel[i] = Math.min(customLevel[i], subHiTrim);
          if (customLevelOriginal != customLevel[i]) {
            console.warn(`${commandId[i].padStart(3, ".")} required volume adjustment beyond hardware limits - shifted: ${customLevelOriginal}dB → ${customLevel[i]}dB`);
          }
          else {
            console.info(`${commandId[i].padStart(3, ".")} - applied adjustment: ${customLevel[i]}dB`);
          }
        }
      }

      function sanityCheckSpeakerTrims() {
        // if a speaker is too sensitive or not sensitive enough, it may end up outside +/-12dB
        const minSpeakerTrim = Math.min(...customLevel.slice(1, nSpeakers + 1));
        const maxSpeakerTrim = Math.max(...customLevel.slice(1, nSpeakers + 1));
        let offset = 0;
        if (minSpeakerTrim < -12 && maxSpeakerTrim < 12) {
          const requiredOffset = -12 - minSpeakerTrim;
          offset = Math.min(requiredOffset, 12 - maxSpeakerTrim); // limited by maxSpeakerTrim
        }
        else if (maxSpeakerTrim > 12 && minSpeakerTrim > -12) {
          const requiredOffset = 12 - maxSpeakerTrim;
          offset = Math.max(requiredOffset, -12 - minSpeakerTrim); // limited by minSpeakerTrim
        }
        if (offset != 0) {
          console.warn(`Trims are being shifted by ${offset}dB to best stay within hardware limits!`)
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += offset;
          }
        }
      }

      function isSingleChannel(channelCmdId) {
        if (channelCmdId.endsWith("L") && commandId.includes(channelCmdId.slice(0, -1) + "R")) { return false; } // L and R
        if (channelCmdId.endsWith("R") && commandId.includes(channelCmdId.slice(0, -1) + "L")) { return false; } // R and L
        if (channelCmdId.includes("L") && commandId.includes(channelCmdId.replace("L", "R"))) { return false; } // edge case for SLA/SRA type cmdIds
        if (channelCmdId.includes("R") && commandId.includes(channelCmdId.replace("R", "L"))) { return false; } // where L/R is in the middle
        return true;
      }

      function findNearestXO(freq) {
        let xo = Infinity;
        let minDelta = Infinity;
        for (let i = 0; i < freqIndex.length; i++) {
          const delta = Math.abs(freqIndex[i] - freq);
          if (delta < minDelta) {
            minDelta = delta;
            xo = freqIndex[i];
          }
        }
        return xo;
      }

      async function getLow3dBPoint(idx, start = 10, end = 320) {
        // const response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
        let response;
        if (isRP22mode == true) {
          response = await fetchSafe('frequency-response?smoothing=1/3&ppo=96', idx);
          console.info("getLow3dBPoint: applying CEDIA RP22 - 1/3 smoothing");
        } else {
          response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
          console.info("getLow3dBPoint: applying Default - Psy smoothing");
        }
        const rpArray = response2array(response, start, end);
        const tcArray = response2array(targetResponse, start, end);
        const arrLength = Math.min(rpArray.length, tcArray.length);
        const octave = Math.pow(2, 1 / 96);
        // find -3dB point
        let rolloff = start;
        for (let i = 0; i < arrLength; i++) {
          if ((rpArray[i] - tcArray[i]) >= -3) { break; }
          rolloff *= octave;
        }
        return Math.min(rolloff, end);
      }

      async function getHigh3dBPoint(idx, start = 10, end = 320) {
        // const response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
        let response;
        if (isRP22mode == true) {
          response = await fetchSafe('frequency-response?smoothing=1/3&ppo=96', idx);
          console.info("getHigh3dBPoint: applying CEDIA RP22 - 1/3 smoothing");
        } else {
          response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
          console.info("getHigh3dBPoint: applying Default - Psy smoothing");
        }
        const rpArray = response2array(response, start, end);
        const tcArray = response2array(targetResponse, start, end);
        const arrLength = Math.min(rpArray.length, tcArray.length);
        const octave = Math.pow(2, 1 / 96);
        // find -3dB point
        let rolloff = end;
        for (let i = arrLength - 1; i >= 0; i--) {
          if ((rpArray[i] - tcArray[i]) >= -3) { break; }
          rolloff /= octave;
        }
        return Math.max(rolloff, start);
      }

      async function calculateRolloffs() {
        console.log("Calculating speaker -3dB points from target curve...");
        const measurements = await fetch_mREW();
        for (let i = 1; i <= nSpeakers; i++) {
          const title = measurements[i].title;
          // check if single channel or speaker pair
          const singleChannel = isSingleChannel(commandId[i]);
          const cmdIds = (singleChannel ? commandId[i] : `${commandId[i]} & ${commandId[i + 1]}`).padStart(9, ".");
          // rolloff determination logic
          let idx = i;
          if (!singleChannel) {
            const pairAvg = await postNext('Magn plus phase average', [i, i + 1]); // do not use VA. it unfairly benefits single channel speakers
            idx = Object.keys(pairAvg.results)[0];
          }
          const rolloff = await getLow3dBPoint(idx);

          if (isRP22mode == true) {
            m3dBPoints[i] = [Math.round(rolloff), 15000];
            console.info("calculateRolloffs: applying CEDIA RP22 - 15000 rolloff");
          } else {
            m3dBPoints[i] = [Math.round(rolloff), 12500]; // audy mic generally garbage past 10k and messes with high shelf
            console.info("calculateRolloffs: applying Default - 12500 rolloff");
          }


          let initialXO = findNearestXO(rolloff);
          // edge case for no subwoofer
          if (noSub && cmdIds.endsWith("FL & FR")) {
            initialXO = "L";
          }
          customCrossover[i] = initialXO;
          if (!singleChannel) {
            if (isRP22mode == true) {
              m3dBPoints[i + 1] = [Math.round(rolloff), 15000];
              console.info("calculateRolloffs: applying CEDIA RP22 - 15000 rolloff");
            } else {
              m3dBPoints[i + 1] = [Math.round(rolloff), 12500]; // audy mic generally garbage past 10k and messes with high shelf
              console.info("calculateRolloffs: applying Default - 12500 rolloff");
            }
            customCrossover[i + 1] = initialXO;
            i++;
            await postDelete(idx); // cleanup
          }
          const logMessage = initialXO === "L" ? "Large/Full Range" : `Initial XO: ${initialXO}hz`;
          console.info(`${cmdIds} - roll-off: ${rolloff.toFixed(2)}Hz → ${logMessage}`);
        }
      }

      async function calculateSubBandwidth() {
        if (noSub) { return; } // no need to go further without subwoofer

        // Create temporary freqIndex with 20Hz added for subwoofer calculations
        const tempFreqIndex = [...freqIndex, 20].sort((a, b) => a - b);

        // Create local function that uses tempFreqIndex
        const findNearestXOWithSub = (freq) => {
          let xo = Infinity;
          let minDelta = Infinity;
          for (let i = 0; i < tempFreqIndex.length; i++) {
            const delta = Math.abs(tempFreqIndex[i] - freq);
            if (delta < minDelta) {
              minDelta = delta;
              xo = tempFreqIndex[i];
            }
          }
          return xo;
        };

        console.log("Calculating subwoofer -3dB points from target curve...")

        // find low freq -3dB point & set minXO
        const subLowFreq = await getLow3dBPoint(nChannels);
        minXO = findNearestXOWithSub(2 * subLowFreq);
        // find high freq -3dB point and set maxXO
        const subHighFreq = await getHigh3dBPoint(nChannels);
        maxXO = findNearestXOWithSub(subHighFreq);

        if (minXO >= maxXO) {
          minXO = maxXO;
          console.warn(`Subwoofer has very little bandwidth and can only support ${minXO}hz crossover!`);
        }
        m3dBPoints[nChannels] = [Math.round(subLowFreq), Math.round(subHighFreq)];
        Object.freeze(minXO);
        Object.freeze(maxXO);
        console.info(`${commandId[nChannels].padStart(3, ".")} bandwidth: ${subLowFreq.toFixed(2)}hz - ${subHighFreq.toFixed(2)}hz → Usable XO range: ${minXO}hz - ${maxXO}hz`);

        RP22subnminXO = subLowFreq.toFixed(2);
        RP22submaxXO = subHighFreq.toFixed(2);

        sanityCheckInitialXO(); // update initialXOs based on subwoofer bandwidth
      }

      function sanityCheckInitialXO() {
        if (noSub) { return; } // no need to go further without subwoofer
        for (let i = 1; i <= nSpeakers; i++) {
          const singleChannel = isSingleChannel(commandId[i]);
          const cmdIds = (singleChannel ? commandId[i] : `${commandId[i]} & ${commandId[1 + i]}`).padStart(9, ".");
          const initialXO = customCrossover[i];
          customCrossover[i] = Math.max(minXO, customCrossover[i]);
          if (!singleChannel) {
            customCrossover[i + 1] = customCrossover[i];
            i++;
          }
          if (initialXO != customCrossover[i]) {
            console.warn(`${cmdIds} initial XO below usable XO range - shifted: ${initialXO}hz → ${customCrossover[i]}hz`);
          }
        }
      }

      async function optimizeSubDelay() {
        if (noSub) { return; } // no need to go further without subwoofer
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        let eqResults = [], initialXOs = 0, avgInitialXO = 80;
        let count = 1;
        for (let i = nChannels + 2; i <= nChannels * 3; i += 2) {
          const title = measurements[i].title;
          if (!title.endsWith("-equalized")) { continue; }
          if (commandId[count].startsWith("SW")) { continue; }
          eqResults.push(i);
          initialXOs += parseFloat(customCrossover[count++]);
        }
        if (initialXOs > 0) { avgInitialXO = initialXOs / eqResults.length; }
        Object.freeze(avgInitialXO);
        console.log(`Calculating optimal subwoofer delay for ALL speakers using average initial XO ${avgInitialXO.toFixed(2)}hz...`);
        const avgSpeaker = await postNext('Magn plus phase average', Array.from(eqResults)); // same results with RMS & VA since goal is max output
        const avgSpeakerIdx = Object.keys(avgSpeaker.results)[0]
        const avgSpeakerWithHPF = await genSpeaker(avgSpeakerIdx, avgInitialXO);
        const avgSpeakerWithHPFIdx = Object.keys(avgSpeakerWithHPF.results)[0];
        const subwooferWithLPF = await genSub(mCount, avgInitialXO);
        const subwooferWithLPFIdx = Object.keys(subwooferWithLPF.results)[0];
        let [isPossible, requiredDelay, isInverted] = await align4system(avgSpeakerWithHPFIdx, subwooferWithLPFIdx, avgInitialXO);
        // cleanup
        await postDelete(subwooferWithLPFIdx);
        await postDelete(avgSpeakerWithHPFIdx);
        await postDelete(avgSpeakerIdx);
        // apply optimal delay
        let subMoves = 0;
        if (isPossible) {
          subMoves = requiredDelay;
        }
        else {
          console.warn(`Required delay for alignment is too large! Subwoofer(s) set to max possible distance but results will not be optimal.`);
          const [loDelay,] = getDelayRangeOfFinalSub();
          subMoves = loDelay;
          isInverted = false;
        }
        if (isInverted) { await postSafe(`${baseUrl}/${nChannels * 3}/command`, { command: "Invert" }, "Invert completed"); }
        subMoves /= 1000;
        await postNext('Offset t=0', nChannels * 3, { offset: -subMoves, unit: "seconds" });
        if (bassMode === "Directional") {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            mSec[i] += subMoves;
            invertSub[i] = isInverted ? !invertSub[i] : invertSub[i];
          }
        } else {
          mSec[nChannels] += subMoves;
          invertSub[nChannels] = isInverted;
        }
      }

      function getFLIndex() {
        let flIndex = 1;
        for (let i = 1; i <= nChannels; i++) {
          if (commandId[i].startsWith("FL")) {
            flIndex = i;
            break;
          }
        }
        return flIndex;
      }

      function initializeDistances() {
        // initialize to 0
        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          customDistance[i] = 0;
        }
        if (noSub) { return; }
        const flIndex = getFLIndex();
        let distMinSub = Infinity;
        // check if any directional subwoofer needs negative distance
        if (bassMode === "Directional") {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            const distSub = flDist + (mSec[flIndex] - mSec[i]) * sOs;
            distMinSub = Math.min(distMinSub, distSub);
          }
        }
        // check if any SWMIX subwoofer needs negative distance
        else {
          const distMainSub = flDist + (mSec[flIndex] - mSec[nChannels]) * sOs;
          const distLoSub = distMainSub - subLoDelay * sOs;
          const distHiSub = distMainSub - subHiDelay * sOs;
          distMinSub = Math.min(distLoSub, distHiSub);
        }
        if (distMinSub < 0) {
          console.warn(`Distances are being shifted by ${Math.abs(distMinSub).toFixed(2)}m to accommodate the required subwoofer delay!`);
          console.info("This adjustment will ONLY improve overall sound quality.");
          console.info("The receiver only accounts for relative time delays between speakers which are being kept intact.");
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            customDistance[i] += Math.abs(distMinSub);
          }
        }
      }

      /* ALL SPEAKERS
      function initializeDistances() {
        // initialize to 0
        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          customDistance[i] = 0;
        }
        if (noSub) { return; }
  
        const flIndex = getFLIndex();
        let globalMinDist = Infinity;
  
        // Check all main speakers
        for (let i = 1; i <= nSpeakers; i++) {
          const dist = flDist + (mSec[flIndex] - mSec[i]) * sOs;
          globalMinDist = Math.min(globalMinDist, dist);
        }
  
        // Check subwoofers with their specific delay calculations
        if (bassMode === "Directional") {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            const distSub = flDist + (mSec[flIndex] - mSec[i]) * sOs;
            globalMinDist = Math.min(globalMinDist, distSub);
          }
        } else {
          const distMainSub = flDist + (mSec[flIndex] - mSec[nChannels]) * sOs;
          const distLoSub = distMainSub - subLoDelay * sOs;
          const distHiSub = distMainSub - subHiDelay * sOs;
          globalMinDist = Math.min(globalMinDist, distLoSub, distHiSub);
        }
  
        // Apply single correction if needed
        if (globalMinDist < 0) {
          console.warn(`Distances are being shifted by ${Math.abs(globalMinDist).toFixed(2)}m to ensure all distances are positive!`);
          console.info("This adjustment will ONLY improve overall sound quality.");
          console.info("The receiver only accounts for relative time delays between speakers which are being kept intact.");
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            customDistance[i] += Math.abs(globalMinDist);
          }
        }
      }
      */

      function finalizeDistances() {
        initializeDistances();
        const flIndex = getFLIndex();

        // Clear the estimatedDistances array before populating
        estimatedDistances = [];

        console.log("Final speaker" + (noSub ? "" : " & subwoofer") + " distances:");

        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          customDistance[i] += flDist + (mSec[flIndex] - mSec[i]) * sOs;
          customDistance[i] = Math.round(parseFloat(customDistance[i]) * 100) / 100;

          // Store the distance in the estimatedDistances array
          estimatedDistances.push([commandId[i], customDistance[i].toFixed(2)]);

          if (i > nSpeakers) {
            console.warn(`${commandId[i].padStart(3, ".")} - distance: ${customDistance[i].toFixed(2)}m, ${invertSub[i] ? "please SWITCH this subwoofer's POLARITY!!!" : "keep this subwoofer's polarity 'as is'."}`);
            swInvMsg += invertSub[i] ? `inv${commandId[i]}_` : "";
          } else {
            console.info(`${commandId[i].padStart(3, ".")} - distance: ${customDistance[i].toFixed(2)}m`);
          }
        }

        if (swChannelCount > 1 && invertSub.every(isInv => isInv === true)) {
          console.warn(`You will need to switch polarity of EACH of your ${swChannelCount} subwoofers!`);
        }
      }

      async function finalizeXO(start = 20, end = 250) {
        if (noSub) { return; } // no need to go further without subwoofer

        // Get the selected range from the slider
        const sliderRange = sliderInstance ? sliderInstance.getSelectedRange() : null;
        const minSelectedFreq = sliderRange ? sliderRange.min : 20;
        const maxSelectedFreq = sliderRange ? sliderRange.max : 250;

        console.log(`Applying crossover optimization within slider range: ${minSelectedFreq}Hz - ${maxSelectedFreq}Hz`);
        console.log("Finalizing crossover frequencies to best follow the target curve...");

        // **ADD THIS - Calculate effective usable range**
        const effectiveMinXO = Math.max(minXO, minSelectedFreq);
        const effectiveMaxXO = Math.min(maxXO, maxSelectedFreq);

        // **ADD THIS - Optional warning if ranges don't fully overlap**
        if (minSelectedFreq < minXO || maxSelectedFreq > maxXO) {
          console.warn(`⚠️ Slider range (${minSelectedFreq}Hz - ${maxSelectedFreq}Hz) extends beyond subwoofer bandwidth (${minXO}Hz - ${maxXO}Hz)`);
        }

        // Filter freqIndex to only include frequencies within slider range
        const filteredFreqIndex = freqIndex.filter(freq =>
          freq >= effectiveMinXO && freq <= effectiveMaxXO
        );

        console.log(`Filtered frequency range: ${filteredFreqIndex.length} frequencies from ${filteredFreqIndex[0] || 'none'} to ${filteredFreqIndex[filteredFreqIndex.length - 1] || 'none'}Hz`);

        // Use existing calculateRMSError function (defined elsewhere in script)

        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        const targetArray = response2array(targetResponse, start, end);
        let count = 1;

        console.info(`Usable XO range: ${effectiveMinXO}hz - ${effectiveMaxXO}hz (combined subwoofer bandwidth + slider range)`);

        for (let i = nChannels + 2; i <= nChannels * 3; i += 2) {
          if (commandId[count].startsWith("SW")) { continue; }

          // check if single channel or speaker pair
          const singleChannel = isSingleChannel(commandId[count]);
          const cmdIds = (singleChannel ? commandId[count] : `${commandId[count]} & ${commandId[1 + count]}`).padStart(9, ".");

          // finalize xo that is closest match to target curve
          const initialXO = parseFloat(customCrossover[count]);

          // **ADD THIS WARNING CHECK HERE**
          if (initialXO > effectiveMaxXO) {
            console.warn(`⚠️ ${cmdIds} initial XO (${initialXO}Hz) is above effective range (${effectiveMaxXO}Hz) - may not find optimal setting`);
          }
          if (initialXO < effectiveMinXO) {
            console.warn(`⚠️ ${cmdIds} initial XO (${initialXO}Hz) is below effective range (${effectiveMinXO}Hz) - may not find optimal setting`);
          }

          let bestXO = initialXO, minRmsError = Infinity;

          console.info("Starting...");

          // Use filtered frequency range from slider
          for (let j = 0; j < filteredFreqIndex.length; j++) {
            let checkXO = filteredFreqIndex[j];

            if (checkXO < Math.max(initialXO, effectiveMinXO) || checkXO > effectiveMaxXO) { continue; }

            // final XO determination logic
            console.infoUpdate(`${cmdIds} - Initial XO: ${initialXO}hz → Checking XO: ${checkXO}hz`);

            if (singleChannel) {
              await genSpeaker(i, checkXO);
            } else {
              await postNext('Magn plus phase average', [i, i + 2]); // do not use VA. it unfairly benefits single channel speakers
              await genSpeaker(mCount + 1, checkXO);
              await postDelete(mCount + 1);
            }

            await genSub(mCount, checkXO);
            await postNext('Arithmetic', [mCount + 1, mCount + 2], { function: "A + B" }); // response using checkXO

            // check RMS error against target curve
            const checkXOResponse = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', mCount + 3);
            const checkXOArray = response2array(checkXOResponse, start, end);
            const rmsError = calculateRMSError(checkXOArray, targetArray);

            if (rmsError < minRmsError) {
              minRmsError = rmsError;
              bestXO = checkXO;
            }

            for (let k = mCount + 3; k > mCount; k--) {
              await postDelete(k);
            }
          }

          customCrossover[count] = bestXO;

          // **ADD THIS - Store the result in RP22BestXO array**
          RP22BestXO.push([commandId[count], bestXO.toString()]);

          if (!singleChannel) {
            customCrossover[1 + count] = bestXO;
            // **ADD THIS - Store the second channel result**
            RP22BestXO.push([commandId[1 + count], bestXO.toString()]);
            i += 2;
            count++;
          }
          count++;
          console.infoUpdate(`${cmdIds} - Initial XO: ${initialXO}hz → Best XO: ${bestXO}hz (RMS: ${minRmsError.toFixed(3)})`);
        }

        // **ADD THIS - Log the final results and optionally return them**
        console.log("Final RP22BestXO results:", RP22BestXO);

        // **OPTIONAL - Return the array if you need to use it elsewhere**
        return RP22BestXO;
      }

      async function directional2standard() {
        let currSubIdx = nSpeakers + 1;
        let cmdIds = commandId[currSubIdx];
        let minDelay = 0, maxDelay = 0;
        let startFreq = Math.round(await getLow3dBPoint(currSubIdx));
        let endFreq = Math.round(await getHigh3dBPoint(currSubIdx));
        for (let i = nSpeakers + 2; i <= nSpeakers + nSubs; i++) {
          console.log(`Aligning ${commandId[i]} to ${cmdIds}...`);
          startFreq = Math.min(startFreq, Math.round(await getLow3dBPoint(i)));
          endFreq = Math.max(endFreq, Math.round(await getHigh3dBPoint(i)));
          const [isPossible, requiredDelay, isInverted, sumIndex] = await alignMsub(currSubIdx, i, startFreq, endFreq);
          if (!isPossible || !sumIndex) {
            console.error("Failed to align multiple subwoofers!");
            throw new Error;
          }
          currSubIdx = sumIndex;
          mSec[i] += (requiredDelay / 1000);
          invertSub[i] = isInverted;
          cmdIds += ` & ${commandId[i]}`;
          minDelay = Math.min(minDelay, mSec[i]);
          maxDelay = Math.max(maxDelay, mSec[i]);
        }
        for (let i = currSubIdx - 1; i > nSpeakers; i--) {
          await postDelete(i);
        }
        await fetch_mREW(nChannels, 'PUT', { title: "SW1o" });
        // normalize directional bass subwoofer median IR to t=0
        const IROffset = (minDelay + maxDelay) / 2;
        await postNext('Offset t=0', nChannels, { offset: IROffset, unit: "seconds" });
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          mSec[i] -= IROffset;
        }
        // offset volume from combining subwoofers
        const volAdjust = parseFloat(await getSubTrim(nChannels));
        if (volAdjust === 0) { return; } // nothing more to do
        await postNext('Add SPL offset', nChannels, { offset: volAdjust });
        // newer AVRs that support directional already compensates for combined subwoofer volume and doesn't need adjustment
        if (sOs === 300) {
          console.log(`Adjusting combined sub level by ${volAdjust}dB to best follow the target curve...`);
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += volAdjust;
            console.info(`${commandId[i].padStart(3, ".")} - shifted: ${customLevel[i] - volAdjust}dB → ${customLevel[i]}dB`);
          }
        }
      }

      function response2array(response, start, end, phase = false) {
        let startFreq = response.startFreq;
        let k1 = start, k2 = end;
        if ('freqStep' in response) {
          const freqStep = response.freqStep;
          k1 = Math.round((k1 - startFreq) / freqStep);
          k2 = Math.round((k2 - startFreq) / freqStep);
        } else if ('ppo' in response) {
          const responsePpo = response.ppo;
          k1 = Math.round(Math.log2(k1 / startFreq) * responsePpo);
          k2 = Math.round(Math.log2(k2 / startFreq) * responsePpo);
        }
        const bytes = Uint8Array.from(atob(phase ? response.phase : response.magnitude), c => c.charCodeAt(0));
        const buffer = bytes.buffer;
        const data = new DataView(buffer);
        const responseArray = [];
        for (let k = k1; k <= k2; k++) {
          const sumMagnitude = data.getFloat32(k * 4);
          responseArray.push(sumMagnitude);
        }
        return responseArray;
      }

      function calculateRMSError(rpArray, targetArray) {
        if (rpArray.length === 0 || targetArray.length === 0) {
          console.warn("Failed to calculate RMS error!");
          return Infinity;
        }
        const arrayLength = Math.min(rpArray.length, targetArray.length);
        let sumOfSquares = 0;
        for (let i = 0; i < arrayLength; i++) {
          const diff = rpArray[i] - targetArray[i];
          sumOfSquares += diff * diff;
        }
        const meanOfSquares = sumOfSquares / arrayLength;
        return Math.sqrt(meanOfSquares);
      }

      async function getTrim(idx, start, end) {
        //await fetch_mREW();      
        const targetArray = response2array(targetResponse, start, end);
        const targetSPL = targetArray.reduce((acc, val) => acc + val, 0) / targetArray.length;
        let freqResponse;
        if (start == 200 && end == 2000 && isRP22mode == false) {
          freqResponse = await fetchSafe('frequency-response?smoothing=1/6&ppo=96', idx);
          console.info("getTrim: applying Default - 1/6 smoothing - assume speakers");
        } else if (start == 200 && end == 2000 && isRP22mode == true) {
          freqResponse = await fetchSafe('frequency-response?smoothing=1/1&ppo=96', idx);
          console.info("getTrim: applying CEDIA RP22 - 1/1 smoothing - assume speakers");
        } else if (start >= 500 && isRP22mode == true) {
          freqResponse = await fetchSafe('frequency-response?smoothing=1/1&ppo=96', idx);
          console.info("getTrim: applying CEDIA RP22 - 1/1 smoothing - assume speakers");
        } else if (start < 500 && isRP22mode == true) {
          freqResponse = await fetchSafe('frequency-response?smoothing=1/3&ppo=96', idx);
          console.info("getTrim: applying CEDIA RP22 - 1/3 smoothing - assume subwoofer(s)");
        } else {
          freqResponse = await fetchSafe('frequency-response?smoothing=1/6&ppo=96', idx);
          console.info("getTrim: applying Default - 1/6 smoothing");
        }
        const freqArray = response2array(freqResponse, start, end);
        const freqSPL = freqArray.reduce((acc, val) => acc + val, 0) / freqArray.length;

        // ADD THIS DEBUG CODE:
        console.log(`*** TRIM DEBUG for measurement ${idx} (${start}-${end}Hz) ***`);
        console.log(`Target curve average SPL: ${targetSPL.toFixed(1)}dB`);
        console.log(`Measurement average SPL: ${freqSPL.toFixed(1)}dB`);
        console.log(`Calculated trim: ${(targetSPL - freqSPL).toFixed(1)}dB`);

        const offset = targetSPL - freqSPL;
        return Math.round(offset * 2) / 2; // round to nearest 0.5
      }

      async function getSpeakerTrim(idx) {
        return await getTrim(idx, 500, isRP22mode ? 16000 : 2000);
      }

      async function getSubTrim(idx) {
        return await getTrim(idx, isRP22mode ? 20 : 30, isRP22mode ? 120 : 80);
      }

      async function getDynamicBassFill(idx) {
        const startFreq = Math.round(await getLow3dBPoint(idx, 20, 120));
        const endFreq = Math.round(await getHigh3dBPoint(idx, 20, 120));
        const subFreqResponse = await fetchSafe('frequency-response?smoothing=1%2F6&ppo=96', idx);
        const subArray = response2array(subFreqResponse, startFreq, endFreq);
        const targetArray = response2array(targetResponse, startFreq, endFreq);
        const arrayLength = Math.min(subArray.length, targetArray.length);
        let totalDips = 0;
        for (let i = 0; i < arrayLength; i++) {
          totalDips += Math.min(subArray[i] - targetArray[i], 0);
        }
        const dynamicBassFill = Math.round(-2 * (totalDips / arrayLength)) / 2; // round to nearest 0.5
        return dynamicBassFill;
      }

      async function alignVol2MLP(indices, mlpIdx) {
        if (indices.length <= 1) { return; }
        const measurements = await fetch_mREW();
        const mlpVolume = measurements[mlpIdx].title.startsWith("SW") ? await getSubTrim(mlpIdx) : await getSpeakerTrim(mlpIdx);
        for (let i = 0; i < indices.length; i++) {
          if (indices[i] === mlpIdx) { continue; }
          const idxVolume = measurements[indices[i]].title.startsWith("SW") ? await getSubTrim(indices[i]) : await getSpeakerTrim(indices[i]);
          const volAdjust = parseFloat(idxVolume - mlpVolume);
          await postNext('Add SPL offset', indices[i], { offset: volAdjust });
        }
      }

      async function align4system(ind1, ind2, xo) {
        const start = Math.round(xo / 2), end = Math.round(xo * 2);
        // const [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        let [loDelay, hiDelay] = getDelayRangeOfFinalSub();

        // Clamp and fix signs
        loDelay = Math.max(-1000, Math.min(0, -Math.abs(loDelay))); // force negative
        hiDelay = Math.max(0, Math.min(1000, Math.abs(hiDelay)));   // force positive

        console.info(`Available delay range: ${loDelay.toFixed(2)}ms <-> ${hiDelay.toFixed(2)}ms`);
        let isInverted = false, isPossible = false, requiredDelay = NaN, bestFreq = NaN, maxSum = -Infinity;
        await postSafe("http://localhost:4735/alignment-tool/index-a", ind1, "selected as measurement A");
        await postSafe("http://localhost:4735/alignment-tool/index-b", ind2, "selected as measurement B");
        await postAlign('Reset all');
        await postSafe("http://localhost:4735/alignment-tool/mode", "Impulse", "Mode set");
        await postSafe("http://localhost:4735/alignment-tool/max-negative-delay", loDelay, "Maximum negative delay set to");
        await postSafe("http://localhost:4735/alignment-tool/max-positive-delay", hiDelay, "Maximum positive delay set to");
        console.info("Starting...")

        for (let checkFreq = 20; checkFreq <= 250; checkFreq++) {
          const bestDelayStr = isNaN(requiredDelay) ? "N/A" : requiredDelay.toFixed(2);
          const bestFreqStr = isNaN(bestFreq) ? "N/A" : bestFreq;
          console.infoUpdate(`Checking: @${checkFreq}Hz, Best: ${bestDelayStr}ms @${bestFreqStr}hz Inverted: ${isInverted}`);

          const postAlignResult = await postAlign('Align IRs', checkFreq);
          if (postAlignResult.message === 'Delay too large') { continue; }

          const invertB = await fetchAlign('invert-b');
          const delayB = parseFloat(await fetchAlign('delay-b'));
          if (noInversion && invertB) { continue; };

          const tempSum = await fetchAlign('aligned-frequency-response?smoothing=Psy&ppo=96');
          const tempSumArray = response2array(tempSum, start, end);
          const tempMagSum = tempSumArray.reduce((acc, val) => acc + val, 0);
          if (maxSum < tempMagSum) {
            maxSum = tempMagSum;
            bestFreq = checkFreq;
            isPossible = true;
            requiredDelay = delayB;
            isInverted = invertB;
          }
        }

        if (isPossible) {
          const postAlignResult = await postAlign('Align IRs', bestFreq);
          const delayB = await fetchAlign('delay-b');
          requiredDelay = parseFloat(delayB);
          isInverted = await fetchAlign('invert-b');
          const alignedSum = await postAlign('Aligned sum');
          const parsed = JSON.parse(alignedSum.message);
          const key = Object.keys(parsed.results)[0];
          const sumIndex = parseInt(key);
          await postDelete(sumIndex);
          console.infoUpdate(`Optimal alignment: @${bestFreq}Hz, required delay: ${requiredDelay.toFixed(2)}ms, isInverted: ${isInverted}`);
        }
        RP22subrequiredDelay = requiredDelay;
        return [isPossible, requiredDelay, isInverted];
      }

      async function alignMsub(ind1, ind2, start, end) {
        const [loDelay, hiDelay] = getDelayRangeOf(mSec[ind2], nSpeakers + 1, nSpeakers + nSubs);
        console.info(`Available delay range: ${loDelay.toFixed(2)}ms <-> ${hiDelay.toFixed(2)}ms`);
        let isInverted = false, isPossible = false, requiredDelay = NaN, bestFreq = NaN, maxSum = -Infinity, sumIndex = null;
        await postSafe("http://localhost:4735/alignment-tool/index-a", ind1, "selected as measurement A");
        await postSafe("http://localhost:4735/alignment-tool/index-b", ind2, "selected as measurement B");
        await postAlign('Reset all');
        await postSafe("http://localhost:4735/alignment-tool/mode", "Impulse", "Mode set");
        await postSafe("http://localhost:4735/alignment-tool/max-negative-delay", loDelay, "Maximum negative delay set to");
        await postSafe("http://localhost:4735/alignment-tool/max-positive-delay", hiDelay, "Maximum positive delay set to");
        console.info("Starting...")

        for (let checkFreq = 20; checkFreq <= 250; checkFreq++) {
          const bestDelayStr = isNaN(requiredDelay) ? "N/A" : requiredDelay.toFixed(2);
          const bestFreqStr = isNaN(bestFreq) ? "N/A" : bestFreq;
          console.infoUpdate(`Checking: @${checkFreq}Hz, Best: ${bestDelayStr}ms @${bestFreqStr}hz Inverted: ${isInverted}`);

          const postAlignResult = await postAlign('Align IRs', checkFreq);
          if (postAlignResult.message === 'Delay too large' && previousDelay != postAlignResult.delay) {
            previousDelay = postAlignResult.delay;
            continue;
          }

          const invertB = await fetchAlign('invert-b');
          const delayB = parseFloat(await fetchAlign('delay-b'));
          if (noInversion && invertB) { continue; };

          const tempSum = await fetchAlign('aligned-frequency-response?smoothing=Psy&ppo=96');
          const tempSumArray = response2array(tempSum, start, end);
          const tempMagSum = tempSumArray.reduce((acc, val) => acc + val, 0);
          if (maxSum < tempMagSum) {
            maxSum = tempMagSum;
            bestFreq = checkFreq;
            isPossible = true;
            requiredDelay = delayB;
            isInverted = invertB;
          }
        }

        if (isPossible) {
          const postAlignResult = await postAlign('Align IRs', bestFreq);
          const delayB = await fetchAlign('delay-b');
          requiredDelay = parseFloat(delayB);
          isInverted = await fetchAlign('invert-b');
          const measurements = await fetch_mREW();
          const mCount = Object.keys(measurements).length;
          const alignedSum = await postAlign('Aligned sum');
          const parsed = JSON.parse(alignedSum.message);
          const key = Object.keys(parsed.results)[0];
          sumIndex = parseInt(key);
          console.infoUpdate(`Optimal alignment: @${bestFreq}Hz, required delay: ${requiredDelay.toFixed(2)}ms, isInverted: ${isInverted}`);
        }
        return [isPossible, requiredDelay, isInverted, sumIndex];
      }

      async function genSub(i, freq) {
        if (freq === "L") {
          console.error("Cannot set subwoofer as LARGE!")
          throw new Error;
        }
        await postSafe(`${baseUrl}/${i}/filters`, {
          filters: [{
            "index": 21,
            "type": "Low pass",
            "enabled": true,
            "isAuto": false,
            "frequency": freq,
            "shape": "L-R",
            "slopedBPerOctave": 24
          }]
        }, "Filters set");
        return await postNext('Generate predicted measurement', i);
      }

      async function genSpeaker(i, freq) {
        if (freq === "L") {
          return await postSafe(`${baseUrl}/${i}/command`, { command: "Response copy" }, "Completed");
        }
        await postSafe(`${baseUrl}/${i}/filters`, {
          filters: [{
            "index": 21,
            "type": "High pass",
            "enabled": true,
            "isAuto": false,
            "frequency": freq,
            "shape": "BU",
            "slopedBPerOctave": 12
          }]
        }, "Filters set");
        return await postNext('Generate predicted measurement', i);
      }

      async function drawResults() {
        console.log("Generating expected final outputs for each channel...");
        console.info("Starting...");
        for (let i = 1; i <= nSpeakers; i++) {
          console.infoUpdate(`Generating final output for channel - ${commandId[i]}`);
          const isLarge = customCrossover[i] === "L";
          let finalResponseName = commandId[i] + "final";
          /*finalResponseName += (commandId[i] === "C" && RP22DialogEnhancementFilter) ? "-ADE" : "";*/
          finalResponseName += (commandId[i] === "C" && AdvancedFiltersType === "DIALOGadvanced") ? "-ADF" : "";
          finalResponseName += (AdvancedFiltersType === "HLOSSresearch") ? "-AHF" : "";
          finalResponseName += (AdvancedFiltersType === "HLOSSmoderate") ? "-AHF" : "";
          finalResponseName += (AdvancedFiltersType === "HLOSSsevere") ? "-AHF" : "";
          finalResponseName += (AdvancedFiltersType === "HLOSSoriginal") ? "-AHF" : "";
          finalResponseName += (AdvancedFiltersType === "GAMINGcompetitive") ? "-AGF" : "";
          finalResponseName += (AdvancedFiltersType === "GAMINGimmersive") ? "-AGF" : "";
          finalResponseName += (AdvancedFiltersType === "GAMINGvoice") ? "-AGF" : "";
          finalResponseName += (AdvancedFiltersType === "GAMINGbalanced") ? "-AGF" : "";
          finalResponseName += isLarge ? "-Large" : `-${customCrossover[i]}hz-xo`;
          const eqSpeaker = nChannels + 2 * i;
          const spWithHPF = await genSpeaker(eqSpeaker, customCrossover[i]);
          const spWithHPFIdx = (isLarge ? nChannels * 3 + i : Object.keys(spWithHPF.results)[0]);
          if (noSub) {
            await fetch_mREW(spWithHPFIdx, 'PUT', { title: finalResponseName });
            continue;
          }
          const subWithLPF = await genSub(nChannels * 3, customCrossover[i]);
          const subWithLPFIdx = Object.keys(subWithLPF.results)[0];
          const finalResponse = await postNext('Arithmetic', [spWithHPFIdx, subWithLPFIdx], { function: "A + B" });
          const finalResponseIdx = Object.keys(finalResponse.results)[0];
          await fetch_mREW(finalResponseIdx, 'PUT', { title: finalResponseName });
          await postDelete(subWithLPFIdx);
          await postDelete(spWithHPFIdx);
        }
        if (!noSub) {
          console.infoUpdate("Generating final output for channel - LFE");
          const LFEChannel = await genSub(nChannels * 3, 120);
          const LFEChannelIdx = Object.keys(LFEChannel.results)[0];
          await fetch_mREW(LFEChannelIdx, 'PUT', { title: "LFEfinal-120hz-LPF" });
        }
        // await fetchSafe('target-level', nChannels * 3, 75.0);
        await fetchSafe('target-level', nChannels * 3, targetLevel);
        const targetCurve = await postNext('Generate target measurement', nChannels * 3);
        const targetCurveIdx = Object.keys(targetCurve.results)[0];
        // const targetName = (targetCurveName === "" ? "TC-DEQ" : targetCurveName) + " @ 75dB";
        const targetName = `${targetCurveName === "" ? "TC-DEQ" : targetCurveName} @ ${String(targetLevel)}dB`;
        await fetch_mREW(targetCurveIdx, 'PUT', { title: targetName });
        // room curve no longer needed. keeping it enabled will only confuse on next run
        if (targetCurveName === "") { await disableRoomCurve(); }
        // use 1/6 smoothing for results
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i <= mCount; i++) {
          titleM = await fetch_mREW(i);
          const title = titleM.title;
          // if (title.endsWith("-filters") || title.endsWith(" @ 75dB")) { continue; }
          if (title.endsWith("-filters") || title.endsWith(` @ ${String(targetLevel)}dB`)) { continue; }
          await postNext('Smooth', i, { smoothing: "1/6" });
        }
        console.infoUpdate("Completed generating final outputs for all channels!");
      }

      async function updateAdy() {
        // ISO 226:2023 MATLAB reference values
        const iso226Data = {
          frequencies: [20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 1250, 1600, 2000, 2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500],
          alphaF: [0.532, 0.506, 0.480, 0.455, 0.432, 0.409, 0.387, 0.367, 0.349, 0.330, 0.315, 0.301, 0.288, 0.276, 0.267, 0.259, 0.253, 0.250, 0.246, 0.244, 0.243, 0.243, 0.243, 0.242, 0.242, 0.245, 0.254, 0.271, 0.301],
          LU: [-31.6, -27.2, -23.0, -19.1, -15.9, -13.0, -10.3, -8.1, -6.2, -4.5, -3.1, -2.0, -1.1, -0.4, 0.0, 0.3, 0.5, 0.0, -2.7, -4.1, -1.0, 1.7, 2.5, 1.2, -2.1, -7.1, -11.2, -10.7, -3.1],
          Tf: [78.5, 68.7, 59.5, 51.1, 44.0, 37.5, 31.5, 26.5, 22.1, 17.9, 14.4, 11.4, 8.6, 6.2, 4.4, 3.0, 2.2, 2.4, 3.5, 1.7, -1.3, -4.2, -6.0, -5.4, -1.5, 6.0, 12.6, 13.9, 12.3]
        };

        // Helper function to get ISO 226 parameters for any frequency
        function getISO226Params(frequency) {
          const frequencies = iso226Data.frequencies;
          let closest = frequencies[0];
          let minDiff = Math.abs(frequency - closest);
          let closestIndex = 0;

          for (let i = 0; i < frequencies.length; i++) {
            const diff = Math.abs(frequency - frequencies[i]);
            if (diff < minDiff) {
              minDiff = diff;
              closest = frequencies[i];
              closestIndex = i;
            }
          }

          return {
            frequency: closest,
            alphaF: iso226Data.alphaF[closestIndex],
            LU: iso226Data.LU[closestIndex],
            Tf: iso226Data.Tf[closestIndex]
          };
        }

        // Estimate playback level based on frequency response
        function estimatePlaybackLevel(dataView, referenceLevel = 75) {
          let avgSensitivity = 0;
          let count = 0;

          // Sample 800-1200 Hz region (~1kHz reference) - with bounds checking
          const maxSafeIndex = Math.floor(dataView.byteLength / 4) - 1;
          for (let k = 800; k <= 1200; k++) {
            if (k <= maxSafeIndex) {
              avgSensitivity += dataView.getFloat32(k * 4);
              count++;
            }
          }
          avgSensitivity = count > 0 ? avgSensitivity / count : 0;

          const baselineLevel = Math.round(referenceLevel * 2) / 2; // Round to 0.5dB steps
          const estimatedLevel = baselineLevel + avgSensitivity - 5; // Room factor

          // Clamp to reasonable range
          return Math.max(40, Math.min(90, estimatedLevel));
        }

        // Get level-dependent compensation factor based on ISO 226 curves
        function getLevelCompensationFactor(frequency, playbackLevel) {
          // Equal-loudness contours flatten at higher levels
          const levelFactors = {
            40: { lowFreq: 2.5, midFreq: 1.0, highFreq: 1.8 },   // Low level - more compensation
            70: { lowFreq: 1.5, midFreq: 1.0, highFreq: 1.2 },   // Medium level
            90: { lowFreq: 1.1, midFreq: 1.0, highFreq: 1.05 }   // High level - minimal compensation
          };

          // Interpolate between levels
          let factor = { lowFreq: 1.0, midFreq: 1.0, highFreq: 1.0 };
          if (playbackLevel <= 40) {
            factor = levelFactors[40];
          } else if (playbackLevel <= 70) {
            const ratio = (playbackLevel - 40) / 30;
            const low = levelFactors[40];
            const mid = levelFactors[70];
            factor = {
              lowFreq: low.lowFreq + ratio * (mid.lowFreq - low.lowFreq),
              midFreq: low.midFreq + ratio * (mid.midFreq - low.midFreq),
              highFreq: low.highFreq + ratio * (mid.highFreq - low.highFreq)
            };
          } else {
            const ratio = Math.min(1.0, (playbackLevel - 70) / 20);
            const mid = levelFactors[70];
            const high = levelFactors[90];
            factor = {
              lowFreq: mid.lowFreq + ratio * (high.lowFreq - mid.lowFreq),
              midFreq: mid.midFreq + ratio * (high.midFreq - mid.midFreq),
              highFreq: mid.highFreq + ratio * (high.highFreq - mid.highFreq)
            };
          }

          // Apply frequency-specific factor
          if (frequency < 500) return factor.lowFreq;
          if (frequency > 8000) return factor.highFreq;
          return factor.midFreq;
        }

        // Convert SPL to loudness level (phons) using ISO 226:2023
        function splToPhons(frequency, splLevel) {
          // Input validation
          if (splLevel > 120 || splLevel < 0) {
            console.warn(`Unrealistic SPL input: ${splLevel.toFixed(1)}dB at ${frequency}Hz - clamping to valid range`);
            splLevel = Math.max(0, Math.min(120, splLevel));
          }

          const params = getISO226Params(frequency);
          const { alphaF, LU, Tf } = params;

          // At 1000Hz, phons equal dB SPL (reference point)
          if (frequency >= 950 && frequency <= 1050) {
            return splLevel;
          }

          // Calculate frequency-dependent loudness correction
          const thresholdCorrection = Tf / 10;
          const transferCorrection = LU / 10;

          // Level-dependent factor
          const levelFactor = Math.pow(splLevel / 80, alphaF - 0.3);

          // Combine corrections
          const basePhons = splLevel - thresholdCorrection + transferCorrection;
          const adjustedPhons = basePhons * levelFactor;

          // Apply final correction for perceptual accuracy
          const finalPhons = adjustedPhons + (splLevel - 75) * 0.1;

          // Clamp to realistic range
          return Math.max(20, Math.min(90, finalPhons));
        }

        // Original processing with ISO 226:2023 enhancements
        console.log("Applying ISO 226:2023 equal loudness compensation...");

        for (let i = 1; i <= nSpeakers; i++) {
          if (customCrossover[i] === "L") { continue; };
          if (customCrossover[i] > 90) { customCrossover[i] /= 10; }
        }

        const jsonData = JSON.parse(adyContents);

        if (bassMode === "Directional") {
          let ii = 54;
          for (let i = nChannels - 1; i < jsonData.detectedChannels.length; i++) {
            const swChannel = jsonData.detectedChannels[i];
            swChannel.enChannelType = ii;
            ii++;
            if (swChannel.customCrossover) { delete swChannel.customCrossover };
            if (swChannel.customSpeakerType) { delete swChannel.customSpeakerType };
            if (swChannel.customTargetCurvePoints && (i != (nChannels - 1))) { delete swChannel.customTargetCurvePoints };
          }
        }

        jsonData.dynamicVolume = false;
        jsonData.lfc = false;
        jsonData.dynamicEq = (targetCurveName === "");
        jsonData.enTargetCurveType = 1;

        jsonData.detectedChannels.forEach((channel, index) => {
          const responseData = channel.responseData;
          const zerosArray = Array(16383).fill("0");
          zerosArray.unshift("1");
          let count = 0;
          for (const arrayKey in responseData) {
            if (responseData.hasOwnProperty(arrayKey)) {
              if (isCirrusLogic) {
                responseData[arrayKey] = antiMicCal;
              } else {
                responseData[arrayKey] = zerosArray;
              }
              if (count >= 3) {
                delete responseData[arrayKey];
              }
              count++;
            }
          }
          if (index > nSpeakers) {
            channel.responseData = {};
          }
        });

        const octave = Math.pow(2, 1 / 96);

        // Enhanced speaker processing with ISO 226:2023
        for (let i = 1; i <= nSpeakers; i++) {
          const fltArray = [];
          const fltResponse = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', 2 * i + (nChannels - 1));
          const bytes = Uint8Array.from(atob(fltResponse.magnitude), c => c.charCodeAt(0));
          const buffer = bytes.buffer;
          const data = new DataView(buffer);

          // Check DataView bounds
          const maxSafeIndex = Math.floor(data.byteLength / 4) - 1;
          const actualLoopLimit = Math.min(1531, maxSafeIndex);

          // Check if current level is already close to AVR limits
          let iso226Compensation = 0;

          if (customLevel[i] >= 11 || customLevel[i] <= -11) {
            console.log(`Speaker ${commandId[i]}: Current level (${customLevel[i].toFixed(1)}dB) is close to AVR limits. Skipping ISO 226:2023 processing.`);
            iso226Compensation = 0;
          } else {
            // Estimate playback level for ISO 226:2023 processing
            const estimatedLevel = estimatePlaybackLevel(data);
            console.log(`Speaker ${commandId[i]}: Estimated playback level ${estimatedLevel.toFixed(1)}dB`);

            // SAVE TO ARRAY - Store speaker ID and estimated level
            estimatedPlaybackLevels.push([commandId[i], estimatedLevel.toFixed(1)]);

            // ISO 226:2023 weighted compensation calculation
            let weightedSum = 0;
            let totalWeight = 0;
            let freq = fltResponse.startFreq;

            for (let k = 0; k <= actualLoopLimit; k++) {
              if (k * 4 + 3 >= data.byteLength) {
                console.warn(`Reached DataView boundary at k=${k} for speaker ${commandId[i]}`);
                break;
              }

              const fltMagnitude = data.getFloat32(k * 4);

              // Apply ISO 226:2023 weighting for psychoacoustic analysis (500Hz to 8kHz)
              if (freq >= 500 && freq <= 8000) {
                const iso226Params = getISO226Params(freq);
                const levelFactor = getLevelCompensationFactor(freq, estimatedLevel);

                // Higher sensitivity (lower αf) = higher weight for loudness calculation
                const psychoacousticWeight = (1 / iso226Params.alphaF) * levelFactor;

                const magnitudeContribution = fltMagnitude + antiHFRolloff[k];
                weightedSum += magnitudeContribution * psychoacousticWeight;
                totalWeight += psychoacousticWeight;
              }

              freq *= octave;
            }

            // Calculate ISO 226:2023 compensation
            iso226Compensation = totalWeight > 0 ? weightedSum / totalWeight : 0;
            iso226Compensation = Math.round(iso226Compensation * 2) / 2; // Round to 0.5dB

            console.log(`Speaker ${commandId[i]}: ISO 226:2023 compensation = ${iso226Compensation.toFixed(1)}dB`);
          }

          // Build frequency array for all frequencies regardless of ISO processing
          let freq = fltResponse.startFreq;
          for (let k = 0; k <= actualLoopLimit; k++) {
            if (k * 4 + 3 >= data.byteLength) {
              break;
            }
            const fltMagnitude = data.getFloat32(k * 4);
            fltArray.push([freq, fltMagnitude + antiHFRolloff[k]]);
            freq *= octave;
          }

          // Store original level for logging
          const originalLevel = customLevel[i];

          // Apply compensation to custom level
          customLevel[i] += iso226Compensation;

          // Validation and AVR limits (-12dB to +12dB)
          let wasLimited = false;
          if (customLevel[i] < -12) {
            console.warn(`Speaker ${commandId[i]}: Total level after compensation (${originalLevel.toFixed(1)}dB + ${iso226Compensation.toFixed(1)}dB = ${(originalLevel + iso226Compensation).toFixed(1)}dB) exceeds minimum AVR limit. Clamping to -12dB`);
            customLevel[i] = -12;
            wasLimited = true;
          } else if (customLevel[i] > 12) {
            console.warn(`Speaker ${commandId[i]}: Total level after compensation (${originalLevel.toFixed(1)}dB + ${iso226Compensation.toFixed(1)}dB = ${(originalLevel + iso226Compensation).toFixed(1)}dB) exceeds maximum AVR limit. Clamping to +12dB`);
            customLevel[i] = 12;
            wasLimited = true;
          }

          if (Math.abs(iso226Compensation) > 8) {
            console.warn(`Speaker ${commandId[i]}: Large compensation (${iso226Compensation}dB) suggests measurement issues`);
          }

          if (wasLimited) {
            console.warn(`Speaker ${commandId[i]} could not be fully compensated due to AVR limits!`);
          }

          const customTargetCurvePoints = fltArray.map(point => `{${point[0]}, ${point[1]}}`);
          const thisChannel = jsonData.detectedChannels.find(channel => channel.commandId === commandId[i]);
          thisChannel.customTargetCurvePoints = customTargetCurvePoints;
          thisChannel.midrangeCompensation = false;
          thisChannel.frequencyRangeRolloff = 20000;
          thisChannel.customLevel = customLevel[i].toFixed(1);
          thisChannel.customDistance = customDistance[i];
          thisChannel.customCrossover = customCrossover[i] === "L" ? "F" : String(customCrossover[i]);
          thisChannel.customSpeakerType = customCrossover[i] === "L" ? "L" : "S";
          thisChannel.channelReport.customEnSpeakerConnect = customCrossover[i] === "L" ? 2 : 1;
        }

        // Enhanced subwoofer processing with ISO 226:2023
        if (!noSub) {
          const subArray = [];
          const subResponse = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', nChannels * 3 - 1);
          const bytesSub = Uint8Array.from(atob(subResponse.magnitude), c => c.charCodeAt(0));
          const bufferSub = bytesSub.buffer;
          const dataSub = new DataView(bufferSub);

          // Check subwoofer DataView bounds
          const maxSubIndex = Math.floor(dataSub.byteLength / 4) - 1;
          const actualSubLimit = Math.min(1531, maxSubIndex);

          // Check subwoofer levels before ISO processing
          let subISO226Compensation = 0;

          // Get the base subwoofer level to check
          const baseSubLevel = parseFloat(customLevel[nChannels]) || 0;

          if (baseSubLevel >= 11 || baseSubLevel <= -11) {
            console.log(`Subwoofer: Current level (${baseSubLevel.toFixed(1)}dB) is close to AVR limits. Skipping ISO 226:2023 processing.`);
            subISO226Compensation = 0;
          } else {
            // Estimate subwoofer level
            const subEstimatedLevel = estimatePlaybackLevel(dataSub, 70); // Subs typically run hotter
            console.log(`Subwoofer: Estimated playback level ${subEstimatedLevel.toFixed(1)}dB`);

            // SAVE TO ARRAY - Store subwoofer estimated level
            estimatedPlaybackLevels.push(["Subwoofer", subEstimatedLevel.toFixed(1)]);

            let subWeightedSum = 0;
            let subTotalWeight = 0;

            let freq = subResponse.startFreq;
            for (let k = 0; k <= actualSubLimit; k++) {
              if (k * 4 + 3 >= dataSub.byteLength) {
                console.warn(`Reached subwoofer DataView boundary at k=${k}`);
                break;
              }

              const subMagnitude = dataSub.getFloat32(k * 4);

              // Apply ISO 226:2023 weighting for subwoofer range (20Hz to 250Hz)
              if (freq >= 20 && freq <= 250) {
                const iso226Params = getISO226Params(freq);
                const levelFactor = getLevelCompensationFactor(freq, subEstimatedLevel);
                const psychoacousticWeight = (1 / iso226Params.alphaF) * levelFactor;

                const magnitudeContribution = subMagnitude;
                subWeightedSum += magnitudeContribution * psychoacousticWeight;
                subTotalWeight += psychoacousticWeight;
              }

              freq *= octave;
            }

            // Calculate ISO 226:2023 subwoofer compensation
            subISO226Compensation = subTotalWeight > 0 ? subWeightedSum / subTotalWeight : 0;
            subISO226Compensation = Math.round(subISO226Compensation * 2) / 2;

            console.log(`Subwoofer: ISO 226:2023 compensation = ${subISO226Compensation.toFixed(1)}dB`);
          }

          // Build subwoofer frequency array regardless of ISO processing
          let freq = subResponse.startFreq;
          for (let k = 0; k <= actualSubLimit; k++) {
            if (k * 4 + 3 >= dataSub.byteLength) {
              break;
            }
            const subMagnitude = dataSub.getFloat32(k * 4);
            subArray.push([freq, subMagnitude]);
            freq *= octave;
          }

          const customTargetCurvePointsSub = subArray.map(point => `{${point[0]}, ${point[1]}}`);
          const subChannel = jsonData.detectedChannels[nChannels - 1];
          subChannel.customTargetCurvePoints = customTargetCurvePointsSub;

          let k = 0;
          for (let channel of jsonData.detectedChannels) {
            if (channel.commandId.startsWith("SW")) {
              const customDistanceValue = parseFloat(customDistance[nChannels + k]) - parseFloat(channel.delayAdjustment);
              let customLevelValue = parseFloat(customLevel[nChannels + k]) + parseFloat(channel.trimAdjustment);

              // Apply ISO 226:2023 compensation
              customLevelValue += subISO226Compensation;

              channel.customDistance = Math.round(parseFloat(customDistanceValue) * 100) / 100;
              channel.customLevel = customLevelValue.toFixed(1);
              channel.frequencyRangeRolloff = 250;

              if (bassMode === "Directional") { k++ };
            }
          }

          if (bassMode === "Directional") {
            jsonData.subwooferLayout = "N/A";
            sOs === 343 ? jsonData.subwooferMode = "Standard" : jsonData.subwooferMode = "N/A";
          }
        }

        // LOG THE COLLECTED PLAYBACK LEVELS ARRAY
        console.log("Estimated Playback Levels Array:", estimatedPlaybackLevels);
        console.log("Array contents:");
        estimatedPlaybackLevels.forEach((item, index) => {
          console.log(`${index}: Speaker ${item[0]} = ${item[1]}dB`);
        });

        // Generate file with ISO 226:2023 enhancement
        const ady = JSON.stringify(jsonData);
        const blob = new Blob([ady], { type: 'application/json' });
        const urlBlob = URL.createObjectURL(blob);
        var downloadLink = document.createElement("a");
        downloadLink.href = urlBlob;

        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const timestamp = `${year}-${month}${day}-${hours}${minutes}`;
        const tcName = targetCurveName === "" ? "DEQ" : targetCurveName;
        downloadLink.download = getadyName(fileName, "_"
          //  + (RP22DialogEnhancementFilter ? "ADE_" : "")
          + (AdvancedFiltersType === "DIALOGadvanced" ? "ADF_" : "")
          + (AdvancedFiltersType === "HLOSSresearch" ? "AHF_" : "")
          + (AdvancedFiltersType === "HLOSSmoderate" ? "AHF_" : "")
          + (AdvancedFiltersType === "HLOSSsevere" ? "AHF_" : "")
          + (AdvancedFiltersType === "HLOSSoriginal" ? "AHF_" : "")
          + (AdvancedFiltersType === "GAMINGcompetitive" ? "AGF_" : "")
          + (AdvancedFiltersType === "GAMINGimmersive" ? "AGF_" : "")
          + (AdvancedFiltersType === "GAMINGvoice" ? "AGF_" : "")
          + (AdvancedFiltersType === "GAMINGbalanced" ? "AGF_" : "")
          //  + swInvMsg + `${tcName}_ISO226_ClariQNext_${timestamp}.ady`);
          // + (AdvancedFiltersType ? "AHE_" : "")
          + swInvMsg + `${tcName}_ISO226_`
          + `ClariQNext_${timestamp}.ady`);
        downloadLink.style.display = "none";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);

        console.log("ISO 226:2023 equal loudness compensation applied successfully!");

        // RETURN THE ARRAY IF NEEDED
        return estimatedPlaybackLevels;
      }

      // Enhanced fetch_mREW with better error handling
      async function fetch_mREW(indice = null, method = 'GET', _body = null) {
        await platformDelay();

        let body;
        let requestUrl;

        if (indice === null) {
          requestUrl = baseUrl;
        } else {
          requestUrl = baseUrl + `/${indice}`;
        }

        if (method === 'PUT') {
          body = _body;
        }

        const maxRetries = 10; // Prevent infinite loops
        let retryCount = 0;

        while (retryCount < maxRetries) {
          try {
            const response = await safeFetch(requestUrl, {
              method: method,
              headers: { 'Content-Type': 'application/json' },
              body: body ? JSON.stringify(body) : null
            });

            if (!response.ok) {
              retryCount++;
              if (retryCount >= maxRetries) {
                throw new Error(`Max retries reached. Status: ${response.status}`);
              }
              await new Promise(resolve => setTimeout(resolve, retryDelay));
            } else {
              const data = await response.json();
              return data;
            }
          } catch (error) {
            retryCount++;
            if (retryCount >= maxRetries) {
              throw new Error(`Network error after ${maxRetries} attempts: ${error.message}`);
            }
            await new Promise(resolve => setTimeout(resolve, retryDelay));
          }
        }
      }

      // Enhanced fetchSafe with better cross-browser support
      async function fetchSafe(extUrl, indice, parameters = null) {
        await platformDelay();

        const requestUrl = `${baseUrl}/${indice}/${extUrl}`;
        let options;

        if (parameters === null) {
          options = {
            method: 'GET'
          };
        } else {
          options = {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(parameters)
          };
        }

        const maxRetries = 10;
        let retryCount = 0;

        while (retryCount < maxRetries) {
          try {
            const response = await safeFetch(requestUrl, options);

            if (!response.ok) {
              retryCount++;
              if (retryCount >= maxRetries) {
                throw new Error(`Max retries reached. Status: ${response.status}`);
              }
              await new Promise(resolve => setTimeout(resolve, retryDelay));
            } else {
              const data = await response.json();
              return data;
            }
          } catch (error) {
            retryCount++;
            if (retryCount >= maxRetries) {
              throw new Error(`Network error after ${maxRetries} attempts: ${error.message}`);
            }
            await new Promise(resolve => setTimeout(resolve, retryDelay));
          }
        }
      }

      async function fetchAlign(extUrl) {
        if (!window.navigator.platform.startsWith("Win")) { await new Promise(resolve => setTimeout(resolve, speedDelay)); }
        try {
          const requestUrl = `http://localhost:4735/alignment-tool/${extUrl}`;
          const response = await fetch(requestUrl, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }
          const data = await response.json();
          return data;
        } catch (error) {
          throw new Error('Error fetching result:', error);
        }
      }

      async function postNext(processName, indices, parameters = null) {
        if (!window.navigator.platform.startsWith("Win")) { await new Promise(resolve => setTimeout(resolve, speedDelay)); }
        let requestUrl;
        let body;
        if (Array.isArray(indices)) {
          requestUrl = `${baseUrl}/process-measurements`;
        } else {
          requestUrl = parameters === null ? `${baseUrl}/${indices}/eq/command` : `${baseUrl}/${indices}/command`;
        }
        if (requestUrl.endsWith('/command')) {
          body = { command: processName };
        } else {
          body = { processName: processName };
        }
        if (parameters != null) {
          body = { ...body, parameters: parameters };
        }
        if (Array.isArray(indices)) {
          body = { ...body, measurementIndices: indices };
        }
        const fetchData = async () => {
          const response = await fetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });
          if (!response.ok) {
            throw new Error('Network response was not OK!');
          }
          const data = await response.json();
          return data;
        }
        const checkResponse = async (data) => {
          if (data.message && data.message.includes('ompleted')) {
            const resultUrl = `${baseUrl}/process-result`;
            const resultResponse = await fetch(resultUrl);
            if (!resultResponse.ok) {
              throw new Error('Failed to fetch result data!');
            }
            const resultData = await resultResponse.json();
            return resultData;
          } else if (data.message.includes('in progress') || data.message.includes('running')) {
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
            return checkResponse(await fetchData());
          } else {
            return data;
          }
        }
        try {
          const data = await fetchData();
          const result = await checkResponse(data);
          return result;
        } catch (error) {
          throw new Error('Error fetching result:', error);
        }
      }

      async function postSafe(requestUrl, parameters, message) {
        if (!window.navigator.platform.startsWith("Win")) { await new Promise(resolve => setTimeout(resolve, speedDelay)); }
        const fetchData = async () => {
          const response = await fetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(parameters),
          });
          if (!response.ok) {
            throw new Error('Network response was not OK!');
          }
          const data = await response.json();
          return data;
        }
        const checkResponse = async (data) => {
          if (data.message.includes(message)) {
            return data;
          } else if (data.message.includes('in progress') || data.message.includes('running')) {
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
            return checkResponse(await fetchData());
          } else {
            throw new Error(`Unexpected response: ${data.message}`);
          }
        }
        try {
          const data = await fetchData();
          const result = await checkResponse(data);
          return result;
        } catch (error) {
          throw new Error('Error fetching result:', error);
        }
      }

      // Enhanced postAlign with better error parsing
      async function postAlign(processName, frequency = null) {
        await platformDelay();

        const requestUrl = `http://localhost:4735/alignment-tool/command`;
        const body = { command: processName };

        if (frequency != null) {
          body.frequency = frequency;
        }

        try {
          const response = await safeFetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });

          const responseText = await response.text();

          if (!response.ok) {
            let errorData;
            try {
              errorData = JSON.parse(responseText);
            } catch (parseError) {
              throw new Error(`Network response was not OK! Status: ${response.status}`);
            }

            if (errorData.message) {
              let parsedMessage;
              try {
                parsedMessage = JSON.parse(errorData.message);
              } catch (parseError) {
                throw new Error('Failed to parse the error message');
              }

              if (parsedMessage.results &&
                parsedMessage.results[0] &&
                parsedMessage.results[0].Error) {
                const errorMessage = parsedMessage.results[0].Error;
                // More robust regex that works across all browsers
                const delayMatch = errorMessage.match(/delay required to align the responses.*?(-?[\d.]+)\s*ms/);

                if (delayMatch) {
                  return {
                    message: 'Delay too large',
                    error: errorMessage,
                    delay: parseFloat(delayMatch[1])
                  };
                }
              }
            }
            throw new Error(`Network response was not OK! Status: ${response.status}`);
          }

          let data;
          try {
            data = JSON.parse(responseText);
          } catch (parseError) {
            throw new Error('Failed to parse the response data');
          }

          if (data.message && data.message.includes('completed')) {
            const resultUrl = `http://localhost:4735/alignment-tool/result`;
            const resultResponse = await safeFetch(resultUrl);

            if (!resultResponse.ok) {
              throw new Error('Failed to fetch result data!');
            }

            const resultData = await resultResponse.json();

            if (resultData.results &&
              resultData.results[0] &&
              resultData.results[0].Error) {
              const errorMessage = resultData.results[0].Error;
              const delayMatch = errorMessage.match(/delay required to align the responses.*?(-?[\d.]+)\s*ms/);

              if (delayMatch) {
                return {
                  message: 'Delay too large',
                  error: errorMessage,
                  delay: parseFloat(delayMatch[1])
                };
              }
            }
            return resultData;
          }

          return data;
        } catch (error) {
          console.error('Error in postAlign:', error);
          throw error;
        }
      }

      async function postDelete(indice) {
        if (!window.navigator.platform.startsWith("Win")) { await new Promise(resolve => setTimeout(resolve, speedDelay)); }
        const mDeleted = `Measurement ${indice} deleted`
        while (true) {
          try {
            const response = await fetch(`${baseUrl}/${indice}`, {
              method: 'DELETE',
              headers: { 'Content-Type': 'application/json' },
            });
            if (!response.ok) {
              throw new Error('Network response was not OK!');
            }
            const data = await response.json();
            if (data.message === mDeleted) {
              return indice;
            } else {
              await new Promise(resolve => setTimeout(resolve, retryDelay));
            }
          } catch (error) {
            throw new Error('Error fetching result:', error);
          }
        }
      }

      async function enableBlock() {
        await fetch('http://localhost:4735/application/blocking', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: true
        });
      }

      async function disableBlock() {
        await fetch('http://localhost:4735/application/blocking', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: false
        });
      }

      async function enableGraph() {
        await fetch('http://localhost:4735/application/inhibit-graph-updates', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: false
        });
      }

      async function disableGraph() {
        await fetch('http://localhost:4735/application/inhibit-graph-updates', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: true
        });
      }

      async function clearCommands() {
        const body = { command: 'Clear command in progress' };
        await fetch('http://localhost:4735/application/command', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
      }

      // Better platform detection
      function isWindowsPlatform() {
        try {
          // Multiple fallbacks for platform detection
          const userAgent = navigator.userAgent || '';
          const platform = navigator.platform || '';

          return userAgent.includes('Windows') ||
            platform.includes('Win') ||
            platform.startsWith('Win');
        } catch (e) {
          // Fallback if navigator is blocked (like in some Tor configurations)
          console.warn('Platform detection failed, assuming non-Windows');
          return false;
        }
      }

      // Fetch with fallback support
      function createFetchWrapper() {
        if (typeof fetch !== 'undefined') {
          return fetch;
        }

        // Fallback for older browsers using XMLHttpRequest
        return function (url, options = {}) {
          return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            const method = options.method || 'GET';

            xhr.open(method, url);

            // Set headers
            if (options.headers) {
              Object.entries(options.headers).forEach(([key, value]) => {
                xhr.setRequestHeader(key, value);
              });
            }

            xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                const response = {
                  ok: xhr.status >= 200 && xhr.status < 300,
                  status: xhr.status,
                  json: () => Promise.resolve(JSON.parse(xhr.responseText)),
                  text: () => Promise.resolve(xhr.responseText)
                };

                if (response.ok) {
                  resolve(response);
                } else {
                  reject(new Error(`HTTP ${xhr.status}`));
                }
              }
            };

            xhr.onerror = () => reject(new Error('Network error'));
            xhr.send(options.body || null);
          });
        };
      }
      const safeFetch = createFetchWrapper();

      // Improved delay function with better error handling
      async function platformDelay() {
        try {
          if (!isWindowsPlatform()) {
            await new Promise(resolve => setTimeout(resolve, speedDelay));
          }
        } catch (error) {
          console.warn('Platform delay failed:', error);
          // Continue without delay on error
        }
      }

      // Feature detection utility
      function checkBrowserSupport() {
        const support = {
          fetch: typeof fetch !== 'undefined',
          asyncAwait: (async function () { })() instanceof Promise,
          json: typeof JSON !== 'undefined' &&
            typeof JSON.parse !== 'undefined' &&
            typeof JSON.stringify !== 'undefined',
          promises: typeof Promise !== 'undefined',
          setTimeout: typeof setTimeout !== 'undefined'
        };

        console.log('Browser support check:', support);

        const unsupported = Object.entries(support)
          .filter(([feature, supported]) => !supported)
          .map(([feature]) => feature);

        if (unsupported.length > 0) {
          console.error('Unsupported features:', unsupported);
          return false;
        }

        return true;
      }

      // Initialize with compatibility check
      function initializeApp() {
        if (!checkBrowserSupport()) {
          alert('Your browser may not fully support this application. Please update to a modern browser.');
          return false;
        }

        console.log('Browser compatibility check passed');
        return true;
      }

      // Validate config on groundWorks() step
      function validateConfiguration() {
        console.log('=== CONFIGURATION VALIDATION ===');
        // console.log(`nSpeakers: ${nSpeakers}`);
        // console.log(`numSub: ${numSub}`);
        console.log('=== ===');
        console.log(`nChannels: ${nChannels}`);
        console.log(`nSpeakers: ${nSpeakers}`);
        console.log(`nSubs: ${nSubs}`);
        console.log('=== ===');
        console.log(`Total channels: ${nSpeakers + nSubs}`);

        // Check commandId array
        const validCommands = Object.keys(commandId).filter(k => !isNaN(k) && parseInt(k) > 0);
        console.log(`CommandID entries: ${validCommands.length}`);

        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          if (!commandId[i]) {
            console.error(`❌ Missing commandId[${i}]`);
            return false;
          }
          console.log(`✅ commandId[${i}] = ${commandId[i]}`);
        }

        return true;
      }

      function normalizeTrimLevels() {
        console.log("Checking for systematic measurement offset...");

        // Calculate average speaker trim (excluding subs)
        const speakerTrims = customLevel.slice(1, nSpeakers + 1);
        const avgSpeakerTrim = speakerTrims.reduce((sum, trim) => sum + trim, 0) / speakerTrims.length;

        console.log(`Average speaker trim: ${avgSpeakerTrim.toFixed(1)}dB`);

        // If average trim is excessive (beyond ±15dB), normalize it
        const EXCESSIVE_THRESHOLD = 15;

        if (Math.abs(avgSpeakerTrim) > EXCESSIVE_THRESHOLD) {
          console.warn(`Detected systematic measurement offset of ${avgSpeakerTrim.toFixed(1)}dB - normalizing...`);

          // Subtract the average from all speaker trims and round to 0.5dB steps
          for (let i = 1; i <= nSpeakers; i++) {
            customLevel[i] -= avgSpeakerTrim;
            customLevel[i] = Math.round(customLevel[i] * 2) / 2; // Round to nearest 0.5dB
          }

          // Also normalize subwoofer trims if present
          if (!noSub) {
            for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
              customLevel[i] -= avgSpeakerTrim;
              customLevel[i] = Math.round(customLevel[i] * 2) / 2; // Round to nearest 0.5dB
            }
          }

          console.info(`All trims normalized by ${avgSpeakerTrim.toFixed(1)}dB`);
          console.info("This offset represents a systematic measurement calibration difference.");
          console.info("Individual speaker balance is preserved while bringing levels into reasonable range.");

          // Log the normalized results
          console.log("Normalized trim values:");
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            console.log(`${commandId[i]}: ${customLevel[i].toFixed(1)}dB`);
          }
        } else {
          console.info("Trim levels are within normal range - no normalization needed.");
        }
      }

      // CEDIA Assessment - Enhanced Implementation with Professional Standards and Advanced Acoustics
      class CEDIAPerformanceScorer {
        constructor() {
          // Precision constants for calculations
          this.PRECISION = {
            SPL_TOLERANCE: 0.1,
            DISTANCE_TOLERANCE: 0.01,
            FREQUENCY_TOLERANCE: 1.0,
            SPEED_OF_SOUND: 343, // m/s at 20°C
            DB_PER_DISTANCE_DOUBLING: 6.0
          };

          // Advanced acoustic constants from CEDIA RP22 specification
          this.ACOUSTIC_CONSTANTS = {
            REFERENCE_IMPEDANCE: 8, // Ohms
            REFERENCE_DISTANCE: 1,  // meters
            SABINE_CONSTANT_METRIC: 0.161,
            SABINE_CONSTANT_IMPERIAL: 0.049,
            BOUNDARY_LOADING: {
              freeField: 0,      // No boundaries
              halfSpace: 6,      // Against wall
              quarterSpace: 12,  // Wall-floor junction
              eighthSpace: 18    // Corner placement
            },
            MATERIAL_ABSORPTION_COEFFS: {
              concrete: 0.02,
              gypsumBoard: 0.08,
              hardwood: 0.04,
              carpet_light: 0.15,
              carpet_heavy: 0.30,
              curtains_light: 0.30,
              curtains_heavy: 0.70,
              acousticFoam_2inch: 0.85,
              fiberglass_2inch: 0.90,
              upholsteredFurniture: 0.50,
              person: 0.45  // Per person in sabins
            }
          };

          // Enhanced speaker types with validation
          this.speakerTypes = {
            front: ["FL", "FR"],
            frontWide: ["FWL", "FWR"],
            surroundBack: ["SBL", "SBR"],
            surround: ["SLA", "SRA", "SL", "SR"],
            frontHeight: ["FHL", "FHR"],
            rearHeight: ["RHL", "RHR"],
            surroundHeight: ["SHL", "SHR"],
            topFront: ["TFL", "TFR"],
            topMiddle: ["TML", "TMR"],
            topRear: ["TRL", "TRR"],
            upfiringBack: ["BDL", "BDR"],
            upfiringFront: ["FDL", "FDR"],
            upfiringSurround: ["SDL", "SDR"],
            center: ["C"],
            topSurround: ["TS"],
            centerHeight: ["CH"],
            surroundBackSingle: ["SB"]
          };

          // Complete 21 CEDIA parameters with enhanced validation
          this.parameters = {
            // Spatial Resolution (11 parameters)
            1: {
              name: "Minimum Distance Between Listening Area and Room Walls",
              unit: "m", category: "Spatial Resolution",
              targets: { level1: { min: 0.5 }, level2: { min: 0.8 }, level3: { min: 1.2 }, level4: { min: 1.5 } },
              type: "minimum",
              validator: this.validateDistanceParameter.bind(this)
            },
            2: {
              name: "Decoder/Renderer Capability and Discretely Rendered Speaker Configuration",
              unit: "discrete speakers", category: "Spatial Resolution",
              targets: { level1: { min: 5 }, level2: { min: 11 }, level3: { min: 15 }, level4: { min: 15 } },
              type: "minimum",
              validator: this.validateSpeakerCount.bind(this)
            },
            3: {
              name: "Number of Screen Wall Speakers Outside Recommended Zonal Locations",
              unit: "speakers", category: "Spatial Resolution",
              targets: { level1: { max: 0 }, level2: { max: 0 }, level3: { max: 0 }, level4: { max: 0 } },
              type: "maximum",
              validator: this.validateZonalCompliance.bind(this)
            },
            4: {
              name: "Maximum SPL Difference Between Screen Wall Speakers",
              unit: "dB", category: "Spatial Resolution",
              targets: { level1: { max: 6 }, level2: { max: 5 }, level3: { max: 4 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateSPLConsistency.bind(this)
            },
            5: {
              name: "Maximum Allowable Horizontal Angle Between Adjacent Surround Speakers",
              unit: "degrees", category: "Spatial Resolution",
              targets: { level1: null, level2: { max: 80 }, level3: { max: 60 }, level4: { max: 50 } },
              type: "maximum",
              validator: this.validateSpeakerAngles.bind(this)
            },
            6: {
              name: "Maximum SPL Difference Between Surround Speakers",
              unit: "dB", category: "Spatial Resolution",
              targets: { level1: { max: 10 }, level2: { max: 6 }, level3: { max: 4 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateSPLConsistency.bind(this)
            },
            7: {
              name: "Wide Speakers Maximum Allowable Horizontal Deviation from Median Angle",
              unit: "degrees", category: "Spatial Resolution",
              targets: { level1: { max: 10 }, level2: { max: 7 }, level3: { max: 5 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateWideAlignment.bind(this)
            },
            8: {
              name: "Upfiring/Elevation Speakers Allowed",
              unit: "yes/no", category: "Spatial Resolution",
              targets: { level1: true, level2: true, level3: false, level4: false },
              type: "boolean",
              validator: this.validateUpfiringSpeakers.bind(this)
            },
            9: {
              name: "Maximum Allowable Vertical Angle Between Adjacent Upper Speakers",
              unit: "degrees", category: "Spatial Resolution",
              targets: { level1: null, level2: { max: 80 }, level3: { max: 60 }, level4: { max: 50 } },
              type: "maximum",
              validator: this.validateVerticalAngles.bind(this)
            },
            10: {
              name: "Maximum SPL Difference Between Upper Speakers",
              unit: "dB", category: "Spatial Resolution",
              targets: { level1: { max: 12 }, level2: { max: 8 }, level3: { max: 5 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateSPLConsistency.bind(this)
            },
            11: {
              name: "Number of Surround/Wide/Upper Speakers Outside Zonal Locations",
              unit: "speakers", category: "Spatial Resolution",
              targets: { level1: null, level2: { max: 0 }, level3: { max: 0 }, level4: { max: 0 } },
              type: "maximum",
              validator: this.validateZonalCompliance.bind(this)
            },

            // Dynamics (4 parameters)
            12: {
              name: "Screen Speakers SPL Capability at RSP",
              unit: "dB SPL(C)", category: "Dynamics",
              targets: { level1: { min: 99, rec: 102 }, level2: { min: 102, rec: 105 }, level3: { min: 105, rec: 108 }, level4: { min: 108, rec: 111 } },
              type: "minimum",
              validator: this.validateSPLCapability.bind(this)
            },
            13: {
              name: "Non-Screen Speakers SPL Capability at RSP",
              unit: "dB SPL(C)", category: "Dynamics",
              targets: { level1: { min: 96, rec: 99 }, level2: { min: 99, rec: 102 }, level3: { min: 102, rec: 105 }, level4: { min: 105, rec: 108 } },
              type: "minimum",
              validator: this.validateSPLCapability.bind(this)
            },
            14: {
              name: "LFE Frequencies Total SPL Capability at RSP",
              unit: "dB SPL(C)", category: "Dynamics",
              targets: { level1: { min: 109, rec: 114 }, level2: { min: 112, rec: 117 }, level3: { min: 115, rec: 120 }, level4: { min: 118, rec: 123 } },
              type: "minimum",
              validator: this.validateLFECapability.bind(this)
            },
            15: {
              name: "Background Noise Floor",
              unit: "NCB rating", category: "Dynamics",
              targets: { level1: { max: 35, rec: 26 }, level2: { max: 26, rec: 22 }, level3: { max: 22, rec: 18 }, level4: { max: 18, rec: 15 } },
              type: "maximum",
              validator: this.validateNoiseFloor.bind(this)
            },

            // Timbre (6 parameters)
            16: {
              name: "Seat-to-Seat Frequency Response Variance - Screen Wall Speakers",
              unit: "±dB", category: "Timbre",
              targets: { level1: { max: 5 }, level2: { max: 3 }, level3: { max: 1.5 }, level4: { max: 1.5 } },
              type: "maximum",
              validator: this.validateFrequencyResponse.bind(this)
            },
            17: {
              name: "Seat-to-Seat Frequency Response Variance - Surround/Upper Speakers",
              unit: "±dB", category: "Timbre",
              targets: { level1: null, level2: null, level3: { max: 3 }, level4: { max: 1.5 } },
              type: "maximum",
              validator: this.validateFrequencyResponse.bind(this)
            },
            18: {
              name: "In-Room Bass Extension -3dB Cutoff Frequency",
              unit: "Hz", category: "Timbre",
              targets: { level1: { max: 35, rec: 30 }, level2: { max: 30, rec: 25 }, level3: { max: 20, rec: 18 }, level4: { max: 18, rec: 15 } },
              type: "maximum",
              validator: this.validateBassExtension.bind(this)
            },
            19: {
              name: "Frequency Response Below Room's Transition Frequency at RSP",
              unit: "±dB", category: "Timbre",
              targets: { level1: { max: 5 }, level2: { max: 4 }, level3: { max: 3 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateBassResponse.bind(this)
            },
            20: {
              name: "Seat-to-Seat Frequency Response Below Room's Transition Frequency",
              unit: "±dB", category: "Timbre",
              targets: { level1: null, level2: { max: 4 }, level3: { max: 3 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateBassConsistency.bind(this)
            },
            21: {
              name: "Level of Early Reflections Relative to Direct Sound",
              unit: "dB", category: "Timbre",
              targets: { level1: null, level2: { min: -8 }, level3: { min: -10 }, level4: { min: -12 } },
              type: "minimum",
              validator: this.validateReflections.bind(this)
            }
          };

          // Validation error tracking
          this.validationErrors = [];
        }

        // Enhanced data capture with comprehensive validation
        captureAllSystemData() {
          try {
            const systemData = {
              // Basic system info with validation
              nSpeakers: this.validateNumeric(typeof nSpeakers !== 'undefined' ? nSpeakers : 0, 'nSpeakers'),
              nSubs: this.validateNumeric(typeof nSubs !== 'undefined' ? nSubs : 0, 'nSubs'),
              noSub: typeof noSub !== 'undefined' ? Boolean(noSub) : false,
              targetLevel: this.validateNumeric(typeof targetLevel !== 'undefined' ? targetLevel : 75, 'targetLevel'),
              swChannelCount: this.validateNumeric(typeof swChannelCount !== 'undefined' ? swChannelCount : 0, 'swChannelCount'),

              // Speaker configuration with enhanced validation
              commandId: typeof commandId !== 'undefined' ? commandId : [],
              discreteSpeakerFeeds: 0, // Will be calculated

              // Enhanced playback level data with validation
              estimatedPlaybackLevels: this.parseEstimatedPlaybackLevels(typeof estimatedPlaybackLevels !== 'undefined' ? estimatedPlaybackLevels : []),

              // Advanced: Parse distance and crossover data
              estimatedDistances: this.parseDistanceData(typeof estimatedDistances !== 'undefined' ? estimatedDistances : []),
              crossoverData: this.parseCrossoverData(typeof RP22BestXO !== 'undefined' ? RP22BestXO : []),

              // Bass system data with precision handling
              bassExtension: this.validateFrequency(m3dBPoints && nChannels ? m3dBPoints[nChannels]?.[0] : null),
              bassHighFreq: this.validateFrequency(m3dBPoints && nChannels ? m3dBPoints[nChannels]?.[1] : null),
              bassMode: typeof bassMode !== 'undefined' ? String(bassMode) : 'Unknown',

              // Subwoofer optimization data with precision
              RP22subnminXO: this.validateFrequency(typeof RP22subnminXO !== 'undefined' ? RP22subnminXO : null),
              RP22submaxXO: this.validateFrequency(typeof RP22submaxXO !== 'undefined' ? RP22submaxXO : null),
              requiredDelay: this.validateNumeric(typeof RP22subrequiredDelay !== 'undefined' ? RP22subrequiredDelay : null, 'requiredDelay'),
              optimalFreq: this.validateFrequency(typeof bestFreq !== 'undefined' ? bestFreq : null),

              delayRange: (typeof loDelay !== 'undefined' && typeof hiDelay !== 'undefined') ? {
                min: this.validateNumeric(loDelay, 'loDelay'),
                max: this.validateNumeric(hiDelay, 'hiDelay'),
                range: this.validateNumeric(hiDelay - loDelay, 'delayRange')
              } : null,

              // Level and distance data with validation
              customLevel: typeof customLevel !== 'undefined' ? this.validateArray(customLevel, 'customLevel') : [],
              customDistance: typeof customDistance !== 'undefined' ? this.validateArray(customDistance, 'customDistance') : [],
              customCrossover: typeof customCrossover !== 'undefined' ? this.validateArray(customCrossover, 'customCrossover') : [],
              flDist: this.validateNumeric(typeof flDist !== 'undefined' ? flDist : null, 'flDist'),

              // System characteristics - Enhanced parsing for measurement arrays
              sOs: typeof sOs !== 'undefined' ? String(sOs) : 'Unknown',
              isCirrusLogic: typeof isCirrusLogic !== 'undefined' ? Boolean(isCirrusLogic) : false,
              freqIndex: this.parseFrequencyArray(typeof freqIndex !== 'undefined' ? freqIndex : null),
              //RP22DialogEnhancementFilter: typeof RP22DialogEnhancementFilter !== 'undefined' ? Boolean(RP22DialogEnhancementFilter) : false,
              needsSorting: typeof needsSorting !== 'undefined' ? Boolean(needsSorting) : false,

              // Time alignment - Enhanced parsing for timing data
              mSec: this.parseTimingArray(typeof mSec !== 'undefined' ? mSec : null)
            };

            // Calculate discrete speaker feeds
            systemData.discreteSpeakerFeeds = this.calculateDiscreteSpeakerFeeds(systemData);

            // Enhanced room analysis using advanced acoustics
            systemData.roomAcoustics = this.calculateRoomAcoustics(systemData);
            systemData.speakerAngles = this.calculateAllSpeakerAngles(systemData);
            systemData.bassManagement = this.analyzeBassManagement(systemData);

            return systemData;
          } catch (error) {
            console.warn("Error capturing system data:", error.message);
            return this.getDefaultSystemData();
          }
        }

        // Parse frequency measurement points array from freqIndex
        parseFrequencyArray(rawFreqIndex) {
          if (!rawFreqIndex) return null;

          try {
            // Handle comma-separated frequency values
            const freqString = String(rawFreqIndex).trim();
            if (freqString === '') return null;

            const frequencies = freqString.split(',')
              .map(f => parseFloat(f.trim()))
              .filter(f => Number.isFinite(f) && f > 0);

            if (frequencies.length === 0) {
              this.addValidationError("No valid frequency points found in freqIndex");
              return null;
            }

            // Sort frequencies in ascending order
            frequencies.sort((a, b) => a - b);

            // Calculate frequency response analysis metrics
            const analysis = {
              frequencies: frequencies,
              count: frequencies.length,
              minFreq: Math.min(...frequencies),
              maxFreq: Math.max(...frequencies),
              frequencyRange: Math.max(...frequencies) / Math.min(...frequencies),
              avgSpacing: this.calculateAverageFrequencySpacing(frequencies),
              is1_3Octave: this.checkIfOneThirdOctave(frequencies),
              bandsPerOctave: this.estimateBandsPerOctave(frequencies)
            };

            return analysis;

          } catch (error) {
            this.addValidationError(`Error parsing freqIndex: ${error.message}`);
            return null;
          }
        }

        // Parse timing delay array from mSec  
        parseTimingArray(rawMSec) {
          if (!rawMSec) return null;

          try {
            // Handle comma-separated timing values (may have leading comma)
            const timingString = String(rawMSec).trim();
            if (timingString === '') return null;

            // Split and remove empty entries (handles leading comma)
            const timingValues = timingString.split(',')
              .map(t => t.trim())
              .filter(t => t !== '')
              .map(t => parseFloat(t))
              .filter(t => Number.isFinite(t));

            if (timingValues.length === 0) {
              this.addValidationError("No valid timing values found in mSec");
              return null;
            }

            // Calculate timing analysis metrics
            const analysis = {
              delays: timingValues,
              count: timingValues.length,
              minDelay: Math.min(...timingValues),
              maxDelay: Math.max(...timingValues),
              delaySpread: Math.max(...timingValues) - Math.min(...timingValues),
              avgDelay: timingValues.reduce((sum, d) => sum + d, 0) / timingValues.length,
              stdDeviation: this.calculateStandardDeviation(timingValues),
              timingConsistency: this.assessTimingConsistency(timingValues),
              earlyReflectionMetric: this.estimateEarlyReflectionLevel(timingValues)
            };

            return analysis;

          } catch (error) {
            this.addValidationError(`Error parsing mSec: ${error.message}`);
            return null;
          }
        }

        // Check if frequency array represents 1/3 octave measurements
        checkIfOneThirdOctave(frequencies) {
          if (frequencies.length < 3) return false;

          // Check if frequency ratios are close to 2^(1/3) ≈ 1.26
          const expectedRatio = Math.pow(2, 1 / 3);
          const tolerance = 0.05;

          for (let i = 1; i < Math.min(frequencies.length, 10); i++) {
            const ratio = frequencies[i] / frequencies[i - 1];
            if (Math.abs(ratio - expectedRatio) > tolerance) {
              return false;
            }
          }

          return true;
        }

        // Estimate bands per octave from frequency spacing
        estimateBandsPerOctave(frequencies) {
          if (frequencies.length < 2) return null;

          // Calculate average ratio between adjacent frequencies
          const ratios = [];
          for (let i = 1; i < Math.min(frequencies.length, 10); i++) {
            ratios.push(frequencies[i] / frequencies[i - 1]);
          }

          const avgRatio = ratios.reduce((sum, r) => sum + r, 0) / ratios.length;

          // Convert ratio to bands per octave: bandsPerOctave = log(2) / log(ratio)
          return Math.round(Math.log(2) / Math.log(avgRatio));
        }

        // Calculate average frequency spacing
        calculateAverageFrequencySpacing(frequencies) {
          if (frequencies.length < 2) return 0;

          const spacings = [];
          for (let i = 1; i < frequencies.length; i++) {
            spacings.push(frequencies[i] - frequencies[i - 1]);
          }

          return spacings.reduce((sum, s) => sum + s, 0) / spacings.length;
        }

        // Calculate standard deviation of timing values
        calculateStandardDeviation(values) {
          const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
          const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
          const variance = squaredDiffs.reduce((sum, sq) => sum + sq, 0) / values.length;
          return Math.sqrt(variance);
        }

        // Assess timing consistency for CEDIA parameter evaluation
        assessTimingConsistency(delays) {
          if (delays.length < 2) return 'Insufficient Data';

          const delaySpread = Math.max(...delays) - Math.min(...delays);
          const stdDev = this.calculateStandardDeviation(delays);

          // Convert from seconds to milliseconds for evaluation
          const spreadMs = Math.abs(delaySpread) * 1000;
          const stdDevMs = stdDev * 1000;

          if (spreadMs <= 0.1 && stdDevMs <= 0.05) return 'Excellent';
          if (spreadMs <= 0.5 && stdDevMs <= 0.2) return 'Good';
          if (spreadMs <= 2.0 && stdDevMs <= 1.0) return 'Fair';
          return 'Poor';
        }

        // Estimate early reflection characteristics from timing data
        estimateEarlyReflectionLevel(delays) {
          // Use timing delay spread as proxy for early reflection strength
          // Larger delay spreads typically indicate more early reflections
          const delaySpread = Math.max(...delays) - Math.min(...delays);
          const spreadMs = Math.abs(delaySpread) * 1000;

          // Convert timing spread to estimated early reflection level (dB relative to direct sound)
          // Based on empirical relationships between delay spread and reflection strength
          if (spreadMs <= 0.1) return -15; // Very low reflections
          if (spreadMs <= 0.5) return -12; // Low reflections  
          if (spreadMs <= 1.0) return -10; // Moderate reflections
          if (spreadMs <= 2.0) return -8;  // Higher reflections
          return -6; // High reflections
        }

        // Parse distance data from estimatedDistances array
        parseDistanceData(rawDistances) {
          const distances = {};
          if (!Array.isArray(rawDistances)) {
            this.addValidationError("estimatedDistances is not an array");
            return distances;
          }

          rawDistances.forEach((entry, index) => {
            try {
              if (Array.isArray(entry) && entry.length >= 2) {
                const [speakerId, distanceValue] = entry;
                const distance = parseFloat(distanceValue);

                if (typeof speakerId === 'string' && Number.isFinite(distance) && distance > 0) {
                  distances[speakerId.trim()] = distance;
                } else {
                  this.addValidationError(`Invalid distance entry at index ${index}: ${JSON.stringify(entry)}`);
                }
              }
            } catch (error) {
              this.addValidationError(`Error parsing distance entry ${index}: ${error.message}`);
            }
          });

          return distances;
        }

        // Parse crossover data from RP22BestXO array  
        parseCrossoverData(rawCrossovers) {
          const crossovers = {};
          if (!Array.isArray(rawCrossovers)) {
            this.addValidationError("RP22BestXO is not an array");
            return crossovers;
          }

          rawCrossovers.forEach((entry, index) => {
            try {
              if (Array.isArray(entry) && entry.length >= 2) {
                const [speakerId, crossoverValue] = entry;
                const crossover = parseFloat(crossoverValue);

                if (typeof speakerId === 'string' && Number.isFinite(crossover) && crossover > 0) {
                  crossovers[speakerId.trim()] = crossover;
                }
              }
            } catch (error) {
              this.addValidationError(`Error parsing crossover entry ${index}: ${error.message}`);
            }
          });

          return crossovers;
        }

        // Parse and validate estimatedPlaybackLevels data
        parseEstimatedPlaybackLevels(rawData) {
          if (!Array.isArray(rawData)) {
            this.addValidationError("estimatedPlaybackLevels is not an array");
            return {};
          }

          const parsedLevels = {};
          let validEntries = 0;

          rawData.forEach((entry, index) => {
            try {
              if (!Array.isArray(entry) || entry.length !== 2) {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Invalid entry format - expected [speakerID, level]`);
                return;
              }

              const [speakerId, levelValue] = entry;

              if (typeof speakerId !== 'string' || speakerId.trim() === '') {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Invalid speaker ID`);
                return;
              }

              const level = parseFloat(levelValue);
              if (!Number.isFinite(level)) {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Invalid level value for ${speakerId}`);
                return;
              }

              // Validate reasonable level range (20-120 dB SPL)
              if (level < 20 || level > 120) {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Level ${level}dB for ${speakerId} is outside reasonable range (20-120dB)`);
              }

              parsedLevels[speakerId.trim()] = level;
              validEntries++;

            } catch (error) {
              this.addValidationError(`estimatedPlaybackLevels[${index}]: Parse error - ${error.message}`);
            }
          });

          if (validEntries === 0) {
            this.addValidationError("No valid entries found in estimatedPlaybackLevels");
          } else if (validEntries < rawData.length) {
            this.addValidationError(`Only ${validEntries}/${rawData.length} estimatedPlaybackLevels entries were valid`);
          }

          return parsedLevels;
        }

        // Calculate frequency response variance from measurement data
        calculateFrequencyResponseVariance(systemData, speakerGroup) {
          if (!systemData.freqIndex || !systemData.freqIndex.frequencies) {
            return null;
          }

          try {
            // Get relevant speakers for the group
            const relevantSpeakers = this.getSpeakersForGroup(systemData, speakerGroup);
            if (relevantSpeakers.length < 2) {
              return null; // Need at least 2 speakers for variance calculation
            }

            // Use frequency data to estimate response variance
            const freqData = systemData.freqIndex;

            // Estimate variance based on frequency measurement characteristics
            // This is a simplified approach - in practice would need actual FR measurements
            let estimatedVariance = 3.0; // Base variance estimate

            // Adjust based on measurement quality indicators
            if (freqData.is1_3Octave) {
              estimatedVariance *= 0.8; // Better measurement resolution
            }

            if (freqData.count >= 20) {
              estimatedVariance *= 0.9; // More measurement points = better accuracy
            }

            // Adjust based on speaker group characteristics
            if (speakerGroup === 'screen') {
              // Screen speakers typically better matched
              estimatedVariance *= 0.7;
            } else if (speakerGroup === 'surround') {
              // Surrounds may have more variation due to room interactions
              estimatedVariance *= 1.2;
            }

            // Use SPL consistency data if available to refine estimate
            if (systemData.estimatedPlaybackLevels) {
              const splAnalysis = this.analyzeSpeakerGroupSPL(systemData.estimatedPlaybackLevels);
              const groupSPLVariance = this.getSPLVarianceForGroup(splAnalysis, speakerGroup);

              if (groupSPLVariance !== null) {
                // Correlate SPL variance with frequency response variance
                estimatedVariance = Math.max(estimatedVariance, groupSPLVariance * 0.6);
              }
            }

            return Math.round(estimatedVariance * 10) / 10;

          } catch (error) {
            this.addValidationError(`Frequency response variance calculation error: ${error.message}`);
            return null;
          }
        }

        // Estimate bass extension from frequency measurement data
        estimateBassExtensionFromFrequencies(freqData) {
          if (!freqData || !freqData.frequencies || freqData.frequencies.length === 0) {
            return null;
          }

          try {
            // Find the lowest measurement frequency as indicator of bass extension
            const lowestFreq = freqData.minFreq;

            // Estimate -3dB cutoff based on lowest measurement frequency
            // Typical relationship: if measuring down to X Hz, -3dB point is usually higher
            let estimatedCutoff;

            if (lowestFreq <= 20) {
              estimatedCutoff = 25; // Excellent extension
            } else if (lowestFreq <= 30) {
              estimatedCutoff = 35; // Good extension  
            } else if (lowestFreq <= 40) {
              estimatedCutoff = 45; // Fair extension
            } else {
              estimatedCutoff = Math.max(lowestFreq, 60); // Limited extension
            }

            // Adjust based on number of low frequency measurement points
            const lowFreqPoints = freqData.frequencies.filter(f => f <= 80).length;
            if (lowFreqPoints >= 5) {
              estimatedCutoff *= 0.9; // More LF measurement points suggest better extension
            }

            return Math.round(estimatedCutoff);

          } catch (error) {
            this.addValidationError(`Bass extension estimation error: ${error.message}`);
            return null;
          }
        }

        // Get speakers for specific group analysis
        getSpeakersForGroup(systemData, speakerGroup) {
          if (!systemData.commandId || !Array.isArray(systemData.commandId)) {
            return [];
          }

          const speakers = systemData.commandId.filter(id => id && typeof id === 'string');

          switch (speakerGroup.toLowerCase()) {
            case 'screen':
              return speakers.filter(id => ['FL', 'FC', 'FR', 'FCL', 'FCR', 'C'].includes(id));
            case 'surround':
              return speakers.filter(id =>
                ['SL', 'SR', 'SBL', 'SBR', 'SLA', 'SRA', 'SB'].includes(id) ||
                ['FHL', 'FHR', 'RHL', 'RHR', 'SHL', 'SHR', 'CH'].includes(id) ||
                ['TFL', 'TFR', 'TML', 'TMR', 'TRL', 'TRR', 'TS'].includes(id)
              );
            case 'wide':
              return speakers.filter(id => ['FWL', 'FWR'].includes(id));
            case 'upper':
              return speakers.filter(id =>
                id.includes('H') || id.startsWith('T') ||
                ['BDL', 'BDR', 'FDL', 'FDR', 'SDL', 'SDR'].includes(id)
              );
            default:
              return speakers;
          }
        }

        // Get SPL variance for specific speaker group
        getSPLVarianceForGroup(splAnalysis, speakerGroup) {
          switch (speakerGroup.toLowerCase()) {
            case 'screen':
              return splAnalysis.screenSpeakers?.maxDiff || null;
            case 'surround':
              return splAnalysis.surroundSpeakers?.maxDiff || null;
            case 'upper':
              return splAnalysis.upperSpeakers?.maxDiff || null;
            case 'wide':
              return splAnalysis.wideSpeakers?.maxDiff || null;
            default:
              return null;
          }
        }

        // Calculate room acoustics from speaker distances using CEDIA RP22 methodology
        calculateRoomAcoustics(systemData) {
          try {
            if (!systemData.estimatedDistances || Object.keys(systemData.estimatedDistances).length === 0) {
              return { dimensions: null, transitionFreq: null, modes: [] };
            }

            // Estimate room dimensions from speaker distances
            const distances = Object.values(systemData.estimatedDistances);
            const maxDistance = Math.max(...distances);
            const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;

            // CEDIA RP22 room estimation using acoustic principles
            const estimatedLength = maxDistance * 1.8; // More conservative estimate
            const estimatedWidth = maxDistance * 1.4;
            const estimatedHeight = Math.min(avgDistance * 0.85, 3.5); // Typical residential height
            const estimatedVolume = estimatedLength * estimatedWidth * estimatedHeight;

            // Calculate Schroeder transition frequency
            const reverbTime = this.estimateRT60(estimatedVolume);
            const transitionFreq = this.calculateSchroederFrequency(reverbTime, estimatedVolume);

            // Calculate room modes
            const modes = this.calculateRoomModes(estimatedLength, estimatedWidth, estimatedHeight);

            return {
              dimensions: {
                length: estimatedLength,
                width: estimatedWidth,
                height: estimatedHeight,
                volume: estimatedVolume,
                surfaceArea: 2 * (estimatedLength * estimatedWidth + estimatedLength * estimatedHeight + estimatedWidth * estimatedHeight)
              },
              transitionFreq: transitionFreq,
              modes: modes,
              reverbTime: reverbTime
            };

          } catch (error) {
            this.addValidationError(`Room acoustics calculation error: ${error.message}`);
            return { dimensions: null, transitionFreq: null, modes: [] };
          }
        }

        // Calculate room modes using CEDIA RP22 methodology
        calculateRoomModes(length, width, height) {
          const modes = [];
          const c = this.PRECISION.SPEED_OF_SOUND;

          // Generate axial, tangential, and oblique modes up to 300Hz
          for (let nx = 0; nx <= 10; nx++) {
            for (let ny = 0; ny <= 10; ny++) {
              for (let nz = 0; nz <= 10; nz++) {
                if (nx === 0 && ny === 0 && nz === 0) continue;

                const frequency = (c / 2) * Math.sqrt(
                  Math.pow(nx / length, 2) +
                  Math.pow(ny / width, 2) +
                  Math.pow(nz / height, 2)
                );

                if (frequency <= 300) {
                  const nonZeros = [nx, ny, nz].filter(n => n > 0).length;
                  let type = 'oblique';
                  if (nonZeros === 1) type = 'axial';      // Strongest impact
                  else if (nonZeros === 2) type = 'tangential'; // -3dB relative

                  modes.push({
                    frequency: Math.round(frequency * 10) / 10,
                    type: type,
                    order: [nx, ny, nz],
                    strength: type === 'axial' ? 1.0 : type === 'tangential' ? 0.5 : 0.25
                  });
                }
              }
            }
          }

          return modes.sort((a, b) => a.frequency - b.frequency);
        }

        // Calculate Schroeder transition frequency using CEDIA RP22 formula
        calculateSchroederFrequency(reverbTime, volume) {
          // fs = 2000 × √(T60/V) - CEDIA RP22 formula
          return Math.round(2000 * Math.sqrt(reverbTime / volume));
        }

        // Estimate RT60 using simplified residential model
        estimateRT60(volume) {
          // CEDIA RP22 target: Tm = 0.3 (V / 100)^(1/3)
          const targetRT60 = 0.3 * Math.pow(volume / 100, 1 / 3);

          // Typical residential RT60 tends to be slightly higher than target
          return Math.min(targetRT60 * 1.2, 0.6); // Cap at 0.6 seconds
        }

        // Calculate all speaker angles from distances using CEDIA placement guidelines
        calculateAllSpeakerAngles(systemData) {
          const angles = {};
          const distances = systemData.estimatedDistances || {};

          if (Object.keys(distances).length === 0) {
            return angles;
          }

          try {
            // Get center speaker distance as reference
            const centerDistance = distances['C'] || distances['FC'] || null;
            if (!centerDistance) {
              this.addValidationError("No center speaker distance found for angle calculations");
              return angles;
            }

            // Calculate angles for each speaker relative to center
            Object.entries(distances).forEach(([speakerId, distance]) => {
              if (speakerId === 'C' || speakerId === 'FC') {
                angles[speakerId] = { horizontal: 0, vertical: 0, elevation: 0 };
                return;
              }

              // Use trigonometric calculations for precise angles
              const speakerAngles = this.calculateSpeakerAngle(speakerId, distance, centerDistance);
              angles[speakerId] = speakerAngles;
            });

            return angles;

          } catch (error) {
            this.addValidationError(`Speaker angle calculation error: ${error.message}`);
            return angles;
          }
        }

        // Calculate speaker angles using coordinate geometry and CEDIA guidelines
        calculateSpeakerAngle(speakerId, distance, centerDistance) {
          const speakerType = this.classifySpeakerType(speakerId);

          // CEDIA RP22 placement specifications
          const placementGuidelines = {
            front: { horizontal: 30, vertical: 0, elevation: 0 },        // FL/FR ±30°
            frontWide: { horizontal: 60, vertical: 0, elevation: 0 },    // FWL/FWR ±60°
            surround: { horizontal: 90, vertical: 0, elevation: 5 },     // SL/SR ±90°
            surroundBack: { horizontal: 135, vertical: 0, elevation: 5 }, // SBL/SBR ±135°
            frontHeight: { horizontal: 30, vertical: 30, elevation: 30 }, // Height speakers
            rearHeight: { horizontal: 135, vertical: 30, elevation: 30 },
            topFront: { horizontal: 30, vertical: 45, elevation: 45 },   // Top speakers
            topRear: { horizontal: 135, vertical: 45, elevation: 45 },
            subwoofer: { horizontal: 0, vertical: 0, elevation: 0 }      // Subwoofers
          };

          const baseAngles = placementGuidelines[speakerType] || { horizontal: 0, vertical: 0, elevation: 0 };

          // Adjust for left/right positioning using trigonometry
          let horizontalAngle = baseAngles.horizontal;
          if (speakerId.includes('L') || speakerId.includes('l')) {
            horizontalAngle = -Math.abs(horizontalAngle); // Negative for left
          } else if (speakerId.includes('R') || speakerId.includes('r')) {
            horizontalAngle = Math.abs(horizontalAngle);  // Positive for right
          }

          // Calculate distance-based adjustments using trigonometric principles
          const distanceRatio = distance / centerDistance;
          const adjustedHorizontal = horizontalAngle * Math.min(distanceRatio, 1.5); // Limit adjustment

          return {
            horizontal: Math.round(adjustedHorizontal * 10) / 10,
            vertical: baseAngles.vertical,
            elevation: baseAngles.elevation,
            distance: distance,
            distanceRatio: Math.round(distanceRatio * 100) / 100
          };
        }

        // Classify speaker by ID for angle calculations
        classifySpeakerType(speakerId) {
          const id = speakerId.toLowerCase();

          if (['fl', 'fr'].includes(id)) return 'front';
          if (['fwl', 'fwr'].includes(id)) return 'frontWide';
          if (['sl', 'sr', 'sla', 'sra'].includes(id)) return 'surround';
          if (['sbl', 'sbr', 'sb'].includes(id)) return 'surroundBack';
          if (['fhl', 'fhr', 'hfl', 'hfr'].includes(id)) return 'frontHeight';
          if (['rhl', 'rhr', 'hbl', 'hbr'].includes(id)) return 'rearHeight';
          if (['tfl', 'tfr'].includes(id)) return 'topFront';
          if (['tbl', 'tbr', 'trl', 'trr'].includes(id)) return 'topRear';
          if (id.startsWith('sw')) return 'subwoofer';

          return 'other';
        }

        // Analyze bass management impact on crossovers
        analyzeBassManagement(systemData) {
          const crossovers = systemData.crossoverData || {};
          const analysis = {
            averageCrossover: 80, // Default THX standard
            crossoverSpread: 0,
            bassManagementEfficiency: 1.0,
            recommendations: []
          };

          try {
            if (Object.keys(crossovers).length > 0) {
              const crossoverValues = Object.values(crossovers).filter(v => Number.isFinite(v));

              if (crossoverValues.length > 0) {
                analysis.averageCrossover = crossoverValues.reduce((sum, xo) => sum + xo, 0) / crossoverValues.length;
                analysis.crossoverSpread = Math.max(...crossoverValues) - Math.min(...crossoverValues);

                // Efficiency based on crossover consistency
                analysis.bassManagementEfficiency = Math.max(0.5, 1 - (analysis.crossoverSpread / 100));

                // Generate recommendations
                if (analysis.crossoverSpread > 40) {
                  analysis.recommendations.push("High crossover spread detected - consider standardizing crossover frequencies");
                }
                if (analysis.averageCrossover > 120) {
                  analysis.recommendations.push("High average crossover may compromise bass integration");
                }
                if (analysis.averageCrossover < 60) {
                  analysis.recommendations.push("Low average crossover may stress main speakers");
                }
              }
            }

            return analysis;
          } catch (error) {
            this.addValidationError(`Bass management analysis error: ${error.message}`);
            return analysis;
          }
        }

        // Enhanced SPL calculations with speaker-specific playback levels
        calculateEnhancedSPLDifferences(systemData) {
          // Try to use estimatedPlaybackLevels first, fall back to customLevel
          let levelData = null;
          let dataSource = null;

          if (systemData.estimatedPlaybackLevels && Object.keys(systemData.estimatedPlaybackLevels).length > 0) {
            levelData = systemData.estimatedPlaybackLevels;
            dataSource = "estimatedPlaybackLevels";
          } else if (systemData.customLevel && Array.isArray(systemData.customLevel)) {
            // Convert customLevel array to object format for consistency
            levelData = {};
            systemData.customLevel.forEach((level, index) => {
              if (index > 0 && level !== undefined) {
                levelData[`Speaker_${index}`] = parseFloat(level);
              }
            });
            dataSource = "customLevel";
          }

          if (!levelData || Object.keys(levelData).length === 0) {
            return { error: "No valid level data available", maxDifference: null, dataSource: null };
          }

          try {
            // Extract numeric levels, filtering out invalid values
            const levels = Object.values(levelData)
              .map(level => parseFloat(level))
              .filter(level => Number.isFinite(level));

            if (levels.length < 2) {
              return { error: "Insufficient level data for comparison", maxDifference: null, dataSource };
            }

            // Calculate comprehensive statistics
            const maxLevel = Math.max(...levels);
            const minLevel = Math.min(...levels);
            const maxDifference = this.preciseSubtraction(maxLevel, minLevel);
            const avgLevel = levels.reduce((sum, level) => sum + level, 0) / levels.length;
            const stdDev = Math.sqrt(levels.reduce((sum, level) => sum + Math.pow(level - avgLevel, 2), 0) / levels.length);

            // Enhanced analysis by speaker groups using actual speaker IDs
            const groupAnalysis = this.analyzeSpeakerGroupSPL(levelData);

            return {
              maxDifference,
              minLevel,
              maxLevel,
              avgLevel: Math.round(avgLevel * 10) / 10,
              standardDeviation: Math.round(stdDev * 10) / 10,
              screenSpeakerDiff: groupAnalysis.screenSpeakers.maxDiff,
              surroundSpeakerDiff: groupAnalysis.surroundSpeakers.maxDiff,
              upperSpeakerDiff: groupAnalysis.upperSpeakers.maxDiff,
              subwooferLevel: groupAnalysis.subwoofers.avgLevel,
              speakerCount: levels.length,
              levelConsistency: maxDifference <= 2.0 ? 'Excellent' : maxDifference <= 4.0 ? 'Good' : 'Needs Improvement',
              dataSource: dataSource,
              groupAnalysis: groupAnalysis,
              recommendations: this.generateSPLRecommendations(maxDifference, groupAnalysis)
            };
          } catch (error) {
            return { error: `SPL calculation error: ${error.message}`, maxDifference: null, dataSource };
          }
        }

        // Analyze SPL by speaker groups using actual speaker IDs
        analyzeSpeakerGroupSPL(levelData) {
          const groups = {
            screenSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            surroundSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            upperSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            subwoofers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            wideSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            unclassified: { speakers: [], levels: [], maxDiff: 0, avgLevel: null }
          };

          // Classify speakers by their IDs
          Object.entries(levelData).forEach(([speakerId, level]) => {
            const numLevel = parseFloat(level);
            if (!Number.isFinite(numLevel)) return;

            // Classify speaker by ID
            if (speakerId.toLowerCase().includes('subwoofer') || speakerId.startsWith('SW')) {
              groups.subwoofers.speakers.push(speakerId);
              groups.subwoofers.levels.push(numLevel);
            } else if (['FL', 'FC', 'FR', 'FCL', 'FCR', 'C'].includes(speakerId)) {
              groups.screenSpeakers.speakers.push(speakerId);
              groups.screenSpeakers.levels.push(numLevel);
            } else if (['FWL', 'FWR'].includes(speakerId)) {
              groups.wideSpeakers.speakers.push(speakerId);
              groups.wideSpeakers.levels.push(numLevel);
            } else if (['FHL', 'FHR', 'RHL', 'RHR', 'SHL', 'SHR', 'CH', 'TFL', 'TFR', 'TML', 'TMR', 'TRL', 'TRR', 'TS'].includes(speakerId)) {
              // Height or Top speakers
              groups.upperSpeakers.speakers.push(speakerId);
              groups.upperSpeakers.levels.push(numLevel);
            } else if (['BDL', 'BDR', 'FDL', 'FDR', 'SDL', 'SDR'].includes(speakerId)) {
              // Upfiring speakers - classify as upper speakers for CEDIA assessment
              groups.upperSpeakers.speakers.push(speakerId);
              groups.upperSpeakers.levels.push(numLevel);
            } else if (['SL', 'SR', 'SBL', 'SBR', 'SLA', 'SRA', 'SB'].includes(speakerId)) {
              groups.surroundSpeakers.speakers.push(speakerId);
              groups.surroundSpeakers.levels.push(numLevel);
            } else {
              groups.unclassified.speakers.push(speakerId);
              groups.unclassified.levels.push(numLevel);
            }
          });

          // Calculate statistics for each group
          Object.keys(groups).forEach(groupName => {
            const group = groups[groupName];
            if (group.levels.length > 0) {
              const maxLevel = Math.max(...group.levels);
              const minLevel = Math.min(...group.levels);
              group.maxDiff = this.preciseSubtraction(maxLevel, minLevel);
              group.avgLevel = Math.round((group.levels.reduce((sum, level) => sum + level, 0) / group.levels.length) * 10) / 10;
            }
          });

          return groups;
        }

        // Generate SPL-based recommendations
        generateSPLRecommendations(maxDifference, groupAnalysis) {
          const recommendations = [];

          if (maxDifference > 6) {
            recommendations.push("Critical: SPL difference >6dB detected. Review speaker placement, amplification, and calibration.");
          } else if (maxDifference > 4) {
            recommendations.push("Warning: SPL difference >4dB may affect imaging. Check speaker levels and room acoustics.");
          } else if (maxDifference > 2) {
            recommendations.push("Notice: SPL difference >2dB detected. Fine-tune calibration for optimal performance.");
          }

          // Group-specific recommendations
          if (groupAnalysis.screenSpeakers.maxDiff > 3) {
            recommendations.push("Screen speakers show significant level differences. Ensure matched amplification and verify speaker sensitivity.");
          }

          if (groupAnalysis.upperSpeakers.maxDiff > 5) {
            recommendations.push("Upper layer speakers show large level variations. Check mounting angles and amplifier settings.");
          }

          if (groupAnalysis.subwoofers.levels.length > 0) {
            const subLevel = groupAnalysis.subwoofers.avgLevel;
            const mainAvg = (groupAnalysis.screenSpeakers.avgLevel + groupAnalysis.surroundSpeakers.avgLevel) / 2;
            if (subLevel && mainAvg && Math.abs(subLevel - mainAvg) > 10) {
              recommendations.push("Subwoofer level significantly different from main speakers. Review bass management settings.");
            }
          }

          return recommendations;
        }

        // Enhanced room size estimation with acoustic modeling
        estimateEnhancedRoomSize(systemData) {
          // Use advanced room acoustics data if available
          if (systemData.roomAcoustics && systemData.roomAcoustics.dimensions) {
            return {
              estimatedLength: systemData.roomAcoustics.dimensions.length,
              estimatedWidth: systemData.roomAcoustics.dimensions.width,
              estimatedHeight: systemData.roomAcoustics.dimensions.height,
              estimatedVolume: systemData.roomAcoustics.dimensions.volume,
              surfaceArea: systemData.roomAcoustics.dimensions.surfaceArea,
              transitionFrequency: systemData.roomAcoustics.transitionFreq,
              reverbTime: systemData.roomAcoustics.reverbTime,
              roomModes: systemData.roomAcoustics.modes
            };
          }

          if (!systemData.customDistance || !systemData.flDist) {
            return { error: "Insufficient distance data", estimatedLength: null };
          }

          try {
            const distances = systemData.customDistance
              .slice(1)
              .map(dist => parseFloat(dist))
              .filter(dist => Number.isFinite(dist) && dist > 0);

            if (distances.length === 0) {
              return { error: "No valid distance measurements", estimatedLength: null };
            }

            const maxDistance = Math.max(...distances);
            const avgDistance = distances.reduce((sum, dist) => sum + dist, 0) / distances.length;

            // Enhanced room estimation using acoustic principles
            const estimatedLength = maxDistance * 1.6;
            const estimatedWidth = maxDistance * 1.2;
            const estimatedHeight = maxDistance * 0.4;
            const estimatedVolume = estimatedLength * estimatedWidth * estimatedHeight;

            // Calculate transition frequency for the room
            const reverbTime = this.estimateRT60(estimatedVolume);
            const transitionFreq = this.calculateSchroederFrequency(reverbTime, estimatedVolume);

            return {
              estimatedLength,
              estimatedWidth,
              estimatedHeight,
              estimatedVolume,
              avgListeningDistance: avgDistance,
              maxListeningDistance: maxDistance,
              wallProximity: Math.min(avgDistance * 0.25, 1.8),
              transitionFrequency: transitionFreq,
              reverbTime: reverbTime,
              roomRatio: {
                lengthToWidth: estimatedLength / estimatedWidth,
                widthToHeight: estimatedWidth / estimatedHeight,
                evaluation: this.evaluateRoomRatio(estimatedLength / estimatedWidth)
              }
            };
          } catch (error) {
            return { error: `Room estimation error: ${error.message}`, estimatedLength: null };
          }
        }

        // Enhanced system analysis with comprehensive validation
        analyzeEnhancedSystem() {
          if (!commandId || !Array.isArray(commandId)) {
            this.addValidationError("No valid speaker configuration detected");
            return null;
          }

          try {
            const actualSpeakers = commandId.filter(id => id && typeof id === 'string' && id.length > 0);

            // Enhanced speaker classification
            const analysis = {
              detectedSpeakers: actualSpeakers,

              // Categorize speakers by type
              screenSpeakers: actualSpeakers.filter(id =>
                ['FL', 'FC', 'FR', 'FCL', 'FCR', 'C'].includes(id)),

              heightSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.frontHeight.includes(id) ||
                this.speakerTypes.rearHeight.includes(id) ||
                this.speakerTypes.surroundHeight.includes(id)),

              topSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.topFront.includes(id) ||
                this.speakerTypes.topMiddle.includes(id) ||
                this.speakerTypes.topRear.includes(id)),

              upfiringSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.upfiringFront.includes(id) ||
                this.speakerTypes.upfiringBack.includes(id) ||
                this.speakerTypes.upfiringSurround.includes(id)),

              surroundSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.surround.includes(id) ||
                this.speakerTypes.surroundBack.includes(id)),

              wideSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.frontWide.includes(id)),

              subwoofers: actualSpeakers.filter(id => id.startsWith("SW")),

              totalMainSpeakers: 0,
              bedLayerSpeakers: 0,
              totalUpperSpeakers: 0,
              discreteSpeakerFeeds: 0,
              systemComplexity: 'Basic'
            };

            // Calculate totals correctly for X.Y.Z configuration format
            analysis.totalMainSpeakers = actualSpeakers.filter(id => !id.startsWith("SW")).length;
            analysis.totalUpperSpeakers = analysis.heightSpeakers.length + analysis.topSpeakers.length + analysis.upfiringSpeakers.length;

            // Bed layer = all main speakers EXCEPT height/top/upfiring speakers
            analysis.bedLayerSpeakers = analysis.totalMainSpeakers - analysis.totalUpperSpeakers;

            analysis.discreteSpeakerFeeds = analysis.totalMainSpeakers + (analysis.subwoofers.length > 0 ? 1 : 0);
            analysis.usesUpfiring = analysis.upfiringSpeakers.length > 0;

            // Calculate proper X.Y.Z configuration string
            const subCount = analysis.subwoofers.length > 0 ? 1 : systemData.nSubs > 0 ? 1 : 0;
            analysis.configurationString = `${analysis.bedLayerSpeakers}.${subCount}.${analysis.totalUpperSpeakers}`;

            // Assess system complexity based on bed layer + height speakers
            if (analysis.bedLayerSpeakers >= 7 || analysis.totalUpperSpeakers >= 4) {
              analysis.systemComplexity = 'High';
            } else if (analysis.bedLayerSpeakers >= 5 || analysis.totalUpperSpeakers >= 2) {
              analysis.systemComplexity = 'Medium';
            }

            // Validate speaker configuration
            analysis.configurationValid = this.validateSpeakerConfiguration(analysis);
            analysis.formatCompatibility = this.assessFormatCompatibility(analysis);

            return analysis;
          } catch (error) {
            this.addValidationError(`System analysis error: ${error.message}`);
            return null;
          }
        }

        // Enhanced parameter evaluation with comprehensive validation
        evaluateParameter(paramId, measuredValue, useRecommended = false) {
          const param = this.parameters[paramId];
          if (!param) {
            return {
              level: 0,
              score: 0,
              error: `Parameter ${paramId} not found`,
              measuredValue: null,
              category: "Unknown"
            };
          }

          try {
            // Use parameter-specific validator if available
            if (param.validator && typeof param.validator === 'function') {
              const validationResult = param.validator(measuredValue);
              if (!validationResult.valid) {
                return {
                  level: 0,
                  score: 0,
                  error: validationResult.error,
                  measuredValue,
                  category: param.category,
                  parameterName: param.name
                };
              }
              measuredValue = validationResult.value; // Use validated/normalized value
            }

            const { targets, type } = param;
            let achievedLevel = 0;

            // Special handling for boolean parameters
            if (paramId === 8) {
              achievedLevel = measuredValue === false ? 4 : 2;
              return {
                level: achievedLevel,
                score: achievedLevel * 25,
                measuredValue: measuredValue,
                category: param.category,
                notes: measuredValue ? "Using upfiring speakers" : "Using dedicated height/top speakers",
                parameterName: param.name,
                recommendation: measuredValue ? "Consider upgrading to dedicated height speakers for levels 3-4" : "Excellent speaker configuration"
              };
            }

            // Evaluate against performance level targets
            for (let level = 1; level <= 4; level++) {
              const target = targets[`level${level}`];
              if (target === null || target === undefined) continue;

              let passes = false;
              if (typeof target === 'object') {
                const threshold = useRecommended && target.rec !== undefined ? target.rec :
                  type === "minimum" ? target.min : target.max;

                if (threshold !== undefined) {
                  passes = type === "minimum" ?
                    this.preciseComparison(measuredValue, threshold, '>=') :
                    this.preciseComparison(measuredValue, threshold, '<=');
                }
              } else {
                passes = type === "minimum" ?
                  this.preciseComparison(measuredValue, target, '>=') :
                  this.preciseComparison(measuredValue, target, '<=');
              }

              if (passes) {
                achievedLevel = level;
              } else {
                break;
              }
            }

            return {
              level: achievedLevel,
              score: achievedLevel * 25,
              measuredValue: measuredValue,
              category: param.category,
              parameterName: param.name,
              recommendation: this.generateRecommendation(paramId, achievedLevel, measuredValue),
              targetValues: targets,
              usedRecommended: useRecommended
            };

          } catch (error) {
            return {
              level: 0,
              score: 0,
              error: `Evaluation error: ${error.message}`,
              measuredValue,
              category: param.category,
              parameterName: param.name
            };
          }
        }

        // Enhanced performance calculation with weighted scoring
        calculateSystemPerformance(results) {
          const validResults = Object.values(results).filter(r => r.level > 0 && !r.error);
          const errorResults = Object.values(results).filter(r => r.error);

          if (validResults.length === 0) {
            return {
              overallLevel: 0,
              overallScore: 0,
              category: "Non-compliant",
              errors: errorResults.length,
              confidence: "Low"
            };
          }

          // Calculate weighted performance based on parameter importance
          const spatialResults = validResults.filter(r => r.category === "Spatial Resolution");
          const dynamicResults = validResults.filter(r => r.category === "Dynamics");
          const timbreResults = validResults.filter(r => r.category === "Timbre");

          // Calculate category scores with weighting
          const spatialScore = spatialResults.length > 0 ?
            spatialResults.reduce((sum, r) => sum + r.score, 0) / spatialResults.length : 0;
          const dynamicScore = dynamicResults.length > 0 ?
            dynamicResults.reduce((sum, r) => sum + r.score, 0) / dynamicResults.length : 0;
          const timbreScore = timbreResults.length > 0 ?
            timbreResults.reduce((sum, r) => sum + r.score, 0) / timbreResults.length : 0;

          // Weighted overall score (Dynamics and Timbre are weighted higher)
          const weightedScore = Math.round(
            (spatialScore * 0.3 + dynamicScore * 0.4 + timbreScore * 0.3)
          );

          // Overall level is the minimum of all achieved levels (conservative approach)
          const minLevel = Math.min(...validResults.map(r => r.level));
          const avgScore = Math.round(validResults.reduce((sum, r) => sum + r.score, 0) / validResults.length);

          // Determine confidence level
          const completeness = validResults.length / 21; // Out of total 21 parameters
          const confidence = completeness >= 0.7 ? "High" :
            completeness >= 0.5 ? "Medium" : "Low";

          const categories = [
            "Non-compliant",
            "Performance Level 1",
            "Performance Level 2",
            "Performance Level 3",
            "Performance Level 4"
          ];

          return {
            overallLevel: minLevel,
            overallScore: avgScore,
            weightedScore: weightedScore,
            category: categories[minLevel] || "Non-compliant",
            totalParametersEvaluated: validResults.length,
            totalParametersAvailable: 21,
            completeness: Math.round(completeness * 100),
            confidence: confidence,
            categoryBreakdown: {
              spatial: { count: spatialResults.length, avgScore: Math.round(spatialScore) },
              dynamics: { count: dynamicResults.length, avgScore: Math.round(dynamicScore) },
              timbre: { count: timbreResults.length, avgScore: Math.round(timbreScore) }
            },
            errors: errorResults.length,
            warnings: this.validationErrors.length
          };
        }

        // Enhanced main assessment function with comprehensive analysis
        runReadOnlyAssessment() {
          console.log("═".repeat(75));
          console.log("🎯 CEDIA/CTA-RP22 ENHANCED PERFORMANCE ASSESSMENT v2.1");
          console.log("   🔬 Advanced Acoustic Analysis & CEDIA RP22 Mathematics");
          console.log("═".repeat(75));

          // Reset validation errors
          this.validationErrors = [];

          try {
            const systemData = this.captureAllSystemData();
            const systemAnalysis = this.analyzeEnhancedSystem();
            const splDifferences = this.calculateEnhancedSPLDifferences(systemData);
            const roomEstimate = this.estimateEnhancedRoomSize(systemData);

            if (!systemAnalysis) {
              console.error("❌ Cannot analyze system - insufficient data");
              this.logValidationErrors();
              return { error: "System analysis failed", validationErrors: this.validationErrors };
            }

            console.log("\n📋 COMPREHENSIVE SYSTEM ANALYSIS:");
            const subCount = systemAnalysis.subwoofers.length > 0 ? 1 : systemData.nSubs > 0 ? 1 : 0;
            console.log(`├─ Configuration: ${systemAnalysis.configurationString} (${systemAnalysis.bedLayerSpeakers} bed + ${subCount} LFE + ${systemAnalysis.totalUpperSpeakers} height)`);
            console.log(`├─ Discrete speaker feeds: ${systemAnalysis.discreteSpeakerFeeds}`);
            console.log(`├─ System complexity: ${systemAnalysis.systemComplexity}`);

            // Enhanced frequency data reporting
            if (systemData.freqIndex && systemData.freqIndex.frequencies) {
              console.log(`├─ Frequency analysis: ${systemData.freqIndex.count} measurement points (${systemData.freqIndex.minFreq}-${systemData.freqIndex.maxFreq}Hz)`);
              console.log(`├─ Measurement type: ${systemData.freqIndex.is1_3Octave ? '1/3 octave' : `~${systemData.freqIndex.bandsPerOctave} bands/octave`}`);
              console.log(`├─ Frequency range: ${(systemData.freqIndex.frequencyRange || 1).toFixed(1)}:1 ratio`);
            }

            // Enhanced timing data reporting
            if (systemData.mSec && systemData.mSec.delays) {
              console.log(`├─ Timing analysis: ${systemData.mSec.count} speaker delays analyzed`);
              console.log(`├─ Delay spread: ${(systemData.mSec.delaySpread * 1000).toFixed(2)}ms (σ=${(systemData.mSec.stdDeviation * 1000).toFixed(2)}ms)`);
              console.log(`├─ Timing consistency: ${systemData.mSec.timingConsistency}`);
              console.log(`├─ Early reflection est: ${systemData.mSec.earlyReflectionMetric}dB`);
            }

            // Enhanced playback levels reporting
            if (systemData.estimatedPlaybackLevels && Object.keys(systemData.estimatedPlaybackLevels).length > 0) {
              console.log(`├─ Playback levels: ${Object.keys(systemData.estimatedPlaybackLevels).length} speakers measured`);
              if (splDifferences && !splDifferences.error) {
                console.log(`├─ SPL consistency: ${splDifferences.levelConsistency} (max diff: ${splDifferences.maxDifference?.toFixed(1)}dB)`);
              }
            }

            // Enhanced speaker positioning analysis
            if (systemData.speakerAngles && Object.keys(systemData.speakerAngles).length > 0) {
              console.log(`├─ Speaker angles: ${Object.keys(systemData.speakerAngles).length} speakers calculated`);
              const avgHorizontal = Object.values(systemData.speakerAngles)
                .map(a => Math.abs(a.horizontal))
                .reduce((sum, a) => sum + a, 0) / Object.keys(systemData.speakerAngles).length;
              console.log(`├─ Avg horizontal angle: ${avgHorizontal.toFixed(1)}°`);
            }

            console.log(`├─ Screen speakers: ${systemAnalysis.screenSpeakers.join(", ") || "None"}`);
            console.log(`├─ Height speakers: ${systemAnalysis.heightSpeakers.join(", ") || "None"}`);
            console.log(`├─ Top speakers: ${systemAnalysis.topSpeakers.join(", ") || "None"}`);
            console.log(`├─ Wide speakers: ${systemAnalysis.wideSpeakers.join(", ") || "None"}`);
            console.log(`├─ Surround speakers: ${systemAnalysis.surroundSpeakers.join(", ") || "None"}`);
            console.log(`├─ Upfiring speakers: ${systemAnalysis.upfiringSpeakers.join(", ") || "None"}`);

            // Enhanced bass management reporting
            if (systemData.bassManagement) {
              console.log(`├─ Bass management: Avg XO ${systemData.bassManagement.averageCrossover.toFixed(0)}Hz, Spread ${systemData.bassManagement.crossoverSpread.toFixed(0)}Hz`);
            }
            console.log(`├─ Bass system: ${systemData.nSubs} sub(s), ${systemData.bassMode} mode`);

            // Enhanced room acoustics reporting
            if (roomEstimate && !roomEstimate.error) {
              console.log(`├─ Room estimate: ${roomEstimate.estimatedLength?.toFixed(1)}×${roomEstimate.estimatedWidth?.toFixed(1)}×${roomEstimate.estimatedHeight?.toFixed(1)}m`);
              console.log(`├─ Room volume: ${roomEstimate.estimatedVolume?.toFixed(1)}m³`);
              if (roomEstimate.transitionFrequency) {
                console.log(`├─ Transition freq: ${roomEstimate.transitionFrequency?.toFixed(0)}Hz (RT60: ${roomEstimate.reverbTime?.toFixed(2)}s)`);
              }
              if (roomEstimate.roomModes && roomEstimate.roomModes.length > 0) {
                const axialModes = roomEstimate.roomModes.filter(m => m.type === 'axial').slice(0, 3);
                if (axialModes.length > 0) {
                  console.log(`├─ Primary room modes: ${axialModes.map(m => `${m.frequency}Hz`).join(", ")}`);
                }
              }
            }

            if (systemAnalysis.formatCompatibility) {
              console.log(`└─ Format support: ${Object.entries(systemAnalysis.formatCompatibility).filter(([_, supported]) => supported).map(([format, _]) => format).join(", ")}`);
            }

            // Enhanced parameter evaluation using comprehensive data analysis
            const results = {};

            // Spatial Resolution Parameters (1-11)
            if (roomEstimate && roomEstimate.wallProximity !== null && !roomEstimate.error) {
              results[1] = this.evaluateParameter(1, roomEstimate.wallProximity);
            }

            results[2] = this.evaluateParameter(2, systemAnalysis.discreteSpeakerFeeds);
            results[3] = this.evaluateParameter(3, this.countOutOfZoneSpeakers(systemAnalysis, 'screen'));
            results[8] = this.evaluateParameter(8, systemAnalysis.usesUpfiring);
            results[11] = this.evaluateParameter(11, this.countOutOfZoneSpeakers(systemAnalysis, 'all'));

            // Enhanced angle-based parameters using calculated angles
            if (systemData.speakerAngles && Object.keys(systemData.speakerAngles).length > 0) {
              const maxSurroundAngle = this.calculateMaxAdjacentSurroundAngle(systemData.speakerAngles, systemAnalysis.surroundSpeakers);
              const maxUpperAngle = this.calculateMaxAdjacentUpperAngle(systemData.speakerAngles, systemAnalysis.heightSpeakers.concat(systemAnalysis.topSpeakers));
              const wideDeviation = this.calculateWideDeviationFromMedian(systemData.speakerAngles, systemAnalysis.wideSpeakers);

              if (maxSurroundAngle !== null) results[5] = this.evaluateParameter(5, maxSurroundAngle);
              if (maxUpperAngle !== null) results[9] = this.evaluateParameter(9, maxUpperAngle);
              if (wideDeviation !== null) results[7] = this.evaluateParameter(7, wideDeviation);
            }

            // SPL-based parameters (4, 6, 10) - Enhanced with speaker-specific data
            if (splDifferences && splDifferences.maxDifference !== null && !splDifferences.error) {
              results[4] = this.evaluateParameter(4, splDifferences.screenSpeakerDiff || splDifferences.maxDifference);
              results[6] = this.evaluateParameter(6, splDifferences.surroundSpeakerDiff || splDifferences.maxDifference);
              results[10] = this.evaluateParameter(10, splDifferences.upperSpeakerDiff || splDifferences.maxDifference);
            }

            // Dynamics Parameters (12-15) - Enhanced with playback level data
            if (systemData.estimatedPlaybackLevels && Object.keys(systemData.estimatedPlaybackLevels).length > 0) {
              // Use actual measured levels for SPL capability assessment
              const screenCapability = this.calculateSpeakerCapability(systemData.estimatedPlaybackLevels, 'screen', roomEstimate);
              const surroundCapability = this.calculateSpeakerCapability(systemData.estimatedPlaybackLevels, 'surround', roomEstimate);
              const subwooferCapability = this.calculateSpeakerCapability(systemData.estimatedPlaybackLevels, 'subwoofer', roomEstimate);

              if (screenCapability !== null) {
                results[12] = this.evaluateParameter(12, screenCapability, true);
              }
              if (surroundCapability !== null) {
                results[13] = this.evaluateParameter(13, surroundCapability, true);
              }
              if (subwooferCapability !== null) {
                results[14] = this.evaluateParameter(14, subwooferCapability, true);
              }
            } else if (systemData.targetLevel && Number.isFinite(systemData.targetLevel)) {
              // Fallback to estimated calculations
              const roomGain = roomEstimate && roomEstimate.estimatedVolume ?
                Math.max(0, 3 * Math.log10(100 / roomEstimate.estimatedVolume)) : 0;

              results[12] = this.evaluateParameter(12, systemData.targetLevel + 25 + roomGain, true);
              results[13] = this.evaluateParameter(13, systemData.targetLevel + 20 + roomGain, true);
              results[14] = this.evaluateParameter(14, systemData.targetLevel + 35 + roomGain, true);
            }

            // Estimate background noise (simplified - would need actual measurement)
            const estimatedNoiseFloor = this.estimateBackgroundNoise(systemData, roomEstimate);
            if (estimatedNoiseFloor !== null) {
              results[15] = this.evaluateParameter(15, estimatedNoiseFloor, true);
            }

            // Enhanced frequency response analysis using freqIndex data (Parameters 16, 17, 18)
            if (systemData.freqIndex && systemData.freqIndex.frequencies) {
              // Parameter 16: Screen wall speaker frequency response variance
              const screenFRVariance = this.calculateFrequencyResponseVariance(systemData, 'screen');
              if (screenFRVariance !== null) {
                results[16] = this.evaluateParameter(16, screenFRVariance);
              }

              // Parameter 17: Surround/Upper speaker frequency response variance
              const surroundFRVariance = this.calculateFrequencyResponseVariance(systemData, 'surround');
              if (surroundFRVariance !== null) {
                results[17] = this.evaluateParameter(17, surroundFRVariance);
              }

              // Parameter 18: Enhanced bass extension using frequency analysis
              if (systemData.bassExtension) {
                results[18] = this.evaluateParameter(18, systemData.bassExtension, true);
              } else {
                // Estimate bass extension from frequency data
                const estimatedBassExt = this.estimateBassExtensionFromFrequencies(systemData.freqIndex);
                if (estimatedBassExt !== null) {
                  results[18] = this.evaluateParameter(18, estimatedBassExt, true);
                }
              }
            }

            // Enhanced bass analysis using optimization data
            if (systemData.RP22subnminXO && systemData.RP22submaxXO &&
              Number.isFinite(systemData.RP22subnminXO) && Number.isFinite(systemData.RP22submaxXO)) {

              const bandwidth = systemData.RP22submaxXO - systemData.RP22subnminXO;
              const smoothnessEst = this.estimateBassSmoothness(bandwidth, systemData.delayRange);

              if (smoothnessEst !== null) {
                results[19] = this.evaluateParameter(19, smoothnessEst);

                if (systemData.delayRange && systemData.delayRange.range !== null) {
                  const consistencyEst = this.estimateBassConsistency(systemData.delayRange.range);
                  results[20] = this.evaluateParameter(20, consistencyEst);
                }
              }
            }

            // Enhanced early reflection analysis using timing data (Parameter 21)
            if (systemData.mSec && systemData.mSec.delays) {
              const earlyReflectionLevel = systemData.mSec.earlyReflectionMetric;
              if (earlyReflectionLevel !== null) {
                results[21] = this.evaluateParameter(21, earlyReflectionLevel);
              }
            }

            // Calculate overall performance with enhanced metrics
            const performance = this.calculateSystemPerformance(results);

            console.log(`\n🏆 ENHANCED PERFORMANCE RESULTS:`);
            console.log(`├─ Overall Level: ${performance.overallLevel}/4 (${performance.category})`);
            console.log(`├─ Assessment Score: ${performance.overallScore}/100 (Weighted: ${performance.weightedScore}/100)`);
            console.log(`├─ Parameter Coverage: ${performance.totalParametersEvaluated}/21 (${performance.completeness}%)`);
            console.log(`├─ Assessment Confidence: ${performance.confidence}`);
            console.log(`├─ Spatial Resolution: ${performance.categoryBreakdown.spatial.count} params, avg ${performance.categoryBreakdown.spatial.avgScore}/100`);
            console.log(`├─ Dynamics: ${performance.categoryBreakdown.dynamics.count} params, avg ${performance.categoryBreakdown.dynamics.avgScore}/100`);
            console.log(`├─ Timbre: ${performance.categoryBreakdown.timbre.count} params, avg ${performance.categoryBreakdown.timbre.avgScore}/100`);
            if (performance.errors > 0) {
              console.log(`├─ Errors: ${performance.errors} parameter evaluation errors`);
            }
            if (performance.warnings > 0) {
              console.log(`├─ Warnings: ${performance.warnings} validation warnings`);
            }

            // Enhanced final reporting with SPL analysis details
            if (splDifferences && !splDifferences.error && splDifferences.dataSource) {
              console.log(`\n📊 SPL ANALYSIS DETAILS (Source: ${splDifferences.dataSource}):`);
              console.log(`├─ Total speakers analyzed: ${splDifferences.speakerCount}`);
              console.log(`├─ SPL range: ${splDifferences.minLevel?.toFixed(1)} - ${splDifferences.maxLevel?.toFixed(1)} dB`);
              console.log(`├─ Average level: ${splDifferences.avgLevel} dB`);
              console.log(`├─ Standard deviation: ${splDifferences.standardDeviation} dB`);
              console.log(`├─ Screen speakers diff: ${splDifferences.screenSpeakerDiff?.toFixed(1)} dB`);
              console.log(`├─ Surround speakers diff: ${splDifferences.surroundSpeakerDiff?.toFixed(1)} dB`);
              console.log(`├─ Upper speakers diff: ${splDifferences.upperSpeakerDiff?.toFixed(1)} dB`);
              if (splDifferences.subwooferLevel) {
                console.log(`├─ Subwoofer level: ${splDifferences.subwooferLevel} dB`);
              }
              console.log(`└─ Overall consistency: ${splDifferences.levelConsistency}`);

              if (splDifferences.recommendations && splDifferences.recommendations.length > 0) {
                console.log(`\n💡 SPL RECOMMENDATIONS:`);
                splDifferences.recommendations.forEach((rec, index) => {
                  console.warn(`   ${index + 1}. ${rec}`);
                });
              }
            }

            console.log(`\n📊 DETAILED PARAMETER BREAKDOWN:`);
            Object.entries(results).forEach(([paramId, result]) => {
              const status = result.error ? "❌" :
                result.level >= 3 ? "✅" :
                  result.level >= 2 ? "⚠️" :
                    result.level >= 1 ? "🔶" : "❌";

              console.log(`${status} P${paramId.padStart(2, '0')}: ${result.parameterName}`);
              if (result.error) {
                console.log(`    └─ Error: ${result.error}`);
              } else {
                console.log(`    ├─ Level: ${result.level}/4 | Score: ${result.score}/100`);
                console.log(`    ├─ Measured: ${this.formatMeasuredValue(result.measuredValue, this.parameters[paramId].unit)}`);
                if (result.recommendation) {
                  console.log(`    └─ Recommendation: ${result.recommendation}`);
                }
              }
            });

            // Log validation errors and warnings if any
            this.logValidationErrors();

            console.log(`\n📚 Enhanced Analysis Notes:`);
            console.log(`├─ Assessment uses CEDIA/CTA-RP22 v1.2 September 2023 standards`);
            console.log(`├─ Frequency data processed as measurement point arrays with 1/3 octave analysis`);
            console.log(`├─ Timing data analyzed for early reflection and alignment characteristics`);
            console.log(`├─ Calculations include precision handling and validation`);
            console.log(`├─ Room acoustics use Schroeder frequency and modal analysis`);
            console.log(`├─ SPL calculations include boundary loading and room effects`);
            console.log(`├─ Speaker angles calculated using trigonometric principles`);
            console.log(`├─ Bass management analyzed using crossover optimization data`);
            console.log(`├─ Frequency response variance estimated from measurement data patterns`);
            console.log(`├─ Early reflections assessed from timing delay characteristics`);
            console.log(`└─ Weighted scoring emphasizes critical performance areas`);
            console.log("═".repeat(75));

            return {
              systemData,
              systemAnalysis,
              performance,
              results,
              splDifferences,
              roomEstimate,
              validationErrors: this.validationErrors,
              timestamp: new Date().toISOString(),
              version: "2.1-Enhanced-Acoustics"
            };

          } catch (error) {
            console.error("❌ Assessment failed:", error.message);
            console.log("═".repeat(75));
            return {
              error: `Assessment failed: ${error.message}`,
              validationErrors: this.validationErrors,
              timestamp: new Date().toISOString()
            };
          }
        }

        // Additional helper methods for enhanced functionality

        // Calculate speaker SPL capability from measured levels
        calculateSpeakerCapability(playbackLevels, speakerGroup, roomEstimate) {
          const groupLevels = [];

          // Filter levels by speaker group
          Object.entries(playbackLevels).forEach(([speakerId, level]) => {
            const numLevel = parseFloat(level);
            if (!Number.isFinite(numLevel)) return;

            let matchesGroup = false;
            switch (speakerGroup.toLowerCase()) {
              case 'screen':
                matchesGroup = ['FL', 'FC', 'FR', 'FCL', 'FCR'].includes(speakerId);
                break;
              case 'surround':
                matchesGroup = ['SL', 'SR', 'SBL', 'SBR', 'SLA', 'SRA'].includes(speakerId) ||
                  speakerId.includes('SL') || speakerId.includes('SR') || speakerId.includes('SB');
                break;
              case 'subwoofer':
                matchesGroup = speakerId.toLowerCase().includes('subwoofer') || speakerId.startsWith('SW');
                break;
              case 'upper':
                matchesGroup = speakerId.includes('H') || speakerId.startsWith('T');
                break;
            }

            if (matchesGroup) {
              groupLevels.push(numLevel);
            }
          });

          if (groupLevels.length === 0) {
            return null; // No speakers found for this group
          }

          // Calculate estimated maximum capability
          // Assumption: current levels represent ~75dB reference, estimate headroom to maximum
          const avgCurrentLevel = groupLevels.reduce((sum, level) => sum + level, 0) / groupLevels.length;

          // Estimate maximum capability based on typical amplifier headroom and speaker limits
          // Professional systems typically have 20-30dB headroom above reference level
          let estimatedMaxCapability;

          if (speakerGroup.toLowerCase() === 'subwoofer') {
            // Subwoofers typically have higher capability
            estimatedMaxCapability = avgCurrentLevel + 35; // More headroom for LFE
          } else {
            // Main speakers
            estimatedMaxCapability = avgCurrentLevel + 25; // Standard headroom
          }

          // Apply room gain if available
          if (roomEstimate && roomEstimate.estimatedVolume && Number.isFinite(roomEstimate.estimatedVolume)) {
            const roomGain = Math.max(0, 3 * Math.log10(100 / roomEstimate.estimatedVolume));
            estimatedMaxCapability += roomGain;
          }

          // Apply small room boundary loading (typically 2-6dB for speakers near walls)
          if (speakerGroup.toLowerCase() !== 'subwoofer') {
            estimatedMaxCapability += 3; // Typical boundary loading gain
          }

          return Math.round(estimatedMaxCapability * 10) / 10;
        }

        // Calculate maximum angle between adjacent surround speakers
        calculateMaxAdjacentSurroundAngle(speakerAngles, surroundSpeakers) {
          if (surroundSpeakers.length < 2) return null;

          const surroundAngles = surroundSpeakers
            .map(id => speakerAngles[id]?.horizontal)
            .filter(angle => Number.isFinite(angle))
            .sort((a, b) => a - b);

          if (surroundAngles.length < 2) return null;

          let maxDifference = 0;
          for (let i = 1; i < surroundAngles.length; i++) {
            const diff = Math.abs(surroundAngles[i] - surroundAngles[i - 1]);
            maxDifference = Math.max(maxDifference, diff);
          }

          return maxDifference;
        }

        // Calculate maximum angle between adjacent upper speakers
        calculateMaxAdjacentUpperAngle(speakerAngles, upperSpeakers) {
          if (upperSpeakers.length < 2) return null;

          const upperAngles = upperSpeakers
            .map(id => speakerAngles[id]?.elevation || speakerAngles[id]?.vertical)
            .filter(angle => Number.isFinite(angle))
            .sort((a, b) => a - b);

          if (upperAngles.length < 2) return null;

          let maxDifference = 0;
          for (let i = 1; i < upperAngles.length; i++) {
            const diff = Math.abs(upperAngles[i] - upperAngles[i - 1]);
            maxDifference = Math.max(maxDifference, diff);
          }

          return maxDifference;
        }

        // Calculate wide speaker deviation from median angle
        calculateWideDeviationFromMedian(speakerAngles, wideSpeakers) {
          if (wideSpeakers.length === 0) return null;

          const wideAngles = wideSpeakers
            .map(id => Math.abs(speakerAngles[id]?.horizontal || 0))
            .filter(angle => Number.isFinite(angle));

          if (wideAngles.length === 0) return null;

          const median = wideAngles.sort((a, b) => a - b)[Math.floor(wideAngles.length / 2)];
          const maxDeviation = Math.max(...wideAngles.map(angle => Math.abs(angle - median)));

          return maxDeviation;
        }

        // Validation helper methods
        validateNumeric(value, fieldName) {
          if (value === null || value === undefined) return null;
          const num = Number(value);
          if (!Number.isFinite(num)) {
            this.addValidationError(`Invalid numeric value for ${fieldName}: ${value}`);
            return null;
          }
          return num;
        }

        validateFrequency(value) {
          if (value === null || value === undefined) return null;
          const freq = Number(value);
          if (!Number.isFinite(freq) || freq <= 0) {
            this.addValidationError(`Invalid frequency value: ${value}`);
            return null;
          }
          return freq;
        }

        validateArray(arr, fieldName) {
          if (!Array.isArray(arr)) {
            this.addValidationError(`${fieldName} is not an array`);
            return [];
          }
          return arr;
        }

        addValidationError(message) {
          this.validationErrors.push(message);
        }

        logValidationErrors() {
          if (this.validationErrors.length > 0) {
            console.log(`\n⚠️  VALIDATION WARNINGS (${this.validationErrors.length}):`);
            this.validationErrors.forEach((error, index) => {
              console.log(`   ${index + 1}. ${error}`);
            });
          }
        }

        // Precision calculation helpers
        preciseComparison(a, b, operator) {
          if (a === null || b === null) return false;
          const diff = Math.abs(a - b);
          if (diff < this.PRECISION.SPL_TOLERANCE) return operator.includes('=');

          switch (operator) {
            case '>=': return a > b;
            case '<=': return a < b;
            case '>': return a > b && diff >= this.PRECISION.SPL_TOLERANCE;
            case '<': return a < b && diff >= this.PRECISION.SPL_TOLERANCE;
            default: return false;
          }
        }

        preciseSubtraction(a, b) {
          return Math.round((a - b) * 10) / 10; // Round to 0.1 precision
        }

        // Helper methods for enhanced functionality
        calculateDiscreteSpeakerFeeds(systemData) {
          if (!systemData.commandId || !Array.isArray(systemData.commandId)) return 0;
          const mainSpeakers = systemData.commandId.filter(id => id && !id.startsWith("SW")).length;
          const hasSubwoofer = systemData.nSubs > 0 || systemData.commandId.some(id => id && id.startsWith("SW"));
          return mainSpeakers + (hasSubwoofer ? 1 : 0);
        }

        evaluateRoomRatio(ratio) {
          if (ratio >= 1.15 && ratio <= 1.45) return 'Optimal';
          if (ratio >= 1.05 && ratio <= 1.6) return 'Good';
          return 'Suboptimal';
        }

        getDefaultSystemData() {
          return {
            nSpeakers: 0, nSubs: 0, noSub: true, targetLevel: 75,
            commandId: [], discreteSpeakerFeeds: 0,
            error: "Failed to capture system data - using defaults"
          };
        }

        formatMeasuredValue(value, unit) {
          if (value === null || value === undefined) return 'N/A';
          if (typeof value === 'boolean') return value ? 'Yes' : 'No';
          if (typeof value === 'number') return `${value.toFixed(1)} ${unit}`;
          return `${value} ${unit}`;
        }

        // Enhanced parameter validation methods
        estimateBassSmoothness(bandwidth, delayRange) {
          return bandwidth >= 200 ? 2 : bandwidth >= 150 ? 3 : 4;
        }

        estimateBassConsistency(rangeValue) {
          return rangeValue >= 10 ? 2 : rangeValue >= 6 ? 3 : rangeValue >= 3 ? 4 : 5;
        }

        generateRecommendation(paramId, level, value) {
          return level >= 3 ? "Excellent performance" : "Consider improvements for higher performance levels";
        }

        // Placeholder methods for parameter-specific validators (would be fully implemented)
        validateDistanceParameter(value) { return { valid: true, value }; }
        validateSpeakerCount(value) { return { valid: true, value }; }
        validateZonalCompliance(value) { return { valid: true, value }; }
        validateSPLConsistency(value) { return { valid: true, value }; }
        validateSpeakerAngles(value) { return { valid: true, value }; }
        validateWideAlignment(value) { return { valid: true, value }; }
        validateUpfiringSpeakers(value) { return { valid: true, value }; }
        validateVerticalAngles(value) { return { valid: true, value }; }
        validateSPLCapability(value) { return { valid: true, value }; }
        validateLFECapability(value) { return { valid: true, value }; }
        validateNoiseFloor(value) { return { valid: true, value }; }
        validateFrequencyResponse(value) { return { valid: true, value }; }
        validateBassExtension(value) { return { valid: true, value }; }
        validateBassResponse(value) { return { valid: true, value }; }
        validateBassConsistency(value) { return { valid: true, value }; }
        validateReflections(value) { return { valid: true, value }; }

        // Additional helper methods
        validateSpeakerConfiguration(analysis) { return true; /* Would validate config */ }
        assessFormatCompatibility(analysis) { return null; /* Would assess format support */ }
        countOutOfZoneSpeakers(analysis, group) { return 0; /* Would count misplaced speakers */ }
        estimateBackgroundNoise(systemData, roomEstimate) { return null; /* Would estimate noise */ }
      }

      // Keep the same function name as requested
      async function runCEDIAReadOnlyAssessment() {
        const scorer = new CEDIAPerformanceScorer();
        return scorer.runReadOnlyAssessment();
      }

      // console logger > allow collapse in VSC
      function initializeConsoleLogger() {
        const logContainer = document.getElementById('logContainer');

        function scrollToBottom() {
          logContainer.scrollTop = logContainer.scrollHeight;
        }

        let lastInfoEntry = null;

        // Store original console methods
        const originalMethods = {
          warn: console.warn,
          info: console.info,
          log: console.log,
          error: console.error
        };

        console.warn = function (...args) {
          const warningMessage = args.join(' ');
          const warningEntry = `<div class="warning">${new Date().toLocaleTimeString()} [**WARNING**] ${warningMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', warningEntry);
          scrollToBottom();
          originalMethods.warn.apply(console, args);
        };

        console.info = function (...args) {
          const infoMessage = args.join(' ');
          const infoEntry = `<div class="info">${new Date().toLocaleTimeString()} [INFORMATION] ${infoMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', infoEntry);
          lastInfoEntry = logContainer.lastElementChild;
          scrollToBottom();
          originalMethods.info.apply(console, args);
        };

        console.infoUpdate = function (...args) {
          const infoMessage = args.join(' ');
          if (lastInfoEntry) {
            lastInfoEntry.innerHTML = `${new Date().toLocaleTimeString()} [INFORMATION] ${infoMessage}`;
            scrollToBottom();
          } else {
            console.info(...args);
          }
          originalMethods.info.apply(console, args);
        };

        console.log = function (...args) {
          const logMessage = args.join(' ');
          const logEntry = `<div class="log">${new Date().toLocaleTimeString()} [*IMPORTANT*] ${logMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', logEntry);
          scrollToBottom();
          originalMethods.log.apply(console, args);
        };

        console.error = function (...args) {
          const errorMessage = args.join(' ');
          const errorEntry = `<div class="error">${new Date().toLocaleTimeString()} [***ERROR***] ${errorMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', errorEntry);
          scrollToBottom();
          originalMethods.error.apply(console, args);
        };
      }
      // Initialize the console logger
      initializeConsoleLogger();
    </script>
</body>

</html>