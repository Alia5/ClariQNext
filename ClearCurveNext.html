<!DOCTYPE html>
<html lang="en" class="notranslate" translate="no">

<head>
  <meta charset="UTF-8">
  <title>ClearCurve Next - Nvexx 2025</title>
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/css/bootstrap.min.css'>
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css'>
  <link rel='stylesheet'
    href='https://cdnjs.cloudflare.com/ajax/libs/simple-line-icons/2.5.5/css/simple-line-icons.min.css'>
  <link rel="stylesheet" href="./style.css">
  <meta name="googlebot" content="notranslate" />
</head>

<body data-theme="dark">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    //ALL SETTINGS GO HERE
    const nextversion = "ClearCurve Next 0.0.3 - 13-09-2025 @ 15:56";
    // ClearCurve
    let isClearCurve = true;
    // DEFAULT
    var startFrequency = 10; // End frequency for amplitude correction filters (max. 20Khz)
    var endFrequency = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // MAINS > FRONTS
    var startFrequencyF = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyF = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // MAINS > CENTER
    var startFrequencyC = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyC = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // SURROUNDS
    var startFrequencySur = 10; // Start frequency for amplitude correction filters
    var mergeFrequencySur = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // SURROUNDS > BACK/REAR
    var startFrequencySurB = 10; // Start frequency for amplitude correction filters
    var mergeFrequencySurB = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // SURROUNDS > BACK/REAR SINGLE
    var startFrequencySurBS = 10; // Start frequency for amplitude correction filters
    var mergeFrequencySurBS = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // WIDE
    var startFrequencyFW = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyFW = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // HEIGHTS > FRONT
    var startFrequencyFH = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyFH = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // HEIGHTS > SURROUND
    var startFrequencySH = 10; // Start frequency for amplitude correction filters
    var mergeFrequencySH = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // HEIGHTS > SURROUND REAR
    var startFrequencyRH = 10; // Start frequency for amplitude correction filters (max. 20Khz)
    var mergeFrequencyRH = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // TOPS > FRONT
    var startFrequencyTF = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyTF = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // TOPS > MIDDLE
    var startFrequencyTM = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyTM = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // TOPS > REAR
    var startFrequencyTR = 10; // Start frequency for amplitude correction filters (max. 20Khz)
    var mergeFrequencyTR = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // DOLBY BOUNCE > FRONT
    var startFrequencyFD = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyFD = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // DOLBY BOUNCE > SURROUND
    var startFrequencySD = 10; // Start frequency for amplitude correction filters
    var mergeFrequencySD = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // DOLBY BOUNCE > BACK
    var startFrequencyBD = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyBD = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // AURO-3D > TOP SURROUND
    var startFrequencyTS = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyTS = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // AURO-3D > CENTER HEIGHT
    var startFrequencyCH = 10; // Start frequency for amplitude correction filters
    var mergeFrequencyCH = 272; // End frequency for amplitude correction filters (max. 20Khz)
    // SUBWOOFER SETTINGS
    // SUBWOOFER SETTINGS
    var sw1_filterfreq_merge = 250;
    var sw2_filterfreq_merge = 250;
    var sw3_filterfreq_merge = 250;
    var sw4_filterfreq_merge = 250;
    const modelsSoS300 = ["-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011", "SR6011", "C-A110", "X3700H", "X4700H", "X6500H", "X6700H",
      "X8500H", "R-A110", "-S730H", "-S740H", "-S750H", "-S760H", "-S930H", "-S940H", "-S950H", "-S960H", "X1400H", "X1500H", "X1600H",
      "X1700H", "X2400H", "X2500H", "X2600H", "X2700H", "X3400H", "X3500H", "X3600H", "X3700H", "X4300H", "X4400H", "X4500H", "X4700H",
      "X6300H", "X6400H", "X6500H", "X6700H", "X8500H", "AV7703", "AV7704", "AV7705", "AV7706", "AV8805", "NR1608", "NR1609", "NR1710",
      "NR1711", "SR5012", "SR5013", "SR5014", "SR5015", "SR6012", "SR6013", "SR6014", "SR6015", "SR7011", "SR7012", "SR7013", "SR7015",
      "SR8012", "SR8015"];
    const micCalProb = ["-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011",
      "-S730H", "-S740H", "-S750H", "-S760H", "-S930H", "-S940H", "-S950H",
      "-S960H", "X1400H", "X1500H", "X1600H", "X1700H", "X2400H", "X2500H",
      "X2600H", "X2700H", "X3400H", "X3500H", "X3600H", "NR1608", "NR1609",
      "NR1710", "NR1711", "SR5012", "SR5013", "SR5014", "SR5015", "SR6013",
      "SR6014", "-S770H", "-S970H", "X1800H", "X2800H", "EMA 60", "MA 70s"];
    const noxo180 = ["-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011", "SR6011", "X6500H", "-S730H", "-S740H", "-S930H", "-S940H",
      "X1400H", "X1500H", "X2400H", "X2500H", "X3400H", "X3500H", "X4300H", "X4400H", "X4500H", "X6300H", "X6400H", "X6500H", "AV7703",
      "AV7704", "AV7705", "NR1608", "NR1609", "SR5012", "SR5013", "SR6012", "SR6013", "SR7011", "SR7012", "SR7013", "SR8012"];
    const models70xo = ["A-900H", "MA 70S", "-S970H", "X2800H", "-S670H", " AV 10", " AV 20", "VR-A1H", "VC-A1H", "X3800H", "X4800H",
      "EMA 30", "EMA 40", "EMA 50", "X6800H", "R-A10H", "C-A10H"];

    const baseUrl = 'http://localhost:4735/measurements', retryDelay = 500;
    let adyContents, fileName, sOs, isCirrusLogic, flDist, nChannels, nSpeakers, nSubs, noCenter;
    let targetCurvePath, targetCurveName, targetResponse, noInversion = false, swInvMsg = "";
    let bassMode = "Standard", noSub = false, subLoTrim, subHiTrim, subLoDelay, subHiDelay;
    let minXO = 40, maxXO = 250, previousDelay = null, swChannelCount = 0;
    const freqIndex = [40, 60, 80, 90, 100, 110, 120, 150, 200, 250];
    const customLevel = [], customDistance = [], customCrossover = [];
    const mSec = [], invertSub = [], commandId = [];
    const m3dBPoints = {};
    let targetLevel = 75.0; // Audyssey typically calibrates to 75 dB SPL
    let isCirrusLogictargetLevel = 75.0;
    // Advanced sorting check and correction
    let needsSorting = false;
    let expectedOrder = [];
    // MODES
    let isDarkMode = true; // start script in Darkmode 
    let isDolbymode = false; // calibrationSPL: 82, peakSPL: 105, subPeakSPL: 115 
    let isTHXmode = false; // calibrationSPL: 85, peakSPL: 105, subPeakSPL: 115
    let isIMAXmode = false; // calibrationSPL: 100, peakSPL: 100, subPeakSPL: 115
    let supportsIMAX = false; // explicit IMAX support variable
    let modeSubXOMin = 31.5; // highest low of them all
    let modeSubXOMax = 120; // highest high of them all
    let modeSpkMin = 20; // lowest low.
    let modeSpkMax = 20000; // highest high.
    // Dyslexic Mode
    let isDyslexicMode = false; // DyslexicMode off by default
    // cedia specific
    let isRP22mode = false; // calibrationSPL: 'performance-based', peakSPL: 105, subPeakSPL: 115
    let RP22subnminXO;
    let RP22submaxXO;
    let RP22subrequiredDelay;
    let RP22hasAtmos;
    let RP22hasDTSX;
    let RP22hasAURO3D;
    // CREATE ARRAY TO STORE ESTIMATED PLAYBACK LEVELS
    let estimatedPlaybackLevels = [];
    // CREATE ARRAY TO STORE ESTIMATED DISTANCES
    let estimatedDistances = [];
    // CREATE ARRAY TO STORE FINAL XO'S DISTANCES 
    let RP22BestXO = [];
    // CONDENCED VERSION
    let AdvancedFilters = false;
    let AdvancedFiltersType = "null";
    // SPEED DELAY BASED ON CPU CORES LIKE BEFORE
    // Add delay based on CPU cores ("logical")
    // Don't have to set speedDelay each time anymore!
    var cores = 1;
    const getOptimalDelay = () => {
      cores = navigator.hardwareConcurrency || 1; // Fallback to 1 if undefined
      let delay;

      if (cores <= 1) {
        delay = 256;
      } else if (cores <= 2) {
        delay = 236;
      } else if (cores <= 4) {
        delay = 216;
      } else if (cores <= 8) {
        delay = 196;
      } else if (cores <= 12) {
        delay = 176;
      } else if (cores <= 16) {
        delay = 156;
      } else if (cores <= 24) {
        delay = 136;
      } else if (cores <= 32) {
        delay = 116;
      } else {
        delay = 256;
      }
      console.warn(`Detected ${cores} logical CPU core(s). Assigned delay: ${delay}ms`);
      return delay;
    };
    let speedDelay = getOptimalDelay();
    // store more AVR default values
    let lfcSupport;
    let enMultEQType;
    let auro;
    let dolbyVersion;
    let dynamicEq;
    let dynamicVolume;
    let lfc;
    let subwooferNum;
    let subwooferLayout;
    //
    let hasHeightChannel = false;
    const heightChannelIds = ["FHL", "RHL", "SHL", "TFL", "TML", "TRL", "BDL", "FDL", "SDL", "TS", "CH"];
    let isDebugMode = false;
    const delaymax = 1000.33;
    let lowFreq, highFreq; // subwoofer values!
  </script>
  <!-- partial -->
  <script src="./script.js"></script>
  <!-- partial:index.partial.html -->
  <div class="container">
    <div class="form-container">
      <div class="form-header">
        <div class="theme-toggle">
          <!--<span class="theme-label">‚òÄÔ∏è</span>-->
          <div class="toggle-switch active" id="themeToggle">
            <div class="toggle-slider">‚òÄÔ∏è</div>
          </div>
          <!--<span class="theme-label">üåô</span>-->
        </div>

        <div class="font-toggle">
          <!--<span class="theme-label">‚òÄÔ∏è</span>-->
          <div class="toggle-switch active" id="dyslexicToggle">
            <div class="toggle-slider">üî§</div>
          </div>
          <!--<span class="theme-label">üåô</span>-->
        </div>

        <h2><img src="https://www.nvexx.nl/audyssey/nvexx_128.png" class="centerimg" alt="Nvexx logo" />ClearCurve Next
        </h2>
        <!--<p class="text-muted">Your house curve generator</p>-->
        <noscript>
          <div style="color: red; padding: 10px; border: 1px solid red;">
            JavaScript is disabled in your browser. Please enable it for full functionality.
          </div>
        </noscript>
      </div>

      <div class="progress">
        <div class="progress-bar" role="progressbar" style="width: 0%"></div>
      </div>

      <div class="step-indicator">
        <div class="step-line"></div>
        <div class="step-circle active">1</div>
        <div class="step-circle">2</div>
        <div class="step-circle">3</div>
        <div class="step-circle">4</div>
        <div class="step-circle">5</div>
        <div class="step-circle">6</div>
        <div class="step-circle">7</div>
        <div class="step-circle">8</div>
        <div class="step-circle">9</div>
        <div class="step-circle">10</div>
        <div class="step-circle">11</div>
      </div>

      <form id="multiStepForm">
        <!-- Step 1: Basic settings -->
        <div class="form-step active" data-step="1">
          <h3 class="mb-4" style="display:none;">Basic settings</h3>
          <div class="mb-4" style="display:none;">
            <ul>
              <li>Sub inversion allowed</li>
              <ul>
                <li>Can or are you willing to physically change subwoofer polarity?</li>
              </ul>
            </ul>
            <ul>
              <li>Script mode</li>
              <ul>
                <li>Full auto - the script goes through each step</li>
                <li>Manual - allows you to go through each step manually. (button clicks)</li>
              </ul>
            </ul>
          </div>

          <hr style="display:none;" />
          <div class="row g-4" style="display:none;">
            <div class="col-md-4">
              <label for="radio_home_cinema">Sub inversion allowed</label><br>
              <input type="radio" id="radio_home_cinema" name="sub_inversion" value="0" required checked="checked"
                disabled>
            </div>
          </div>

          <hr style="display:none;" />
          <div class="row g-4" style="display:none;">
            <div class="col-md-4">
              <label for="radio_script_mode_auto">Fully automatic</label><br>
              <input type="radio" id="radio_script_mode_auto" name="script_mode" value="0" required checked="checked"
                disabled>
            </div>
          </div>

          <hr style="display:none;" />
          <div class="row g-4" style="display:none;">
            <h3 class="mb-4">Advanced Filters</h3>
            <div class="col-md-4">
              <label for="radio_script_af_off">Advanced Filters OFF</label><br>
              <input type="radio" id="radio_script_af_off" name="script_af" value="0" required checked="checked"
                disabled>
            </div>
          </div>

          <div class="row g-4" style="display:none;">
            <div class="col-md-4">
              <label for="script_af_type">Advanced Filters Type</label><br>
              <select name="script_af_type" id="script_af_type" disabled>
                <option value="null" selected>none</option>
                <option value="DIALOGadvanced">Advanced Dialog Enhancement - CEDIA RP22</option>
                <option value="HLOSSresearch">Hearing Loss >> Research-Based Hearing Loss Compensation (presbycusis
                  patterns)</option>
                <option value="HLOSSmoderate">Hearing Loss >> Moderate Hearing Loss Compensationmoderate (mild hearing
                  loss)</option>
                <option value="HLOSSsevere">Hearing Loss >> Severe Hearing Loss Compensation (‚ö†Ô∏èhigh gains)</option>
                <option value="HLOSSoriginal">Hearing Loss >> original / ClearCurve Next 0.0.3 values</option>
                <option value="GAMINGcompetitive">Gaming >> Competitive Gaming EQ (Footsteps & Tactical Audio)</option>
                <option value="GAMINGimmersive">Gaming >> Immersive Gaming EQ (Cinematic Experience)</option>
                <option value="GAMINGvoice">Gaming >> Voice Chat Gaming EQ (Clear Communication)</option>
                <option value="GAMINGbalanced">Gaming >> Balanced Gaming EQ (All-Purpose)</option>
              </select>
            </div>
          </div>

          <br />
          <div class="mb-4">
            <h3 class="mb-4 warning">Usage</h3>
            <ul>
              <li>Download and install the free room correction software Room EQ Wizard (v5.40
                Beta) on
                your computer
                <ul>
                  <li class="small-bullet">Download link for the latest REW Beta version: <a
                      href="https://www.avnirvana.com/threads/rew-api-beta-releases.12981/" target="_blank">here</a>
                  </li>
                </ul>
              </li>
              <li>Choose your preffered Basic settings</li>
              <li>When done click the '[.ady]' button below to go to the next step.</li>
            </ul>
          </div>
          <div class="d-flex justify-content-end mt-4">
            <button type="button" class="btn btn-primary btn-nav next-step">.ady file</button>
          </div>
        </div>

        <!-- Step 2: Professional Experience -->
        <div class="form-step" data-step="2">
          <div class="mb-4" id="BMs" style="display:none;">
            <h3 class="mb-4" style="display:none;">Basic Measurement settings</h3>
            <ul>
              <li>Measurement mode</li>
              <ul>
                <li>Home Cinema (75dB -SPL) default</li>
                <ul>
                  <li>Subwoofer 30hz - 80Hz</li>
                  <li>Speakers 20hz - 20kHz</li>
                </ul>
              </ul>
            </ul>
          </div>
          <div class="mb-4" id="adyf">
            <h3 class="mb-4">.ady file</h3>
            <ul>
              <li>upload your .ady file here</li>
              <ul>
                <li>browse to the Audyssey calibration file (.ady) generated by the MultEQ Editor (IOS/Android) app
                </li>
                <li>When prompted, download and 'save' the .zip (measurements) on your computer. Make sure the zip
                  file
                  is unblocked: right-click > properties > unblock</li>
                <li>Start REW, go to the 'EQ' / 'House Curve', and select a target curve of your choice</li>
                <li>Open the zip file and select ALL (keyboard shortcut: "CTRL+A" for Windows / "Command+A" for Mac)
                  the
                  files in that folder</li>
                <li>Left click on the selection (inside the .zip file) and drag & drop them onto REW. Wait until all
                  measurements are imported
                  and '[SPL Adjustments ‚Üí]' button is enabled</li>
              </ul>
              <li>You can also use custom measurements with ClearCurve Next!</li>
              <ul>
                <li>naming still needs to follow $0/1/2/3/4/5/6/7/8/9/10/11/12/13/14/15 etc for normal speakers</li>
                <li>naming still needs to follow SW10/11/12/13/14/15/16/17/18/19/110/111/112/113/114/115 etc for
                  subwoofers</li>
                <li>naming still needs to follow SW20/21/22/23/24/25/26/27/28/29/210/211/212/213/214/215 etc for
                  subwoofers</li>
                <li>the order in REW doesn't matter only the naming (custom sorting by ClearCurve Next)</li>
              </ul>
              <li>Merge Range Selector(s)</li>
              <ul>
                <li>once your .ady is uploaded and the measurements are loaded into REW the Merge Range Selector(s)
                  will be availble</li>
                <ul>
                  <li>Select a "preferred Merge range" from the frequency index values supported</li>
                </ul>
              </ul>
            </ul>
          </div>
          <hr />
          <div class="row g-4">
            <strong class="error" id="unlock_cinema_modes">Please upload your .ady and import your measurements into
              REW</strong>
            <div class="col-md-4" style="display:none;">
              <label for="radio_home_cinema">Home Cinema (75dB)</label><br>
              <input type="radio" id="radio_home_cinema" name="cinema_type" value="75" required checked="checked">
            </div>
          </div>

          <hr />
          <li><strong class="warning">Please keep REW on 'SPL & Phase' tab and stay on this web page until
              optimization
              is
              completed!</strong></li>
          </ul>
          <br />
          <label class="form-label" id="resumeUploadlabel" for="resumeUpload">.ady Upload</label>
          <div class="file-upload" id="resumeUpload">
            <input type="file" id="resume" class="d-none" accept=".ady">
            <div class="upload-content">
              <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor"
                class="bi bi-cloud-upload mb-3" viewBox="0 0 16 16">
                <path fill-rule="evenodd"
                  d="M4.406 1.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 2 5.166 4.579C14.758 4.804 16 6.137 16 7.773 16 9.569 14.502 11 12.687 11H10a.5.5 0 0 1 0-1h2.688C13.979 10 15 8.988 15 7.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 2.825 10.328 1 8 1a4.53 4.53 0 0 0-2.941 1.1c-.757.652-1.153 1.438-1.153 2.055v.448l-.445.049C2.064 4.805 1 5.952 1 7.318 1 8.785 2.23 10 3.781 10H6a.5.5 0 0 1 0 1H3.781C1.708 11 0 9.366 0 7.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383z" />
                <path fill-rule="evenodd"
                  d="M7.646 4.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707V14.5a.5.5 0 0 1-1 0V5.707L5.354 7.854a.5.5 0 1 1-.708-.708l3-3z" />
              </svg>
              <p class="mb-1">Drag and drop your ADY here</p>
              <p class="text-muted small">or click to browse (ADY)</p>
            </div>
          </div>

          <!-- BED LAYER Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container bed-layer" style="display:none;">
            <h4 class="mb-4">Merge Range Selector - BED LAYER</h4>
            <ul>
              <li>Select a "preferred Merge range" from the Merge index values</li>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-bed"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-bed"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-bed"></span> |
                Indices: <span id="indicesValue-bed"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-bed"></div>
              </div>
              <div class="slider-handle min" id="minHandle-bed"></div>
              <div class="slider-handle max" id="maxHandle-bed"></div>

              <div class="slider-ticks" id="sliderTicks-bed"></div>
            </div>
          </div>

          <!-- HEIGHT LAYER Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container height-layer" style="display: none;">
            <h4 class="mb-4">Merge Range Selector - HEIGHT LAYER</h4>
            <ul>
              <li>Select a "preferred Merge range" from the Merge index values</li>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-height"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-height"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-height"></span> |
                Indices: <span id="indicesValue-height"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-height"></div>
              </div>
              <div class="slider-handle min" id="minHandle-height"></div>
              <div class="slider-handle max" id="maxHandle-height"></div>

              <div class="slider-ticks" id="sliderTicks-height"></div>
            </div>
          </div>


          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">‚Üê Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">SPL Adjustments ‚Üí</button>
          </div>
        </div>

        <!-- Step 3: Portfolio & Resume -->
        <div class="form-step" data-step="3">
          <h3 class="mb-4">SPL Adjustments</h3>
          <div class="mb-4">
            <ul>
              <li>
                <span id="target-level-display">Select cinema type to see target level</span>
              </li>
              <li>Makes it easier to read in REW</li>
              <ul>
                <li>Takes into account original MJ 120dB spl offsets</li>
                <li>Takes into account original MJC 78dB spl offsets</li>
                <li>Takes into account custom measurements</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">‚Üê Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">BootUP ‚Üí</button>
          </div>
        </div>

        <!-- Step 4: Additional Information -->
        <div class="form-step" data-step="4">
          <h3 class="mb-4">Bootup</h3>
          <div class="mb-4">
            <ul>
              <li>Here we go.. Be patient!</li>
              <li>Applying Audyssey microphone calibration file to measurements if needed</li>
              <li>Resets, IR windows, EQ target shape, room curve settings and equalizer to
                'Generic/Generic' for all measurements..</li>
              <li>Checking measurement names, indices and sorting</li>
              <ul>
                <li>Custom sorting if custom measurements are not correctly sorted</li>
                <li>ClearCurve Next sorting, the standard REW A-Z sorting doesn't suffice!</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">‚Üê Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">GroundWorks ‚Üí</button>
          </div>
        </div>

        <!-- Step 5: Additional Information -->
        <div class="form-step" data-step="5">
          <h3 class="mb-4">Groundworks</h3>
          <div class="mb-4">
            <ul>
              <li>Optimizes speaker volume & time alignment</li>
              <ul>
                <li>based on #measurement count per speaker (microphone positions)</li>
              </ul>
              <li>Aligns multi-subwoofer setups</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">‚Üê Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Speaker Calibration ‚Üí</button>
          </div>
        </div>

        <!-- Step 6: Main Speaker Calibration Function -->
        <div class="form-step" data-step="6">
          <h3 class="mb-4">Speaker Calibration</h3>
          <div class="mb-4">
            <ul>
              <li>Calculates speaker(s) -3dB points against target curve</li>
              <ul>
                <li>calculates availble bandwidth</li>
                <li>sets "estimated" XO range based on available bandwidth</li>
                <ul>
                  <li>can be a bit optimisitc, can be adjusted by using the slider range</li>
                </ul>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">‚Üê Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Subwoofer Calibration ‚Üí</button>
          </div>
        </div>

        <!-- Step 7: Subwoofer(s) Calibration Function -->
        <div class="form-step" data-step="7">
          <h3 class="mb-4">Subwoofer Calibration</h3>
          <div class="mb-4">
            <ul>
              <li>Calculates subwoofer(s) -3dB points against target curve</li>
              <ul>
                <li>calculates availble bandwidth</li>
                <li>sets appropriate XO range based on available bandwidth</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">‚Üê Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Generate speaker curves ‚Üí</button>
          </div>
        </div>

        <!-- Step 8: Generate speaker curves -->
        <div class="form-step" data-step="8">
          <h3 class="mb-4">Generate Speaker Curves</h3>
          <div class="mb-4">
            <ul>
              <li>Generates speaker curves</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">‚Üê Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Generate subwoofer(s) curves ‚Üí</button>
          </div>
        </div>

        <!-- Step 9: Generate subwoofer curves -->
        <div class="form-step" data-step="9">
          <h3 class="mb-4">Generate Subwoofer curves</h3>
          <div class="mb-4">
            <ul>
              <li>Generates subwoofer(s) curves</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">‚Üê Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Generate AVG Curves
              ‚Üí</button>
          </div>
        </div>

        <!-- Step 10: Generate AVG Curves -->
        <div class="form-step" data-step="10">
          <h3 class="mb-4">Generate AVG Curves</h3>
          <div class="mb-4">
            <ul>
              <li>Generate AVG Curves</li>
              <ul>
                <li>Averaging between speaker pair(s) curves</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">‚Üê Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Finalize House Curve ‚Üí</button>
          </div>
        </div>

        <!-- Step 11: Finalize distances -->
        <div class="form-step" data-step="11">
          <h3 class="mb-4">Clean UP</h3>
          <div class="mb-4">
            <ul>
              <li>Finalize and cleaup</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">‚Üê Back</button>
          </div>
        </div>
      </form>
      <pre id="logContainer"></pre>

      <br />
      <br />
      <div class="row g-4">
        <div class="col-md-4" style="text-align: center;">
          <p>Socials:</p>
          <a href="https://ko-fi.com/nvexx" target="_blank" style="text-decoration: none;">Ko-fi <span
              class="icon-cup"></span></a>
          &nbsp;
          <a href="https://discord.com/invite/fyVzznE" target="_blank" style="text-decoration: none;">Discord
            <svg class="w-[48px] h-[48px] text-gray-800 dark:text-white" aria-hidden="true"
              xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
              <path
                d="M18.942 5.556a16.3 16.3 0 0 0-4.126-1.3 12.04 12.04 0 0 0-.529 1.1 15.175 15.175 0 0 0-4.573 0 11.586 11.586 0 0 0-.535-1.1 16.274 16.274 0 0 0-4.129 1.3 17.392 17.392 0 0 0-2.868 11.662 15.785 15.785 0 0 0 4.963 2.521c.41-.564.773-1.16 1.084-1.785a10.638 10.638 0 0 1-1.706-.83c.143-.106.283-.217.418-.331a11.664 11.664 0 0 0 10.118 0c.137.114.277.225.418.331-.544.328-1.116.606-1.71.832a12.58 12.58 0 0 0 1.084 1.785 16.46 16.46 0 0 0 5.064-2.595 17.286 17.286 0 0 0-2.973-11.59ZM8.678 14.813a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.918 1.918 0 0 1 1.8 2.047 1.929 1.929 0 0 1-1.8 2.045Zm6.644 0a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.919 1.919 0 0 1 1.8 2.047 1.93 1.93 0 0 1-1.8 2.045Z" />
            </svg>
          </a>
          &nbsp;
          <a href="https://github.com/NvexxNL/ClariQNext" target="_blank" style="text-decoration: none;">GitHub <span
              class="icon-social-github"></span></a>
        </div>

        <div class="col-md-4" style="text-align: center;">
          <a href="https://ko-fi.com/nvexx/tip" target="_blank"><img height="74" style="border: 0px; height: 74px"
              src="https://storage.ko-fi.com/cdn/brandasset/v2/support_me_on_kofi_badge_red.png"
              alt="Support me on ko-fi.com" /></a>
        </div>

        <div class="col-md-4" style="text-align: center;">
          <a href="https://open.spotify.com/playlist/0ADi7e8brgnKkzri4qfpHS"
            style="size: 48px; font-size: 48pt; color: #1db954; text-decoration: none;" target="_blank"><span
              class="icon-social-spotify"></span></a>
          <p style="color: #1db954; ">skull's Audio System Test Tracks</p>
        </div>
      </div>

    </div>

    <script>
      function extractAdy(event) {
        console.info(`Initializing ${nextversion}`);
        const file = event.target.files[0];
        fileName = file.name;
        console.info(`Audyssey calibration '${fileName}' has been uploaded!`)
        const reader = new FileReader();
        reader.onload = async function (e) {
          adyContents = e.target.result;
          const jsonData = JSON.parse(adyContents);
          let modelName = jsonData.targetModelName;
          const model = modelName.slice(-6);
          sOs = modelsSoS300.includes(model) ? 300.00 : 343.00;
          Object.freeze(sOs);
          isCirrusLogic = micCalProb.includes(model) ? true : false;
          Object.freeze(isCirrusLogic);
          if (!noxo180.includes(model)) {
            freqIndex.push(180);
          }
          if (models70xo.includes(model)) {
            freqIndex.push(70);
            supportsIMAX = true;
          }
          freqIndex.sort(function (a, b) { return a - b; });
          Object.freeze(freqIndex);
          console.log(`Speed of sound setting has been automatically adjusted for your ${modelName} at ${sOs} m/s.`);
          const hasSWChannels = jsonData.detectedChannels.some(channel => channel.commandId && channel.commandId.startsWith("SW"));
          if (!hasSWChannels) {
            console.warn("No subwoofer detected in your calibration file. Mains will be set to Large/Full Range!");
            noSub = true;
          }
          Object.freeze(noSub);
          bassMode = jsonData.subwooferMode;
          Object.freeze(bassMode);
          //
          lfcSupport = jsonData.lfcSupport;
          Object.freeze(lfcSupport);
          enMultEQType = jsonData.enMultEQType;
          Object.freeze(enMultEQType);
          auro = jsonData.auro;
          Object.freeze(auro);
          dolbyVersion = jsonData.dolbyVersion;
          Object.freeze(dolbyVersion);
          dynamicEq = jsonData.dynamicEq;
          Object.freeze(dynamicEq);
          dynamicVolume = jsonData.dynamicVolume;
          Object.freeze(dynamicVolume);
          lfc = jsonData.lfc;
          Object.freeze(lfc);
          subwooferMode = jsonData.subwooferMode;
          Object.freeze(subwooferMode);
          subwooferNum = jsonData.subwooferNum;
          Object.freeze(subwooferNum);
          subwooferLayout = jsonData.subwooferLayout;
          Object.freeze(subwooferLayout);
          //
          noCenter = true;
          subLoTrim = Infinity;
          subHiTrim = -Infinity;
          subLoDelay = Infinity;
          subHiDelay = -Infinity;

          console.info("");
          console.info("title:", jsonData.title);
          console.info("enAmpAssignType:", jsonData.enAmpAssignType);
          console.info("dynamicVolume:", jsonData.dynamicVolume);
          console.info("enTargetCurveType:", jsonData.enTargetCurveType);
          console.info("lfcSupport:", jsonData.lfcSupport);
          console.info("targetModelName:", jsonData.targetModelName);
          console.info("interfaceVersion:", jsonData.interfaceVersion);
          console.info("dynamicEq:", jsonData.dynamicEq);
          console.info("ampAssignInfo:", jsonData.ampAssignInfo);
          console.info("lfc:", jsonData.lfc);
          console.info("systemDelay:", jsonData.systemDelay);
          console.info("auro:", jsonData.auro);
          console.info("dolbyVersion:", jsonData.dolbyVersion);
          console.info("upgradeInfo:", jsonData.upgradeInfo);
          console.info("enMultEQType:", jsonData.enMultEQType);
          console.info("adcLineup:", jsonData.adcLineup);
          console.info("subwooferNum:", jsonData.subwooferNum);
          console.info("subwooferMode:", jsonData.subwooferMode);
          console.info("subwooferLayout:", jsonData.subwooferLayout);
          console.info("measurementsPerPosition:", jsonData.measurementsPerPosition);


          // console.info("detectedChannels ")
          // log the full detected channels list in one line
          console.info("detectedChannels", jsonData.detectedChannels.map(ch => ch.commandId).join(","));
          console.info("");
          jsonData.detectedChannels.forEach(channel => {

            if (channel.commandId && channel.commandId === "C") {
              noCenter = false;
            }
            if (channel.commandId && channel.commandId.startsWith("SW")) {
              swChannelCount++;
              subLoTrim = Math.min(subLoTrim, parseFloat(channel.trimAdjustment));
              subHiTrim = Math.max(subHiTrim, parseFloat(channel.trimAdjustment));
              subLoDelay = Math.min(subLoDelay, parseFloat(channel.delayAdjustment));
              subHiDelay = Math.max(subHiDelay, parseFloat(channel.delayAdjustment));
              //
              channel.midrangeCompensation = true;
              channel.frequencyRangeRolloff = 250;
              if ("customCrossover" in channel) {
                delete channel.customCrossover;
              }
              if ("customSpeakerType" in channel) {
                delete channel.customSpeakerType;
              }
              if (swChannelCount === 1) {
                channel.customTargetCurvePoints = [];
              } else {
                if ("customTargetCurvePoints" in channel) {
                  delete channel.customTargetCurvePoints;
                }
              }
            } else {
              channel.customTargetCurvePoints = [];
              channel.midrangeCompensation = false;
              channel.frequencyRangeRolloff = 20000;
            }


            if (channel.commandId && heightChannelIds.includes(channel.commandId)) {
              hasHeightChannel = true;
            }
            /*
            console.info(channel.commandId);
            console.info("customEnSpeakerConnect", channel.channelReport.customEnSpeakerConnect);
            console.info("distance", channel.channelReport.distance);
            console.info("enSpeakerConnect", channel.channelReport.enSpeakerConnect);
            console.info("isReversePolarity", channel.channelReport.isReversePolarity);
            console.info("customCrossover", channel.customCrossover);
            console.info("customDistance", channel.customDistance);
            console.info("customLevel", channel.customLevel);
            console.info("customSpeakerType", channel.customSpeakerType);
            console.info("delayAdjustment", channel.delayAdjustment);
            console.info("enChannelType", channel.enChannelType);
            console.info("frequencyRangeRolloff", channel.frequencyRangeRolloff);
            console.info("isSkipMeasurement", channel.isSkipMeasurement);
            console.info("midrangeCompensation", channel.midrangeCompensation);
            console.info("trimAdjustment", channel.trimAdjustment);
            console.info("");
            */
          });
          Object.freeze(noCenter);
          Object.freeze(swChannelCount);
          subLoTrim = -12 + Math.abs(subLoTrim);
          subHiTrim = 12 - Math.abs(subHiTrim);
          Object.freeze(subLoTrim);
          Object.freeze(subHiTrim);
          subLoDelay /= sOs;
          subHiDelay /= sOs;
          Object.freeze(subLoDelay);
          Object.freeze(subHiDelay);
          flDist = getFLDistance(jsonData.detectedChannels);
          Object.freeze(flDist);
          console.info("Speaker measurements have been extracted from the uploaded calibration file.");
          // updateCheckboxStates();
          let totalMeasurements = 0;
          const zip = new JSZip();
          const { detectedChannels } = jsonData;
          const filePromises = Object.entries(detectedChannels).map(([key, detectedChannel]) => {
            const { responseData, commandId } = detectedChannel;
            return Promise.all(Object.entries(responseData).map(([arrayKey, arrayData]) => {
              const dataString = arrayData.join('\n');
              const rewHeader = `* Impulse Response data saved by REW\n0 // Peak value before normalisation\n0 // Peak index\n16384 // Response length\n2.0833333333333333E-5 // Sample interval (seconds)\n0.0 // Start time (seconds)\n78.0 // Data offset (dB)\n* Data start\n${dataString}`;
              const measurementName = `${commandId}${arrayKey}.txt`;
              zip.file(measurementName, rewHeader);
              totalMeasurements++;
            }));
          });
          Object.freeze(totalMeasurements);
          if (isCirrusLogic) {
            zip.file("_micCal.txt", micCal);
          }
          console.log(`Please save ${fileName.substring(0, fileName.lastIndexOf('.'))}_extractedMeasurements.zip file when prompted.`);
          console.info("Checking for measurements...");
          await Promise.all(filePromises.flat());
          try {
            const content = await zip.generateAsync({ type: 'blob' });
            const urlZip = URL.createObjectURL(content);
            const downloadLink = document.createElement('a');
            downloadLink.href = urlZip;
            downloadLink.download = `${fileName.substring(0, fileName.lastIndexOf('.'))}_extractedMeasurements.zip`;
            downloadLink.style.display = 'none';
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
          } catch (error) {
            console.error('Error generating or downloading zip file:', error);
          }
          let lastValidationState = null; // Track previous validation state
          let isFirstValidation = true; // Track if this is the first validation run

          const checkMeasurementCount = async () => {
            const measurements = await fetch_mREW();
            let mCount = Object.keys(measurements).length;
            if (isCirrusLogic) (mCount--);

            // Always validate measurement names against ADY file (regardless of count)
            try {
              const expectedMeasurements = new Set();

              // Extract expected measurement names from ADY
              jsonData.detectedChannels.forEach(channel => {
                const commandId = channel.commandId;  // e.g., "FL"
                const channelIndices = Object.keys(channel.responseData); // e.g., ["0", "1", "2"]

                // Generate expected REW names: FL0, FL1, FL2
                channelIndices.forEach(index => {
                  expectedMeasurements.add(`${commandId}${index}`);
                });
              });

              // Get actual REW measurement names
              const actualMeasurements = new Set();
              for (let i = 1; i <= mCount; i++) {
                actualMeasurements.add(measurements[i].title);
              }

              // Find discrepancies
              const missing = [...expectedMeasurements].filter(name => !actualMeasurements.has(name));
              const extra = [...actualMeasurements].filter(name => !expectedMeasurements.has(name));

              // Create current validation state for comparison
              const currentValidationState = JSON.stringify({ missing, extra, mCount });

              // Show validation messages on first run OR if state changed
              if (isFirstValidation || currentValidationState !== lastValidationState) {
                console.infoUpdate("Validating REW measurements against ADY file...");

                // Report findings
                if (missing.length === 0 && extra.length === 0) {
                  console.infoUpdate("‚úì All REW measurements match ADY file expectations");
                } else {
                  if (missing.length > 0) {
                    console.warn(`‚ö† Missing measurements (expected in ADY but not in REW): ${missing.join(', ')}`);
                  }
                  if (extra.length > 0) {
                    console.warn(`‚ö† Extra measurements (in REW but not expected by ADY): ${extra.join(', ')}`);
                  }
                  console.warn("You can add/remove measurements in REW before continuing");
                }

                lastValidationState = currentValidationState;
                isFirstValidation = false;
              }

            } catch (error) {
              console.warn("Could not validate measurement names against ADY file:", error.message);
            }

            // Check if count matches for success logic
            if (mCount === totalMeasurements) {
              // Enhanced success logging with measurement names
              const importedMeasurements = [];
              for (let i = 1; i <= mCount; i++) {
                importedMeasurements.push(measurements[i].title);
              }

              // Original success logic
              // document.getElementById("button2").disabled = false;
              console.infoUpdate(`All ${isCirrusLogic ? mCount + 1 : mCount} measurements have now been successfully imported!`);
              console.infoUpdate(`Successfully imported measurements: ${importedMeasurements.join(', ')}`);

              // communicate with script.js
              window.measurementsImported = true;
              window.updateContinueButtonState();
              clearInterval(intervalId);
              // At the end of your extractAdy function, after freqIndex is populated:
              if (window.onMeasurementsImported) {
                window.onMeasurementsImported();
                document.getElementById("resumeUpload").disabled = true;
                document.getElementById("resumeUpload").style.display = "none";
                document.getElementById("resumeUploadlabel").style.display = "none";
              }
            } else {
              console.infoUpdate(`Expecting ${totalMeasurements} measurements`
                + (isCirrusLogic ? " and Audyssey microphone calibration file" : "") + ` to be imported into REW...`);
            }
          }
          const intervalId = setInterval(checkMeasurementCount, 1000);
        }
        reader.readAsText(file);
      }

      // Not needed... Find solution later
      function SetTargetlevel() {
        const selectedRadio = document.querySelector('input[name="cinema_type"]:checked');
      }

      // Not needed... Find solution later
      function SetnoInversion() {
        const selectedRadio = document.querySelector('input[name="sub_inversion"]:checked');
        if (selectedRadio.value === "1") {
          // noInversion = false; // Inversion allowed
        } else {
          // noInversion = true;  // Inversion NOT allowed
        }
      }

      /* async function CorrectSPL() */
      // Constants for better maintainability
      const SPL_OFFSETS = {
        MJC_78DB: 78,
        STANDARD_88DB: 88,
        OLD_MJ_120DB: 120
      };

      const VALID_TARGET_LEVELS = [75, 82, 85, 100];
      const DEFAULT_TARGET_LEVEL = 75;

      // Helper function to set target level based on configuration
      function setTargetLevel(targetLevel, isCirrusLogic) {
        const validLevel = VALID_TARGET_LEVELS.includes(targetLevel) ? targetLevel : DEFAULT_TARGET_LEVEL;

        // Note: The original logic sets the same value regardless of isCirrusLogic flag
        // This suggests the flag might be for future use or legacy code
        return parseFloat(validLevel);
      }

      // Helper function to handle different SPL offset types
      function handleSplOffset(splOffsetdB, measurements, targetLevel, isCirrusLogic) {
        const offset = parseFloat(splOffsetdB);

        switch (offset) {
          case SPL_OFFSETS.MJC_78DB:
            console.warn("Measurements at 78.0dB MJC");
            return setTargetLevel(targetLevel, isCirrusLogic);

          case SPL_OFFSETS.STANDARD_88DB:
            console.warn("Measurements at 88.0dB");
            return setTargetLevel(targetLevel, isCirrusLogic);

          case SPL_OFFSETS.OLD_MJ_120DB:
            // Check if this is the deprecated old MJ format
            const requiredProperties = ['timingReference', 'delay', 'timingOffset', 'signalToNoisedB'];
            const hasRequiredProperties = requiredProperties.every(prop =>
              measurements[1].hasOwnProperty(prop)
            );

            if (!hasRequiredProperties) {
              console.error("120dB measurements (old MJ) are no longer supported!");
              console.error("Please use the ZIP that came with ClearCurve Next");
              console.error("Or use custom measurements inside REW");
              throw new Error("Unsupported measurement type: 120dB old MJ format is deprecated");
            }

            return setTargetLevel(targetLevel, isCirrusLogic);

          default:
            console.warn(`Custom measurements detected. SPL offset: ${offset}dB`);
            return setTargetLevel(targetLevel, isCirrusLogic);
        }
      }

      // Helper function for setup operations
      async function performSetupOperations(speedDelay) {
        const operations = [
          { fn: clearCommands, name: "clearCommands" },
          { fn: disableBlock, name: "disableBlock" },
          { fn: enableGraph, name: "enableGraph" },
          { fn: enableBlock, name: "enableBlock" },
          { fn: disableGraph, name: "disableGraph" },
          { fn: enableGraph, name: "enableGraph" }
        ];

        for (const operation of operations) {
          await operation.fn();
          await new Promise((resolve) => setTimeout(resolve, speedDelay));
        }
      }

      // Main function - now much cleaner and focused
      async function CorrectSPL() {
        try {
          // Setup operations
          await performSetupOperations(speedDelay);

          console.log("##################");
          console.log("## CorrectSPL() ##");
          console.log("##################");

          // Fetch measurements
          const measurements = await fetch_mREW();

          // Validate measurements
          if (!measurements || !measurements[1]) {
            throw new Error("Invalid measurements data");
          }

          // Get measurement count
          const measurementIds = Object.keys(measurements).filter(key => !isNaN(key));
          console.log(`Found ${measurementIds.length} measurements to check`);

          // Process SPL offset and set target level
          const splOffsetdB = measurements[1].splOffsetdB;
          if (splOffsetdB === undefined) {
            throw new Error("SPL offset not found in measurements");
          }

          isCirrusLogictargetLevel = handleSplOffset(
            splOffsetdB,
            measurements,
            targetLevel,
            isCirrusLogic
          );

          console.log(`Target level set to: ${isCirrusLogictargetLevel}dB`);

        } catch (error) {
          console.error("Error in CorrectSPL:", error.message);

          // Handle specific error types
          if (error.message.includes("Unsupported measurement type")) {
            isAutoMode = false;
            isScriptRunning = false;
            process.exit(1);
          }

          // Re-throw other errors for higher-level handling
          throw error;
        }
      }

      function getadyName(fileName, suffix) {
        const dotIndex = fileName.lastIndexOf(".");
        const modifiedName = fileName.substring(0, dotIndex) + suffix;
        return modifiedName;
      }

      function getFLDistance(channels) {
        let flIndex = 0;
        for (let i = 0; i < channels.length; i++) {
          if (channels[i].commandId === "FL") {
            flIndex = i;
            break;
          }
        }
        let dist = parseFloat(channels[flIndex].channelReport.distance);
        if (isNaN(dist) || dist === 0) {
          dist = parseFloat(channels[flIndex].customDistance);
          if (isNaN(dist) || dist === 0 || dist === null) {
            // Try the distance property as a fallback
            dist = parseFloat(channels[flIndex].distance);
            if (isNaN(dist) || dist === 0 || dist === null) {
              console.warn(`No distance found for ${channels[flIndex].commandId}! Defaulting to 6m.`)
              console.warn(`To fix: Open ady in MultEQ phone app then -\nSpeaker Detection Results > Change any crossover > Save and then retry.`);
              dist = 6.00;
            }
          }
        }
        return dist;
      }

      async function addmicCal() {
        console.info("Applying Audyssey microphone calibration file to measurements...");
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i < mCount; i++) {
          const irWindows = await fetchSafe('ir-windows', i);
          const leftW = parseFloat(irWindows.leftWindowWidthms);
          const rightW = parseFloat(irWindows.rightWindowWidthms);
          const refTime = parseFloat(irWindows.refTimems);
          await postNext('Arithmetic', [i, mCount], { function: "A * B" });
          await postSafe(`${baseUrl}/${mCount + i}/ir-windows`, { leftWindowWidthms: leftW, rightWindowWidthms: rightW, refTimems: refTime }, "Update processed");
          const name = measurements[i].title;
          await fetch_mREW(mCount + i, 'PUT', { title: name });
        }
        for (let i = mCount; i >= 1; i--) {
          await postDelete(i);
        }
        console.infoUpdate("Completed applying Audyssey microphone calibration file to measurements.");
      }

      // Add this debugging function to help troubleshoot the user's specific environment
      async function debugUserEnvironment() {
        console.log("=== USER ENVIRONMENT DEBUG ===");

        // Check REW API connectivity and version
        try {
          const rewVersion = await fetch(`http://localhost:4735/version`);
          if (rewVersion.ok) {
            const rew = await rewVersion.json();
            console.log(`REW Version: ${rew.message}`);
          } else {
            console.error(`REW Version check failed: ${rewVersion.status}`);
          }
        } catch (error) {
          console.error("REW API connection failed:", error);
        }

        // Check what postNext function actually looks like
        console.log("postNext function type:", typeof postNext);
        if (typeof postNext === 'function') {
          console.log("postNext function source (first 200 chars):", postNext.toString().substring(0, 200));
        }

        // Check baseUrl
        console.log("baseUrl:", baseUrl);

        // Test simple REW API call
        try {
          const measurements = await fetch_mREW();
          console.log("fetch_mREW successful, measurement count:", Object.keys(measurements).length);

          // Test a simple command on measurement 1 if it exists
          if (measurements[1]) {
            console.log("Testing simple command on measurement 1...");
            const testResult = await postNext('Smooth', 1, { smoothing: "1/48" });
            console.log("Simple command test successful");
          }
        } catch (error) {
          console.error("Basic REW API test failed:", error);
        }

        console.log("=== END ENVIRONMENT DEBUG ===");
      }

      // Modified addmicCal with extensive logging but keeping original logic
      async function addmicCalDebug() {
        console.info("Applying Audyssey microphone calibration file to measurements...");

        // Add environment debug for problematic user
        await debugUserEnvironment();

        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;

        console.log(`=== MICROCAL PROCESS START ===`);
        console.log(`Total measurements: ${mCount}`);
        console.log(`isCirrusLogic: ${isCirrusLogic}`);

        // Log all measurements
        for (let j = 1; j <= mCount; j++) {
          if (measurements[j]) {
            console.log(`  Measurement ${j}: ${measurements[j].title}`);
          } else {
            console.log(`  Measurement ${j}: MISSING`);
          }
        }

        for (let i = 1; i < mCount; i++) {
          if (!measurements[i]) {
            console.warn(`Skipping missing measurement ${i}`);
            continue;
          }

          console.log(`\n--- Processing ${i}/${mCount - 1}: ${measurements[i].title} ---`);

          try {
            const irWindows = await fetchSafe('ir-windows', i);
            console.log(`IR Windows retrieved for measurement ${i}`);

            const leftW = parseFloat(irWindows.leftWindowWidthms);
            const rightW = parseFloat(irWindows.rightWindowWidthms);
            const refTime = parseFloat(irWindows.refTimems);

            console.log(`IR Settings: Left=${leftW}, Right=${rightW}, Ref=${refTime}`);

            // Log exactly what we're about to send
            console.log(`About to call: postNext('Arithmetic', [${i}, ${mCount}], { function: "A * B" })`);

            // Check measurements still exist right before the call
            const preCallCheck = await fetch_mREW();
            if (!preCallCheck[i]) {
              throw new Error(`Measurement ${i} disappeared before arithmetic!`);
            }
            if (!preCallCheck[mCount]) {
              throw new Error(`Measurement ${mCount} (micCal) disappeared before arithmetic!`);
            }

            // THE ORIGINAL CALL - unchanged from working version
            const arithmeticResult = await postNext('Arithmetic', [i, mCount], { function: "A * B" });

            console.log(`‚úì Arithmetic successful for measurement ${i}`);
            console.log(`Result:`, arithmeticResult);

            // Continue with original logic
            const resultIndex = Object.keys(arithmeticResult.results)[0];
            await postSafe(`${baseUrl}/${resultIndex}/ir-windows`, { leftWindowWidthms: leftW, rightWindowWidthms: rightW, refTimems: refTime }, "Update processed");
            const name = measurements[i].title;
            await fetch_mREW(resultIndex, 'PUT', { title: name });

            console.log(`‚úì Completed processing measurement ${i}`);

          } catch (error) {
            console.error(`‚ùå FAILED processing measurement ${i} (${measurements[i].title}):`, error);

            // Additional debugging for the failed case
            console.log("=== FAILURE DEBUG ===");
            console.log("Error type:", error.constructor.name);
            console.log("Error message:", error.message);
            console.log("Error stack:", error.stack);

            // Check if measurements still exist after failure
            try {
              const postErrorCheck = await fetch_mREW();
              console.log(`Post-error measurement ${i} exists:`, !!postErrorCheck[i]);
              console.log(`Post-error measurement ${mCount} exists:`, !!postErrorCheck[mCount]);
            } catch (checkError) {
              console.log("Could not check measurements after error:", checkError);
            }

            throw error; // Re-throw to maintain original behavior
          }
        }

        console.log("\n=== CLEANUP PHASE ===");
        for (let i = mCount; i >= 1; i--) {
          console.log(`Deleting measurement ${i}`);
          await postDelete(i);
        }
        console.infoUpdate("Completed applying Audyssey microphone calibration file to measurements.");
      }

      // Fallback version that skips microcal if it fails > Not needed anymore.... Clean later
      async function addmicCalWithSkipOption() {
        try {
          // Try the original addmicCal first
          await addmicCalDebug();
        } catch (error) {
          console.error("‚ùå Microphone calibration failed:", error);

          // Ask user if they want to continue without microcal
          const skipMicCal = confirm(
            "Microphone calibration failed. This might be due to a REW version compatibility issue.\n\n" +
            "Would you like to continue WITHOUT microphone calibration?\n\n" +
            "(Click OK to skip microcal and continue, or Cancel to stop)"
          );

          if (skipMicCal) {
            console.warn("üö® USER CHOSE TO SKIP MICROPHONE CALIBRATION");

            // Remove the microcal measurement to prevent issues later
            const measurements = await fetch_mREW();
            const mCount = Object.keys(measurements).length;

            if (measurements[mCount] && measurements[mCount].title.includes("micCal")) {
              console.log("Removing microphone calibration measurement...");
              await postDelete(mCount);
              console.log("‚úì Microphone calibration measurement removed");
            }

            console.warn("‚ö†Ô∏è Continuing without microphone calibration - results may be less accurate");
            return; // Continue execution
          } else {
            console.error("User chose to stop due to microcal failure");
            throw error; // Re-throw to stop execution
          }
        }
      }

      async function enableRoomCurve() {
        await postSafe(`http://localhost:4735/eq/default-room-curve-settings`, {
          addRoomCurve: true, lowFreqRiseStartHz: 630, lowFreqRiseEndHz: 100, lowFreqRiseSlopedBPerOctave: 0.8,
          highFreqFallStartHz: 630, highFreqFallSlopedBPerOctave: 0.8
        }, "Update processed");
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i <= mCount; i++) {
          await postSafe(`${baseUrl}/${i}/room-curve-settings`, {
            addRoomCurve: true, lowFreqRiseStartHz: 630, lowFreqRiseEndHz: 100, lowFreqRiseSlopedBPerOctave: 0.8,
            highFreqFallStartHz: 630, highFreqFallSlopedBPerOctave: 0.8
          }, "Update processed");
        }
      }

      async function disableRoomCurve() {
        await postSafe(`http://localhost:4735/eq/default-room-curve-settings`, { addRoomCurve: false }, "Update processed");
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i <= mCount; i++) {
          await postSafe(`${baseUrl}/${i}/room-curve-settings`, { addRoomCurve: false }, "Update processed");
        }
      }

      function logCustomizations() {
        console.info(`****************************************************************************************************`);
        console.log("Optimization parameters:")
        if (targetCurveName === "") {
          console.info("  No target curve - 'ClearCurve Next' - will EQ to a gentle downward slope & enable Dynamic EQ.");
        } else {
          console.info(`  Active target curve: ${targetCurveName}.`);
        }

        if (targetLevel == 75) {
          console.info(`  Target level set to ${targetLevel}dB`);
        } else {
          console.warn(`  Target level set to ${targetLevel}dB`);
        }

        if (isRP22mode == true || isRP22mode == 1) {
          console.warn(`  CEDIA RP22 mode set to ${isRP22mode}`);
        }

        if (isDolbymode == true || isDolbymode == 1) {
          console.warn(`  DOLBY mode set to ${isDolbymode}`);
        }

        if (isTHXmode == true || isTHXmode == 1) {
          console.warn(`  THX mode set to ${isTHXmode}`);
        }

        if (isIMAXmode == true || isIMAXmode == 1) {
          console.warn(`  IMAX mode set to ${isIMAXmode}`);
        }

        if (freqIndex.includes(180)) {
          console.info("  AVR supports 180Hz");
        }
        if (freqIndex.includes(70)) {
          console.info("  AVR supports IMAX 70Hz");
        }

        if (noInversion) {
          console.warn(`  Subwoofer polarity inversion allowed: No.`);
        } else {
          console.info(`  Subwoofer polarity inversion allowed: Yes.`);
        }

        if (AdvancedFilters == true || AdvancedFilters == 1) {
          console.warn(`  Advanced Filters: ${AdvancedFilters}`);
        } else {
          console.info(`  Advanced Filters: ${AdvancedFilters}`);
        }

        if (AdvancedFilters == true && AdvancedFiltersType == "null") {
          console.info(`  Advanced Filters Type: none`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "DIALOGadvanced") {
          console.warn(`  Advanced Filters Type: Advanced Dialog Enhancement CEDIA RP22`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSresearch") {
          console.warn(`  Advanced Filters Type: Research-Based Hearing Loss Compensation`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSmoderate") {
          console.warn(`  Advanced Filters Type: Moderate Hearing Loss Compensation`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSsevere") {
          console.warn(`  Advanced Filters Type: Severe Hearing Loss Compensation`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSoriginal") {
          console.warn(`  Advanced Filters Type: Original 0.0.3 Hearing Loss Compensation`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGcompetitive") {
          console.warn(`  Advanced Filters Type: Competitive Gaming EQ (Footsteps & Tactical Audio)`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGimmersive") {
          console.warn(`  Advanced Filters Type: Immersive Gaming EQ (Cinematic Experience)`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGvoice") {
          console.warn(`  Advanced Filters Type: Voice Chat Gaming EQ (Clear Communication)`);

        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGbalanced") {
          console.infwarno(`  Advanced Filters Type: Balanced Gaming EQ (All-Purpose)`);
        }

        if (needsSorting) {
          console.warn(`  Measurements are custom sorted`);
        } else {
          console.info(`  Measurements are default sorted`);
        }
        console.info(`  Version: ${nextversion}`)
        console.info(`****************************************************************************************************`);
      }

      async function bootUp() {
        console.info("Resetting IR windows, equalizer & target settings for all measurements");
        const measurements = await fetch_mREW();
        const titles = {}; let titleIndices = {};
        let mCount = Object.keys(measurements).length;

        console.info(`Starting processing of ${mCount} measurements...`);
        for (let q = 1; q <= mCount; q++) {
          console.infoUpdate(`Counting measurement ${q} of ${mCount}`);
        }

        if (mCount > 100) {
          console.warn(`large amount of measurements found ${mCount} REW may seem unresponsive for some time`)
          console.warn(`Please be patient`)
        }

        if (!mCount) { console.error(`There are no measurements in REW!`); throw new Error; }

        // NEW: Identify and store mic calibration measurements before processing
        let micCalMeasurements = [];
        let actualMCount = mCount;

        for (let i = 1; i <= mCount; i++) {
          if (measurements[i].title.startsWith('_micCal')) {
            micCalMeasurements.push({
              index: i,
              title: measurements[i].title,
              data: measurements[i]
            });
            actualMCount--;
          }
        }

        // Use actualMCount for processing (excluding mic cal)
        if (isCirrusLogic) { actualMCount--; };

        let baseMessage = "Resetting IR windows, EQ type, target shape and smoothing for all measurements..."

        // Reset settings for ALL measurements (including mic cal)
        for (let q = 1; q <= mCount; q++) {
          await postSafe(`${baseUrl}/${q}/ir-windows`, { leftWindowType: "Rectangular", rightWindowType: "Rectangular" }, "Update processed");
          await new Promise((resolve) => setTimeout(resolve, speedDelay / 3));
          await postSafe(`${baseUrl}/${q}/equaliser`, { manufacturer: "Generic", model: "Generic" }, "Equaliser selected");
          await new Promise((resolve) => setTimeout(resolve, speedDelay / 3));
          await postSafe(`${baseUrl}/${q}/target-settings`, { shape: "None" }, "Update processed");
          await new Promise((resolve) => setTimeout(resolve, speedDelay / 3));
          await postNext('Smooth', q, { smoothing: "1/48" });
          await new Promise((resolve) => setTimeout(resolve, speedDelay / 3));
          console.infoUpdate(`${baseMessage} (${q}/${mCount})`);
        }

        await console.infoUpdate("Resetting default equalizer to 'Generic/Generic'...");
        await postSafe(`http://localhost:4735/eq/default-equaliser`, { manufacturer: "Generic", model: "Generic" }, "Default equaliser changed");
        await new Promise((resolve) => setTimeout(resolve, speedDelay / 3));

        await console.infoUpdate(`Resetting default target level to ${targetLevel}dB...`);
        await fetch("http://localhost:4735/eq/default-target-level", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: Number(targetLevel).toFixed(1),
        });
        await new Promise((resolve) => setTimeout(resolve, speedDelay / 3));

        const firstTitle = measurements[1].title;
        console.infoUpdate(`Checking measurement names, indices and sorting...`);

        // MODIFIED: Build titleIndices excluding mic calibration measurements
        for (let i = 1; i <= mCount; i++) {
          const title = measurements[i].title;

          // Skip mic calibration measurements for sorting logic
          if (title.startsWith('_micCal')) {
            continue;
          }

          const titleKey = title.replace(/\d+/g, '');
          if (!/^\D+(\d+)?$/.test(titleKey)) {
            console.error(`Speaker name ${titleKey} does not end with a numeric index.`);
            throw new Error;
          }
          if (!titles[titleKey]) {
            titles[titleKey] = true;
            titleIndices[titleKey] = [];
          }
          const matchResult = title.match(/\d+/);
          if (matchResult && matchResult.length > 0) {
            titleIndices[titleKey].push(parseInt(matchResult[0]));
          } else {
            console.error(`No indices found in speaker name: ${title}`);
            throw new Error;
          }
        }

        // Build expected order: regular speakers first, then subwoofers (mic cal will be handled separately)
        const regularGroups = Object.keys(titleIndices).filter(key => !key.startsWith('SW')).sort();
        const swGroups = Object.keys(titleIndices).filter(key => key.startsWith('SW')).sort();

        for (const groupKey of [...regularGroups, ...swGroups]) {
          for (const index of titleIndices[groupKey].sort((a, b) => a - b)) {
            expectedOrder.push(groupKey + index);
          }
        }

        // MODIFIED: Check if current REW order matches expected order (excluding mic cal)
        let currentOrderWithoutMicCal = [];
        for (let i = 1; i <= mCount; i++) {
          if (!measurements[i].title.startsWith('_micCal')) {
            currentOrderWithoutMicCal.push(measurements[i].title);
          }
        }

        for (let i = 0; i < expectedOrder.length; i++) {
          if (currentOrderWithoutMicCal[i] !== expectedOrder[i]) {
            needsSorting = true;
            console.info(`Order mismatch at position ${i + 1}: found "${currentOrderWithoutMicCal[i]}", expected "${expectedOrder[i]}"`);
            break;
          }
        }

        if (needsSorting) {
          console.infoUpdate("Measurements need reordering. Performing manual sort for proper numeric ordering...");
          disableGraph();
          try {
            // Get current measurements
            const currentMeasurements = await fetch_mREW();
            const currentMCount = Object.keys(currentMeasurements).length;

            // MODIFIED: Separate mic cal measurements from regular measurements
            const regularMeasurements = [];
            const micCalMeasurementsForSorting = [];

            for (let i = 1; i <= currentMCount; i++) {
              const name = currentMeasurements[i].title;
              if (name.startsWith('_micCal')) {
                micCalMeasurementsForSorting.push({
                  originalIndex: i,
                  name: name,
                  index: 999999 // Ensure mic cal sorts last
                });
              } else {
                regularMeasurements.push({
                  originalIndex: i,
                  name: name
                });
              }
            }

            // Parse regular measurements and group them
            const measurementGroups = {};
            for (const measurement of regularMeasurements) {
              const name = measurement.name;
              const titleKey = name.replace(/\d+/g, '');
              const matchResult = name.match(/\d+/);
              if (matchResult && matchResult.length > 0) {
                const groupKey = titleKey;
                const index = parseInt(matchResult[0]);

                if (!measurementGroups[groupKey]) {
                  measurementGroups[groupKey] = [];
                }
                measurementGroups[groupKey].push({
                  originalIndex: measurement.originalIndex,
                  name: name,
                  index: index
                });
              } else {
                console.error(`No indices found in speaker name: ${name}`);
                throw new Error;
              }
            }

            // Sort each group numerically by index
            const sortedGroups = {};
            for (const groupKey in measurementGroups) {
              sortedGroups[groupKey] = measurementGroups[groupKey].sort((a, b) => a.index - b.index);
            }

            // Determine copy order: regular speakers first, then SW groups, then mic cal
            const copyOrder = [];
            const regularGroups = Object.keys(sortedGroups).filter(key => !key.startsWith('SW')).sort();
            const swGroups = Object.keys(sortedGroups).filter(key => key.startsWith('SW')).sort();

            // Add regular and SW measurements
            for (const groupKey of [...regularGroups, ...swGroups]) {
              copyOrder.push(...sortedGroups[groupKey]);
            }

            // MODIFIED: Add mic cal measurements at the end
            copyOrder.push(...micCalMeasurementsForSorting);

            console.infoUpdate(`Copying ${copyOrder.length} measurements in correct numeric order...`);

            // Copy all measurements in the correct order
            for (let i = 0; i < copyOrder.length; i++) {
              const measurement = copyOrder[i];
              await postSafe(`http://localhost:4735/measurements/${measurement.originalIndex}/command`, { command: "Response copy" }, "Completed");
              await new Promise((resolve) => setTimeout(resolve, speedDelay || 100));
              console.infoUpdate(`Copying measurements... (${i + 1}/${copyOrder.length})`);
            }

            console.infoUpdate("Removing original measurements...");

            // Delete all original measurements (backwards to avoid index shifting)
            for (let i = currentMCount; i >= 1; i--) {
              await postDelete(i);
              await new Promise((resolve) => setTimeout(resolve, speedDelay || 100));
              console.infoUpdate(`Removing original measurements... (${currentMCount - i + 1}/${currentMCount})`);
            }

            console.infoUpdate("Renaming copied measurements to remove '-copy' suffixes...");

            // Re-fetch to get the remaining measurements (all should be -copy versions now)
            const copiedMeasurements = await fetch_mREW();
            const newMCount = Object.keys(copiedMeasurements).length;

            // Rename all measurements that have "-copy" suffix
            for (let q = 1; q <= newMCount; q++) {
              const name = copiedMeasurements[q].title;
              if (name.endsWith("-copy")) {
                const newname = name.replace(/-copy/gim, "");
                const requestOptions = {
                  method: "PUT",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ title: newname }),
                };
                await fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
                await new Promise((resolve) => setTimeout(resolve, speedDelay || 100));
                console.infoUpdate(`Renaming measurements... (${q}/${newMCount})`);
              }
            }

            console.infoUpdate("ClearCurve Next sorting completed. Mic calibration preserved at end.");

            // Re-fetch and rebuild measurement data
            const sortedMeasurements = await fetch_mREW();
            mCount = Object.keys(sortedMeasurements).length;

            // Recalculate actualMCount after sorting
            actualMCount = mCount;
            for (let i = 1; i <= mCount; i++) {
              if (sortedMeasurements[i].title.startsWith('_micCal')) {
                actualMCount--;
              }
            }
            if (isCirrusLogic) { actualMCount--; };

            // Clear and rebuild the titles and indices with sorted data (excluding mic cal)
            Object.keys(titles).forEach(key => delete titles[key]);
            Object.keys(titleIndices).forEach(key => delete titleIndices[key]);

            for (let i = 1; i <= mCount; i++) {
              const title = sortedMeasurements[i].title;

              // Skip mic calibration measurements
              if (title.startsWith('_micCal')) {
                continue;
              }

              const titleKey = title.replace(/\d+/g, '');

              if (!titles[titleKey]) {
                titles[titleKey] = true;
                titleIndices[titleKey] = [];
              }

              const matchResult = title.match(/\d+/);
              if (matchResult && matchResult.length > 0) {
                titleIndices[titleKey].push(parseInt(matchResult[0]));
              }
            };

            console.infoUpdate("ClearCurve Next sorting and re-indexing completed successfully.");
            enableGraph();

          } catch (error) {
            console.error("Failed to perform ClearCurve Next sorting:", error);
            console.error("Please report your issue on discord!");
            throw new Error;
          }
        }

        // Continue with rest of original logic using actualMCount
        nSpeakers = 0;
        nSubs = 0;
        for (const titleKey in titleIndices) {
          const indices = titleIndices[titleKey];
          if (indices[0] != Math.min(...indices)) {
            console.error(`MLP measurement needs to be the first measurement for ${titleKey} channel!`);
            throw new Error;
          }
          if (titleKey === "SWMIX") {
            nSubs = 1;
          }
          else if (titleKey.startsWith("SW")) {
            for (let i = 0; i < titleIndices[titleKey].length; i++) {
              swIdx = String(titleIndices[titleKey][i]);
              if (swIdx.length === 2 && swIdx.endsWith("0")) {
                nSubs++;
              }
            }
          }
          else {
            nSpeakers++;
          }
        }
        Object.freeze(nSpeakers);
        Object.freeze(nSubs);
        nChannels = Object.keys(titles).length;
        Object.freeze(nChannels);
        const rewVersion = await fetch(`http://localhost:4735/version`);
        if (rewVersion.ok) {
          const rew = await rewVersion.json();
          console.infoUpdate(`Integrity checks completed successfully. Running Room EQ Wizard version ${rew.message}`);
        }
        else {
          console.error('There seems to be a problem with REW installation!');
          throw new Error;
        }

        // only apply if all sanity checks pass
        if (isCirrusLogic) {
          try {
            await addmicCal();
          } catch (error) {
            console.error("Microphone calibration failed:", error);
            const skipMicCal = confirm("Microphone calibration failed. Continue without it?");
            if (skipMicCal) {
              // Remove microcal measurement and continue
              const measurements = await fetch_mREW();
              const mCount = Object.keys(measurements).length;
              await postDelete(mCount);
              console.warn("Continuing without microphone calibration");
            } else {
              throw error;
            }
          }
        }

        const tcResponse = await fetch('http://localhost:4735/eq/house-curve');
        if (tcResponse.ok) {
          const target = await tcResponse.json();
          targetCurvePath = String(target);
          if (target && targetCurvePath) {
            targetCurveName = targetCurvePath.replace(/^.*[\\/]/, '').split(".")[0];
            Object.freeze(targetCurveName);
            Object.freeze(targetCurvePath);
            await disableRoomCurve();
            await postSafe(`http://localhost:4735/eq/house-curve`, targetCurvePath, "House curve set");
          }
          else {
            targetCurveName = "";
            await enableRoomCurve();
          }
          await fetchSafe('target-level', 1, targetLevel)
          const targetCurve = await postNext('Generate target measurement', 1);
          const targetCurveIdx = Object.keys(targetCurve.results)[0];
          targetResponse = await fetchSafe(`frequency-response?smoothing=1%2F48&ppo=96`, targetCurveIdx);

          if (isDebugMode) {
            console.log("=== TARGET CURVE SPL DEBUG ===");
            const targetArray200to2000 = response2array(targetResponse, 200, 2000);
            const targetSPL200to2000 = targetArray200to2000.reduce((acc, val) => acc + val, 0) / targetArray200to2000.length;
            console.log(`Target curve average SPL (200-2000Hz): ${targetSPL200to2000.toFixed(1)}dB`);

            const targetArray30to80 = response2array(targetResponse, 30, 80);
            const targetSPL30to80 = targetArray30to80.reduce((acc, val) => acc + val, 0) / targetArray30to80.length;
            console.log(`Target curve average SPL (30-80Hz): ${targetSPL30to80.toFixed(1)}dB`);

            console.log(`Target level setting: ${targetLevel}dB`);
            console.log("=== END TARGET CURVE DEBUG ===");
          }

          Object.freeze(targetResponse);
          await postDelete(targetCurveIdx);
        }
        else {
          console.error(`Failed to fetch target curve, please make sure to have started REW API server! HTTP status code: ${tcResponse.status}.`);
          throw new Error;
        }
        const indicesCounts = Object.values(titleIndices).map(indices => indices.length);
        const isIndicesEqual = indicesCounts.every(count => count === indicesCounts[0]);
        if (!isIndicesEqual) {
          const problemG = [];
          for (const [titleKey, indices] of Object.entries(titleIndices)) {
            if (indices.length !== indicesCounts[0]) {
              problemG.push(titleKey);
            }
          }
          if (problemG.some(group => group.startsWith('SW')) && bassMode === "Directional") {
            console.info(`'Directional bass' mode with '${nSubs}' subwoofers detected!`);
          } else {
            console.error('Speaker names have different numbers of indices.');
            throw new Error();
          }
        }
        logCustomizations();
        return;
      }

      function getDelayHeadroom(startIdx, endIdx) {
        const minM = Math.min(...mSec.slice(startIdx, endIdx + 1));
        const maxM = Math.max(...mSec.slice(startIdx, endIdx + 1));
        const limInsec = 6 / sOs;
        const msecMin = maxM - limInsec;
        const msecMax = minM + limInsec;
        const maxNegative = msecMin * delaymax;
        const maxPositive = msecMax * delaymax;
        if (maxNegative > maxPositive) {
          console.error("Ran out of delay range!");
          throw new Error;
        }
        return [maxNegative, maxPositive];
      }

      // returns range that "thisDelay" can be shifted by
      function getDelayRangeOf(thisDelay, startIdx, endIdx) {
        const [maxNegative, maxPositive] = getDelayHeadroom(startIdx, endIdx);
        const delayms = thisDelay * delaymax;
        const loDelay = maxNegative - delayms;
        const hiDelay = maxPositive - delayms;
        if (loDelay > hiDelay) {
          console.error("Ran out of delay range!");
          throw new Error;
        }
        return [loDelay, hiDelay];
      }

      function getDelayRangeOfFinalSub() {
        let [loDelay, hiDelay] = getDelayRangeOf(mSec[nChannels], 1, nSpeakers);
        // directional subwoofer delay(s)
        if (bassMode === "Directional") {
          const loDelaySub = Math.min(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          const hiDelaySub = Math.max(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          [loDelay,] = getDelayRangeOf(loDelaySub, 1, nSpeakers);
          [, hiDelay] = getDelayRangeOf(hiDelaySub, 1, nSpeakers);
        }
        // standard bass relative delay(s)
        else if (subLoDelay != 0 || subHiDelay != 0) {
          [loDelay,] = getDelayRangeOf(mSec[nChannels] + subLoDelay, 1, nSpeakers);
          [, hiDelay] = getDelayRangeOf(mSec[nChannels] + subHiDelay, 1, nSpeakers);
        }
        if (loDelay > hiDelay) {
          console.error("Ran out of delay range!");
          throw new Error;
        }
        return [loDelay, hiDelay];
      }

      async function groundWorks() {
        let measurements = await fetch_mREW();
        let mCount = Object.keys(measurements).length;
        const micPositions = mCount / (nSpeakers + nSubs);

        if (bassMode != "Directional" && swChannelCount > 1) {
          bassMode = "Standard";
          console.info(`'Standard bass' mode with '${swChannelCount}' subwoofers detected.`);
        }

        if (bassMode != "Directional" && swChannelCount === 1) {
          bassMode = "Standard";
          console.info(`'Standard bass' mode with '${swChannelCount}' subwoofer detected.`);
        }

        console.log(`Optimizing speaker volume & time alignment using <${micPositions}> different microphone positions...`);
        console.info(`Starting...`);
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        let count = 1;
        let title = {};
        for (let i = 1; i <= mCount; i += micPositions) {
          console.infoUpdate(`Computing optimal spatial averaging configuration for speaker #${(i - 1) / micPositions + 1}`)
          const indices = Array.from({ length: micPositions }, (_, j) => i + j);

          console.info(`üìç Processing microphone positions: indices [${indices.join(', ')}]`)

          if (micPositions > 1) {
            console.info(`üîÑ Cross-correlating ${micPositions} microphone positions...`);
            await postNext('Cross corr align', indices);
            console.log(`‚úÖ Cross-correlation alignment completed`);
          }
          mSec[count] = 0;
          title[count] = measurements[i].title.slice(0, -1) + "o";
          console.info(`üéØ Calculating trim for MLP (Main Listening Position) - Index ${i}`)
          if (title[count].startsWith("SW")) {
            console.info(`MLP (Main Listening Position) measurement for: ${title[count]}`);
            customLevel[count] = await getSubTrim(i);
          } else {
            console.info(`MLP (Main Listening Position) measurement: ${title[count]}`);
            customLevel[count] = await getSpeakerTrim(i);
          }
          console.info(`üìä MLP trim result: ${customLevel[count]}dB`);
          if (micPositions === 1) {
            console.info(`üìã Single microphone position - copying measurement`);
            await postSafe(`${baseUrl}/${i}/command`, { command: "Response copy" }, "Completed"); // nothing to average
          } else {
            console.info(`üßÆ Averaging ${micPositions} microphone positions...`);
            await postNext('Magn plus phase average', indices); // do not use VA, it reduces SPL!
            console.info(`‚úÖ Spatial averaging completed for ${micPositions} positions`);
          }
          // the "o" measurement
          const idx = mCount + count;
          await fetch_mREW(idx, 'PUT', { title: title[count] });

          console.info(`üìù Created averaged measurement: Index ${idx} - "${title[count]}"`);
          console.info(`üéØ Calculating trim for averaged result - Index ${idx}`);
          // o vs target curve
          const volAdjust = title[count].startsWith("SW") ? await getSubTrim(idx) : await getSpeakerTrim(idx);
          console.info(`üìä Averaged trim result: ${volAdjust}dB`);

          await postNext('Add SPL offset', idx, { offset: volAdjust });
          console.info(`üîß Applied ${volAdjust}dB SPL offset to averaged measurement`);
          console.info(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
          // go to next channel
          count++;
        }

        console.infoUpdate("Deleting processed measurements...");
        for (let i = mCount; i >= 1; i--) {
          await postDelete(i);
        }
        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          commandId[i] = title[i].slice(0, -1);
        }
        console.infoUpdate("Time aligning speakers...");
        // align speakers but leave subwoofers alone. ANY align command messes up subwoofer IR alignment
        const spIndices = Array.from({ length: nSpeakers }, (_, j) => j + 1);
        await postNext('Time align', spIndices);
        measurements = await fetch_mREW();
        // calculate audyssey IR start delay
        let totalIRShift = 0;
        for (let i = 1; i <= nSpeakers; i++) {
          totalIRShift += parseFloat(measurements[i].cumulativeIRShiftSeconds);
        }
        // determine relative delays and remove audyssey IR start delay
        const IRStartDelay = totalIRShift / nSpeakers;
        for (let i = 1; i <= nSpeakers; i++) {
          mSec[i] -= (parseFloat(measurements[i].cumulativeIRShiftSeconds) - IRStartDelay);
        }

        // Normalize Trim levels targetLevel vs 75dB
        normalizeTrimLevels();

        console.infoUpdate("Completed averaging, volume & time alignment!");
        // no need to go further without subwoofer
        if (noSub) { return; }
        // remove audyssey IR start delay from subwoofers
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          await postNext('Offset t=0', i, { offset: IRStartDelay, unit: "seconds" });
        }
        if (bassMode === "Directional") {
          console.warn("Your system will now be converted to 'standard bass' mode for a better sound experience...");
          await directional2standard();
          console.warn("Conversion from 'directional bass' mode to 'standard bass' mode completed.")
        }
        else {
          // normalize standard bass subwoofer median IR to t=0
          const IROffset = (subLoDelay + subHiDelay) / 2;
          await postNext('Offset t=0', nChannels, { offset: IROffset, unit: "seconds" });
          mSec[nChannels] -= IROffset;
        }
        // align final subwoofer median IR to median IR of speakers
        // note: this ensures min/max delays are negative/positive, otherwise REW crashes
        const loSPDelay = Math.min(...mSec.slice(1, nSpeakers + 1));
        const hiSPDelay = Math.max(...mSec.slice(1, nSpeakers + 1));
        const medianSPDelay = (loSPDelay + hiSPDelay) / 2;
        await postNext('Offset t=0', nChannels, { offset: -medianSPDelay, unit: "seconds" });
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          mSec[i] += medianSPDelay;
        }
        // done with groundworks and log
        const [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        console.info(`Available bass system volume adjustment range ‚Üí { ${subLoTrim}dB : ${subHiTrim}dB }`);
        console.info(`Total subwoofer 'delay headroom' available ‚Üí ${(hiDelay - loDelay).toFixed(2)}ms`);
        const dynamicBassFilldB = await getDynamicBassFill(nChannels);
        if (dynamicBassFilldB != 0) {
          console.warn(`***Adding ${dynamicBassFilldB}dB dynamic bass fill to compensate for dips!***`);
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += dynamicBassFilldB;
            console.info(`${commandId[i].padStart(3, ".")} - shifted: ${customLevel[i] - dynamicBassFilldB}dB ‚Üí ${customLevel[i]}dB`);
          }
          await postNext('Add SPL offset', nChannels, { offset: dynamicBassFilldB });
        }
      }

      async function getALOffset(idx, isSub) {
        const fltResponse = await fetchSafe('frequency-response?smoothing=1%2F1&ppo=96', idx);
        // let lowFreq, highFreq;
        if (isRP22mode) {
          lowFreq = 20; highFreq = 120;
        } else if (isDolbymode) {
          lowFreq = 31.5; highFreq = 120;
        } else if (isTHXmode) {
          lowFreq = 20; highFreq = 120;
        } else if (isIMAXmode) {
          lowFreq = 20; highFreq = 70;
        } else {
          lowFreq = 30; highFreq = 80;
        }
        const fltArray = isSub ? await response2array(fltResponse, lowFreq, highFreq) : await response2array(fltResponse, 500, 2000);
        const offset = fltArray.reduce((acc, val) => acc + val, 0) / fltArray.length;
        return offset;
      }

      // ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì
      // PROPRIETARY FILTER GENERATION AND CHECKING ! 
      // CAN NOT BE USED WITHOUT EXPLICIT PERMISSION OF NVEXX !
      // ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì
      async function generateFilters() {
        console.log(`Generating min. phase EQ filters...`);

        // ===== FILTER CONFIGURATION =====
        // Set these variables to enable different filter types:
        // Hearing loss compensation: "research", "moderate", "severe", "original", or null
        // const hearingLossType = "research";
        // Gaming EQ optimization: "competitive", "immersive", "voice", "balanced", or null  
        // - "competitive": Optimized for footsteps, gunshots, tactical audio (FPS games)
        // - "immersive": Cinematic experience with enhanced atmosphere (RPG/Adventure) 
        // - "voice": Clear voice chat communication with game audio
        // - "balanced": All-purpose gaming enhancement
        // const gamingEQType = "competitive";
        // Dialog enhancement: controlled by existing RP22DialogEnhancementFilter boolean
        // Disabled all HP as the filters get messed up!

        // Smart filter creation helper - handles REW API parameter requirements
        const createREWFilter = (index, type, frequency, gaindB = 0, q = 1.0) => ({
          index,
          type,
          enabled: true,
          isAuto: false,
          frequency,
          ...(type !== "HP" && { gaindB }), // All except HP have gaindB
          ...(type === "PK" && { q })        // Only PK filters have q
        });

        const getAdvancedFilters = (type) => {
          switch (type) {
            case "DIALOGadvanced":
              return {
                filters: [
                  createREWFilter(16, "PK", 1600, 2.5, 1.2),   // Peak speech intelligibility
                  createREWFilter(17, "PK", 3000, 3.0, 1.5),   // Critical consonant clarity
                  createREWFilter(18, "PK", 800, 1.5, 0.8),    // Speech warmth and body
                  createREWFilter(19, "PK", 4500, 2.0, 1.8),   // Upper consonant definition
                  createREWFilter(20, "HS", 5000, -1.0)        // Sibilance control
                ],
                description: "Advanced Dialog Enhancement CEDIA RP22",
                targets: [
                  "- 800Hz: +1.5dB (Speech warmth and body)",
                  "- 1.6kHz: +2.5dB (Peak speech intelligibility",
                  "- 3kHz: +3.0dB (Critical consonant clarity)",
                  "- 4.5kHz: +2.0dB (Upper consonant definition)",
                  "- 5kHz+: -1.0dB (Sibilance control)"
                ]
              };


            case "HLOSSresearch":
              return {
                filters: [
                  createREWFilter(11, "PK", 2000, 2.0, 1.0),   // Presbycusis difficulty onset
                  createREWFilter(12, "PK", 4000, 4.0, 1.2),   // Critical consonant clarity
                  createREWFilter(13, "PK", 6000, 6.0, 1.5),   // Major presbycusis loss frequency  
                  createREWFilter(14, "HS", 8000, 4.0)         // High-frequency presbycusis
                ],
                description: "Research-Based Hearing Loss Compensation",
                targets: [
                  "- 2kHz: +2.0dB (Presbycusis difficulty onset)",
                  "- 4kHz: +4.0dB (Critical consonant clarity)",
                  "- 6kHz: +6.0dB (Major presbycusis loss frequency)",
                  "- 8kHz+: +4.0dB (High-frequency compensation)"
                ]
              };

            case "HLOSSmoderate":
              return {
                filters: [
                  // createREWFilter(11, "HP", 80),               // Remove low-frequency masking
                  createREWFilter(12, "PK", 2500, 3.0, 1.0),   // Speech intelligibility range
                  createREWFilter(13, "PK", 4000, 5.0, 1.3),   // 4kHz notch compensation
                  createREWFilter(14, "HS", 6000, 3.0)         // General high-frequency lift
                ],
                description: "Moderate Hearing Loss Compensation",
                targets: [
                  // "- 80Hz: High-pass filter (remove masking)",
                  "- 2.5kHz: +3.0dB (Speech intelligibility)",
                  "- 4kHz: +5.0dB (Notch compensation)",
                  "- 6kHz+: +3.0dB (High-frequency lift)"
                ]
              };

            case "HLOSSsevere":
              return {
                filters: [
                  // createREWFilter(11, "HP", 100),              // Aggressive low-cut
                  createREWFilter(12, "PK", 2000, 6.0, 1.0),   // Strong speech boost
                  createREWFilter(13, "PK", 4000, 10.0, 1.5),  // Maximum 4kHz compensation
                  createREWFilter(14, "PK", 6000, 12.0, 1.5),  // Strong 6kHz boost
                  createREWFilter(15, "HS", 8000, 8.0)         // Aggressive high-frequency
                ],
                description: "Severe Hearing Loss Compensation",
                targets: [
                  // "- 100Hz: High-pass filter (aggressive low-cut)",
                  "- 2kHz: +6.0dB (Strong speech boost)",
                  "- 4kHz: +10.0dB (Maximum compensation)",
                  "- 6kHz: +12.0dB (Strong high-frequency boost)",
                  "- 8kHz+: +8.0dB (Aggressive compensation)"
                ]
              };

            case "HLOSSoriginal":
              return {
                filters: [
                  createREWFilter(11, "PK", 1000, 1.5, 0.9),   // Speech body and presence
                  createREWFilter(12, "PK", 2500, 3.0, 1.2),   // Consonant intelligibility
                  createREWFilter(13, "PK", 4000, 4.0, 1.5),   // High consonant clarity boost
                  createREWFilter(14, "PK", 6000, 3.0, 1.8),   // Upper speech and sibilant detail
                  createREWFilter(15, "HS", 8000, 2.0)         // High frequency audibility
                ],
                description: "Original 0.0.3 Hearing Loss Compensation",
                targets: [
                  "- 1kHz: +1.5dB (Speech body and presence)",
                  "- 2.5kHz: +3.0dB (Consonant intelligibility)",
                  "- 4kHz: +4.0dB (High consonant clarity boost)",
                  "- 6kHz: +3.0dB (Upper speech and sibilant detail)",
                  "- 8kHz+: +2.0dB (High frequency audibility)"
                ]
              };

            case "GAMINGcompetitive":
              return {
                filters: [
                  // createREWFilter(5, "HP", 60),            // Remove low-frequency rumble
                  createREWFilter(6, "PK", 400, -2.0, 1.0),   // Reduce muddiness that masks footsteps
                  createREWFilter(7, "PK", 2000, 3.0, 1.2),   // Boost footstep frequency range
                  createREWFilter(8, "PK", 4000, 4.0, 1.5),   // Critical footstep/gunshot clarity
                  createREWFilter(9, "PK", 8000, 3.0, 1.8),   // High-frequency tactical sounds
                  createREWFilter(10, "HS", 10000, 2.0)       // Enhance detail/positioning cues
                ],
                description: "Competitive Gaming EQ (Footsteps & Tactical Audio)",
                targets: [
                  // "- 60Hz: High-pass (remove rumble that masks footsteps)",
                  "- 400Hz: -2.0dB (reduce muddiness)",
                  "- 2kHz: +3.0dB (footstep detection range)",
                  "- 4kHz: +4.0dB (critical footsteps & gunshots)",
                  "- 8kHz: +3.0dB (tactical audio positioning)",
                  "- 10kHz+: +2.0dB (detail & directional cues)"
                ]
              };

            case "GAMINGimmersive":
              return {
                filters: [
                  createREWFilter(5, "PK", 80, 2.0, 0.8),     // Enhanced bass for explosions/atmosphere
                  createREWFilter(6, "PK", 200, 3.0, 1.0),    // Low-mid warmth and impact
                  createREWFilter(7, "PK", 1000, 1.0, 0.9),   // Balanced mid-range
                  createREWFilter(8, "PK", 3000, 2.0, 1.2),   // Speech and effects clarity
                  createREWFilter(9, "PK", 6000, 1.5, 1.5),   // Detail without harshness
                  createREWFilter(10, "HS", 8000, 1.0)        // Subtle air and openness
                ],
                description: "Immersive Gaming EQ (Cinematic Experience)",
                targets: [
                  "- 80Hz: +2.0dB (bass impact for explosions)",
                  "- 200Hz: +3.0dB (warmth and atmosphere)",
                  "- 1kHz: +1.0dB (balanced mid-range)",
                  "- 3kHz: +2.0dB (speech and effects clarity)",
                  "- 6kHz: +1.5dB (detail without fatigue)",
                  "- 8kHz+: +1.0dB (subtle air and space)"
                ]
              };

            case "GAMINGvoice":
              return {
                filters: [
                  // createREWFilter(5, "HP", 100),           // Remove low-frequency noise
                  createREWFilter(6, "PK", 300, -1.0, 1.0),   // Reduce boom in voice
                  createREWFilter(7, "PK", 1500, 3.0, 1.0),   // Core voice intelligibility
                  createREWFilter(8, "PK", 3000, 4.0, 1.5),   // Voice clarity and consonants
                  createREWFilter(9, "PK", 5000, 2.0, 2.0),   // Voice presence without sibilance
                  createREWFilter(10, "HS", 8000, -1.0)       // Reduce harshness
                ],
                description: "Voice Chat Gaming EQ (Clear Communication)",
                targets: [
                  // "- 100Hz: High-pass (remove voice noise)",
                  "- 300Hz: -1.0dB (reduce voice boom)",
                  "- 1.5kHz: +3.0dB (core voice intelligibility)",
                  "- 3kHz: +4.0dB (voice clarity & consonants)",
                  "- 5kHz: +2.0dB (presence without sibilance)",
                  "- 8kHz+: -1.0dB (reduce harshness)"
                ]
              };

            case "GAMINGbalanced":
              return {
                filters: [
                  // createREWFilter(5, "HP", 40),            // Gentle low-cut
                  createREWFilter(6, "PK", 150, 1.0, 0.8),    // Subtle bass enhancement
                  createREWFilter(7, "PK", 1000, 1.5, 1.0),   // Mid-range presence
                  createREWFilter(8, "PK", 3000, 2.0, 1.3),   // Speech/effects balance
                  createREWFilter(9, "PK", 6000, 1.5, 1.5),   // Detail and clarity
                  createREWFilter(10, "HS", 10000, 1.0)       // Subtle high-end extension
                ],
                description: "Balanced Gaming EQ (All-Purpose)",
                targets: [
                  // "- 40Hz: High-pass (gentle low-cut)",
                  "- 150Hz: +1.0dB (subtle bass enhancement)",
                  "- 1kHz: +1.5dB (mid-range presence)",
                  "- 3kHz: +2.0dB (speech & effects balance)",
                  "- 6kHz: +1.5dB (detail and clarity)",
                  "- 10kHz+: +1.0dB (subtle high-end)"
                ]
              };

            default:
              return null;
          }
        };

        for (let i = 1; i <= nChannels; i++) {
          console.info(`${commandId[i].padStart(3, ".")} - equalizing channel...`);
          const isSub = commandId[i].startsWith("SW");
          // FIXED: Set target level directly - no pre-compensation
          // Target curve alignment will happen naturally through EQ matching
          //
          // await fetchSafe('target-level', i, targetLevel);
          /* Commit f594500 */
          const tcLevelOffset = isSub ? 0 : await getTCTrim(i, 200, 2000);
          await fetchSafe('target-level', i, targetLevel - tcLevelOffset);
          /* Commit f594500 */
          await postNext('Smooth', i, { smoothing: "Var" });
          await postSafe(`${baseUrl}/${i}/target-settings`, {
            shape: isSub ? "Subwoofer" : "Full range",
            lowFreqCutoffHz: (isSub && m3dBPoints[i][0] === 10) ? 0 : m3dBPoints[i][0],
            lowFreqSlopedBPerOctave: 48, // steep slope to EQ without effect and keep REW happy
            bassManagementCutoffHz: (isSub && m3dBPoints[i][1] === 320) ? 20000 : m3dBPoints[i][1],
            bassManagementSlopedBPerOctave: 48 // steep slope to EQ without effect and keep REW happy
          }, "Update processed");

          await postSafe(`http://localhost:4735/eq/match-target-settings`, {
            startFrequency: m3dBPoints[i][0],
            endFrequency: m3dBPoints[i][1],
            // endFrequency: isSub ? 250 : 19000,
            // individualMaxBoostdB: isSub ? 6 : 3,
            // overallMaxBoostdB: isSub ? 3 : 0,
            individualMaxBoostdB: isSub ? 3 : 3,
            overallMaxBoostdB: isSub ? 0 : 0,
            flatnessTargetdB: 1,
            allowNarrowFiltersBelow200Hz: true,
            varyQAbove200Hz: false,
            allowLowShelf: isSub,
            lowShelfMin: -6,
            lowShelfMax: 6,
            allowHighShelf: !isSub,
            highShelfMin: -6,
            highShelfMax: 6
          }, "Update processed");

          try {
            await postNext('Match target', i);
          }
          catch (error) {
            // not really an issue if it fails
            console.debug(`${commandId[i]} could not be equalized!`);
          }

          // SANITY CHECK: Ensure no filters exceed +3dB boost or -10dB cut limits
          try {
            const filters = await getFilters(i);
            const violations = sanityCheck(filters);
            if (violations) {
              const boostViolations = violations.filter(v => v.currentGain > 3).length;
              const cutViolations = violations.filter(v => v.currentGain < -10).length;

              if (boostViolations && cutViolations) {
                console.warn(`${commandId[i]} - Fixed ${boostViolations} boost and ${cutViolations} cut filter violations`);
              } else if (boostViolations) {
                console.warn(`${commandId[i]} - Fixed ${boostViolations} filter(s) exceeding +3dB boost limit`);
              } else {
                console.warn(`${commandId[i]} - Fixed ${cutViolations} filter(s) exceeding -10dB cut limit`);
              }

              await updateFilters(i, violations);
            }
          }
          catch (error) {
            console.debug(`${commandId[i]} - Sanity check failed:`, error);
          }

          // Apply Advanced Filters (if enabled, has a type other than null and is not subwoofer) 
          if (AdvancedFilters && AdvancedFiltersType !== "null" && commandId[i] !== "SW" && commandId[i] !== "SW1" && commandId[i] !== "SWMIX") {
            // For DIALOGadvanced, ONLY apply to center channel
            if (AdvancedFiltersType === "DIALOGadvanced") {
              if (commandId[i] === "C") {
                // Apply DIALOGadvanced filter to center channel
                const AdvanedFiltersConfig = getAdvancedFilters(AdvancedFiltersType);

                if (AdvanedFiltersConfig) {
                  console.log(`APPLYING ${AdvanedFiltersConfig.description} to:`, commandId[i]);
                  console.info("Advanced Filter Optimization Targets:");

                  // Apply filters sequentially with delays
                  for (let j = 0; j < AdvanedFiltersConfig.filters.length; j++) {
                    await postSafe(`${baseUrl}/${i}/filters`, {
                      filters: [AdvanedFiltersConfig.filters[j]]
                    }, "Filters set");
                    await new Promise((resolve) => setTimeout(resolve, speedDelay / 2));
                  }

                  // Log all targets
                  AdvanedFiltersConfig.targets.forEach(target => console.info(target));

                  console.log(`${AdvanedFiltersConfig.description} applied successfully to:`, commandId[i]);
                }
              }
              // If not center channel, do nothing (skip)
            } else {
              // For all other filter types, apply to all non-subwoofer channels
              const AdvanedFiltersConfig = getAdvancedFilters(AdvancedFiltersType);

              if (AdvanedFiltersConfig) {
                console.log(`APPLYING ${AdvanedFiltersConfig.description} to:`, commandId[i]);
                console.info("Advanced Filter Optimization Targets:");

                // Apply filters sequentially with delays
                for (let j = 0; j < AdvanedFiltersConfig.filters.length; j++) {
                  await postSafe(`${baseUrl}/${i}/filters`, {
                    filters: [AdvanedFiltersConfig.filters[j]]
                  }, "Filters set");
                  await new Promise((resolve) => setTimeout(resolve, speedDelay / 2));
                }

                // Log all targets
                AdvanedFiltersConfig.targets.forEach(target => console.info(target));

                console.log(`${AdvanedFiltersConfig.description} applied successfully to:`, commandId[i]);
              }
            }
          }

          // generate filters & auto level it
          const filter = await postNext('Generate filters measurement', i);
          const filterIdx = Object.keys(filter.results)[0];
          const filterName = `${commandId[i]}-filters`;
          await fetch_mREW(filterIdx, 'PUT', { title: filterName });

          // FIXED: Only calculate and apply auto-level offset (no tcLevelOffset)
          const ALOffset = await getALOffset(filterIdx, isSub);

          if (isDebugMode) {
            console.log(`=== AUTO-LEVEL DEBUG for ${commandId[i]} ===`);
            console.log(`Auto-level offset calculated: ${ALOffset.toFixed(2)}dB`);
            console.log(`This will be SUBTRACTED from the filter response`);
          }

          // Apply auto-level compensation to filter
          await postNext('Add SPL offset', filterIdx, { offset: -ALOffset });

          // generate predicted equalized response using the auto leveled filter
          const eqResponse = await postNext('Arithmetic', [i, filterIdx], { function: "A * B" });
          const eqResponseIdx = Object.keys(eqResponse.results)[0];
          const eqResponseName = `${commandId[i]}-equalized`;
          await fetch_mREW(eqResponseIdx, 'PUT', { title: eqResponseName });

          // FIXED: Only apply auto-level offset (rounded to nearest 0.5dB)
          // let logUpdate = `${commandId[i].padStart(3, ".")} - equalized`;   
          // const trimOffset = Math.round(ALOffset * 2) / 2; //round to nearest 0.5
          /* Commit f594500 */
          let logUpdate = `${commandId[i].padStart(3, ".")} - equalized`;
          const trimOffset = tcLevelOffset + Math.round(ALOffset * 2) / 2; //round to nearest 0.5
          /* Commit f594500 */

          if (trimOffset != 0) {
            // Apply offset to equalized response for consistency
            await postNext('Add SPL offset', eqResponseIdx, { offset: trimOffset });

            // Update custom levels to reflect the change
            const customLevelOriginal = customLevel[i];
            if (isSub) {
              for (let j = nSpeakers + 1; j <= nSpeakers + nSubs; j++) {
                customLevel[j] += trimOffset;
              }
            }
            else {
              customLevel[i] += trimOffset;
            }
            logUpdate += ` | auto-level offset: ${customLevelOriginal}dB ‚Üí ${customLevel[i]}dB (${trimOffset}dB)`;

            if (isDebugMode) {
              console.log(`=== TRIM OFFSET DEBUG for ${commandId[i]} ===`);
              console.log(`Auto-level offset: ${ALOffset.toFixed(2)}dB`);
              console.log(`Rounded trim offset applied: ${trimOffset.toFixed(2)}dB`);
              console.log(`customLevel change: ${customLevelOriginal.toFixed(1)}dB ‚Üí ${customLevel[i].toFixed(1)}dB`);
            }
          }
          console.infoUpdate(logUpdate);
        }

        // clean up EQ params
        for (let i = nChannels + 1; i <= nChannels * 3; i++) {
          await postSafe(`${baseUrl}/${i}/target-settings`, { shape: "None" }, "Update processed");
        }
      }

      async function getFilters(measurementId) {
        const response = await fetch(`http://localhost:4735/measurements/${measurementId}/filters`, {
          method: 'GET',
          headers: { 'accept': 'application/json' }
        });
        return await response.json();
      }

      function sanityCheck(filters) {
        const violations = [];

        // Header logging
        console.log(`üîç VALIDATING REW-GENERATED FILTERS...`);
        console.log(`üìä Found ${filters.length} REW-generated filters to validate:`);

        filters.forEach(filter => {
          if (filter.hasOwnProperty('gaindB')) {

            // Build detailed filter description
            let filterDesc = `Filter ${filter.index}: ${filter.type}`;

            if (filter.frequency) {
              filterDesc += ` at ${filter.frequency.toFixed(2)}Hz`;
            }

            filterDesc += `, Gain: ${filter.gaindB.toFixed(1)}dB`;

            if (filter.q && filter.type === "PK") {
              filterDesc += `, Q: ${filter.q.toFixed(1)}`;
            }

            // Log the detailed filter info
            console.info(`   ${filterDesc}`);

            let violation = null;
            const originalGain = filter.gaindB;

            if (filter.gaindB > 3) {
              violation = 'BOOST';
              filter.gaindB = 3;
            } else if (filter.gaindB < -10) {
              violation = 'CUT';
              filter.gaindB = -10;
            }

            if (violation) {
              // REW API constraint: HS filters cannot be set to auto
              if (filter.type === "HS") {
                filter.isAuto = false;
              }
              console.warn(`*** ${violation} VIOLATION FOUND: Filter ${filter.index} corrected to ${filter.gaindB}dB`);
              violations.push({
                index: filter.index,
                currentGain: originalGain,  // ‚Üê Use original violating value
                filter: filter
              });
            }
          }
        });

        console.log(`Total violations found: ${violations.length}`);
        return violations.length > 0 ? violations : null;
      }

      async function updateFilters(measurementId, violations) {
        // Update only the filters that had violations
        for (const violation of violations) {
          const response = await fetch(`http://localhost:4735/measurements/${measurementId}/filters`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'accept': 'application/json'
            },
            body: JSON.stringify(violation.filter)  // Send single filter object directly
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`PUT failed: ${response.status} - ${errorText}`);
          }

          const result = await response.json();
          console.log(`Filter ${violation.filter.index} updated:`, result.message);
        }
      }
      // ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë
      // PROPRIETARY FILTER GENERATION AND CHECKING ! 
      // CAN NOT BE USED WITHOUT EXPLICIT PERMISSION OF NVEXX !
      // ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë

      function finalizeTrims() {
        if (isDebugMode) {
          console.log("=== FINAL TRIMS DEBUG ===");
          console.log("Raw customLevel values BEFORE sanity check:");
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            console.log(`  ${commandId[i]}: ${customLevel[i].toFixed(1)}dB`);
          }
        }
        // console.log("DEBUG!!!! Raw customLevel values before sanity check:", customLevel.slice(1, nSpeakers + nSubs + 1));
        // console.log("These look like absolute SPL measurements (sound pressure level readings), not relative trim adjustments!")
        sanityCheckSpeakerTrims();
        console.log("Final speaker" + (noSub ? "" : " & subwoofer") + " trims:")
        for (let i = 1; i <= nSpeakers; i++) {
          const customLevelOriginal = customLevel[i];
          customLevel[i] = Math.max(-12, customLevel[i]);
          customLevel[i] = Math.min(customLevel[i], 12);
          if (customLevelOriginal != customLevel[i]) {
            console.warn(`${commandId[i].padStart(3, ".")} required volume adjustment beyond hardware limits - shifted: ${customLevelOriginal}dB ‚Üí ${customLevel[i]}dB`);
          }
          else {
            console.info(`${commandId[i].padStart(3, ".")} - applied adjustment: ${customLevel[i]}dB`);
          }
        }
        if (noSub) { return; } // no need to go further without subwoofer
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          const customLevelOriginal = customLevel[i];
          customLevel[i] = Math.max(subLoTrim, customLevel[i]);
          customLevel[i] = Math.min(customLevel[i], subHiTrim);
          if (customLevelOriginal != customLevel[i]) {
            console.warn(`${commandId[i].padStart(3, ".")} required volume adjustment beyond hardware limits - shifted: ${customLevelOriginal}dB ‚Üí ${customLevel[i]}dB`);
          }
          else {
            console.info(`${commandId[i].padStart(3, ".")} - applied adjustment: ${customLevel[i]}dB`);
          }
        }
      }

      function sanityCheckSpeakerTrims() {
        // if a speaker is too sensitive or not sensitive enough, it may end up outside +/-12dB
        const minSpeakerTrim = Math.min(...customLevel.slice(1, nSpeakers + 1));
        const maxSpeakerTrim = Math.max(...customLevel.slice(1, nSpeakers + 1));
        let offset = 0;
        if (minSpeakerTrim < -12 && maxSpeakerTrim < 12) {
          const requiredOffset = -12 - minSpeakerTrim;
          offset = Math.min(requiredOffset, 12 - maxSpeakerTrim); // limited by maxSpeakerTrim
        }
        else if (maxSpeakerTrim > 12 && minSpeakerTrim > -12) {
          const requiredOffset = 12 - maxSpeakerTrim;
          offset = Math.max(requiredOffset, -12 - minSpeakerTrim); // limited by minSpeakerTrim
        }
        if (offset != 0) {
          console.warn(`Trims are being shifted by ${offset}dB to best stay within hardware limits!`)
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += offset;
          }
        }
      }

      function isSingleChannel(channelCmdId) {
        if (channelCmdId.endsWith("L") && commandId.includes(channelCmdId.slice(0, -1) + "R")) { return false; } // L and R
        if (channelCmdId.endsWith("R") && commandId.includes(channelCmdId.slice(0, -1) + "L")) { return false; } // R and L
        if (channelCmdId.includes("L") && commandId.includes(channelCmdId.replace("L", "R"))) { return false; } // edge case for SLA/SRA type cmdIds
        if (channelCmdId.includes("R") && commandId.includes(channelCmdId.replace("R", "L"))) { return false; } // where L/R is in the middle
        return true;
      }

      function findNearestXO(freq) {
        let xo = Infinity;
        let minDelta = Infinity;
        for (let i = 0; i < freqIndex.length; i++) {
          const delta = Math.abs(freqIndex[i] - freq);
          if (delta < minDelta) {
            minDelta = delta;
            xo = freqIndex[i];
          }
        }
        return xo;
      }

      // CURVE!!
      async function getLow3dBPoint(idx, start = 10, end = 320) {
        // const response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
        let response;
        if (isRP22mode == true) {
          response = await fetchSafe('frequency-response?smoothing=1/3&ppo=96', idx);
          console.info("getLow3dBPoint: applying CEDIA RP22 - 1/3 smoothing");
        } else {
          response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
          // response = await fetchSafe('frequency-response?smoothing=1/2&ppo=96', idx);
          console.info("getLow3dBPoint: applying Default - Psy smoothing");
        }
        const rpArray = response2array(response, start, end);
        const tcArray = response2array(targetResponse, start, end);
        const arrLength = Math.min(rpArray.length, tcArray.length);
        const octave = Math.pow(2, 1 / 96);

        // find -3dB point
        let rolloff = start;
        for (let i = 0; i < arrLength; i++) {
          if ((rpArray[i] - tcArray[i]) >= -3) { break; }
          rolloff *= octave;
        }

        if (isDebugMode) {
          // ADD THIS ABSOLUTE LEVEL CHECK HERE ‚Üì
          console.log("=== ABSOLUTE LEVEL CHECK ===");

          // Find speaker's actual peak level in measurement range
          let maxLevel = -Infinity;
          let maxLevelFreq = start;
          for (let i = 0; i < rpArray.length; i++) {
            if (rpArray[i] > maxLevel) {
              maxLevel = rpArray[i];
              maxLevelFreq = start * Math.pow(octave, i);
            }
          }

          // Find true -3dB rolloff from speaker's own maximum
          let absoluteRolloff = start;
          for (let i = 0; i < rpArray.length; i++) {
            // True -3dB from speaker's own maximum, not target-relative
            if ((rpArray[i] - maxLevel) >= -3) { break; }
            absoluteRolloff *= octave;
          }

          console.log(`Speaker peak: ${maxLevel.toFixed(1)}dB at ${maxLevelFreq.toFixed(1)}Hz`);
          console.log(`Target-relative rolloff: ${rolloff.toFixed(1)}Hz`);
          console.log(`Absolute -3dB rolloff: ${absoluteRolloff.toFixed(1)}Hz`);

          // Audioholics reality check
          if (rolloff < 40) {
            console.warn(`‚ö†Ô∏è  ${rolloff.toFixed(1)}Hz rolloff detected - likely room gain effect`);
            console.warn("   Audioholics recommends ground plane measurements for true speaker response");
          }

          if (Math.abs(rolloff - absoluteRolloff) > 20) {
            console.warn(`‚ö†Ô∏è  Large difference between target-relative (${rolloff.toFixed(1)}Hz) and absolute (${absoluteRolloff.toFixed(1)}Hz) rolloffs`);
            console.warn("   This suggests target curve issues or room acoustics effects");
          }

          console.log("=== END ABSOLUTE LEVEL CHECK ===");
          // END ADDITION ‚Üë
        }
        return Math.min(rolloff, end);
      }

      // CURVE!!
      async function getHigh3dBPoint(idx, start = 10, end = 320) {
        // const response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
        let response;
        if (isRP22mode == true) {
          response = await fetchSafe('frequency-response?smoothing=1/3&ppo=96', idx);
          console.info("getHigh3dBPoint: applying CEDIA RP22 - 1/3 smoothing");
        } else {
          response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
          // response = await fetchSafe('frequency-response?smoothing=1/2&ppo=96', idx);
          console.info("getHigh3dBPoint: applying Default - Psy smoothing");
        }
        const rpArray = response2array(response, start, end);
        const tcArray = response2array(targetResponse, start, end);
        const arrLength = Math.min(rpArray.length, tcArray.length);
        const octave = Math.pow(2, 1 / 96);
        // find -3dB point
        let rolloff = end;
        for (let i = arrLength - 1; i >= 0; i--) {
          if ((rpArray[i] - tcArray[i]) >= -3) { break; }
          rolloff /= octave;
        }

        if (isDebugMode) {
          // ADD THIS ABSOLUTE LEVEL CHECK HERE ‚Üì
          console.log("=== ABSOLUTE LEVEL CHECK ===");

          // Find speaker's actual peak level in measurement range
          let maxLevel = -Infinity;
          let maxLevelFreq = start;
          for (let i = 0; i < rpArray.length; i++) {
            if (rpArray[i] > maxLevel) {
              maxLevel = rpArray[i];
              maxLevelFreq = start * Math.pow(octave, i);
            }
          }

          // Find true -3dB rolloff from speaker's own maximum
          let absoluteRolloff = start;
          for (let i = 0; i < rpArray.length; i++) {
            // True -3dB from speaker's own maximum, not target-relative
            if ((rpArray[i] - maxLevel) >= -3) { break; }
            absoluteRolloff *= octave;
          }

          console.log(`Speaker peak: ${maxLevel.toFixed(1)}dB at ${maxLevelFreq.toFixed(1)}Hz`);
          console.log(`Target-relative rolloff: ${rolloff.toFixed(1)}Hz`);
          console.log(`Absolute -3dB rolloff: ${absoluteRolloff.toFixed(1)}Hz`);

          // Audioholics reality check
          if (rolloff < 40) {
            console.warn(`‚ö†Ô∏è  ${rolloff.toFixed(1)}Hz rolloff detected - likely room gain effect`);
            console.warn("   Audioholics recommends ground plane measurements for true speaker response");
          }

          if (Math.abs(rolloff - absoluteRolloff) > 20) {
            console.warn(`‚ö†Ô∏è  Large difference between target-relative (${rolloff.toFixed(1)}Hz) and absolute (${absoluteRolloff.toFixed(1)}Hz) rolloffs`);
            console.warn("   This suggests target curve issues or room acoustics effects");
          }

          console.log("=== END ABSOLUTE LEVEL CHECK ===");
          // END ADDITION ‚Üë
        }

        return Math.max(rolloff, start);
      }

      // let modeSubXOMin = 31.5; let modeSubXOMax = 120;
      async function getAbsLow3dBPointForSub(idx, start = 10, end = 300) {
        // finds low -3dB point from mean SPL between 30-80hz
        const response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
        // const response = await fetchSafe('frequency-response?smoothing=1/2&ppo=96', idx);
        // const subArray = response2array(response, 30, 80);
        // const subArray = response2array(response, 15, 200);
        const subArray = response2array(response, modeSubXOMin - 10, modeSubXOMax + 10);
        const subSPL = subArray.reduce((acc, val) => acc + val, 0) / subArray.length;
        const rpArray = response2array(response, start, end);
        const octave = Math.pow(2, 1 / 96);
        let rolloff = start;
        for (let i = 0; i < rpArray.length; i++) {
          if ((rpArray[i] - subSPL) >= -3) { break; }
          rolloff *= octave;
        }
        return Math.min(rolloff, end);
      }

      // let modeSubXOMin = 31.5; let modeSubXOMax = 120;
      async function getAbsHigh3dBPointForSub(idx, start = 10, end = 300) {
        // finds high -3dB point from mean SPL between 30-80hz
        const response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
        // const response = await fetchSafe('frequency-response?smoothing=1/2&ppo=96', idx);
        // const subArray = response2array(response, 30, 80);
        // const subArray = response2array(response, 15, 200);
        const subArray = response2array(response, modeSubXOMin - 10, modeSubXOMax + 10);
        const subSPL = subArray.reduce((acc, val) => acc + val, 0) / subArray.length;
        const rpArray = response2array(response, start, end);
        const octave = Math.pow(2, 1 / 96);
        let rolloff = end;
        for (let i = rpArray.length - 1; i >= 0; i--) {
          if ((rpArray[i] - subSPL) >= -3) { break; }
          rolloff /= octave;
        }
        return Math.max(rolloff, start);
      }

      // let modeSpkMin = 20; let modeSpkMax = 20000;
      // async function getAbsLow3dBPointForSpk(idx, start = 20, end = 20000) {
      async function getAbsLow3dBPointForSpk(idx, start = modeSpkMin, end = modeSpkMax) {
        // finds low -3dB point from mean SPL in speaker's optimal midrange
        const response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
        // const response = await fetchSafe('frequency-response?smoothing=1/2&ppo=96', idx);

        // Use midrange reference band for speakers (not bass range like subs)
        const refArray = response2array(response, 500, 2000);  // Speaker midrange reference
        const refSPL = refArray.reduce((acc, val) => acc + val, 0) / refArray.length;

        const rpArray = response2array(response, start, end);
        const octave = Math.pow(2, 1 / 96);
        let rolloff = start;

        for (let i = 0; i < rpArray.length; i++) {
          if ((rpArray[i] - refSPL) >= -3) { break; }
          rolloff *= octave;
        }
        return Math.min(rolloff, end);
      }

      // let modeSpkMin = 20; let modeSpkMax = 20000;
      // async function getAbsHigh3dBPointForSpk(idx, start = 20, end = 20000) {
      async function getAbsHigh3dBPointForSpk(idx, start = modeSpkMin, end = modeSpkMax) {
        // finds high -3dB point from mean SPL in speaker's optimal midrange  
        const response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
        // const response = await fetchSafe('frequency-response?smoothing=1/2&ppo=96', idx);

        // Use midrange reference band for speakers
        const refArray = response2array(response, 500, 2000);  // Speaker midrange reference
        const refSPL = refArray.reduce((acc, val) => acc + val, 0) / refArray.length;

        const rpArray = response2array(response, start, end);
        const octave = Math.pow(2, 1 / 96);
        let rolloff = end;

        for (let i = rpArray.length - 1; i >= 0; i--) {
          if ((rpArray[i] - refSPL) >= -3) { break; }
          rolloff /= octave;
        }
        return Math.max(rolloff, start);
      }

      // async function getSpeakerHFRolloff(idx, start = 10000, end = 20000) {
      async function getSpeakerHFRolloff(idx, start = 10000, end = 20000) {
        // goal of this function is to find the roll-off past 10k before any HF peaks that can mess with the high shelf
        const response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
        const rpArray = response2array(response, start, end);
        const tcArray = response2array(targetResponse, start, end);
        const arrLength = Math.min(rpArray.length, tcArray.length);
        const octave = Math.pow(2, 1 / 96);
        let checkFreq = start;
        let rolloff = checkFreq;
        let lowestSPL = rpArray[0];
        for (let i = 0; i < arrLength; i++) {
          if (rpArray[i] < lowestSPL) {
            lowestSPL = rpArray[i];
            rolloff = checkFreq;
          }
          // if HF peak exceeds lowest point by 3dB, set roll-off before that peak
          // also if HF drops below target by 3dB, stop there otherwise high shelf will fail
          if ((rpArray[i] - lowestSPL >= 3) || (rpArray[i] - tcArray[i] <= -3)) {
            break;
          }
          checkFreq *= octave;
        }
        return Math.min(rolloff, end);
      }

      async function calculateRolloffs() {
        console.log("Calculating speaker -3dB points from target curve...");

        if (isDebugMode) {
          // ADD THIS DEBUG CODE HERE ‚Üì
          console.log("=== TARGET CURVE DEBUG ===");
          console.log("Target curve in bass region:");
          const debugTcArray = response2array(targetResponse, 20, 120);
          for (let i = 0; i < debugTcArray.length; i += 8) { // Every 8th point to avoid spam
            const freq = 20 * Math.pow(2, i / 96);
            if (freq <= 100) {
              console.log(`${freq.toFixed(1)}Hz: ${debugTcArray[i].toFixed(1)}dB`);
            }
          }
          console.log("=== END TARGET CURVE DEBUG ===");
          // END DEBUG CODE ‚Üë
        }

        const measurements = await fetch_mREW();
        for (let i = 1; i <= nSpeakers; i++) {
          const title = measurements[i].title;
          // check if single channel or speaker pair
          const singleChannel = isSingleChannel(commandId[i]);
          const cmdIds = (singleChannel ? commandId[i] : `${commandId[i]} & ${commandId[i + 1]}`).padStart(9, ".");
          // rolloff determination logic
          let idx = i;
          if (!singleChannel) {
            const pairAvg = await postNext('Magn plus phase average', [i, i + 1]); // do not use VA. it unfairly benefits single channel speakers
            idx = Object.keys(pairAvg.results)[0];
          }
          const rolloff = await getLow3dBPoint(idx);
          const rolloffHF = await getSpeakerHFRolloff(i); // speaker specific, not pair specific

          if (isRP22mode == true) {
            m3dBPoints[i] = [Math.round(rolloff), 15000];
            console.info("calculateRolloffs: applying CEDIA RP22 - 15000 rolloff");
          } else if (isDolbymode == true) {
            m3dBPoints[i] = [Math.round(rolloff), 16000];
            console.info("calculateRolloffs: applying DOLBY - 16000 rolloff");
          } else if (isTHXmode == true) {
            m3dBPoints[i] = [Math.round(rolloff), 20000];
            console.info("calculateRolloffs: applying THX - 20000 rolloff");
          } else if (isIMAXmode == true) {
            m3dBPoints[i] = [Math.round(rolloff), 20000];
            console.info("calculateRolloffs: applying IMAX - 20000 rolloff");
          } else {
            // m3dBPoints[i] = [Math.round(rolloff), 12500]; // audy mic generally garbage past 10k and messes with high shelf
            m3dBPoints[i] = [Math.round(rolloff), Math.round(rolloffHF)];
            // console.info("calculateRolloffs: applying Default - 12500 rolloff");
            // console.info("calculateRolloffs: applying Default - calculated rolloff");
            console.info(`calculateRolloffs: applying Default - ${Math.round(rolloffHF)} rolloff`);
          }

          let initialXO = findNearestXO(rolloff);
          // edge case for no subwoofer
          if (noSub && cmdIds.endsWith("FL & FR")) {
            initialXO = "L";
          }

          customCrossover[i] = initialXO;
          if (!singleChannel) {
            const rolloffHFR = await getSpeakerHFRolloff(i + 1); // speaker specific, not pair specific
            if (isRP22mode == true) {
              m3dBPoints[i + 1] = [Math.round(rolloff), 15000];
              console.info("calculateRolloffs: applying CEDIA RP22 - 15000 rolloff");
            } else if (isDolbymode == true) {
              m3dBPoints[i + 1] = [Math.round(rolloff), 16000];
              console.info("calculateRolloffs: applying DOLBY - 16000 rolloff");
            } else if (isTHXmode == true) {
              m3dBPoints[i + 1] = [Math.round(rolloff), 20000];
              console.info("calculateRolloffs: applying THX - 20000 rolloff");
            } else if (isIMAXmode == true) {
              m3dBPoints[i + 1] = [Math.round(rolloff), 20000];
              console.info("calculateRolloffs: applying IMAX - 20000 rolloff");
            } else {
              // m3dBPoints[i] = [Math.round(rolloff), 12500]; // audy mic generally garbage past 10k and messes with high shelf
              m3dBPoints[i + 1] = [Math.round(rolloff), Math.round(rolloffHFR)];
              // console.info("calculateRolloffs: applying Default - 12500 rolloff");
              // console.info("calculateRolloffs: applying Default - calculated rolloff");
              console.info(`calculateRolloffs: applying Default - ${Math.round(rolloffHFR)} rolloff`);
            }
            customCrossover[i + 1] = initialXO;
            i++;
            await postDelete(idx); // cleanup
          }
          const logMessage = initialXO === "L" ? "Large/Full Range" : `Initial XO: ${initialXO}hz`;
          console.info(`${cmdIds} - roll-off: ${rolloff.toFixed(2)}Hz ‚Üí ${logMessage}`);
        }
      }

      async function calculateSubBandwidth() {
        if (noSub) { return; } // no need to go further without subwoofer

        // Create temporary freqIndex with 20Hz added for subwoofer calculations
        // const tempFreqIndex = [...freqIndex, 20].sort((a, b) => a - b);
        // DROP 200 and 250, add 20Hz for subwoofer
        const tempFreqIndex = [...freqIndex.filter(freq => freq !== 200 && freq !== 250), 20].sort((a, b) => a - b);

        // Create local function that uses tempFreqIndex
        const findNearestXOWithSub = (freq) => {
          let xo = Infinity;
          let minDelta = Infinity;
          for (let i = 0; i < tempFreqIndex.length; i++) {
            const delta = Math.abs(tempFreqIndex[i] - freq);
            if (delta < minDelta) {
              minDelta = delta;
              xo = tempFreqIndex[i];
            }
          }
          return xo;
        };

        console.log("Calculating subwoofer -3dB points from target curve...")

        // find low freq -3dB point & set minXO
        const subLowFreq = await getLow3dBPoint(nChannels);
        minXO = findNearestXOWithSub(2 * subLowFreq);
        // find high freq -3dB point and set maxXO
        const subHighFreq = await getHigh3dBPoint(nChannels);
        maxXO = findNearestXOWithSub(subHighFreq);

        if (minXO >= maxXO) {
          minXO = maxXO;
          console.warn(`Subwoofer has very little bandwidth and can only support ${minXO}hz crossover!`);
        }
        m3dBPoints[nChannels] = [Math.round(subLowFreq), Math.round(subHighFreq)];
        Object.freeze(minXO);
        Object.freeze(maxXO);
        console.log(`${commandId[nChannels].padStart(3, ".")} bandwidth: ${subLowFreq.toFixed(2)}hz - ${subHighFreq.toFixed(2)}hz ‚Üí Usable XO range: ${minXO}hz - ${maxXO}hz`);

        RP22subnminXO = subLowFreq.toFixed(2);
        RP22submaxXO = subHighFreq.toFixed(2);

        sanityCheckInitialXO(); // update initialXOs based on subwoofer bandwidth
      }

      function sanityCheckInitialXO() {
        if (noSub) { return; } // no need to go further without subwoofer
        for (let i = 1; i <= nSpeakers; i++) {
          const singleChannel = isSingleChannel(commandId[i]);
          const cmdIds = (singleChannel ? commandId[i] : `${commandId[i]} & ${commandId[1 + i]}`).padStart(9, ".");
          const initialXO = customCrossover[i];
          customCrossover[i] = Math.max(minXO, customCrossover[i]);
          if (!singleChannel) {
            customCrossover[i + 1] = customCrossover[i];
            i++;
          }
          if (initialXO != customCrossover[i]) {
            console.warn(`${cmdIds} initial XO below usable XO range - shifted: ${initialXO}hz ‚Üí ${customCrossover[i]}hz`);
          }
        }
      }

      async function optimizeSubDelay() {
        if (noSub) { return; } // no need to go further without subwoofer
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        let eqResults = [], initialXOs = 0, avgInitialXO = 80;
        let count = 1;
        for (let i = nChannels + 2; i <= nChannels * 3; i += 2) {
          const title = measurements[i].title;
          if (!title.endsWith("-equalized")) { continue; }
          if (commandId[count].startsWith("SW")) { continue; }
          eqResults.push(i);
          initialXOs += parseFloat(customCrossover[count++]);
        }
        if (initialXOs > 0) { avgInitialXO = initialXOs / eqResults.length; }
        Object.freeze(avgInitialXO);
        console.log(`Calculating optimal subwoofer delay for ALL speakers using average initial XO ${avgInitialXO.toFixed(2)}hz...`);
        const avgSpeaker = await postNext('Magn plus phase average', Array.from(eqResults)); // same results with RMS & VA since goal is max output
        const avgSpeakerIdx = Object.keys(avgSpeaker.results)[0]
        const avgSpeakerWithHPF = await genSpeaker(avgSpeakerIdx, avgInitialXO);
        const avgSpeakerWithHPFIdx = Object.keys(avgSpeakerWithHPF.results)[0];
        const subwooferWithLPF = await genSub(mCount, avgInitialXO);
        const subwooferWithLPFIdx = Object.keys(subwooferWithLPF.results)[0];
        let [isPossible, requiredDelay, isInverted] = await align4system(avgSpeakerWithHPFIdx, subwooferWithLPFIdx, avgInitialXO);
        // cleanup
        await postDelete(subwooferWithLPFIdx);
        await postDelete(avgSpeakerWithHPFIdx);
        await postDelete(avgSpeakerIdx);
        // apply optimal delay
        let subMoves = 0;
        if (isPossible) {
          subMoves = requiredDelay;
        } else {
          console.warn(`Required delay for alignment is too large! Subwoofer(s) set to max possible distance but results will not be optimal.`);
          const [loDelay,] = getDelayRangeOfFinalSub();
          subMoves = loDelay;
          isInverted = false;
        }
        if (isInverted) { await postSafe(`${baseUrl}/${nChannels * 3}/command`, { command: "Invert" }, "Invert completed"); }
        subMoves /= delaymax;
        await postNext('Offset t=0', nChannels * 3, { offset: -subMoves, unit: "seconds" });
        if (bassMode === "Directional") {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            mSec[i] += subMoves;
            invertSub[i] = isInverted ? !invertSub[i] : invertSub[i];
          }
        } else {
          mSec[nChannels] += subMoves;
          invertSub[nChannels] = isInverted;
        }
      }

      function getFLIndex() {
        let flIndex = 1;
        for (let i = 1; i <= nChannels; i++) {
          if (commandId[i].startsWith("FL")) {
            flIndex = i;
            break;
          }
        }
        return flIndex;
      }

      function initializeDistances() {
        // initialize to 0
        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          customDistance[i] = 0;
        }
        if (noSub) { return; }
        const flIndex = getFLIndex();
        let distMinSub = Infinity;
        // check if any directional subwoofer needs negative distance
        if (bassMode === "Directional") {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            const distSub = flDist + (mSec[flIndex] - mSec[i]) * sOs;
            distMinSub = Math.min(distMinSub, distSub);
          }
        }
        // check if any SWMIX subwoofer needs negative distance
        else {
          const distMainSub = flDist + (mSec[flIndex] - mSec[nChannels]) * sOs;
          const distLoSub = distMainSub - subLoDelay * sOs;
          const distHiSub = distMainSub - subHiDelay * sOs;
          distMinSub = Math.min(distLoSub, distHiSub);
        }
        if (distMinSub < 0) {
          console.warn(`Distances are being shifted by ${Math.abs(distMinSub).toFixed(2)}m to accommodate the required subwoofer delay!`);
          console.info("This adjustment will ONLY improve overall sound quality.");
          console.info("The receiver only accounts for relative time delays between speakers which are being kept intact.");
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            customDistance[i] += Math.abs(distMinSub);
          }
        }
      }

      function finalizeDistances() {
        initializeDistances();
        const flIndex = getFLIndex();

        // Clear the estimatedDistances array before populating
        estimatedDistances = [];

        console.log("Final speaker" + (noSub ? "" : " & subwoofer") + " distances:");

        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          customDistance[i] += flDist + (mSec[flIndex] - mSec[i]) * sOs;
          customDistance[i] = Math.round(parseFloat(customDistance[i]) * 100) / 100;

          // Store the distance in the estimatedDistances array
          estimatedDistances.push([commandId[i], customDistance[i].toFixed(2)]);

          if (i > nSpeakers) {
            console.warn(`${commandId[i].padStart(3, ".")} - distance: ${customDistance[i].toFixed(2)}m, ${invertSub[i] ? "please SWITCH this subwoofer's POLARITY!!!" : "keep this subwoofer's polarity 'as is'."}`);
            swInvMsg += invertSub[i] ? `inv${commandId[i]}_` : "";
          } else {
            console.info(`${commandId[i].padStart(3, ".")} - distance: ${customDistance[i].toFixed(2)}m`);
          }
        }

        if (swChannelCount > 1 && invertSub.every(isInv => isInv === true)) {
          console.warn(`You will need to switch polarity of EACH of your ${swChannelCount} subwoofers!`);
        }
      }

      async function finalizeXO(start = 20, end = 250) {
        if (noSub) { return; } // no need to go further without subwoofer

        // Helper function to generate frequency array for RMS calculation
        function generateFrequencyArray(startFreq, endFreq, length) {
          const freqArray = [];
          let iFreq = startFreq;
          const step = Math.pow(endFreq / startFreq, 1 / (length - 1));
          for (let k = 0; k < length; k++) {
            freqArray.push(iFreq);
            iFreq *= step;
          }
          return freqArray;
        }

        // Helper function to extract phase data from REW response
        function response2arrayPhase(response, start, end) {
          if (!response.phase) {
            return null;
          }

          const bytes = Uint8Array.from(atob(response.phase), (c) => c.charCodeAt(0));
          const buffer = bytes.buffer;
          const data = new DataView(buffer);
          const phaseArray = [];

          const maxIndex = Math.floor(data.byteLength / 4) - 1;
          const startIndex = Math.round((start - 0.3662109375) / 0.3662109375);
          const endIndex = Math.min(Math.round((end - 0.3662109375) / 0.3662109375), maxIndex);

          for (let i = startIndex; i <= endIndex; i++) {
            if (i * 4 + 3 < data.byteLength) {
              phaseArray.push(data.getFloat32(i * 4));
            }
          }

          // Additional unwrapping in case REW unwrap didn't catch everything
          for (let i = 1; i < phaseArray.length; i++) {
            let diff = phaseArray[i] - phaseArray[i - 1];
            while (diff > 180) {
              phaseArray[i] -= 360;
              diff = phaseArray[i] - phaseArray[i - 1];
            }
            while (diff < -180) {
              phaseArray[i] += 360;
              diff = phaseArray[i] - phaseArray[i - 1];
            }
          }

          return phaseArray;
        }

        // Add this function before calculateExpectedCrossoverPhase
        function estimatePhaseSlope(frequencyArray, phaseArray, crossoverFreq) {
          const low = crossoverFreq / 2;
          const high = crossoverFreq * 2;

          const points = frequencyArray
            .map((f, i) => ({ f, phase: phaseArray[i] }))
            .filter(p => p.f >= low && p.f <= high);

          console.info(`Slope estimation for ${crossoverFreq}Hz: using ${points.length} points from ${low}Hz to ${high}Hz`);

          if (points.length < 2) return null;

          const x = points.map(p => Math.log2(p.f));
          const y = points.map(p => p.phase);

          const n = x.length;
          const meanX = x.reduce((a, b) => a + b, 0) / n;
          const meanY = y.reduce((a, b) => a + b, 0) / n;

          let num = 0, den = 0;
          for (let i = 0; i < n; i++) {
            num += (x[i] - meanX) * (y[i] - meanY);
            den += (x[i] - meanX) ** 2;
          }

          const slope = den === 0 ? null : num / den;
          console.info(`Calculated slope: ${slope?.toFixed(1)}¬∞/octave`);
          return slope;
        }


        function calculateExpectedCrossoverPhase(frequencyArray, crossoverFreq, actualPhaseArray = null) {
          if (actualPhaseArray) {
            const slope = estimatePhaseSlope(frequencyArray, actualPhaseArray, crossoverFreq) ?? -90;

            // Find the closest frequency to the crossover frequency (keep existing logic)
            let closestIndex = 0;
            let minDiff = Math.abs(frequencyArray[0] - crossoverFreq);
            for (let i = 1; i < frequencyArray.length; i++) {
              const diff = Math.abs(frequencyArray[i] - crossoverFreq);
              if (diff < minDiff) {
                minDiff = diff;
                closestIndex = i;
              }
            }
            const xoIndex = closestIndex;
            const xoPhase = actualPhaseArray[xoIndex];

            console.info(`Phase target calc: slope=${slope.toFixed(1)}¬∞/oct, anchor freq=${frequencyArray[xoIndex].toFixed(1)}Hz, anchor phase=${xoPhase.toFixed(1)}¬∞`);

            return frequencyArray.map(freq => {
              const octaves = Math.log2(freq / crossoverFreq);
              return xoPhase + slope * octaves; // Return unwrapped values for calculations
            });
          }

          // Fallback
          return frequencyArray.map(freq => {
            if (freq < crossoverFreq) {
              const phaseRad = -2 * Math.atan(freq / crossoverFreq);
              return phaseRad * (180 / Math.PI);
            } else {
              const phaseRad = -Math.PI / 2 - 2 * Math.atan(crossoverFreq / freq);
              return phaseRad * (180 / Math.PI);
            }
          });
        }

        // Speaker type mappings
        const speakerMappings = {
          BED: {
            front: ["FL", "FR"],
            frontWide: ["FWL", "FWR"],
            surroundBack: ["SBL", "SBR"],
            surroundBackSingle: ["SB"],
            surround: ["SLA", "SRA"],
            center: ["C"]
          },
          HEIGHT: {
            frontHeight: ["FHL", "FHR"],
            rearHeight: ["RHL", "RHR"],
            surroundHeight: ["SHL", "SHR"],
            topFront: ["TFL", "TFR"],
            topMiddle: ["TML", "TMR"],
            topRear: ["TRL", "TRR"],
            upfiringBack: ["BDL", "BDR"],
            upfiringFront: ["FDL", "FDR"],
            upfiringSurround: ["SDL", "SDR"],
            topSurround: ["TS"],
            centerHeight: ["CH"]
          }
        };

        // Create flat arrays for easy lookup
        const bedSpeakers = Object.values(speakerMappings.BED).flat();
        const heightSpeakers = Object.values(speakerMappings.HEIGHT).flat();

        // Function to determine speaker layer type
        function getSpeakerLayer(speakerId) {
          if (bedSpeakers.includes(speakerId)) {
            return 'BED';
          } else if (heightSpeakers.includes(speakerId)) {
            return 'HEIGHT';
          } else {
            return 'UNKNOWN';
          }
        }

        // Get ranges from both sliders
        const bedSliderRange = sliderInstances.bed ? sliderInstances.bed.getSelectedRange() : null;
        const heightSliderRange = sliderInstances.height ? sliderInstances.height.getSelectedRange() : null;

        // Extract frequency ranges based on slider mode
        let bedMinFreq, bedMaxFreq, heightMinFreq, heightMaxFreq;

        if (bedSliderRange) {
          if (bedSliderRange.mode === "single") {
            bedMinFreq = bedMaxFreq = bedSliderRange.value;
          } else {
            bedMinFreq = bedSliderRange.min;
            bedMaxFreq = bedSliderRange.max;
          }
        } else {
          bedMinFreq = bedMaxFreq = null;
        }

        if (heightSliderRange) {
          if (heightSliderRange.mode === "single") {
            heightMinFreq = heightMaxFreq = heightSliderRange.value;
          } else {
            heightMinFreq = heightSliderRange.min;
            heightMaxFreq = heightSliderRange.max;
          }
        } else {
          heightMinFreq = heightMaxFreq = null;
        }

        console.log(`BED layer range: ${bedMinFreq}Hz - ${bedMaxFreq}Hz`);
        console.log(`HEIGHT layer range: ${heightMinFreq}Hz - ${heightMaxFreq}Hz`);
        console.info("Finalizing crossover frequencies to best follow the target curve...");

        // Function to get the appropriate frequency range for a speaker
        function getSpeakerFreqRange(speakerId) {
          const layer = getSpeakerLayer(speakerId);

          if (layer === 'BED' && bedMinFreq !== null && bedMaxFreq !== null) {
            return { min: bedMinFreq, max: bedMaxFreq, layer: 'BED' };
          } else if (layer === 'HEIGHT' && heightMinFreq !== null && heightMaxFreq !== null) {
            return { min: heightMinFreq, max: heightMaxFreq, layer: 'HEIGHT' };
          } else {
            // Fallback to default range if no slider available or speaker type unknown
            console.warn(`Using default range for ${speakerId} (${layer} layer)`);
            return { min: 20, max: 250, layer: 'DEFAULT' };
          }
        }

        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        const targetArray = response2array(targetResponse, start, end);
        let count = 1;

        for (let i = nChannels + 2; i <= nChannels * 3; i += 2) {
          if (commandId[count].startsWith("SW")) { continue; }

          // check if single channel or speaker pair
          const singleChannel = isSingleChannel(commandId[count]);
          const cmdIds = (singleChannel ? commandId[count] : `${commandId[count]} & ${commandId[1 + count]}`).padStart(9, ".");

          // Get the appropriate frequency range for this speaker
          const primarySpeakerId = commandId[count];
          const speakerRange = getSpeakerFreqRange(primarySpeakerId);

          console.info(`${cmdIds} using ${speakerRange.layer} layer range: ${speakerRange.min}Hz - ${speakerRange.max}Hz`);

          // Calculate effective usable range for this speaker
          const effectiveMinXO = Math.max(minXO, speakerRange.min);
          const effectiveMaxXO = Math.min(maxXO, speakerRange.max);

          // Warning if ranges don't fully overlap
          if (speakerRange.min < minXO || speakerRange.max > maxXO) {
            console.warn(`${cmdIds} slider range (${speakerRange.min}Hz - ${speakerRange.max}Hz) extends beyond subwoofer bandwidth (${minXO}Hz - ${maxXO}Hz)`);
          }

          // Filter freqIndex to only include frequencies within this speaker's range
          const filteredFreqIndex = freqIndex.filter(freq =>
            freq >= effectiveMinXO && freq <= effectiveMaxXO
          );

          console.info(`${cmdIds} filtered frequency range: ${filteredFreqIndex.length} frequencies from ${filteredFreqIndex[0] || 'none'}Hz to ${filteredFreqIndex[filteredFreqIndex.length - 1] || 'none'}Hz`);

          // finalize xo that is closest match to target curve
          const initialXO = parseFloat(customCrossover[count]);

          // Warning checks for this speaker's effective range
          if (initialXO > effectiveMaxXO) {
            console.warn(`${cmdIds} initial XO (${initialXO}Hz) is above effective range (${effectiveMaxXO}Hz) - may not find optimal setting`);
          }
          if (initialXO < effectiveMinXO) {
            console.warn(`${cmdIds} initial XO (${initialXO}Hz) is below effective range (${effectiveMinXO}Hz) - may not find optimal setting`);
          }

          let bestXO = initialXO, minRmsError = Infinity;

          console.info(`Starting optimization for ${cmdIds}...`);

          // Use filtered frequency range from appropriate slider
          for (let j = 0; j < filteredFreqIndex.length; j++) {
            let checkXO = filteredFreqIndex[j];

            // FIXED: Remove initial XO from range check - slider range should be authoritative
            if (checkXO < effectiveMinXO || checkXO > effectiveMaxXO) { continue; }

            // final XO determination logic
            // console.info(`${cmdIds} - Initial XO: ${initialXO}hz ‚Üí Checking XO: ${checkXO}hz (RMS: ${rmsError.toFixed(3)}) [${speakerRange.layer} layer]`);
            // console.info(`${cmdIds} - Initial XO: ${initialXO}hz ‚Üí Checking XO: ${checkXO}hz [${speakerRange.layer} layer]`);
            console.info(`‚Üí`);
            console.info(`${cmdIds} - Initial XO: ${initialXO}hz ‚Üí Testing XO: ${checkXO}hz [${speakerRange.layer} layer]`);

            if (singleChannel) {
              await genSpeaker(i, checkXO);
            } else {
              await postNext('Magn plus phase average', [i, i + 2]); // do not use VA. it unfairly benefits single channel speakers
              await genSpeaker(mCount + 1, checkXO);
              await postDelete(mCount + 1);
            }

            await genSub(mCount, checkXO);
            await postNext('Arithmetic', [mCount + 1, mCount + 2], { function: "A + B" }); // response using checkXO

            // Enhanced RMS calculation with PHASE-AWARE optimization
            const checkXOResponse = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', mCount + 3);
            // const checkXOResponse = await fetchSafe('frequency-response?smoothing=1/2&ppo=96', mCount + 3);
            const checkXOArray = response2array(checkXOResponse, start, end);

            // Generate frequency array for the response
            const responseFrequencyArray = generateFrequencyArray(start, end, checkXOArray.length);

            // Extract and unwrap phase data from REW response
            let phaseArray = null;
            let targetPhaseArray = null;

            if (checkXOResponse.phase) {
              // UNWRAP phase first using crossover frequency as reference
              await postSafe(`${baseUrl}/${mCount + 3}/command`, {
                command: "Unwrap phase",
                parameters: { frequency: checkXO }
              }, "Unwrap phase completed");
              // await new Promise((resolve) => setTimeout(resolve, speedDelay / 2));

              // Get the unwrapped phase response  
              const unwrappedResponse = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', mCount + 3);
              phaseArray = response2arrayPhase(unwrappedResponse, start, end);


              if (phaseArray) {
                targetPhaseArray = calculateExpectedCrossoverPhase(responseFrequencyArray, checkXO, phaseArray);
                console.info(`DEBUG: Crossover ${checkXO}Hz phase analysis:`);

                // Add null checks for debugging
                if (phaseArray && phaseArray.length > 0) {
                  console.info(`Actual phase at ${checkXO}Hz: ${phaseArray[Math.floor(phaseArray.length / 2)].toFixed(1)}¬∞`);

                  if (responseFrequencyArray && responseFrequencyArray.length > 1) {
                    const phaseSlope = (phaseArray[phaseArray.length - 1] - phaseArray[0]) / (responseFrequencyArray[responseFrequencyArray.length - 1] - responseFrequencyArray[0]);
                    console.info(`Actual phase slope: ${phaseSlope.toFixed(2)}¬∞/Hz`);
                  }
                }

                if (targetPhaseArray && targetPhaseArray.length > 0) {
                  console.info(`Expected phase at ${checkXO}Hz: ${targetPhaseArray[Math.floor(targetPhaseArray.length / 2)].toFixed(1)}¬∞`);
                } else {
                  console.warn(`ERROR: targetPhaseArray is null or empty`);
                }
                console.info(`Phase optimization enabled for ${checkXO}Hz crossover (unwrapped)`);
              }
            }


            // Calculate RMS error with magnitude AND phase optimization
            const rmsError = calculateRMSError(
              checkXOArray,
              targetArray,
              responseFrequencyArray,
              targetLevel,
              phaseArray !== null, // Enable phase optimization if phase data available
              phaseArray,
              targetPhaseArray,
              checkXO // Pass the actual crossover frequency being tested
            );

            // ADD THIS LINE HERE:
            console.info(`${cmdIds} - XO: ${checkXO}hz ‚Üí Result: RMS: ${rmsError.toFixed(3)}`);
            // console.info(`‚Üê`);

            if (rmsError < minRmsError) {
              minRmsError = rmsError;
              bestXO = checkXO;
            }

            // final XO determination logic
            // console.info(`${cmdIds} - Initial XO: ${initialXO}hz ‚Üí Checking XO: ${checkXO}hz (RMS: ${rmsError.toFixed(3)}) [${speakerRange.layer} layer]`);

            for (let k = mCount + 3; k > mCount; k--) {
              await postDelete(k);
            }
          }

          customCrossover[count] = bestXO;

          // Store the result in RP22BestXO array with layer information
          RP22BestXO.push([commandId[count], bestXO.toString(), speakerRange.layer]);

          if (!singleChannel) {
            customCrossover[1 + count] = bestXO;
            // Store the second channel result with layer information
            const secondarySpeakerId = commandId[1 + count];
            const secondaryLayer = getSpeakerLayer(secondarySpeakerId);
            RP22BestXO.push([secondarySpeakerId, bestXO.toString(), secondaryLayer]);
            i += 2;
            count++;
          }
          count++;
          // console.log(`${cmdIds} - Initial XO: ${initialXO}hz ‚Üí Best XO: ${bestXO}hz (RMS: ${minRmsError.toFixed(3)}) [${speakerRange.layer} layer]`);
          console.log(`‚Üí`);
          console.log(`${cmdIds} - Initial XO: ${initialXO}hz ‚Üí Best XO: ${bestXO}hz (RMS: ${minRmsError.toFixed(3)}) [${speakerRange.layer} layer]`);
          console.log(`‚Üê`);
          // Get the detailed RMS info for the best crossover
          // console.log(`${cmdIds} - Initial XO: ${initialXO}hz ‚Üí Best XO: ${bestXO}hz [${speakerRange.layer} layer]`);
          // console.log(`${cmdIds} - Final result: Combined RMS: ${minRmsError.toFixed(3)} (Magnitude + Phase optimization)`);
        }

        // Log the final results grouped by layer
        const bedResults = RP22BestXO.filter(result => result[2] === 'BED');
        const heightResults = RP22BestXO.filter(result => result[2] === 'HEIGHT');
        const unknownResults = RP22BestXO.filter(result => result[2] === 'DEFAULT' || result[2] === 'UNKNOWN');

        console.log("=== FINAL CROSSOVER OPTIMIZATION RESULTS ===");

        for (let i = 0; i < RP22BestXO.length; i++) {
          const [code, frequency, layer] = RP22BestXO[i];
          console.log(`${code} ‚Üí ${frequency}Hz ‚Üí [${layer} layer]`);
        }

        return RP22BestXO;
      }

      async function directional2standard() {
        let currSubIdx = nSpeakers + 1;
        let cmdIds = commandId[currSubIdx];
        let minDelay = 0, maxDelay = 0;
        // let startFreq = Math.round(await getLow3dBPoint(currSubIdx));
        // let endFreq = Math.round(await getHigh3dBPoint(currSubIdx));
        let startFreq = Math.round(await getAbsLow3dBPointForSub(currSubIdx));
        let endFreq = Math.round(await getAbsHigh3dBPointForSub(currSubIdx));
        for (let i = nSpeakers + 2; i <= nSpeakers + nSubs; i++) {
          console.log(`Aligning ${commandId[i]} to ${cmdIds}...`);
          // startFreq = Math.min(startFreq, Math.round(await getLow3dBPoint(i)));
          // endFreq = Math.max(endFreq, Math.round(await getHigh3dBPoint(i)));
          startFreq = Math.min(startFreq, Math.round(await getAbsLow3dBPointForSub(i)));
          endFreq = Math.max(endFreq, Math.round(await getAbsHigh3dBPointForSub(i)));
          const [isPossible, requiredDelay, isInverted, sumIndex] = await alignMsub(currSubIdx, i, startFreq, endFreq);
          if (!isPossible || !sumIndex) {
            console.error("Failed to align multiple subwoofers!");
            throw new Error;
          }
          currSubIdx = sumIndex;
          // mSec[i] += (requiredDelay / 1000);
          mSec[i] += (requiredDelay / delaymax);
          invertSub[i] = isInverted;
          cmdIds += ` & ${commandId[i]}`;
          minDelay = Math.min(minDelay, mSec[i]);
          maxDelay = Math.max(maxDelay, mSec[i]);
        }
        for (let i = currSubIdx - 1; i > nSpeakers; i--) {
          await postDelete(i);
        }
        await fetch_mREW(nChannels, 'PUT', { title: "SW1o" });
        // normalize directional bass subwoofer median IR to t=0
        const IROffset = (minDelay + maxDelay) / 2;
        await postNext('Offset t=0', nChannels, { offset: IROffset, unit: "seconds" });
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          mSec[i] -= IROffset;
        }
        // offset volume from combining subwoofers
        // const volAdjust = parseFloat(await getSubTrim(nChannels));
        const volAdjust = await getSubTrim(nChannels);
        if (volAdjust === 0) { return; } // nothing more to do
        await postNext('Add SPL offset', nChannels, { offset: volAdjust });
        // newer AVRs that support directional already compensates for combined subwoofer volume and doesn't need adjustment
        if (sOs === 300) {
          console.log(`Adjusting combined sub level by ${volAdjust}dB to best follow the target curve...`);
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += volAdjust;
            console.info(`${commandId[i].padStart(3, ".")} - shifted: ${customLevel[i] - volAdjust}dB ‚Üí ${customLevel[i]}dB`);
          }
        }
      }

      function response2array(response, start, end, phase = false) {
        let startFreq = response.startFreq;
        let k1 = start, k2 = end;
        if ('freqStep' in response) {
          const freqStep = response.freqStep;
          k1 = Math.round((k1 - startFreq) / freqStep);
          k2 = Math.round((k2 - startFreq) / freqStep);
        } else if ('ppo' in response) {
          const responsePpo = response.ppo;
          k1 = Math.round(Math.log2(k1 / startFreq) * responsePpo);
          k2 = Math.round(Math.log2(k2 / startFreq) * responsePpo);
        }
        const bytes = Uint8Array.from(atob(phase ? response.phase : response.magnitude), c => c.charCodeAt(0));
        const buffer = bytes.buffer;
        const data = new DataView(buffer);
        const responseArray = [];
        for (let k = k1; k <= k2; k++) {
          const sumMagnitude = data.getFloat32(k * 4);
          responseArray.push(sumMagnitude);
        }
        return responseArray;
      }

      function calculateRMSError(rpArray, targetArray, frequencyArray = null, playbackLevel = null, includePhase = false, phaseArray = null, targetPhaseArray = null, crossoverFreq = null) {
        if (rpArray.length === 0 || targetArray.length === 0) {
          console.warn("Failed to calculate RMS error!");
          return Infinity;
        }

        const arrayLength = Math.min(rpArray.length, targetArray.length);

        // Calculate traditional magnitude RMS
        let magnitudeSumOfSquares = 0;
        for (let i = 0; i < arrayLength; i++) {
          const diff = rpArray[i] - targetArray[i];
          magnitudeSumOfSquares += diff * diff;
        }
        const magnitudeRMS = Math.sqrt(magnitudeSumOfSquares / arrayLength);

        // If no phase data provided, return magnitude-only RMS
        if (!includePhase || !phaseArray || !targetPhaseArray) {
          console.log(`üìä RMS: Magnitude-only optimization: ${magnitudeRMS.toFixed(6)}`);
          return magnitudeRMS;
        }

        // Helper function for shortest angular distance
        function phaseErrorDeg(actual, expected) {
          let diff = actual - expected;
          return ((diff + 180) % 360) - 180; // shortest path
        }

        // Calculate phase RMS error
        let phaseSumOfSquares = 0;
        let phasePoints = 0;
        const phaseLength = Math.min(phaseArray.length, targetPhaseArray.length, arrayLength);

        for (let i = 0; i < phaseLength; i++) {
          if (frequencyArray && frequencyArray[i]) {
            const frequency = frequencyArray[i];

            // Focus on frequency band around actual crossover (ChatGPT's improvement)
            if (crossoverFreq !== null) {
              const freqLow = crossoverFreq / Math.sqrt(2);  // ~0.7x crossover
              const freqHigh = crossoverFreq * Math.sqrt(2); // ~1.4x crossover

              if (frequency >= freqLow && frequency <= freqHigh) {
                // Calculate shortest angular distance between unwrapped values
                const phaseDiff = phaseErrorDeg(phaseArray[i], targetPhaseArray[i]);

                // Weight phase errors more heavily near the actual crossover frequency
                const frequencyDistanceFromXO = Math.abs(frequency - crossoverFreq);
                const crossoverWeight = frequencyDistanceFromXO <= 15 ? 2.0 : 1.0; // Within ¬±15Hz of crossover

                phaseSumOfSquares += (phaseDiff * phaseDiff * crossoverWeight);
                phasePoints++;
              }
            } else {
              // Fallback to broad frequency range if no crossover specified
              if (frequency >= 40 && frequency <= 200) {
                const phaseDiff = phaseErrorDeg(phaseArray[i], targetPhaseArray[i]);

                phaseSumOfSquares += (phaseDiff * phaseDiff);
                phasePoints++;
              }
            }
          }
        }

        const phaseRMS = phasePoints > 0 ? Math.sqrt(phaseSumOfSquares / phasePoints) : 0;

        // ChatGPT's fix: Normalize phase scale and adjust weighting
        const normalizedPhaseRMS = phaseRMS / 180; // Scale to [0..1] 
        // const phaseWeight = 5.0; // Adjust contribution
        const phaseWeight = 5.0; // Adjust contribution
        const combinedError = magnitudeRMS + (normalizedPhaseRMS * phaseWeight);

        console.info(`üìä RMS: Magnitude: ${magnitudeRMS.toFixed(6)}, Phase: ${phaseRMS.toFixed(2)}¬∞, NormPhase: ${normalizedPhaseRMS.toFixed(4)}, Combined: ${combinedError.toFixed(6)}`);

        return combinedError;
      }

      async function getTrim(idx, start, end) {
        const targetArray = response2array(targetResponse, start, end);
        const targetSPL = targetArray.reduce((acc, val) => acc + val, 0) / targetArray.length;

        // Intelligently detect device type based on frequency range
        const isSubwoofer = (end <= 150);
        // const isSubwoofer = (end < 250);

        let freqResponse;

        /*
        // CEDIA RP22 mode 
        if (isRP22mode) {
          if (isSubwoofer) {
            freqResponse = await fetchSafe('frequency-response?smoothing=1/2&ppo=96', idx);
            console.info(`getTrim: Cedia RP22 subwoofer (${start}-${end}Hz) - 1/2 smoothing`);
          } else {
            freqResponse = await fetchSafe('frequency-response?smoothing=1/1&ppo=96', idx);
            console.info(`getTrim: Cedia RP22 speaker (${start}-${end}Hz) - 1/1 smoothing`);
          }
          // DOLBY mode 
        } else if (isDolbymode) {
          if (isSubwoofer) {
            freqResponse = await fetchSafe('frequency-response?smoothing=1/2&ppo=96', idx);
            console.info(`getTrim: Dolby subwoofer (${start}-${end}Hz) - 1/2 smoothing`);
          } else {
            freqResponse = await fetchSafe('frequency-response?smoothing=1/1&ppo=96', idx);
            console.info(`getTrim: Dolby speaker (${start}-${end}Hz) - 1/1 smoothing`);
          }
          // THX mode
        } else if (isTHXmode) {
          if (isSubwoofer) {
            freqResponse = await fetchSafe('frequency-response?smoothing=1/2&ppo=96', idx);
            console.info(`getTrim: THX subwoofer (${start}-${end}Hz) - 1/2 smoothing`);
          } else {
            freqResponse = await fetchSafe('frequency-response?smoothing=1/1&ppo=96', idx);
            console.info(`getTrim: THX speaker (${start}-${end}Hz) - 1/1 smoothing`);
          }
          // IMAX mode
        } else if (isIMAXmode) {
          if (isSubwoofer) {
            freqResponse = await fetchSafe('frequency-response?smoothing=1/2&ppo=96', idx);
            console.info(`getTrim: IMAX subwoofer (${start}-${end}Hz) - 1/2 smoothing`);
          } else {
            freqResponse = await fetchSafe('frequency-response?smoothing=1/1&ppo=96', idx);
            console.info(`getTrim: IMAX speaker (${start}-${end}Hz) - 1/1 smoothing`);
          }
          // DEFAULT mode
        } else {
         */
        if (isSubwoofer) {
          freqResponse = await fetchSafe('frequency-response?smoothing=1/1&ppo=96', idx);
          console.info(`getTrim: Default subwoofer (${start}-${end}Hz) - 1/2 smoothing`);
        } else {
          freqResponse = await fetchSafe('frequency-response?smoothing=1/1&ppo=96', idx);
          console.info(`getTrim: Default speaker (${start}-${end}Hz) - 1/1 smoothing`);
        }
        // }

        const freqArray = response2array(freqResponse, start, end);
        const freqSPL = freqArray.reduce((acc, val) => acc + val, 0) / freqArray.length;

        if (isDebugMode) {
          console.log(`*** TRIM DEBUG for measurement ${idx} (${start}-${end}Hz) ***`);
          console.log(`Device type detected: ${isSubwoofer ? 'SUBWOOFER' : 'SPEAKER'}`);
          console.log(`Target curve average SPL: ${targetSPL.toFixed(1)}dB`);
          console.log(`Measurement average SPL: ${freqSPL.toFixed(1)}dB`);
          console.log(`Calculated trim: ${(targetSPL - freqSPL).toFixed(1)}dB`);
          const measurements = await fetch_mREW();
          const currentSplOffset = parseFloat(measurements[idx].splOffsetdB);
          console.log(`Current measurement SPL offset: ${currentSplOffset}dB`);
          console.log(`Effective measurement level: ${(freqSPL + currentSplOffset).toFixed(1)}dB`);
        }

        const offset = targetSPL - freqSPL;
        return Math.round(offset * 2) / 2; // round to nearest 0.5
      }

      /* Commit f594500 */
      async function getTCTrim(idx, start, end) {
        const targetArray = response2array(targetResponse, start, end);
        const targetSPL = targetArray.reduce((acc, val) => acc + val, 0) / targetArray.length;
        const freqResponse = await fetchSafe(`frequency-response?smoothing=Var&ppo=96`, idx);
        const freqArray = response2array(freqResponse, start, end);
        const freqSPL = freqArray.reduce((acc, val) => acc + val, 0) / freqArray.length;
        const offset = targetSPL - freqSPL;
        return Math.round(offset * 2) / 2; // round to nearest 0.5
      }
      /* Commit f594500 */

      async function getSpeakerTrim(idx) {
        // const spTrim = await getTrim(idx, 500, 2000);
        let mode = 'default';
        if (isRP22mode) mode = 'RP22';
        else if (isDolbymode) mode = 'DOLBY';
        else if (isTHXmode) mode = 'THX';
        else if (isIMAXmode) mode = 'IMAX';

        // Measure actual speaker capabilities once
        let actualLow = Math.round(await getAbsLow3dBPointForSpk(idx));
        let actualHigh = Math.round(await getAbsHigh3dBPointForSpk(idx));

        let param2, param3;
        switch (mode) {
          case 'RP22':
            param2 = Math.max(actualLow, 20);
            // param3 = Math.min(actualHigh, 20000);
            param3 = Math.max(actualHigh, 20000);
            modeSpkMin = 20;
            modeSpkMax = 20000;
            break;

          case 'DOLBY':
            param2 = Math.max(actualLow, 31.5);  // ‚Üê Now consistent with subwoofer
            // param3 = Math.min(actualHigh, 16000);
            param3 = Math.max(actualHigh, 16000);
            modeSpkMin = 31.5;
            modeSpkMax = 16000;
            break;

          case 'THX':
            param2 = Math.max(actualLow, 20);
            // param3 = Math.min(actualHigh, 20000);
            param3 = Math.max(actualHigh, 20000);
            modeSpkMin = 20;
            modeSpkMax = 20000;
            break;

          case 'IMAX':
            param2 = Math.max(actualLow, 20);
            // param3 = Math.min(actualHigh, 20000);
            param3 = Math.max(actualHigh, 20000);
            modeSpkMin = 20;
            modeSpkMax = 20000;
            break;

          default:
            param2 = Math.max(actualLow, 20);
            param3 = Math.min(actualHigh, 20000);
            modeSpkMin = 20;
            modeSpkMax = 20000;
        }

        return await getTrim(idx, 500, 2000);
      }

      async function getSubTrim(idx) {
        // const subTrim = await getTrim(idx, 30, 80);
        let mode = 'default';
        if (isRP22mode) mode = 'RP22';
        else if (isDolbymode) mode = 'DOLBY';
        else if (isTHXmode) mode = 'THX';
        else if (isIMAXmode) mode = 'IMAX';

        // Measure actual subwoofer capabilities
        let actualLow = Math.round(await getAbsLow3dBPointForSub(idx));
        let actualHigh = Math.round(await getAbsHigh3dBPointForSub(idx));

        let param2, param3;
        let warnings = [];

        switch (mode) {
          case 'RP22':
            param2 = Math.max(actualLow, 20);
            // param3 = Math.min(actualHigh, 120);
            param3 = Math.max(actualHigh, 120);
            // No warnings - RP22 adapts to actual performance
            modeSubXOMin = 20;
            modeSubXOMax = 120;
            break;

          case 'DOLBY':
            param2 = Math.max(actualLow, 31.5);
            // param3 = Math.min(actualHigh, 120);
            param3 = Math.max(actualHigh, 120);
            modeSubXOMin = 31.5;
            modeSubXOMax = 120;
            if (actualLow > 31.5) {
              warnings.push(`Sub ${idx}: Low end ${actualLow}Hz exceeds Dolby spec (31.5Hz)`);
            }
            break;

          case 'THX':
            param2 = Math.max(actualLow, 20);
            // param3 = Math.min(actualHigh, 120);
            param3 = Math.max(actualHigh, 120);
            modeSubXOMin = 20;
            modeSubXOMax = 120;
            if (actualLow > 20) {
              warnings.push(`Sub ${idx}: Low end ${actualLow}Hz doesn't meet THX requirement (20Hz)`);
            }
            break;

          case 'IMAX':
            param2 = Math.max(actualLow, 20);
            // param3 = Math.min(actualHigh, 70);
            param3 = Math.max(actualHigh, 70);
            modeSubXOMin = 20;
            modeSubXOMax = 70;
            if (actualHigh < 70) {
              warnings.push(`Sub ${idx}: High end ${actualHigh}Hz below IMAX crossover (70Hz)`);
            }
            break;

          default:
            param2 = Math.max(actualLow, 30);
            // param3 = Math.min(actualHigh, 80);
            param3 = Math.max(actualHigh, 80);
            modeSubXOMin = 30;
            modeSubXOMax = 80;
        }

        // Log warnings for system diagnostics
        if (warnings.length > 0) {
          console.warn('Subwoofer compliance warnings:', warnings);
        }
        return await getTrim(idx, 30, 80);
      }

      async function getDynamicBassFill(idx) {
        // vs -from target curve (start and end)
        const startFreq = Math.round(await getLow3dBPoint(idx, modeSubXOMin, modeSubXOMax));
        const endFreq = Math.round(await getHigh3dBPoint(idx, modeSubXOMin, modeSubXOMax));
        const subFreqResponse = await fetchSafe('frequency-response?smoothing=1%2F6&ppo=96', idx);
        const subArray = response2array(subFreqResponse, startFreq, endFreq);
        const targetArray = response2array(targetResponse, startFreq, endFreq);
        const arrayLength = Math.min(subArray.length, targetArray.length);
        let totalDips = 0;
        for (let i = 0; i < arrayLength; i++) {
          totalDips += Math.min(subArray[i] - targetArray[i], 0);
        }
        const dynamicBassFill = Math.round(-2 * (totalDips / arrayLength)) / 2; // round to nearest 0.5
        return dynamicBassFill;
      }

      async function align4system(ind1, ind2, xo) {
        const start = Math.round(xo / 2), end = Math.round(xo * 2);
        let [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        loDelay = Math.max(-delaymax, Math.min(0, -Math.abs(loDelay))); // force negative
        hiDelay = Math.max(0, Math.min(delaymax, Math.abs(hiDelay)));   // force positive
        console.info(`Available delay range: ${loDelay.toFixed(2)}ms <-> ${hiDelay.toFixed(2)}ms`);
        let isInverted = false, isPossible = false, requiredDelay = NaN, bestFreq = NaN, maxSum = -Infinity;
        await postSafe("http://localhost:4735/alignment-tool/index-a", ind1, "selected as measurement A");
        await postSafe("http://localhost:4735/alignment-tool/index-b", ind2, "selected as measurement B");
        await postAlign('Reset all');
        await postSafe("http://localhost:4735/alignment-tool/mode", "Impulse", "Mode set");
        await postSafe("http://localhost:4735/alignment-tool/max-negative-delay", loDelay, "Maximum negative delay set to");
        await postSafe("http://localhost:4735/alignment-tool/max-positive-delay", hiDelay, "Maximum positive delay set to");
        console.info("Starting...")

        for (let checkFreq = 20; checkFreq <= 250; checkFreq++) {
          // const bestDelayStr = isNaN(requiredDelay) ? "N/A" : requiredDelay.toFixed(2);
          // const bestFreqStr = isNaN(bestFreq) ? "N/A" : bestFreq;
          // console.infoUpdate(`Checking: @${checkFreq}Hz, Best: ${bestDelayStr}ms @${bestFreqStr}hz Inverted: ${isInverted}`);

          const postAlignResult = await postAlign('Align IRs', checkFreq);
          if (postAlignResult.message === 'Delay too large') { continue; }

          const invertB = await fetchAlign('invert-b');
          const delayB = parseFloat(await fetchAlign('delay-b'));
          if (noInversion && invertB) { continue; };

          const tempSum = await fetchAlign('aligned-frequency-response?smoothing=Psy&ppo=96');
          // const tempSum = await fetchAlign('aligned-frequency-response?smoothing=1/2&ppo=96');
          const tempSumArray = response2array(tempSum, start, end);
          const tempMagSum = tempSumArray.reduce((acc, val) => acc + val, 0);
          if (maxSum < tempMagSum) {
            maxSum = tempMagSum;
            bestFreq = checkFreq;
            isPossible = true;
            requiredDelay = delayB;
            isInverted = invertB;
          }

          const bestDelayStr = isNaN(requiredDelay) ? "N/A" : requiredDelay.toFixed(2);
          const bestFreqStr = isNaN(bestFreq) ? "N/A" : bestFreq;
          console.infoUpdate(`Checking: @${checkFreq}Hz, Best: ${bestDelayStr}ms @${bestFreqStr}hz Inverted: ${isInverted}`);

        }

        if (isPossible) {
          const postAlignResult = await postAlign('Align IRs', bestFreq);
          const delayB = await fetchAlign('delay-b');
          requiredDelay = parseFloat(delayB);
          isInverted = await fetchAlign('invert-b');
          const alignedSum = await postAlign('Aligned sum');
          const parsed = JSON.parse(alignedSum.message);
          const key = Object.keys(parsed.results)[0];
          const sumIndex = parseInt(key);
          await postDelete(sumIndex);
          console.infoUpdate(`Optimal alignment: @${bestFreq}Hz, required delay: ${requiredDelay.toFixed(2)}ms, isInverted: ${isInverted}`);
        }
        RP22subrequiredDelay = requiredDelay;
        return [isPossible, requiredDelay, isInverted];
      }

      async function alignMsub(ind1, ind2, start, end) {
        const [loDelay, hiDelay] = getDelayRangeOf(mSec[ind2], nSpeakers + 1, nSpeakers + nSubs);
        console.info(`Available delay range: ${loDelay.toFixed(2)}ms <-> ${hiDelay.toFixed(2)}ms`);
        let isInverted = false, isPossible = false, requiredDelay = NaN, bestFreq = NaN, maxSum = -Infinity, sumIndex = null;
        await postSafe("http://localhost:4735/alignment-tool/index-a", ind1, "selected as measurement A");
        await postSafe("http://localhost:4735/alignment-tool/index-b", ind2, "selected as measurement B");
        await postAlign('Reset all');
        await postSafe("http://localhost:4735/alignment-tool/mode", "Impulse", "Mode set");
        await postSafe("http://localhost:4735/alignment-tool/max-negative-delay", loDelay, "Maximum negative delay set to");
        await postSafe("http://localhost:4735/alignment-tool/max-positive-delay", hiDelay, "Maximum positive delay set to");
        console.info("Starting...")

        for (let checkFreq = 20; checkFreq <= 250; checkFreq++) {
          const postAlignResult = await postAlign('Align IRs', checkFreq);
          if (postAlignResult.message === 'Delay too large' && previousDelay != postAlignResult.delay) {
            previousDelay = postAlignResult.delay;
            continue;
          }

          const invertB = await fetchAlign('invert-b');
          const delayB = parseFloat(await fetchAlign('delay-b'));
          if (noInversion && invertB) { continue; };

          const tempSum = await fetchAlign('aligned-frequency-response?smoothing=Psy&ppo=96');
          // const tempSum = await fetchAlign('aligned-frequency-response?smoothing=1/2&ppo=96');
          const tempSumArray = response2array(tempSum, start, end);
          const tempMagSum = tempSumArray.reduce((acc, val) => acc + val, 0);
          if (maxSum < tempMagSum) {
            maxSum = tempMagSum;
            bestFreq = checkFreq;
            isPossible = true;
            requiredDelay = delayB;
            isInverted = invertB;
          }

          const bestDelayStr = isNaN(requiredDelay) ? "N/A" : requiredDelay.toFixed(2);
          const bestFreqStr = isNaN(bestFreq) ? "N/A" : bestFreq;
          console.infoUpdate(`Checking: @${checkFreq}Hz, Best: ${bestDelayStr}ms @${bestFreqStr}hz Inverted: ${isInverted}`);
        }

        if (isPossible) {
          const postAlignResult = await postAlign('Align IRs', bestFreq);
          const delayB = await fetchAlign('delay-b');
          requiredDelay = parseFloat(delayB);
          isInverted = await fetchAlign('invert-b');
          const measurements = await fetch_mREW();
          const mCount = Object.keys(measurements).length;
          const alignedSum = await postAlign('Aligned sum');
          const parsed = JSON.parse(alignedSum.message);
          const key = Object.keys(parsed.results)[0];
          sumIndex = parseInt(key);
          console.infoUpdate(`Optimal alignment: @${bestFreq}Hz, required delay: ${requiredDelay.toFixed(2)}ms, isInverted: ${isInverted}`);
        }
        return [isPossible, requiredDelay, isInverted, sumIndex];
      }

      async function genSub(i, freq) {
        if (freq === "L") {
          console.error("Cannot set subwoofer as LARGE!")
          throw new Error;
        }
        await postSafe(`${baseUrl}/${i}/filters`, {
          filters: [{
            "index": 21,
            "type": "Low pass",
            "enabled": true,
            "isAuto": false,
            "frequency": freq,
            "shape": "L-R",
            "slopedBPerOctave": 24
          }]
        }, "Filters set");
        return await postNext('Generate predicted measurement', i);
      }

      async function genSpeaker(i, freq) {
        if (freq === "L") {
          return await postSafe(`${baseUrl}/${i}/command`, { command: "Response copy" }, "Completed");
        }
        await postSafe(`${baseUrl}/${i}/filters`, {
          filters: [{
            "index": 21,
            "type": "High pass",
            "enabled": true,
            "isAuto": false,
            "frequency": freq,
            "shape": "BU",
            "slopedBPerOctave": 12
          }]
        }, "Filters set");
        return await postNext('Generate predicted measurement', i);
      }

      async function drawResults() {
        console.log("Generating expected final outputs for each channel...");
        console.info("Starting...");
        for (let i = 1; i <= nSpeakers; i++) {
          console.infoUpdate(`Generating final output for channel - ${commandId[i]}`);
          const isLarge = customCrossover[i] === "L";
          let finalResponseName = commandId[i] + "final";
          finalResponseName += (commandId[i] === "C" && AdvancedFilters && AdvancedFiltersType === "DIALOGadvanced") ? "-ADF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "HLOSSresearch") ? "-AHF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "HLOSSmoderate") ? "-AHF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "HLOSSsevere") ? "-AHF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "HLOSSoriginal") ? "-AHF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "GAMINGcompetitive") ? "-AGF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "GAMINGimmersive") ? "-AGF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "GAMINGvoice") ? "-AGF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "GAMINGbalanced") ? "-AGF" : "";
          finalResponseName += isLarge ? "-Large" : `-${customCrossover[i]}hz-xo`;
          const eqSpeaker = nChannels + 2 * i;
          const spWithHPF = await genSpeaker(eqSpeaker, customCrossover[i]);
          const spWithHPFIdx = (isLarge ? nChannels * 3 + i : Object.keys(spWithHPF.results)[0]);
          if (noSub) {
            await fetch_mREW(spWithHPFIdx, 'PUT', { title: finalResponseName });
            continue;
          }
          const subWithLPF = await genSub(nChannels * 3, customCrossover[i]);
          const subWithLPFIdx = Object.keys(subWithLPF.results)[0];
          const finalResponse = await postNext('Arithmetic', [spWithHPFIdx, subWithLPFIdx], { function: "A + B" });
          const finalResponseIdx = Object.keys(finalResponse.results)[0];
          await fetch_mREW(finalResponseIdx, 'PUT', { title: finalResponseName });
          await postDelete(subWithLPFIdx);
          await postDelete(spWithHPFIdx);
        }
        if (!noSub) {
          console.infoUpdate("Generating final output for channel - LFE");
          const LFEChannel = await genSub(nChannels * 3, 120);
          const LFEChannelIdx = Object.keys(LFEChannel.results)[0];
          await fetch_mREW(LFEChannelIdx, 'PUT', { title: "LFEfinal-120hz-LPF" });
        }
        // await fetchSafe('target-level', nChannels * 3, 75.0);
        await fetchSafe('target-level', nChannels * 3, targetLevel);
        const targetCurve = await postNext('Generate target measurement', nChannels * 3);
        const targetCurveIdx = Object.keys(targetCurve.results)[0];
        // const targetName = (targetCurveName === "" ? "TC-DEQ" : targetCurveName) + " @ 75dB";
        const targetName = `${targetCurveName === "" ? "TC-DEQ" : targetCurveName} @ ${String(targetLevel)}dB`;
        await fetch_mREW(targetCurveIdx, 'PUT', { title: targetName });
        // room curve no longer needed. keeping it enabled will only confuse on next run
        if (targetCurveName === "") { await disableRoomCurve(); }
        // use 1/6 smoothing for results
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i <= mCount; i++) {
          titleM = await fetch_mREW(i);
          const title = titleM.title;
          // if (title.endsWith("-filters") || title.endsWith(" @ 75dB")) { continue; }
          if (title.endsWith("-filters") || title.endsWith(` @ ${String(targetLevel)}dB`)) { continue; }
          await postNext('Smooth', i, { smoothing: "1/6" });
        }
        console.infoUpdate("Completed generating final outputs for all channels!");
      }

      async function updateAdy() {
        console.log("Starting ADY file processing...");

        function estimatePlaybackLevelSpeakers(dataView) {
          let avgSensitivity = 0;
          let count = 0;

          // Sample from middle range (mid frequencies)
          const maxSafeIndex = Math.floor(dataView.byteLength / 4) - 1;
          const startIndex = Math.min(200, maxSafeIndex);
          const endIndex = Math.min(800, maxSafeIndex);

          for (let k = startIndex; k <= endIndex; k++) {
            const value = dataView.getFloat32(k * 4);
            if (Number.isFinite(value) && Math.abs(value) < 100) {
              avgSensitivity += value;
              count++;
            }
          }

          avgSensitivity = count > 0 ? avgSensitivity / count : 0;
          return targetLevel + avgSensitivity;
        }

        function estimatePlaybackLevelSubwoofer(dataView) {
          let avgSensitivity = 0;
          let count = 0;

          // Sample from early indices (low frequencies are typically first)
          const maxSafeIndex = Math.floor(dataView.byteLength / 4) - 1;
          const endIndex = Math.min(50, maxSafeIndex); // Sample first 50 points for bass

          for (let k = 0; k <= endIndex; k++) {
            const value = dataView.getFloat32(k * 4);
            if (Number.isFinite(value) && Math.abs(value) < 100) {
              avgSensitivity += value;
              count++;
            }
          }

          avgSensitivity = count > 0 ? avgSensitivity / count : 0;
          return targetLevel + avgSensitivity;
        }

        for (let i = 1; i <= nSpeakers; i++) {
          if (customCrossover[i] === "L") { continue; };
          if (customCrossover[i] > 90) { customCrossover[i] /= 10; }
        }

        const jsonData = JSON.parse(adyContents);
        if (bassMode === "Directional") {
          let ii = 54;
          for (let i = nChannels - 1; i < jsonData.detectedChannels.length; i++) {
            const swChannel = jsonData.detectedChannels[i];
            swChannel.enChannelType = ii;
            ii++;
            if (swChannel.customCrossover) { delete swChannel.customCrossover };
            if (swChannel.customSpeakerType) { delete swChannel.customSpeakerType };
            if (swChannel.customTargetCurvePoints && (i != (nChannels - 1))) { delete swChannel.customTargetCurvePoints };
          }
        }
        jsonData.dynamicVolume = false;
        jsonData.lfc = false;
        jsonData.dynamicEq = (targetCurveName === "");
        jsonData.enTargetCurveType = 1;
        jsonData.detectedChannels.forEach((channel, index) => {
          const responseData = channel.responseData;
          const zerosArray = Array(16383).fill("0");
          zerosArray.unshift("1");
          let count = 0;
          for (const arrayKey in responseData) {
            if (responseData.hasOwnProperty(arrayKey)) {
              if (isCirrusLogic) {
                responseData[arrayKey] = antiMicCal;
              } else {
                responseData[arrayKey] = zerosArray;
              }
              if (count >= 3) {
                delete responseData[arrayKey];
              }
              count++;
            }
          }
          if (index > nSpeakers) {
            channel.responseData = {};
          }
        });

        const octave = Math.pow(2, 1 / 96);

        // Enhanced speaker processing with logging
        console.log("Processing main speakers...");

        for (let i = 1; i <= nSpeakers; i++) {
          const fltArray = [];
          const fltResponse = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', 2 * i + (nChannels - 1));
          const bytes = Uint8Array.from(atob(fltResponse.magnitude), c => c.charCodeAt(0));
          const buffer = bytes.buffer;
          const data = new DataView(buffer);

          // Estimate playback level and store in array (500-2000 Hz for speakers)
          const estimatedLevel = estimatePlaybackLevelSpeakers(data);
          console.log(`Speaker ${commandId[i]}: Estimated playback level ${estimatedLevel.toFixed(1)}dB`);

          // Store speaker ID and estimated level
          estimatedPlaybackLevels.push([commandId[i], estimatedLevel.toFixed(1)]);

          let freq = fltResponse.startFreq;
          for (let k = 0; k <= 1531; k++) {
            const fltMagnitude = data.getFloat32(k * 4);
            fltArray.push([freq, fltMagnitude + antiHFRolloff[k]]);
            freq *= octave;
          }

          // Store original values for logging
          const originalLevel = customLevel[i];
          const finalLevel = customLevel[i];

          const customTargetCurvePoints = fltArray.map(point => `{${point[0]}, ${point[1]}}`);
          const thisChannel = jsonData.detectedChannels.find(channel => channel.commandId === commandId[i]);
          thisChannel.customTargetCurvePoints = customTargetCurvePoints;
          thisChannel.midrangeCompensation = false;
          thisChannel.frequencyRangeRolloff = 20000;
          thisChannel.customLevel = customLevel[i].toFixed(1);
          thisChannel.customDistance = customDistance[i];
          thisChannel.customCrossover = customCrossover[i] === "L" ? "F" : String(customCrossover[i]);
          thisChannel.customSpeakerType = customCrossover[i] === "L" ? "L" : "S";
          thisChannel.channelReport.customEnSpeakerConnect = customCrossover[i] === "L" ? 2 : 1;

          // Enhanced logging
          console.warn(`Speaker ${commandId[i]}: FINAL TRIM VALUES: ${finalLevel.toFixed(1)}dB`);
          console.warn(`Speaker ${commandId[i]}: Distance: ${customDistance[i]}m, Crossover: ${thisChannel.customCrossover}, Type: ${thisChannel.customSpeakerType}`);
        }

        // Enhanced subwoofer processing with logging
        if (!noSub) {
          console.log("Processing subwoofer(s)...");

          const subArray = [];
          const subResponse = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', nChannels * 3 - 1);
          const bytesSub = Uint8Array.from(atob(subResponse.magnitude), c => c.charCodeAt(0));
          const bufferSub = bytesSub.buffer;
          const dataSub = new DataView(bufferSub);

          // Estimate subwoofer playback level and store in array (30-80 Hz for subwoofers)
          const subEstimatedLevel = estimatePlaybackLevelSubwoofer(dataSub);
          console.log(`Subwoofer: Estimated playback level ${subEstimatedLevel.toFixed(1)}dB`);
          estimatedPlaybackLevels.push(["Subwoofer", subEstimatedLevel.toFixed(1)]);

          let freq = subResponse.startFreq;
          for (let k = 0; k <= 1531; k++) {
            const subMagnitude = dataSub.getFloat32(k * 4);
            subArray.push([freq, subMagnitude]);
            freq *= octave;
          }
          const customTargetCurvePointsSub = subArray.map(point => `{${point[0]}, ${point[1]}}`);
          const subChannel = jsonData.detectedChannels[nChannels - 1];
          subChannel.customTargetCurvePoints = customTargetCurvePointsSub;
          let k = 0;
          for (let channel of jsonData.detectedChannels) {
            if (channel.commandId.startsWith("SW")) {
              const customDistanceValue = parseFloat(customDistance[nChannels + k]) - parseFloat(channel.delayAdjustment);
              const originalSubLevel = parseFloat(customLevel[nChannels + k]) + parseFloat(channel.trimAdjustment);
              let customLevelValue = originalSubLevel;

              channel.customDistance = Math.round(parseFloat(customDistanceValue) * 100) / 100;
              channel.customLevel = customLevelValue.toFixed(1);
              channel.frequencyRangeRolloff = 250;

              // Enhanced subwoofer logging
              console.warn(`${channel.commandId}: FINAL TRIM VALUES: ${customLevelValue.toFixed(1)}dB`);
              console.warn(`${channel.commandId}: Distance: ${channel.customDistance}m`);

              if (bassMode === "Directional") { k++ };
            }
          }
          if (bassMode === "Directional") {
            jsonData.subwooferLayout = "N/A";
            sOs === 343 ? jsonData.subwooferMode = "Standard" : jsonData.subwooferMode = "N/A";
          }
        }

        // LOG THE COLLECTED PLAYBACK LEVELS ARRAY
        console.log("Estimated Playback Levels Array:", estimatedPlaybackLevels);
        console.log("Array contents:");
        estimatedPlaybackLevels.forEach((item, index) => {
          console.log(`${index}: Speaker ${item[0]} = ${item[1]}dB`);
        });

        const ady = JSON.stringify(jsonData);
        const blob = new Blob([ady], { type: 'application/json' });
        const urlBlob = URL.createObjectURL(blob);
        var downloadLink = document.createElement("a");
        downloadLink.href = urlBlob;
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const timestamp = `${year}-${month}${day}-${hours}${minutes}`;
        const tcName = targetCurveName === "" ? "DEQ" : targetCurveName;
        downloadLink.download = getadyName(fileName, "_"
          + (AdvancedFiltersType === "DIALOGadvanced" ? "ADF_" : "")
          + (AdvancedFiltersType === "HLOSSresearch" ? "AHF_" : "")
          + (AdvancedFiltersType === "HLOSSmoderate" ? "AHF_" : "")
          + (AdvancedFiltersType === "HLOSSsevere" ? "AHF_" : "")
          + (AdvancedFiltersType === "HLOSSoriginal" ? "AHF_" : "")
          + (AdvancedFiltersType === "GAMINGcompetitive" ? "AGF_" : "")
          + (AdvancedFiltersType === "GAMINGimmersive" ? "AGF_" : "")
          + (AdvancedFiltersType === "GAMINGvoice" ? "AGF_" : "")
          + (AdvancedFiltersType === "GAMINGbalanced" ? "AGF_" : "")
          + (isRP22mode ? "RP22_" : "")
          + (isDolbymode ? "DOLBY_" : "")
          + (isTHXmode ? "THX_" : "")
          + (isIMAXmode ? "IMAX_" : "")
          + swInvMsg + `${tcName}_ClariQNext_${timestamp}.ady`);
        downloadLink.style.display = "none";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);

        console.log("Processing completed successfully!");
        console.log(`ADY file generated: ${downloadLink.download}`);

        // RETURN THE ARRAY IF NEEDED
        return estimatedPlaybackLevels;
      }

      /////////////////
      // TheCurves() //
      /////////////////
      async function TheCurves() {
        console.log("Running ClearCurve Next for Speakers...");
        let measurements = await fetch_mREW();
        const titles = {};
        let titleIndices = {};
        let mCount = Object.keys(measurements).length;
        let measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));

        // DEFINE SPEAKERS
        var BDLo; // Back Dolby Left (bounce)
        var BDRo; // Back Dolby Right (bounce)
        var Co; // Center
        var CHo; // Center Height (AURO-3D)
        var FDLo; // Front Dolby Left (bounce)
        var FDRo; // Front Dolby Right (bounce)
        var FLo; // Front Left
        var FHLo; // Front Height Left
        var FHRo; // Front Height Right
        var FWLo; // Front Wide Left
        var FWRo; // Front Wide Right
        var FRo; // Front Right
        var RHRo; // Rear Height Right
        var RHLo; // Rear Height Left
        var SBLo; // Surround Rear/Back Left
        var SBRo; // Surround Rear/Back Right
        var SLAo; // Surround Left
        var SRAo; // Surround Right
        var SBo; // Surround Back Single
        var SDLo; // Surround Dolby Left (bounce)
        var SDRo; // Surround Dolby Right (bounce)
        var SHLo; // Surround Height Left
        var SHRo; // Surround Height Right
        var TFLo; // Top Front Left
        var TFRo; // Top Front Right
        var TMLo; // Top Middle Left
        var TMRo; // Top Middle Right
        var TRLo; // Top Rear Left
        var TRRo; // Top Rear Right
        var TSo; // Top Surround (AURO-3D)
        var Curve = targetCurvePath // SpeakerCurve

        // CREATE THE CURVE FIRST
        const targetCurve = await postNext('Generate target measurement', 1);
        const targetCurveIdx = Object.keys(targetCurve.results)[0];
        const targetName = `${targetCurveName}_curve`;
        await fetch_mREW(targetCurveIdx, 'PUT', { title: targetName });
        // room curve no longer needed. keeping it enabled will only confuse on next run
        if (targetCurveName === "") { await disableRoomCurve(); }

        // Back Dolby Left (bounce)
        // Back Dolby Left (bounce)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));

        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // nname === "BDLo"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyBD,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "BDL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "BDLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("BDL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");

            var splOffsetCurve;
            var index = i;
            // endpoint for request
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            // request using the Fetch API
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                // Process the retrieved user data
                // console.log("mData:", mData);
                // console.log("mData:", mData.notes);
                // console.log("mData:", mData.title);
                // console.log("mData:", mData.splOffsetdB);
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                //// console.log("splOffsetdB", splOffsetdB);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                // console.log(match[0]);
                // console.log(match[1]);
                // console.log(match[2]);
                //// console.log("match[3]", match[3]);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                // The substituted value will be contained in the result variable
                const result = str.replace(regex, subst);
                //// console.log("Substitution result: ", result);
                //// console.log("scaled", scaled);
                //// console.log("result", result);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Back Dolby Left (bounce) DONE !!
        // Back Dolby Left (bounce) DONE !!

        // Back Dolby Right (bounce)
        // Back Dolby Right (bounce)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name === "BDRo"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyBD,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "BDR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "BDRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("BDR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");

            var splOffsetCurve;
            var index = i;
            // endpoint for request
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            // request using the Fetch API
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Back Dolby Right (bounce) DONE !!
        // Back Dolby Right (bounce) DONE !!

        // Center
        // Center
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "Co") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name === "Co"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "Co") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "Co") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyC,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "C_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "Co") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("C_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // CENTER DONE !!
        // CENTER DONE !!

        // CENTER HEIGHT (AURO-3D)
        // CENTER HEIGHT (AURO-3D)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "CHo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "CHo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "CHo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyCH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "CH_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "CHo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("CH_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // CENTER HEIGHT (AURO-3D) DONE !!
        // CENTER HEIGHT (AURO-3D) DONE !!

        // Front Dolby Left (bounce)
        // Front Dolby Left (bounce)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDLoy") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyFD,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FDL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FDLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FDL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Dolby Left (bounce) DONE !!
        // Front Dolby Left (bounce) DONE !!

        // Front Dolby Right (bounce)
        // Front Dolby Right (bounce)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name === "FDRo"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyFD,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FDR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FDRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FDR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Dolby Right (bounce) DONE !!
        // Front Dolby Right (bounce) DONE !!

        // Front Left
        // Front Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name === "FLo"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyF,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Left DONE !!
        // Front Left DONE !!

        // Front Height Left
        // Front Height Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name === "FHLo"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyFH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FHL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FHLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FHL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Height Left DONE !!
        // Front Height Left DONE !!

        // Front Height Right
        // Front Height Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyFH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FHR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FHRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FHR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Height Right DONE !!
        // Front Height Right DONE !!

        // Front Wide Left
        // Front Wide Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name === "FWLo"
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyFW,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FWL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FWLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FWL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Wide Left DONE !!
        // Front Wide Left DONE !!

        // Front Wide Right
        // Front Wide Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyFW,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FWR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FWRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FWR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Wide Right DONE !!
        // Front Wide Right DONE !!

        // Front Right
        // Front Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyF,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "FRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("FR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Front Right DONE !!
        // Front Right DONE !!

        // Rear Height Left
        // Rear Height Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyRH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "RHL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "RHLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("RHL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Rear Height Left DONE !!
        // Rear Height Left DONE !!

        // Rear Height Right
        // Rear Height Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyRH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "RHR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "RHRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("RHR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Rear Height Right DONE !!
        // Rear Height Right DONE !!

        // Surround Rear/Back Left
        // Surround Rear/Back Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySurB,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SBL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SBLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SBL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Rear/Back Left DONE !!
        // Surround Rear/Back Left DONE !!

        // Surround Rear/Back Right
        // Surround Rear/Back Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySurB,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SBR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SBRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SBR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Rear/Back Right DONE !!
        // Surround Rear/Back Right DONE !!

        // Surround Left
        // Surround Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SLAo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SLAo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SLAo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySur,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SLA_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SLAo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SLA_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Left DONE !!
        // Surround Left DONE !!

        // Surround Right
        // Surround Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SRAo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SRAo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SRAo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySur,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SRA_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SRAo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SRA_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Right DONE !!
        // Surround Right DONE !!

        // Surround Back Single
        // Surround Back Single
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySurBS,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SB_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SBo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SB_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Back Single DONE !!
        // Surround Back Single DONE !!

        // Surround Dolby Left (bounce)
        // Surround Dolby Left (bounce)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySD,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SDL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SDLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SDL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Dolby Left (bounce) DONE !!
        // Surround Dolby Left (bounce) DONE !!

        // Surround Dolby Right (bounce)
        // Surround Dolby Right (bounce)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySD,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SDR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SDRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SDR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Dolby Right (bounce) DONE !!
        // Surround Dolby Right (bounce) DONE !!

        // Surround Height Left
        // Surround Height Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SHL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SHLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SHL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Height Left DONE !!
        // Surround Height Left DONE !!

        // Surround Height Right
        // Surround Height Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencySH,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SHR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SHRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SHR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Surround Height Right DONE !!
        // Surround Height Right DONE !!

        // Top Front Left
        // Top Front Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTF,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TFL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TFLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TFL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Front Left DONE !!
        // Top Front Left DONE !!

        // Top Front Right
        // Top Front Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTF,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TFR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TFRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TFR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Front Right DONE !!
        // Top Front Right DONE !!

        // Top Middle Left
        // Top Middle Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TMLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TMLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TMLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTM,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TML_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TMLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TML_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Middle Left DONE !!
        // Top Middle Left DONE !!

        // Top Middle Right
        // Top Middle Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TMRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TMRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TMRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTM,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TMR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TMRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TMR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Middle Right DONE !!
        // Top Middle Right DONE !!

        // Top Rear Left
        // Top Rear Left
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRLo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRLo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRLo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTR,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TRL_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TRLo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TRL_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Rear Left DONE !!
        // Top Rear Left DONE !!

        // Top Rear Right
        // Top Rear Right
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRRo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRRo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRRo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTR,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TRR_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TRRo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TRR_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Rear Right DONE !!
        // Top Rear Right DONE !!

        // Top Surround (AURO-3D)
        // Top Surround (AURO-3D)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TSo") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TSo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curve") || name.endsWith("Curve") || name.toLowerCase().endsWith("CURVE".toLowerCase())) {
            Curve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TSo") {
            await postNext("Arithmetic", [i, Curve], {
              function: "Merge B to A",
              mergeFrequency: mergeFrequencyTS,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TS_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "TSo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("TS_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Top Surround (AURO-3D) DONE !!
        // Top Surround (AURO-3D) DONE !!
      }

      //////////////////////////
      // TheCurvesSubwoofer() //
      //////////////////////////
      async function TheCurvesSubwoofer() {
        console.log("Running Nvexx ClearCurve Next Subwoofer...");

        let measurements = await fetch_mREW();
        const titles = {};
        let titleIndices = {};
        let mCount = Object.keys(measurements).length;
        let measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));

        // DEFINE SPEAKERS
        var SW1o; // Subwoofer
        var SW2o; // Subwoofer
        var SW3o; // Subwoofer
        var SW4o; // Subwoofer
        var SWMIXo; // Subwoofer
        var SWMIX1o; // Subwoofer
        var SWMIX2o; // Subwoofer
        var SWMIX3o; // Subwoofer
        var SWMIX4o; // Subwoofer
        var SubCurve = targetCurvePath; // SpeakerCurve

        // CREATE THE CURVE FIRST
        const targetCurve = await postNext('Generate target measurement', 1);
        const targetCurveIdx = Object.keys(targetCurve.results)[0];
        const targetName = `${targetCurveName}_curvesub`;
        await fetch_mREW(targetCurveIdx, 'PUT', { title: targetName });
        // room curve no longer needed. keeping it enabled will only confuse on next run
        if (targetCurveName === "") { await disableRoomCurve(); }

        // Subwoofer SW1
        // Subwoofer SW1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW1o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW1o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW1o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SW1_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SW1o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SW1_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SW1 DONE !!
        // Subwoofer SW1 DONE !!

        // Subwoofer SW2
        // Subwoofer SW2
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW2o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW2o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW2o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SW2_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SW2o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SW2_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SW2 DONE !!
        // Subwoofer SW2 DONE !!

        // Subwoofer SW3
        // Subwoofer SW3
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW3o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW3o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW3o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SW3_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SW3o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SW3_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SW3 DONE !!
        // Subwoofer SW3 DONE !!

        // Subwoofer SW4
        // Subwoofer SW4
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW4o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW4o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW4o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SW4_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SW4o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SW4_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SW4 DONE !!
        // Subwoofer SW4 DONE !!

        // Subwoofer SWMIX
        // Subwoofer SWMIX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIXoy") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIXo") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIXo") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SWMIX_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SWMIXo") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SWMIX_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SWMIX DONE !!
        // Subwoofer SWMIX DONE !!

        // Subwoofer SWMIX1
        // Subwoofer SWMIX1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX1o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX1o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX1o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SWMIX1_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SWMIX1o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SWMIX1_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SWMIX1 DONE !!
        // Subwoofer SWMIX1 DONE !!

        // Subwoofer SWMIX2
        // Subwoofer SWMIX2
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX2o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX2o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX2o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SWMIX2_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SWMIX2o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SWMIX2_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SWMIX2 DONE !!
        // Subwoofer SWMIX2 DONE !!

        // Subwoofer SWMIX3
        // Subwoofer SWMIX3
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX3o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX3o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX3o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SWMIX3_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SWMIX3o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SWMIX3_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SWMIX3 DONE !!
        // Subwoofer SWMIX3 DONE !!

        // Subwoofer SWMIX4
        // Subwoofer SWMIX4
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX4o") {
            console.info("Running Curve Control for:", name);
            await fetch("http://localhost:4735/eq/default-target-level", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: Number(targetLevel).toFixed(1),
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            await fetchSafe("target-level", i, Number(targetLevel).toFixed(1), "Target level set");
            const requestOptions = {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                processName: "Align SPL",
                measurementIndices: [i],
                parameters: {
                  targetdB: 0,
                  frequencyHz: 1000,
                  spanOctaves: 1,
                },
              }),
            };
            fetch(`http://localhost:4735/measurements/process-measurements`, requestOptions);
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // name.endsWith(copy)
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX4o") {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        // GET CURVE!
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.endsWith("curvesub") || name.endsWith("CurveSub") || name.toLowerCase().endsWith("CURVESUB".toLowerCase())) {
            SubCurve = i;
          }
        }

        // Merge B to A
        // Merge B to A
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SWMIX4o") {
            await postNext("Arithmetic", [i, SubCurve], {
              function: "Merge B to A",
              mergeFrequency: sw1_filterfreq_merge,
              mergeBlend: true,
            });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SWMIX4_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("B to A at")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          if (name === "SWMIX4o") {
            await postDelete(q);
            await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name.startsWith("SWMIX4_Crv")) {
            console.info(name, "start 1/1 smoothing");
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
            console.info(name, "smoothing 1/1 done");
            var splOffsetCurve;
            var index = i;
            const apiUrl = `http://localhost:4735/measurements/${index}`;
            fetch(apiUrl)
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Network response was not ok");
                }
                return response.json();
              })
              .then((mData) => {
                const splOffsetdB = mData.splOffsetdB.toFixed(1);
                const notes = mData.notes;
                const regexp = /(.*)(B was scaled by\s)(.*[^dB\s])/;
                const match = notes.match(regexp);
                const scaled = match[3];
                const regex = new RegExp(",", "gmi");
                const str = scaled;
                const subst = `.`;
                const result = str.replace(regex, subst);
                splOffsetCurve = parseFloat(splOffsetdB) + parseFloat(result);
                console.log("spl Offset Curve for:", name, parseFloat(splOffsetCurve).toFixed(1));
                const requestOptions = {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    command: "Add SPL offset",
                    parameters: {
                      offset: -splOffsetCurve,
                    },
                  }),
                };
                fetch(`http://localhost:4735/measurements/${index}/command`, requestOptions);
              })
              .catch((error) => {
                console.error("Error:", error);
              });
          }
        }
        // Subwoofer SWMIX4 DONE !!
        // Subwoofer SWMIX4 DONE !!
      }

      ////////////////////
      // TheCurvesAvg() //
      ////////////////////
      async function TheCurvesAvg() {
        console.log("Running ClearCurve Next Averages...");

        let measurements = await fetch_mREW();
        const titles = {};
        let titleIndices = {};
        let mCount = Object.keys(measurements).length;
        let measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));

        // DEFINE SPEAKERS
        var BDLo; // Back Dolby Left (bounce)
        var BDRo; // Back Dolby Right (bounce)
        var Co; // Center
        var CHo; // Center Height (AURO-3D)
        var FDLo; // Front Dolby Left (bounce)
        var FDRo; // Front Dolby Right (bounce)
        var FLo; // Front Left
        var FHLo; // Front Height Left
        var FHRo; // Front Height Right
        var FWLo; // Front Wide Left
        var FWRo; // Front Wide Right
        var FRo; // Front Right
        var RHRo; // Rear Height Right
        var RHLo; // Rear Height Left
        var SBLo; // Surround Rear/Back Left
        var SBRo; // Surround Rear/Back Right
        var SLAo; // Surround Left
        var SRAo; // Surround Right
        var SBo; // Surround Back Single
        var SDLo; // Surround Dolby Left (bounce)
        var SDRo; // Surround Dolby Right (bounce)
        var SHLo; // Surround Height Left
        var SHRo; // Surround Height Right
        var TFLo; // Top Front Left
        var TFRo; // Top Front Right
        var TMLo; // Top Middle Left
        var TMRo; // Top Middle Right
        var TRLo; // Top Rear Left
        var TRRo; // Top Rear Right
        var TSo; // Top Surround (AURO-3D)
        var Curve = targetCurvePath; // SpeakerCurve 
        //
        var BDLoBDRo; // Back Dolby comb curve
        var BDLoCurve; // Back Dolby L
        var BDRoCurve; // Back Dolby R
        var BDLoBDRoRMSCurve; // Back Dolby

        var FDLoFDRo; // Front Dolby comb curve
        var FDLoCurve; // Front Dolby L
        var FDRoCurve; // Front Dolby R
        var FDLoFDRoRMSCurve; // Back Dolby

        var FLoFRo; // Front Left & Right comb curve
        var FLoCurve; // Front Left & Right
        var FRoCurve; // Front Left & Right
        var FLoFRoRMSCurve; // Front Left & Right

        var FHLoFHRo; // Front Height comb curve
        var FHLoCurve; // Front Height
        var FHRoCurve; // Front Height
        var FHLoFHRoRMSCurve; // Front Height

        var FWLoFWRo; // Front Wide comb curve
        var FWLoCurve; // Front Wide
        var FWRoCurve; // Front Wide
        var FWLoFWRoRMSCurve; // Front Wide

        var RHRoRHLo; // Rear Height comb curve
        var RHLoCurve; // Rear Height
        var RHRoCurve; // Rear Height
        var RHRoRHLoRMSCurve; // Rear Height

        var SBLoSBRo; // Surround Rear/Back comb curve
        var SBLoCurve; // Surround Rear/Back
        var SBRoCurve; // Surround Rear/Back
        var SBLoSBRoRMSCurve; // Surround Rear/Back

        var SLAoSRAo; // Surround comb curve
        var SLAoCurve; // Surround
        var SRAoCurve; // Surround
        var SLAoSRAoRMSCurve; // Surround

        var SDLoSDRo; // Surround Dolby comb curve
        var SDLoCurve; // Surround Dolby
        var SDRoCurve; // Surround Dolby
        var SDLoSDRoRMSCurve; // Surround Dolby

        var SHLoSHRo; // Surround Height comb curve
        var SHLoCurve; // Surround Height
        var SHRoCurve; // Surround Height
        var SHLoSHRoRMSCurve; // Surround Height

        var TFLoTFRo; // Top Front comb curve
        var TFLoCurve; // Top Front
        var TFRoCurve; // Top Front
        var TFLoTFRoRMSCurve; // Top Front

        var TMLoTMRo; // Top Middle comb curve
        var TMLoCurve; // Top Middle
        var TMRoCurve; // Top Middle
        var TMLoTMRoRMSCurve; // Top Middle

        var TRLoTRRo; // Top Rear comb curve
        var TRLoCurve; // Top Rear
        var TRRoCurve; // Top Rear
        var TRLoTRRoRMSCurve; // Top Rear

        var CoCurve; // Center Curve
        var FLoAndFroCurve; // FL+FR_RMSAVG_Crv

        // GET ALL INDEXES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // BACK DOLBY
          if (name === "BDLo") {
            BDLo = i;
            console.warn("BDLo Index:", BDLo);
          }
          if (name === "BDRo") {
            BDRo = i;
            console.warn("BDRo Index:", BDRo);
          }
          // FRONT DOLBY
          if (name === "FDLo") {
            FDLo = i;
            console.warn("FDLo Index:", FDLo);
          }
          if (name === "FDRo") {
            FDRo = i;
            console.warn("FDRo Index:", FDRo);
          }
          // FRONT HEIGHT
          if (name === "FHLo") {
            FHLo = i;
            console.warn("FHLo Index:", FHLo);
          }
          if (name === "FHRo") {
            FHRo = i;
            console.warn("FHRo Index:", FHRo);
          }
          // FRONT WIDE
          if (name === "FWLo") {
            FWLo = i;
            console.warn("FWLo Index:", FWLo);
          }
          if (name === "FWRo") {
            FWRo = i;
            console.warn("FWRo Index:", FWRo);
          }
          // FRONT LEFT - FRONT RIGHT
          if (name === "FLo") {
            FLo = i;
            console.warn("FLo Index:", FLo);
          }
          if (name === "FRo") {
            FRo = i;
            console.warn("FRo Index:", FRo);
          }
          // REAR HEIGHT
          if (name === "RHRo") {
            RHRo = i;
            console.warn("RHRo Index:", RHRo);
          }
          if (name === "RHLo") {
            RHLo = i;
            console.warn("RHLo Index:", RHLo);
          }
          // SURROUND BACK
          if (name === "SBLo") {
            SBLo = i;
            console.warn("SBLo Index:", SBLo);
          }
          if (name === "SBRo") {
            SBRo = i;
            console.warn("SBRo Index:", SBRo);
          }
          // SURROUND
          if (name === "SLAo") {
            SLAo = i;
            console.warn("SLAo Index:", SLAo);
          }
          if (name === "SRAo") {
            SRAo = i;
            console.warn("SRAo Index:", SRAo);
          }
          // SURROUND DOLBY
          if (name === "SDLo") {
            SDLo = i;
            console.warn("SDLo Index:", SDLo);
          }
          if (name === "SDRo") {
            SDRo = i;
            console.warn("SDRo Index:", SDRo);
          }
          // SURROUND HEIGHT
          if (name === "SHLo") {
            SHLo = i;
            console.warn("SHLo Index:", SHLo);
          }
          if (name === "SHRo") {
            SHRo = i;
            console.warn("SHRo Index:", SHRo);
          }
          // TOP FRONT
          if (name === "TFLo") {
            TFLo = i;
            console.warn("TFLo Index:", TFLo);
          }
          if (name === "TFRo") {
            TFRo = i;
            console.warn("TFRo Index:", TFRo);
          }
          // TOP MIDDLE
          if (name === "TMLo") {
            TMLo = i;
            console.warn("TMLo Index:", TMLo);
          }
          if (name === "TMRo") {
            TMRo = i;
            console.warn("TMRo Index:", TMRo);
          }
          // TOP REAR
          if (name === "TRLo") {
            TRLo = i;
            console.warn("TRLo Index:", TRLo);
          }
          if (name === "TRRo") {
            TRRo = i;
            console.warn("TRRo Index:", TRRo);
          }
        }
        // debugger;

        // Back Dolby AVG > START
        // Back Dolby AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (BDLo && BDRo && typeof BDLo === 'number' && typeof BDRo === 'number') {
          // await postNext("Vector average", [BDLo, BDRo]);
          await postNext("Magn plus phase average", [BDLo, BDRo]);
        }
        // debugger;

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }
        // debugger;

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "BDL+BDR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG BDL+BDR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "BDL+BDR_AVG_Crv") {
            BDLoBDRo = i;
            //// console.warn("BDLoBDRo Index:", BDLoBDRo);
          }
        }

        // GET FL and FR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // BackDolbyLeft_Crv* + BackDolbyRight_Crv*
          if (name.startsWith("BDL_Crv")) {
            BDLoCurve = i;
            //// console.warn("BDLoCurve Index:", BDLoCurve);
          }
          if (name.startsWith("BDR_Crv")) {
            BDRoCurve = i;
            //// console.warn("BDRoCurve Index:", BDRoCurve);
          }
        }

        // MAKE AVG RMS
        if (BDLoCurve && BDRoCurve && typeof BDLoCurve === 'number' && typeof BDRoCurve === 'number') {
          await postNext("RMS average", [BDLoCurve, BDRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "BDL+BDR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between BDL + BDR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Back Dolby AVG > DONE
        // Back Dolby AVG > DONE

        // FrontDolby AVG > START
        // FrontDolby AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        // if (FDLo != 0 && FDRo != 0) {
        if (FDLo && FDRo && typeof FDLo === 'number' && typeof FDRo === 'number') {
          // await postNext("Vector average", [FDLo, FDRo]);
          await postNext("Magn plus phase average", [FDLo, FDRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FDL+FDR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG FDL+FDR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FDL+FDR_AVG_Crv") {
            FDLoFDRo = i;
            //// console.warn("FDLoFDRo Index:", FDLoFDRo);
          }
        }

        // GET FDL and FDR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // FrontDolbyLeft_Crv* + FrontDolbyRight_Crv*
          if (name.startsWith("FDL_Crv")) {
            FDLoCurve = i;
            //// console.warn("FDLoCurve Index:", FDLoCurve);
          }
          if (name.startsWith("FDR_Crv")) {
            FDRoCurve = i;
            //// console.warn("FDRoCurve Index:", FDRoCurve);
          }
        }

        // MAKE AVG RMS
        if (FDLoCurve && FDRoCurve && typeof FDLoCurve === 'number' && typeof FDRoCurve === 'number') {
          await postNext("RMS average", [FDLoCurve, FDRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FDL+FDR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between FDL + FDR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // FrontDolby AVG > DONE
        // FrontDolby AVG > DONE

        // FRONTS LEFT & FRONT RIGHT AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        // if (FLo != 0 && FRo != 0) {
        if (FLo && FRo && typeof FLo === 'number' && typeof FRo === 'number') {
          // await postNext("Vector average", [FLo, FRo]);
          await postNext("Magn plus phase average", [FLo, FRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FL+FR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG FL+FR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FL+FR_AVG_Crv") {
            FLoFRo = i;
            //// console.warn("FLoFRo Index:", FLoFRo);
          }
        }

        // GET FL and FR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // FrontLeft_Crv* + FrontRight_Crv*
          if (name.startsWith("FL_Crv")) {
            FLoCurve = i;
            //// console.warn("FLoCurve Index:", FLoCurve);
          }
          if (name.startsWith("FR_Crv")) {
            FRoCurve = i;
            //// console.warn("FRoCurve Index:", FRoCurve);
          }
        }

        // MAKE AVG RMS
        if (FLoCurve && FRoCurve && typeof FLoCurve === 'number' && typeof FRoCurve === 'number') {
          await postNext("RMS average", [FLoCurve, FRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FL+FR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between FL + FR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // FRONTS LEFT & FRONT RIGHT AVG > DONE

        // Front Height AVG > START
        // Front Height AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        // if (FHLo != 0 && FHRo != 0) {
        if (FHLo && FHRo && typeof FHLo === 'number' && typeof FHRo === 'number') {
          // await postNext("Vector average", [FHLo, FHRo]);
          await postNext("Magn plus phase average", [FHLo, FHRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FHL+FHR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG FHL+FHR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FHL+FHR_AVG_Crv") {
            FHLoFHRo = i;
            //// console.warn("FHLoFHRo Index:", FHLoFHRo);
          }
        }

        // GET FHL and FHR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // FrontHeightLeft_Crv* + FrontHeightRight_Crv*
          if (name.startsWith("FHL_Crv")) {
            FHLoCurve = i;
            //// console.warn("FHLoCurve Index:", FHLoCurve);
          }
          if (name.startsWith("FHR_Crv")) {
            FHRoCurve = i;
            //// console.warn("FHRoCurve Index:", FHRoCurve);
          }
        }

        // MAKE AVG RMS
        if (FHLoCurve && FHRoCurve && typeof FHLoCurve === 'number' && typeof FHRoCurve === 'number') {
          await postNext("RMS average", [FHLoCurve, FHRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FHL+FHR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between FHL + FHR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Front Height AVG > DONE
        // Front Height AVG > DONE

        // Front Wide AVG > START
        // Front Wide AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (FWLo && FWRo && typeof FWLo === 'number' && typeof FWRo === 'number') {
          // await postNext("Vector average", [FWLo, FWRo]);
          await postNext("Magn plus phase average", [FWLo, FWRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FWL+FWR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG FWL+FWR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "FWL+FWR_AVG_Crv") {
            FWLoFWRo = i;
            //// console.warn("FWLoFWRo Index:", FWLoFWRo);
          }
        }

        // GET FWL and FWR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // FrontWideLeft_Crv* + FrontWideRight_Crv*
          if (name.startsWith("FWL_Crv")) {
            FWLoCurve = i;
            //// console.warn("FWLoCurve Index:", FWLoCurve);
          }
          if (name.startsWith("FWR_Crv")) {
            FWRoCurve = i;
            //// console.warn("FWRoCurve Index:", FWRoCurve);
          }
        }

        // MAKE AVG RMS
        if (FWLoCurve && FWRoCurve && typeof FWLoCurve === 'number' && typeof FWRoCurve === 'number') {
          await postNext("RMS average", [FWLoCurve, FWRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "FWL+FWR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between FWL + FWR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Front Wide AVG > DONE
        // Front Wide AVG > DONE

        // Rear Height AVG > START
        // Rear Height AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (RHLo && RHRo && typeof RHLo === 'number' && typeof RHRo === 'number') {
          // await postNext("Vector average", [RHLo, RHRo]);
          await postNext("Magn plus phase average", [RHLo, RHRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "RHL+RHR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG RHL+RHR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "RHL+RHR_AVG_Crv") {
            RHLoRHRo = i;
            //// console.warn("RHLoRHRo Index:", RHLoRHRo);
          }
        }

        // GET RHL and RHR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // RearHeightLeft_Crv* + RearHeightRight_Crv*
          if (name.startsWith("RHL_Crv")) {
            RHLoCurve = i;
            //// console.warn("RHLoCurve Index:", RHLoCurve);
          }
          if (name.startsWith("RHR_Crv")) {
            RHRoCurve = i;
            //// console.warn("RHRoCurve Index:", RHRoCurve);
          }
        }

        // MAKE AVG RMS
        if (RHLoCurve && RHRoCurve && typeof RHLoCurve === 'number' && typeof RHRoCurve === 'number') {
          await postNext("RMS average", [RHLoCurve, RHRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "RHL+RHR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between RHL + RHR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Rear Height AVG > DONE
        // Rear Height AVG > DONE

        // Surround Rear/Back AVG > START
        // Surround Rear/Back AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (SBLo && SBRo && typeof SBLo === 'number' && typeof SBRo === 'number') {
          // await postNext("Vector average", [SBLo, SBRo]);
          await postNext("Magn plus phase average", [SBLo, SBRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SBL+SBR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG SBL+SBR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SBL+SBR_AVG_Crv") {
            SBLoSBRo = i;
            //// console.warn("SBLoSBRo Index:", SBLoSBRo);
          }
        }

        // GET SBL and SBR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // SurroundBackLeft_Crv* + SurroundBackRight_Crv*
          if (name.startsWith("SBL_Crv")) {
            SBLoCurve = i;
            //// console.warn("SBLoCurve Index:", SBLoCurve);
          }
          if (name.startsWith("SBR_Crv")) {
            SBRoCurve = i;
            //// console.warn("SBRoCurve Index:", SBRoCurve);
          }
        }

        // MAKE AVG RMS
        if (SBLoCurve && SBRoCurve && typeof SBLoCurve === 'number' && typeof SBRoCurve === 'number') {
          await postNext("RMS average", [SBLoCurve, SBRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SBL+SBR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between SBL + SBR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Surround Rear/Back AVG > DONE
        // Surround Rear/Back AVG > DONE

        // Surround AVG > START
        // Surround AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (SLAo && SRAo && typeof SLAo === 'number' && typeof SRAo === 'number') {
          // await postNext("Vector average", [SLAo, SRAo]);
          await postNext("Magn plus phase average", [SLAo, SRAo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SLA+SRA_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG SLA+SRA_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SLA+SRA_AVG_Crv") {
            SLAoSRAo = i;
            //// console.warn("SLAoSRAo Index:", SLAoSRAo);
          }
        }

        // GET SLA and SRA CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // SurroundLeft_Crv* + SurroundRight_Crv*
          if (name.startsWith("SLA_Crv")) {
            SLAoCurve = i;
            //// console.warn("SLAoCurve Index:", SLAoCurve);
          }
          if (name.startsWith("SRA_Crv")) {
            SRAoCurve = i;
            //// console.warn("SRAoCurve Index:", SRAoCurve);
          }
        }

        // MAKE AVG RMS
        if (SLAoCurve && SRAoCurve && typeof SLAoCurve === 'number' && typeof SRAoCurve === 'number') {
          await postNext("RMS average", [SLAoCurve, SRAoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SLA+SRA_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between SLA + SRA",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Surround AVG > DONE
        // Surround AVG > DONE

        // Surround Dolby AVG > START
        // Surround Dolby AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (SDLo && SDRo && typeof SDLo === 'number' && typeof SDRo === 'number') {
          // await postNext("Vector average", [SDLo, SDRo]);
          await postNext("Magn plus phase average", [SDLo, SDRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SDL+SDR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG SDL+SDR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SDL+SDR_AVG_Crv") {
            SDLoSDRo = i;
            //// console.warn("SDLoSDRo Index:", SDLoSDRo);
          }
        }

        // GET SDL and SDR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // SurroundDolbyLeft_Crv* + SurroundDolbyRight_Crv*
          if (name.startsWith("SDL_Crv")) {
            SDLoCurve = i;
            //// console.warn("SDLoCurve Index:", SDLoCurve);
          }
          if (name.startsWith("SDR_Crv")) {
            SDRoCurve = i;
            //// console.warn("SDRoCurve Index:", SDRoCurve);
          }
        }

        // MAKE AVG RMS
        if (SDLoCurve && SDRoCurve && typeof SDLoCurve === 'number' && typeof SDRoCurve === 'number') {
          await postNext("RMS average", [SDLoCurve, SDRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SDL+SDR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between SDL + SDR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Surround Dolby AVG > DONE
        // Surround Dolby AVG > DONE

        // Surround Height AVG > START
        // Surround Height AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (SHLo && SHRo && typeof SHLo === 'number' && typeof SHRo === 'number') {
          // await postNext("Vector average", [SHLo, SHRo]);
          await postNext("Magn plus phase average", [SHLo, SHRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SHL+SHR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG SHL+SHR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SHL+SHR_AVG_Crv") {
            SHLoSHRo = i;
            //// console.warn("SHLoSHRo Index:", SHLoSHRo);
          }
        }

        // GET SHL and SHR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // SurroundHeightLeft_Crv* + SurroundHeightRight_Crv*
          if (name.startsWith("SHL_Crv")) {
            SHLoCurve = i;
            //// console.warn("SHLoCurve Index:", SHLoCurve);
          }
          if (name.startsWith("SHR_Crv")) {
            SHRoCurve = i;
            //// console.warn("SHRoCurve Index:", SHRoCurve);
          }
        }

        // MAKE AVG RMS
        if (SHLoCurve && SHRoCurve && typeof SHLoCurve === 'number' && typeof SHRoCurve === 'number') {
          await postNext("RMS average", [SHLoCurve, SHRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "SHL+SHR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between SHL + SHR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Surround Height AVG > DONE
        // Surround Height AVG > DONE

        // Top Front AVG > START
        // Top Front AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (TFLo && TFRo && typeof TFLo === 'number' && typeof TFRo === 'number') {
          // await postNext("Vector average", [TFLo, TFRo]);
          await postNext("Magn plus phase average", [TFLo, TFRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TFL+TFR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG TFL+TFR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TFL+TFR_AVG_Crv") {
            TFLoTFRo = i;
            //// console.warn("TFLoTFRo Index:", TFLoTFRo);
          }
        }

        // GET TFL and TFR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // TopFrontLeft_Crv* + TopFrontRight_Crv*
          if (name.startsWith("TFL_Crv")) {
            TFLoCurve = i;
            //// console.warn("TFLoCurve Index:", TFLoCurve);
          }
          if (name.startsWith("TFR_Crv")) {
            TFRoCurve = i;
            //// console.warn("TFRoCurve Index:", TFRoCurve);
          }
        }

        // MAKE AVG RMS
        if (TFLoCurve && TFRoCurve && typeof TFLoCurve === 'number' && typeof TFRoCurve === 'number') {
          await postNext("RMS average", [TFLoCurve, TFRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TFL+TFR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between TFL + TFR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Top Front AVG > DONE
        // Top Front AVG > DONE

        // Top Middle AVG > START
        // Top Middle AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (TMLo && TMRo && typeof TMLo === 'number' && typeof TMRo === 'number') {
          // await postNext("Vector average", [TMLo, TMRo]);
          await postNext("Magn plus phase average", [TMLo, TMRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TML+TMR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG TML+TMR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TML+TMR_AVG_Crv") {
            TMLoTMRo = i;
            //// console.warn("TMLoTMRo Index:", TMLoTMRo);
          }
        }

        // GET TML and TMR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // TopMiddleLeft_Crv* + TopMiddleRight_Crv*
          if (name.startsWith("TML_Crv")) {
            TMLoCurve = i;
            //// console.warn("TMLoCurve Index:", TMLoCurve);
          }
          if (name.startsWith("TMR_Crv")) {
            TMRoCurve = i;
            //// console.warn("TMRoCurve Index:", TMRoCurve);
          }
        }

        // MAKE AVG RMS
        if (TMLoCurve && TMRoCurve && typeof TMLoCurve === 'number' && typeof TMRoCurve === 'number') {
          await postNext("RMS average", [TMLoCurve, TMRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TML+TMR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between TML + TMR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Top Middle AVG > DONE
        // Top Middle AVG > DONE

        // Top Rear AVG > START
        // Top Rear AVG > START
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        if (TRLo && TRRo && typeof TRLo === 'number' && typeof TRRo === 'number') {
          // await postNext("Vector average", [TRLo, TRRo]);
          await postNext("Magn plus phase average", [TRLo, TRRo]);
        }

        // name.endsWith(copy)1
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // if (name.endsWith("Vector average")) {
          if (name.startsWith("RMS Average")) {
            await postNext("Smooth", i, { smoothing: "1/1" });
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
        }

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TRL+TRR_AVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("Vector average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        // GET AVG TRL+TRR_AVG_Crv INDEX
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "TRL+TRR_AVG_Crv") {
            TRLoTRRo = i;
            //// console.warn("TRLoTRRo Index:", TRLoTRRo);
          }
        }

        // GET TRL and TRR CURVES
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          // TopRearLeft_Crv* + TopRearRight_Crv*
          if (name.startsWith("TRL_Crv")) {
            TRLoCurve = i;
            //// console.warn("TRLoCurve Index:", TRLoCurve);
          }
          if (name.startsWith("TRR_Crv")) {
            TRRoCurve = i;
            //// console.warn("TRRoCurve Index:", TRRoCurve);
          }
        }

        // MAKE AVG RMS
        if (TRLoCurve && TRRoCurve && typeof TRLoCurve === 'number' && typeof TRRoCurve === 'number') {
          await postNext("RMS average", [TRLoCurve, TRRoCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "TRL+TRR_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between TRL + TRR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // Top Rear AVG > DONE
        // Top Rear AVG > DONE

        // CENTER OPTIMIZED AVG
        // CENTER OPTIMIZED AVG
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;

          if (name.startsWith("C_Crv")) {
            CoCurve = i;
            //// console.warn("CoCurve Index:", CoCurve);
          }
          if (name.startsWith("FL+FR_RMSAVG_Crv")) {
            FLoAndFroCurve = i;
            //// console.warn("FLoAndFroCurve Index:", FLoAndFroCurve);
          }
        }

        // MAKE AVG RMS
        if (TRLoCurve && TRRoCurve && typeof TRLoCurve === 'number' && typeof TRRoCurve === 'number') {
          await postNext("RMS average", [CoCurve, FLoAndFroCurve]);
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "C_OPT_RMSAVG_Crv" + Number(targetLevel).toFixed(0) + "dB";
          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between C + FL + FR",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // CENTER OPTIMIZED AVG > DONE
        // CENTER OPTIMIZED AVG > DONE

        // debugger;
        // ALL OPTIMIZED AVG
        // ALL OPTIMIZED AVG
        var hasBDL_Crv;
        var hasBDR_Crv;
        var hasC_Crv;
        var hasCH_Crv;
        var hasFDL_Crv;
        var hasFDR_Crv;
        var hasFL_Crv;
        var hasFHL_Crv;
        var hasFHR_Crv;
        var hasFWL_Crv;
        var hasFWR_Crv;
        var hasFR_Crv;
        var hasRHL_Crv;
        var hasRHR_Crv;
        var hasSBL_Crv;
        var hasSBR_Crv;
        var hasSLA_Crv;
        var hasSRA_Crv;
        var hasSB_Crv;
        var hasSDL_Crv;
        var hasSDR_Crv;
        var hasSHL_Crv;
        var hasSHR_Crv;
        var hasTFL_Crv;
        var hasTFR_Crv;
        var hasTML_Crv;
        var hasTMR_Crv;
        var hasTRL_Crv;
        var hasTRR_Crv;
        var hasTS_Crv;
        var hasSW1_Crv;
        var hasSWMIX1_Crv;

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        const allarray = [];
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;

          if (name.startsWith("BDL_Crv")) {
            hasBDL_Crv = i;
            allarray.push(hasBDL_Crv);
          }
          if (name.startsWith("BDR_Crv")) {
            hasBDR_Crv = i;
            allarray.push(hasBDR_Crv);
          }
          if (name.startsWith("C_Crv")) {
            hasC_Crv = i;
            allarray.push(hasC_Crv);
          }
          if (name.startsWith("CH_Crv")) {
            hasCH_Crv = i;
            allarray.push(hasCH_Crv);
          }
          if (name.startsWith("FDL_Crv")) {
            hasFDL_Crv = i;
            allarray.push(hasFDL_Crv);
          }
          if (name.startsWith("FDR_Crv")) {
            hasFDR_Crv = i;
            allarray.push(hasFDR_Crv);
          }
          if (name.startsWith("FL_Crv")) {
            hasFL_Crv = i;
            allarray.push(hasFL_Crv);
          }
          if (name.startsWith("FHL_Crv")) {
            hasFHL_Crv = i;
            allarray.push(hasFHL_Crv);
          }
          if (name.startsWith("FHR_Crv")) {
            hasFHR_Crv = i;
            allarray.push(hasFHR_Crv);
          }
          if (name.startsWith("FWL_Crv")) {
            hasFWL_Crv = i;
            allarray.push(hasFWL_Crv);
          }
          if (name.startsWith("FWR_Crv")) {
            hasFWR_Crv = i;
            allarray.push(hasFWR_Crv);
          }
          if (name.startsWith("FR_Crv")) {
            hasFR_Crv = i;
            allarray.push(hasFR_Crv);
          }
          if (name.startsWith("RHL_Crv")) {
            hasRHL_Crv = i;
            allarray.push(hasRHL_Crv);
          }
          if (name.startsWith("RHR_Crv")) {
            hasRHR_Crv = i;
            allarray.push(hasRHR_Crv);
          }
          if (name.startsWith("SBL_Crv")) {
            hasSBL_Crv = i;
            allarray.push(hasSBL_Crv);
          }
          if (name.startsWith("SBR_Crv")) {
            hasSBR_Crv = i;
            allarray.push(hasSBR_Crv);
          }
          if (name.startsWith("SLA_Crv")) {
            hasSLA_Crv = i;
            allarray.push(hasSLA_Crv);
          }
          if (name.startsWith("SRA_Crv")) {
            hasSRA_Crv = i;
            allarray.push(hasSRA_Crv);
          }
          if (name.startsWith("SB_Crv")) {
            hasSB_Crv = i;
            allarray.push(hasSB_Crv);
          }
          if (name.startsWith("SDL_Crv")) {
            hasSDL_Crv = i;
            allarray.push(hasSDL_Crv);
          }
          if (name.startsWith("SDR_Crv")) {
            hasSDR_Crv = i;
            allarray.push(hasSDR_Crv);
          }
          if (name.startsWith("SHL_Crv")) {
            hasSHL_Crv = i;
            allarray.push(hasSHL_Crv);
          }
          if (name.startsWith("SHR_Crv")) {
            hasSHR_Crv = i;
            allarray.push(hasSHR_Crv);
          }
          if (name.startsWith("TFL_Crv")) {
            hasTFL_Crv = i;
            allarray.push(hasTFL_Crv);
          }
          if (name.startsWith("TFR_Crv")) {
            hasTFR_Crv = i;
            allarray.push(hasTFR_Crv);
          }
          if (name.startsWith("TML_Crv")) {
            hasTML_Crv = i;
            allarray.push(hasTML_Crv);
          }
          if (name.startsWith("TMR_Crv")) {
            hasTMR_Crv = i;
            allarray.push(hasTMR_Crv);
          }
          if (name.startsWith("TRL_Crv")) {
            hasTRL_Crv = i;
            allarray.push(hasTRL_Crv);
          }
          if (name.startsWith("TRR_Crv")) {
            hasTRR_Crv = i;
            allarray.push(hasTRR_Crv);
          }
          if (name.startsWith("TS_Crv")) {
            hasTS_Crv = i;
            allarray.push(hasTS_Crv);
          }
          if (name.startsWith("SW1_Crv")) {
            hasSW1_Crv = i;
          }
          if (name.startsWith("SW2_Crv")) {
            hasSW2_Crv = i;
          }
          if (name.startsWith("SW3_Crv")) {
            hasSW3_Crv = i;
          }
          if (name.startsWith("SW4_Crv")) {
            hasSW4_Crv = i;
          }
          if (name.startsWith("SWMIX_Crv")) {
            hasSWMIX_Crv = i;
          }
          if (name.startsWith("SWMIX1_Crv")) {
            hasSWMIX1_Crv = i;
          }
          if (name.startsWith("SWMIX2_Crv")) {
            hasSWMIX2_Crv = i;
          }
          if (name.startsWith("SWMIX3_Crv")) {
            hasSWMIX3_Crv = i;
          }
          if (name.startsWith("SWMIX4_Crv")) {
            hasSWMIX4_Crv = i;
          }
        }
        var myJsonString = JSON.stringify(allarray);
        await postNext(
          "RMS average",
          allarray,
        );
        await new Promise((resolve) => setTimeout(resolve, speedDelay));

        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let q = 1; q <= mCount; q++) {
          const name = measurements[q].title;
          const newname = "HOUSE_Crv" + Number(targetLevel).toFixed(0) + "dB";

          if (name.startsWith("RMS Average")) {
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                title: newname,
                notes: "Optimized curve average between all speakers excluding subwoofer",
              }),
            };
            fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
          }
        }
        await new Promise((resolve) => setTimeout(resolve, speedDelay));
        // ALL OPTIMIZED AVG > DONE
        // ALL OPTIMIZED AVG > DONE
      }

      /////////////////////////
      // TheCurvesAvgClean() //
      /////////////////////////
      async function TheCurvesClean() {
        // debugger;
        console.log("Cleaning some curves and leftovers.");

        let measurements = await fetch_mREW();
        const titles = {};
        let titleIndices = {};
        let mCount = Object.keys(measurements).length;
        let measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));

        // start removing?
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        measurementArray = Object.keys(measurements).map((key) => ({
          index: parseInt(key),
          title: measurements[key].title,
        }));
        for (let i = mCount; i >= 1; i--) {
          if (measurements[i] && measurements[i].title) {
            const name = measurements[i].title;
            if (!name.includes("ALL_") && !name.includes("_Crv") && !name.includes("curve")) {
              try {
                await postDelete(i);
                await new Promise((resolve) => setTimeout(resolve, speedDelay));
              } catch (error) {
                console.error(`Failed to delete measurement ${i}:`, error);
              }
            } else {
              await postNext("Smooth", i, { smoothing: "1/1" });
              await new Promise((resolve) => setTimeout(resolve, speedDelay / 4));
            }
          }
        }
        console.info("Cleaning done...");
        console.warn("‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì");
        console.warn("Your House curve is ready for use...");
        console.warn("Go to the [ALl SPL] tab in REW >> right click somewhere on the screen");
        console.warn("and choose 'Export as txt'");
        console.warn("Be sure to check the box that says 'Do not include any comments or headers in the export'");
        console.warn("‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë");
      }

      // Enhanced fetch_mREW with better error handling
      async function fetch_mREW(indice = null, method = 'GET', _body = null) {
        await platformDelay();

        let body;
        let requestUrl;

        if (indice === null) {
          requestUrl = baseUrl;
        } else {
          requestUrl = baseUrl + `/${indice}`;
        }

        if (method === 'PUT') {
          body = _body;
        }

        const maxRetries = 10; // Prevent infinite loops
        let retryCount = 0;

        while (retryCount < maxRetries) {
          try {
            const response = await safeFetch(requestUrl, {
              method: method,
              headers: { 'Content-Type': 'application/json' },
              body: body ? JSON.stringify(body) : null
            });

            if (!response.ok) {
              retryCount++;
              if (retryCount >= maxRetries) {
                throw new Error(`Max retries reached. Status: ${response.status}`);
              }
              await new Promise(resolve => setTimeout(resolve, retryDelay));
            } else {
              const data = await response.json();
              return data;
            }
          } catch (error) {
            retryCount++;
            if (retryCount >= maxRetries) {
              throw new Error(`Network error after ${maxRetries} attempts: ${error.message}`);
            }
            await new Promise(resolve => setTimeout(resolve, retryDelay));
          }
        }
      }

      // Enhanced fetchSafe with better cross-browser support
      async function fetchSafe(extUrl, indice, parameters = null) {
        await platformDelay();

        const requestUrl = `${baseUrl}/${indice}/${extUrl}`;
        let options;

        if (parameters === null) {
          options = {
            method: 'GET'
          };
        } else {
          options = {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(parameters)
          };
        }

        const maxRetries = 10;
        let retryCount = 0;

        while (retryCount < maxRetries) {
          try {
            const response = await safeFetch(requestUrl, options);

            if (!response.ok) {
              retryCount++;
              if (retryCount >= maxRetries) {
                throw new Error(`Max retries reached. Status: ${response.status}`);
              }
              await new Promise(resolve => setTimeout(resolve, retryDelay));
            } else {
              const data = await response.json();
              return data;
            }
          } catch (error) {
            retryCount++;
            if (retryCount >= maxRetries) {
              throw new Error(`Network error after ${maxRetries} attempts: ${error.message}`);
            }
            await new Promise(resolve => setTimeout(resolve, retryDelay));
          }
        }
      }

      async function fetchAlign(extUrl) {
        if (!window.navigator.platform.startsWith("Win")) { await new Promise(resolve => setTimeout(resolve, speedDelay)); }
        try {
          const requestUrl = `http://localhost:4735/alignment-tool/${extUrl}`;
          const response = await fetch(requestUrl, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }
          const data = await response.json();
          return data;
        } catch (error) {
          throw new Error('Error fetching result:', error);
        }
      }

      async function postNext(processName, indices, parameters = null) {
        if (!window.navigator.platform.startsWith("Win")) { await new Promise(resolve => setTimeout(resolve, speedDelay)); }
        let requestUrl;
        let body;
        if (Array.isArray(indices)) {
          requestUrl = `${baseUrl}/process-measurements`;
        } else {
          requestUrl = parameters === null ? `${baseUrl}/${indices}/eq/command` : `${baseUrl}/${indices}/command`;
        }
        if (requestUrl.endsWith('/command')) {
          body = { command: processName };
        } else {
          body = { processName: processName };
        }
        if (parameters != null) {
          body = { ...body, parameters: parameters };
        }
        if (Array.isArray(indices)) {
          body = { ...body, measurementIndices: indices };
        }
        const fetchData = async () => {
          const response = await fetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });
          if (!response.ok) {
            throw new Error('Network response was not OK!');
          }
          const data = await response.json();
          return data;
        }
        const checkResponse = async (data) => {
          if (data.message && data.message.includes('ompleted')) {
            const resultUrl = `${baseUrl}/process-result`;
            const resultResponse = await fetch(resultUrl);
            if (!resultResponse.ok) {
              throw new Error('Failed to fetch result data!');
            }
            const resultData = await resultResponse.json();
            return resultData;
          } else if (data.message.includes('in progress') || data.message.includes('running')) {
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
            return checkResponse(await fetchData());
          } else {
            return data;
          }
        }
        try {
          const data = await fetchData();
          const result = await checkResponse(data);
          return result;
        } catch (error) {
          throw new Error('Error fetching result:', error);
        }
      }

      async function postSafe(requestUrl, parameters, message) {
        if (!window.navigator.platform.startsWith("Win")) { await new Promise(resolve => setTimeout(resolve, speedDelay)); }
        const fetchData = async () => {
          const response = await fetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(parameters),
          });
          if (!response.ok) {
            throw new Error('Network response was not OK!');
          }
          const data = await response.json();
          return data;
        }
        const checkResponse = async (data) => {
          if (data.message.includes(message)) {
            return data;
          } else if (data.message.includes('in progress') || data.message.includes('running')) {
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
            return checkResponse(await fetchData());
          } else {
            throw new Error(`Unexpected response: ${data.message}`);
          }
        }
        try {
          const data = await fetchData();
          const result = await checkResponse(data);
          return result;
        } catch (error) {
          throw new Error('Error fetching result:', error);
        }
      }

      // Enhanced postAlign with better error parsing
      async function postAlign(processName, frequency = null) {
        await platformDelay();

        const requestUrl = `http://localhost:4735/alignment-tool/command`;
        const body = { command: processName };

        if (frequency != null) {
          body.frequency = frequency;
        }

        try {
          const response = await safeFetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });

          const responseText = await response.text();

          if (!response.ok) {
            let errorData;
            try {
              errorData = JSON.parse(responseText);
            } catch (parseError) {
              throw new Error(`Network response was not OK! Status: ${response.status}`);
            }

            if (errorData.message) {
              let parsedMessage;
              try {
                parsedMessage = JSON.parse(errorData.message);
              } catch (parseError) {
                throw new Error('Failed to parse the error message');
              }

              if (parsedMessage.results &&
                parsedMessage.results[0] &&
                parsedMessage.results[0].Error) {
                const errorMessage = parsedMessage.results[0].Error;
                // More robust regex that works across all browsers
                const delayMatch = errorMessage.match(/delay required to align the responses.*?(-?[\d.]+)\s*ms/);

                if (delayMatch) {
                  return {
                    message: 'Delay too large',
                    error: errorMessage,
                    delay: parseFloat(delayMatch[1])
                  };
                }
              }
            }
            throw new Error(`Network response was not OK! Status: ${response.status}`);
          }

          let data;
          try {
            data = JSON.parse(responseText);
          } catch (parseError) {
            throw new Error('Failed to parse the response data');
          }

          if (data.message && data.message.includes('completed')) {
            const resultUrl = `http://localhost:4735/alignment-tool/result`;
            const resultResponse = await safeFetch(resultUrl);

            if (!resultResponse.ok) {
              throw new Error('Failed to fetch result data!');
            }

            const resultData = await resultResponse.json();

            if (resultData.results &&
              resultData.results[0] &&
              resultData.results[0].Error) {
              const errorMessage = resultData.results[0].Error;
              const delayMatch = errorMessage.match(/delay required to align the responses.*?(-?[\d.]+)\s*ms/);

              if (delayMatch) {
                return {
                  message: 'Delay too large',
                  error: errorMessage,
                  delay: parseFloat(delayMatch[1])
                };
              }
            }
            return resultData;
          }

          return data;
        } catch (error) {
          console.error('Error in postAlign:', error);
          throw error;
        }
      }

      async function postDelete(indice) {
        if (!window.navigator.platform.startsWith("Win")) { await new Promise(resolve => setTimeout(resolve, speedDelay)); }
        const mDeleted = `Measurement ${indice} deleted`
        while (true) {
          try {
            const response = await fetch(`${baseUrl}/${indice}`, {
              method: 'DELETE',
              headers: { 'Content-Type': 'application/json' },
            });
            if (!response.ok) {
              throw new Error('Network response was not OK!');
            }
            const data = await response.json();
            if (data.message === mDeleted) {
              return indice;
            } else {
              await new Promise(resolve => setTimeout(resolve, retryDelay));
            }
          } catch (error) {
            throw new Error('Error fetching result:', error);
          }
        }
      }

      async function enableBlock() {
        await fetch('http://localhost:4735/application/blocking', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: true
        });
      }

      async function disableBlock() {
        await fetch('http://localhost:4735/application/blocking', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: false
        });
      }

      async function enableGraph() {
        await fetch('http://localhost:4735/application/inhibit-graph-updates', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: false
        });
      }

      async function disableGraph() {
        await fetch('http://localhost:4735/application/inhibit-graph-updates', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: true
        });
      }

      async function clearCommands() {
        const body = { command: 'Clear command in progress' };
        await fetch('http://localhost:4735/application/command', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
      }

      // Better platform detection
      function isWindowsPlatform() {
        try {
          // Multiple fallbacks for platform detection
          const userAgent = navigator.userAgent || '';
          const platform = navigator.platform || '';

          return userAgent.includes('Windows') ||
            platform.includes('Win') ||
            platform.startsWith('Win');
        } catch (e) {
          // Fallback if navigator is blocked (like in some Tor configurations)
          console.warn('Platform detection failed, assuming non-Windows');
          return false;
        }
      }

      // Fetch with fallback support
      function createFetchWrapper() {
        if (typeof fetch !== 'undefined') {
          return fetch;
        }

        // Fallback for older browsers using XMLHttpRequest
        return function (url, options = {}) {
          return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            const method = options.method || 'GET';

            xhr.open(method, url);

            // Set headers
            if (options.headers) {
              Object.entries(options.headers).forEach(([key, value]) => {
                xhr.setRequestHeader(key, value);
              });
            }

            xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                const response = {
                  ok: xhr.status >= 200 && xhr.status < 300,
                  status: xhr.status,
                  json: () => Promise.resolve(JSON.parse(xhr.responseText)),
                  text: () => Promise.resolve(xhr.responseText)
                };

                if (response.ok) {
                  resolve(response);
                } else {
                  reject(new Error(`HTTP ${xhr.status}`));
                }
              }
            };

            xhr.onerror = () => reject(new Error('Network error'));
            xhr.send(options.body || null);
          });
        };
      }
      const safeFetch = createFetchWrapper();

      // Improved delay function with better error handling
      async function platformDelay() {
        try {
          if (!isWindowsPlatform()) {
            await new Promise(resolve => setTimeout(resolve, speedDelay));
          }
        } catch (error) {
          console.warn('Platform delay failed:', error);
          // Continue without delay on error
        }
      }

      // Feature detection utility
      function checkBrowserSupport() {
        const support = {
          fetch: typeof fetch !== 'undefined',
          asyncAwait: (async function () { })() instanceof Promise,
          json: typeof JSON !== 'undefined' &&
            typeof JSON.parse !== 'undefined' &&
            typeof JSON.stringify !== 'undefined',
          promises: typeof Promise !== 'undefined',
          setTimeout: typeof setTimeout !== 'undefined'
        };

        console.log('Browser support check:', support);

        const unsupported = Object.entries(support)
          .filter(([feature, supported]) => !supported)
          .map(([feature]) => feature);

        if (unsupported.length > 0) {
          console.error('Unsupported features:', unsupported);
          return false;
        }

        return true;
      }

      // Initialize with compatibility check
      function initializeApp() {
        if (!checkBrowserSupport()) {
          alert('Your browser may not fully support this application. Please update to a modern browser.');
          return false;
        }

        console.log('Browser compatibility check passed');
        return true;
      }

      // Validate config on groundWorks() step
      function validateConfiguration() {
        console.log('=== CONFIGURATION VALIDATION ===');
        // console.log(`nSpeakers: ${nSpeakers}`);
        // console.log(`numSub: ${numSub}`);
        console.log('=== ===');
        console.log(`nChannels: ${nChannels}`);
        console.log(`nSpeakers: ${nSpeakers}`);
        console.log(`nSubs: ${nSubs}`);
        console.log('=== ===');
        console.log(`Total channels: ${nSpeakers + nSubs}`);

        // Check commandId array
        const validCommands = Object.keys(commandId).filter(k => !isNaN(k) && parseInt(k) > 0);
        console.log(`CommandID entries: ${validCommands.length}`);

        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          if (!commandId[i]) {
            console.error(`‚ùå Missing commandId[${i}]`);
            return false;
          }
          console.log(`‚úÖ commandId[${i}] = ${commandId[i]}`);
        }

        return true;
      }

      function normalizeTrimLevels() {
        console.log("Normalizing trim levels to industry standard (75dB reference)...");

        // Calculate target level offset from industry standard
        const standardReference = 75.0; // Industry standard SPL reference
        const targetOffset = targetLevel - standardReference;

        console.log(`Target level: ${targetLevel}dB, Standard reference: ${standardReference}dB`);
        console.log(`Target level offset: ${targetOffset.toFixed(1)}dB`);

        if (Math.abs(targetOffset) > 0.5) {
          console.log(`Converting trims from ${targetLevel}dB target to ${standardReference}dB standard...`);
        } else {
          console.log("Target level matches standard reference - no conversion needed.");
        }

        // Calculate original trim statistics
        const totalChannels = noSub ? nSpeakers : nSpeakers + nSubs;
        const originalTrims = [...customLevel]; // Store copy of original values

        // Log original values
        console.log("Original trim values (relative to current target):");
        console.log("--- SPEAKERS ---");
        for (let i = 1; i <= nSpeakers; i++) {
          console.log(`${commandId[i]}: ${customLevel[i].toFixed(1)}dB`);
        }
        if (!noSub) {
          console.log("--- SUBWOOFERS ---");
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            console.log(`${commandId[i]}: ${customLevel[i].toFixed(1)}dB`);
          }
        }

        // Apply target level correction to all channels
        for (let i = 1; i <= nSpeakers; i++) {
          customLevel[i] -= targetOffset;
          customLevel[i] = Math.round(customLevel[i] * 2) / 2; // Round to nearest 0.5dB
        }

        if (!noSub) {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] -= targetOffset;
            customLevel[i] = Math.round(customLevel[i] * 2) / 2; // Round to nearest 0.5dB
          }
        }

        if (Math.abs(targetOffset) > 0.5) {
          console.log(`Applied ${targetOffset.toFixed(1)}dB correction to normalize to 75dB standard.`);
        }

        // Log the BEFORE ‚Üí AFTER comparison
        console.log("BEFORE ‚Üí AFTER comparison (normalized to 75dB standard):");
        console.log("--- SPEAKERS ---");
        for (let i = 1; i <= nSpeakers; i++) {
          const change = customLevel[i] - originalTrims[i];
          console.log(`${commandId[i]}: ${originalTrims[i].toFixed(1)}dB ‚Üí ${customLevel[i].toFixed(1)}dB (${change >= 0 ? '+' : ''}${change.toFixed(1)}dB)`);
        }
        if (!noSub) {
          console.log("--- SUBWOOFERS ---");
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            const change = customLevel[i] - originalTrims[i];
            console.log(`${commandId[i]}: ${originalTrims[i].toFixed(1)}dB ‚Üí ${customLevel[i].toFixed(1)}dB (${change >= 0 ? '+' : ''}${change.toFixed(1)}dB)`);
          }
        }

        // Final analysis relative to 75dB standard
        const normalizedTrims = customLevel.slice(1, totalChannels + 1);
        const maxTrim = Math.max(...normalizedTrims);
        const minTrim = Math.min(...normalizedTrims);
        const averageTrim = normalizedTrims.reduce((sum, trim) => sum + trim, 0) / normalizedTrims.length;

        console.log(`‚úì Normalized trim range: ${minTrim.toFixed(1)}dB to ${maxTrim.toFixed(1)}dB`);
        console.log(`‚úì Average trim: ${averageTrim.toFixed(1)}dB (relative to 75dB standard)`);

        // Check against industry recommendations
        const recommendedTrims = normalizedTrims.filter(trim => Math.abs(trim) <= 10);
        const excessiveTrims = normalizedTrims.filter(trim => Math.abs(trim) > 10);

        if (excessiveTrims.length === 0) {
          console.info("‚úì All trim levels within ¬±10dB recommended range");
        } else {
          console.warn(`${excessiveTrims.length} channels exceed ¬±10dB recommended range - consider speaker/room adjustments`);
        }

        // Check hardware limits
        const withinLimits = normalizedTrims.filter(trim => trim >= -12 && trim <= 12);
        if (withinLimits.length === normalizedTrims.length) {
          console.info("‚úì All trim levels within ¬±12dB hardware limits");
        } else {
          console.error(`${normalizedTrims.length - withinLimits.length} channels exceed ¬±12dB hardware limits`);
        }

        // Headroom analysis
        const positiveTrims = normalizedTrims.filter(trim => trim > 0);
        if (positiveTrims.length > 0) {
          const maxPositive = Math.max(...positiveTrims);
          console.log(`üìä Headroom impact: ${positiveTrims.length} channels with positive trims (max: ${maxPositive.toFixed(1)}dB)`);
          console.log(`üìä Reference level achieved at Master Volume ${-maxPositive.toFixed(1)}dB`);
        } else {
          console.info("‚úì No positive trims - maximum headroom preserved");
        }
      }

      // Not used anymore, but leave it for now!
      function normalizeAdyTrimValues() {
        console.log("Optimizing ADY trim values for best AVR performance...");

        // Target ranges: Speakers ¬±6dB (half AVR range), Subs -12dB to +6dB (full flexibility)
        const SPEAKER_MIN = -6.0;
        const SPEAKER_MAX = +6.0;
        const SUB_MIN = -12.0;
        const SUB_MAX = +6.0;

        // Find current ranges
        const speakerTrims = customLevel.slice(1, nSpeakers + 1);
        const minSpeaker = Math.min(...speakerTrims);
        const maxSpeaker = Math.max(...speakerTrims);

        let minSub = 0, maxSub = 0;
        if (!noSub) {
          const subTrims = customLevel.slice(nSpeakers + 1, nSpeakers + nSubs + 1);
          minSub = Math.min(...subTrims);
          maxSub = Math.max(...subTrims);
        }

        console.log(`Current ranges: Speakers ${minSpeaker.toFixed(1)}dB to ${maxSpeaker.toFixed(1)}dB`);
        if (!noSub) {
          console.log(`Current ranges: Subs ${minSub.toFixed(1)}dB to ${maxSub.toFixed(1)}dB`);
        }
        console.log(`Target ranges: Speakers ${SPEAKER_MIN.toFixed(1)}dB to ${SPEAKER_MAX.toFixed(1)}dB, Subs ${SUB_MIN.toFixed(1)}dB to ${SUB_MAX.toFixed(1)}dB`);

        // Check if optimization needed
        const speakersOK = (minSpeaker >= SPEAKER_MIN && maxSpeaker <= SPEAKER_MAX);
        const subsOK = noSub || (minSub >= SUB_MIN && maxSub <= SUB_MAX);

        if (speakersOK && subsOK) {
          console.log("‚úì All trims already within target ranges");

          // Bonus optimization: If sub is below -5dB and we have speaker headroom, optimize sub level
          if (!noSub) {
            const currentSubMax = Math.max(...customLevel.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
            const SUB_OPTIMAL = -5.0; // Optimal upper range for subs per research

            if (currentSubMax < SUB_OPTIMAL) {
              const bonusOffset = SUB_OPTIMAL - currentSubMax;
              const newSpeakerMax = maxSpeaker + bonusOffset;

              if (newSpeakerMax <= SPEAKER_MAX) {
                console.log(`üöÄ Bonus optimization: Sub at ${currentSubMax.toFixed(1)}dB, can shift +${bonusOffset.toFixed(1)}dB to reach optimal -5dB`);
                console.log(`   Speakers would become: ${(minSpeaker + bonusOffset).toFixed(1)}dB to ${newSpeakerMax.toFixed(1)}dB (still within ¬±6dB)`);
                offset = bonusOffset;
              } else {
                console.log(`üí° Sub could be optimized to -5dB but would push speakers beyond +6dB limit`);
                console.log("‚úì No optimization needed - current ranges are good");
                return;
              }
            } else {
              console.log("‚úì No optimization needed - current ranges are good");
              return;
            }
          } else {
            console.log("‚úì No optimization needed - current ranges are good");
            return;
          }
        }

        // Calculate required offset for speakers that are out of range
        if (maxSpeaker > SPEAKER_MAX) {
          offset = SPEAKER_MAX - maxSpeaker;
          console.log(`Speaker max ${maxSpeaker.toFixed(1)}dB > ${SPEAKER_MAX.toFixed(1)}dB: need ${offset.toFixed(1)}dB shift`);
        } else if (minSpeaker < SPEAKER_MIN) {
          offset = SPEAKER_MIN - minSpeaker;
          console.log(`Speaker min ${minSpeaker.toFixed(1)}dB < ${SPEAKER_MIN.toFixed(1)}dB: need ${offset.toFixed(1)}dB shift`);
        }

        // Check if offset causes sub problems
        if (!noSub && Math.abs(offset) > 0.1) {
          const newMinSub = minSub + offset;
          const newMaxSub = maxSub + offset;

          if (newMinSub < SUB_MIN) {
            const adjustment = SUB_MIN - newMinSub;
            offset += adjustment;
            console.log(`Adjusted offset to ${offset.toFixed(1)}dB to keep subs above ${SUB_MIN.toFixed(1)}dB`);
          }

          if (newMaxSub > SUB_MAX) {
            const adjustment = SUB_MAX - newMaxSub;
            offset += adjustment;
            console.log(`Adjusted offset to ${offset.toFixed(1)}dB to keep subs below ${SUB_MAX.toFixed(1)}dB`);
          }
        }

        if (Math.abs(offset) < 0.1) {
          console.log("‚úì No significant offset needed");
          return;
        }

        // Log before values
        console.log("BEFORE optimization:");
        console.log("--- SPEAKERS ---");
        for (let i = 1; i <= nSpeakers; i++) {
          console.log(`${commandId[i]}: ${customLevel[i].toFixed(1)}dB`);
        }
        if (!noSub) {
          console.log("--- SUBWOOFERS ---");
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            console.log(`${commandId[i]}: ${customLevel[i].toFixed(1)}dB`);
          }
        }

        // Store originals
        const originalLevels = [...customLevel];

        // Apply offset
        console.log(`Applying ${offset.toFixed(1)}dB offset to all channels...`);

        for (let i = 1; i <= nSpeakers; i++) {
          customLevel[i] += offset;
          customLevel[i] = Math.round(customLevel[i] * 2) / 2; // Round to 0.5dB
        }

        if (!noSub) {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += offset;
            customLevel[i] = Math.round(customLevel[i] * 2) / 2; // Round to 0.5dB
          }
        }

        // Log after values
        console.log("AFTER optimization:");
        console.log("--- SPEAKERS ---");
        for (let i = 1; i <= nSpeakers; i++) {
          const inRange = customLevel[i] >= SPEAKER_MIN && customLevel[i] <= SPEAKER_MAX ? "‚úì" : "‚ö†Ô∏è";
          console.log(`${commandId[i]}: ${originalLevels[i].toFixed(1)}dB ‚Üí ${customLevel[i].toFixed(1)}dB ${inRange}`);
        }
        if (!noSub) {
          console.log("--- SUBWOOFERS ---");
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            const inRange = customLevel[i] >= SUB_MIN && customLevel[i] <= SUB_MAX ? "‚úì" : "‚ö†Ô∏è";
            console.log(`${commandId[i]}: ${originalLevels[i].toFixed(1)}dB ‚Üí ${customLevel[i].toFixed(1)}dB ${inRange}`);
          }
        }

        // Master volume adjustment guidance
        if (Math.abs(offset) >= 0.5) {
          const masterAdjust = -offset; // Opposite of trim shift
          console.log(`üì¢ Master Volume: Increase by ${masterAdjust.toFixed(1)}dB to maintain same loudness`);
          console.log(`   üìä Relative Scale: -25dB ‚Üí ${(-25 + masterAdjust).toFixed(1)}dB`);
          console.log(`   üìä Absolute Scale: 55 ‚Üí ${(55 + masterAdjust).toFixed(0)} (80 = 0dB reference)`);
        }

        // Final summary
        const finalSpeakerMin = Math.min(...customLevel.slice(1, nSpeakers + 1));
        const finalSpeakerMax = Math.max(...customLevel.slice(1, nSpeakers + 1));
        console.log(`‚úì Final speaker range: ${finalSpeakerMin.toFixed(1)}dB to ${finalSpeakerMax.toFixed(1)}dB`);

        if (!noSub) {
          const finalSubMin = Math.min(...customLevel.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          const finalSubMax = Math.max(...customLevel.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          console.log(`‚úì Final sub range: ${finalSubMin.toFixed(1)}dB to ${finalSubMax.toFixed(1)}dB`);
        }

        console.log("‚úì Optimization complete - relative balance preserved");
      }

      // CEDIA Assessment - Enhanced Implementation with Professional Standards and Advanced Acoustics
      class CEDIAPerformanceScorer {
        constructor() {
          // Precision constants for calculations
          this.PRECISION = {
            SPL_TOLERANCE: 0.1,
            DISTANCE_TOLERANCE: 0.01,
            FREQUENCY_TOLERANCE: 1.0,
            SPEED_OF_SOUND: 343, // m/s at 20¬∞C
            DB_PER_DISTANCE_DOUBLING: 6.0
          };

          // Advanced acoustic constants from CEDIA RP22 specification
          this.ACOUSTIC_CONSTANTS = {
            REFERENCE_IMPEDANCE: 8, // Ohms
            REFERENCE_DISTANCE: 1,  // meters
            SABINE_CONSTANT_METRIC: 0.161,
            SABINE_CONSTANT_IMPERIAL: 0.049,
            BOUNDARY_LOADING: {
              freeField: 0,      // No boundaries
              halfSpace: 6,      // Against wall
              quarterSpace: 12,  // Wall-floor junction
              eighthSpace: 18    // Corner placement
            },
            MATERIAL_ABSORPTION_COEFFS: {
              concrete: 0.02,
              gypsumBoard: 0.08,
              hardwood: 0.04,
              carpet_light: 0.15,
              carpet_heavy: 0.30,
              curtains_light: 0.30,
              curtains_heavy: 0.70,
              acousticFoam_2inch: 0.85,
              fiberglass_2inch: 0.90,
              upholsteredFurniture: 0.50,
              person: 0.45  // Per person in sabins
            }
          };

          // Enhanced speaker types with validation
          this.speakerTypes = {
            front: ["FL", "FR"],
            frontWide: ["FWL", "FWR"],
            surroundBack: ["SBL", "SBR"],
            surround: ["SLA", "SRA", "SL", "SR"],
            frontHeight: ["FHL", "FHR"],
            rearHeight: ["RHL", "RHR"],
            surroundHeight: ["SHL", "SHR"],
            topFront: ["TFL", "TFR"],
            topMiddle: ["TML", "TMR"],
            topRear: ["TRL", "TRR"],
            upfiringBack: ["BDL", "BDR"],
            upfiringFront: ["FDL", "FDR"],
            upfiringSurround: ["SDL", "SDR"],
            center: ["C"],
            topSurround: ["TS"],
            centerHeight: ["CH"],
            surroundBackSingle: ["SB"]
          };

          // Complete 21 CEDIA parameters with enhanced validation
          this.parameters = {
            // Spatial Resolution (11 parameters)
            1: {
              name: "Minimum Distance Between Listening Area and Room Walls",
              unit: "m", category: "Spatial Resolution",
              targets: { level1: { min: 0.5 }, level2: { min: 0.8 }, level3: { min: 1.2 }, level4: { min: 1.5 } },
              type: "minimum",
              validator: this.validateDistanceParameter.bind(this)
            },
            2: {
              name: "Decoder/Renderer Capability and Discretely Rendered Speaker Configuration",
              unit: "discrete speakers", category: "Spatial Resolution",
              targets: { level1: { min: 5 }, level2: { min: 11 }, level3: { min: 15 }, level4: { min: 15 } },
              type: "minimum",
              validator: this.validateSpeakerCount.bind(this)
            },
            3: {
              name: "Number of Screen Wall Speakers Outside Recommended Zonal Locations",
              unit: "speakers", category: "Spatial Resolution",
              targets: { level1: { max: 0 }, level2: { max: 0 }, level3: { max: 0 }, level4: { max: 0 } },
              type: "maximum",
              validator: this.validateZonalCompliance.bind(this)
            },
            4: {
              name: "Maximum SPL Difference Between Screen Wall Speakers",
              unit: "dB", category: "Spatial Resolution",
              targets: { level1: { max: 6 }, level2: { max: 5 }, level3: { max: 4 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateSPLConsistency.bind(this)
            },
            5: {
              name: "Maximum Allowable Horizontal Angle Between Adjacent Surround Speakers",
              unit: "degrees", category: "Spatial Resolution",
              targets: { level1: null, level2: { max: 80 }, level3: { max: 60 }, level4: { max: 50 } },
              type: "maximum",
              validator: this.validateSpeakerAngles.bind(this)
            },
            6: {
              name: "Maximum SPL Difference Between Surround Speakers",
              unit: "dB", category: "Spatial Resolution",
              targets: { level1: { max: 10 }, level2: { max: 6 }, level3: { max: 4 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateSPLConsistency.bind(this)
            },
            7: {
              name: "Wide Speakers Maximum Allowable Horizontal Deviation from Median Angle",
              unit: "degrees", category: "Spatial Resolution",
              targets: { level1: { max: 10 }, level2: { max: 7 }, level3: { max: 5 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateWideAlignment.bind(this)
            },
            8: {
              name: "Upfiring/Elevation Speakers Allowed",
              unit: "yes/no", category: "Spatial Resolution",
              targets: { level1: true, level2: true, level3: false, level4: false },
              type: "boolean",
              validator: this.validateUpfiringSpeakers.bind(this)
            },
            9: {
              name: "Maximum Allowable Vertical Angle Between Adjacent Upper Speakers",
              unit: "degrees", category: "Spatial Resolution",
              targets: { level1: null, level2: { max: 80 }, level3: { max: 60 }, level4: { max: 50 } },
              type: "maximum",
              validator: this.validateVerticalAngles.bind(this)
            },
            10: {
              name: "Maximum SPL Difference Between Upper Speakers",
              unit: "dB", category: "Spatial Resolution",
              targets: { level1: { max: 12 }, level2: { max: 8 }, level3: { max: 5 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateSPLConsistency.bind(this)
            },
            11: {
              name: "Number of Surround/Wide/Upper Speakers Outside Zonal Locations",
              unit: "speakers", category: "Spatial Resolution",
              targets: { level1: null, level2: { max: 0 }, level3: { max: 0 }, level4: { max: 0 } },
              type: "maximum",
              validator: this.validateZonalCompliance.bind(this)
            },

            // Dynamics (4 parameters)
            12: {
              name: "Screen Speakers SPL Capability at RSP",
              unit: "dB SPL(C)", category: "Dynamics",
              targets: { level1: { min: 99, rec: 102 }, level2: { min: 102, rec: 105 }, level3: { min: 105, rec: 108 }, level4: { min: 108, rec: 111 } },
              type: "minimum",
              validator: this.validateSPLCapability.bind(this)
            },
            13: {
              name: "Non-Screen Speakers SPL Capability at RSP",
              unit: "dB SPL(C)", category: "Dynamics",
              targets: { level1: { min: 96, rec: 99 }, level2: { min: 99, rec: 102 }, level3: { min: 102, rec: 105 }, level4: { min: 105, rec: 108 } },
              type: "minimum",
              validator: this.validateSPLCapability.bind(this)
            },
            14: {
              name: "LFE Frequencies Total SPL Capability at RSP",
              unit: "dB SPL(C)", category: "Dynamics",
              targets: { level1: { min: 109, rec: 114 }, level2: { min: 112, rec: 117 }, level3: { min: 115, rec: 120 }, level4: { min: 118, rec: 123 } },
              type: "minimum",
              validator: this.validateLFECapability.bind(this)
            },
            15: {
              name: "Background Noise Floor",
              unit: "NCB rating", category: "Dynamics",
              targets: { level1: { max: 35, rec: 26 }, level2: { max: 26, rec: 22 }, level3: { max: 22, rec: 18 }, level4: { max: 18, rec: 15 } },
              type: "maximum",
              validator: this.validateNoiseFloor.bind(this)
            },

            // Timbre (6 parameters)
            16: {
              name: "Seat-to-Seat Frequency Response Variance - Screen Wall Speakers",
              unit: "¬±dB", category: "Timbre",
              targets: { level1: { max: 5 }, level2: { max: 3 }, level3: { max: 1.5 }, level4: { max: 1.5 } },
              type: "maximum",
              validator: this.validateFrequencyResponse.bind(this)
            },
            17: {
              name: "Seat-to-Seat Frequency Response Variance - Surround/Upper Speakers",
              unit: "¬±dB", category: "Timbre",
              targets: { level1: null, level2: null, level3: { max: 3 }, level4: { max: 1.5 } },
              type: "maximum",
              validator: this.validateFrequencyResponse.bind(this)
            },
            18: {
              name: "In-Room Bass Extension -3dB Cutoff Frequency",
              unit: "Hz", category: "Timbre",
              targets: { level1: { max: 35, rec: 30 }, level2: { max: 30, rec: 25 }, level3: { max: 20, rec: 18 }, level4: { max: 18, rec: 15 } },
              type: "maximum",
              validator: this.validateBassExtension.bind(this)
            },
            19: {
              name: "Frequency Response Below Room's Transition Frequency at RSP",
              unit: "¬±dB", category: "Timbre",
              targets: { level1: { max: 5 }, level2: { max: 4 }, level3: { max: 3 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateBassResponse.bind(this)
            },
            20: {
              name: "Seat-to-Seat Frequency Response Below Room's Transition Frequency",
              unit: "¬±dB", category: "Timbre",
              targets: { level1: null, level2: { max: 4 }, level3: { max: 3 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateBassConsistency.bind(this)
            },
            21: {
              name: "Level of Early Reflections Relative to Direct Sound",
              unit: "dB", category: "Timbre",
              targets: { level1: null, level2: { min: -8 }, level3: { min: -10 }, level4: { min: -12 } },
              type: "minimum",
              validator: this.validateReflections.bind(this)
            }
          };

          // Validation error tracking
          this.validationErrors = [];
        }

        // Enhanced data capture with comprehensive validation
        captureAllSystemData() {
          try {
            const systemData = {
              // Basic system info with validation
              nSpeakers: this.validateNumeric(typeof nSpeakers !== 'undefined' ? nSpeakers : 0, 'nSpeakers'),
              nSubs: this.validateNumeric(typeof nSubs !== 'undefined' ? nSubs : 0, 'nSubs'),
              noSub: typeof noSub !== 'undefined' ? Boolean(noSub) : false,
              targetLevel: this.validateNumeric(typeof targetLevel !== 'undefined' ? targetLevel : 75, 'targetLevel'),
              swChannelCount: this.validateNumeric(typeof swChannelCount !== 'undefined' ? swChannelCount : 0, 'swChannelCount'),

              // Speaker configuration with enhanced validation
              commandId: typeof commandId !== 'undefined' ? commandId : [],
              discreteSpeakerFeeds: 0, // Will be calculated

              // Enhanced playback level data with validation
              estimatedPlaybackLevels: this.parseEstimatedPlaybackLevels(typeof estimatedPlaybackLevels !== 'undefined' ? estimatedPlaybackLevels : []),

              // Advanced: Parse distance and crossover data
              estimatedDistances: this.parseDistanceData(typeof estimatedDistances !== 'undefined' ? estimatedDistances : []),
              crossoverData: this.parseCrossoverData(typeof RP22BestXO !== 'undefined' ? RP22BestXO : []),

              // Bass system data with precision handling
              bassExtension: this.validateFrequency(m3dBPoints && nChannels ? m3dBPoints[nChannels]?.[0] : null),
              bassHighFreq: this.validateFrequency(m3dBPoints && nChannels ? m3dBPoints[nChannels]?.[1] : null),
              bassMode: typeof bassMode !== 'undefined' ? String(bassMode) : 'Unknown',

              // Subwoofer optimization data with precision
              RP22subnminXO: this.validateFrequency(typeof RP22subnminXO !== 'undefined' ? RP22subnminXO : null),
              RP22submaxXO: this.validateFrequency(typeof RP22submaxXO !== 'undefined' ? RP22submaxXO : null),
              requiredDelay: this.validateNumeric(typeof RP22subrequiredDelay !== 'undefined' ? RP22subrequiredDelay : null, 'requiredDelay'),
              optimalFreq: this.validateFrequency(typeof bestFreq !== 'undefined' ? bestFreq : null),

              delayRange: (typeof loDelay !== 'undefined' && typeof hiDelay !== 'undefined') ? {
                min: this.validateNumeric(loDelay, 'loDelay'),
                max: this.validateNumeric(hiDelay, 'hiDelay'),
                range: this.validateNumeric(hiDelay - loDelay, 'delayRange')
              } : null,

              // Level and distance data with validation
              customLevel: typeof customLevel !== 'undefined' ? this.validateArray(customLevel, 'customLevel') : [],
              customDistance: typeof customDistance !== 'undefined' ? this.validateArray(customDistance, 'customDistance') : [],
              customCrossover: typeof customCrossover !== 'undefined' ? this.validateArray(customCrossover, 'customCrossover') : [],
              flDist: this.validateNumeric(typeof flDist !== 'undefined' ? flDist : null, 'flDist'),

              // System characteristics - Enhanced parsing for measurement arrays
              sOs: typeof sOs !== 'undefined' ? String(sOs) : 'Unknown',
              isCirrusLogic: typeof isCirrusLogic !== 'undefined' ? Boolean(isCirrusLogic) : false,
              freqIndex: this.parseFrequencyArray(typeof freqIndex !== 'undefined' ? freqIndex : null),
              //RP22DialogEnhancementFilter: typeof RP22DialogEnhancementFilter !== 'undefined' ? Boolean(RP22DialogEnhancementFilter) : false,
              needsSorting: typeof needsSorting !== 'undefined' ? Boolean(needsSorting) : false,

              // Time alignment - Enhanced parsing for timing data
              mSec: this.parseTimingArray(typeof mSec !== 'undefined' ? mSec : null)
            };

            // Calculate discrete speaker feeds
            systemData.discreteSpeakerFeeds = this.calculateDiscreteSpeakerFeeds(systemData);

            // Enhanced room analysis using advanced acoustics
            systemData.roomAcoustics = this.calculateRoomAcoustics(systemData);
            systemData.speakerAngles = this.calculateAllSpeakerAngles(systemData);
            systemData.bassManagement = this.analyzeBassManagement(systemData);

            return systemData;
          } catch (error) {
            console.warn("Error capturing system data:", error.message);
            return this.getDefaultSystemData();
          }
        }

        // Parse frequency measurement points array from freqIndex
        parseFrequencyArray(rawFreqIndex) {
          if (!rawFreqIndex) return null;

          try {
            // Handle comma-separated frequency values
            const freqString = String(rawFreqIndex).trim();
            if (freqString === '') return null;

            const frequencies = freqString.split(',')
              .map(f => parseFloat(f.trim()))
              .filter(f => Number.isFinite(f) && f > 0);

            if (frequencies.length === 0) {
              this.addValidationError("No valid frequency points found in freqIndex");
              return null;
            }

            // Sort frequencies in ascending order
            frequencies.sort((a, b) => a - b);

            // Calculate frequency response analysis metrics
            const analysis = {
              frequencies: frequencies,
              count: frequencies.length,
              minFreq: Math.min(...frequencies),
              maxFreq: Math.max(...frequencies),
              frequencyRange: Math.max(...frequencies) / Math.min(...frequencies),
              avgSpacing: this.calculateAverageFrequencySpacing(frequencies),
              is1_3Octave: this.checkIfOneThirdOctave(frequencies),
              bandsPerOctave: this.estimateBandsPerOctave(frequencies)
            };

            return analysis;

          } catch (error) {
            this.addValidationError(`Error parsing freqIndex: ${error.message}`);
            return null;
          }
        }

        // Parse timing delay array from mSec  
        parseTimingArray(rawMSec) {
          if (!rawMSec) return null;

          try {
            // Handle comma-separated timing values (may have leading comma)
            const timingString = String(rawMSec).trim();
            if (timingString === '') return null;

            // Split and remove empty entries (handles leading comma)
            const timingValues = timingString.split(',')
              .map(t => t.trim())
              .filter(t => t !== '')
              .map(t => parseFloat(t))
              .filter(t => Number.isFinite(t));

            if (timingValues.length === 0) {
              this.addValidationError("No valid timing values found in mSec");
              return null;
            }

            // Calculate timing analysis metrics
            const analysis = {
              delays: timingValues,
              count: timingValues.length,
              minDelay: Math.min(...timingValues),
              maxDelay: Math.max(...timingValues),
              delaySpread: Math.max(...timingValues) - Math.min(...timingValues),
              avgDelay: timingValues.reduce((sum, d) => sum + d, 0) / timingValues.length,
              stdDeviation: this.calculateStandardDeviation(timingValues),
              timingConsistency: this.assessTimingConsistency(timingValues),
              earlyReflectionMetric: this.estimateEarlyReflectionLevel(timingValues)
            };

            return analysis;

          } catch (error) {
            this.addValidationError(`Error parsing mSec: ${error.message}`);
            return null;
          }
        }

        // Check if frequency array represents 1/3 octave measurements
        checkIfOneThirdOctave(frequencies) {
          if (frequencies.length < 3) return false;

          // Check if frequency ratios are close to 2^(1/3) ‚âà 1.26
          const expectedRatio = Math.pow(2, 1 / 3);
          const tolerance = 0.05;

          for (let i = 1; i < Math.min(frequencies.length, 10); i++) {
            const ratio = frequencies[i] / frequencies[i - 1];
            if (Math.abs(ratio - expectedRatio) > tolerance) {
              return false;
            }
          }

          return true;
        }

        // Estimate bands per octave from frequency spacing
        estimateBandsPerOctave(frequencies) {
          if (frequencies.length < 2) return null;

          // Calculate average ratio between adjacent frequencies
          const ratios = [];
          for (let i = 1; i < Math.min(frequencies.length, 10); i++) {
            ratios.push(frequencies[i] / frequencies[i - 1]);
          }

          const avgRatio = ratios.reduce((sum, r) => sum + r, 0) / ratios.length;

          // Convert ratio to bands per octave: bandsPerOctave = log(2) / log(ratio)
          return Math.round(Math.log(2) / Math.log(avgRatio));
        }

        // Calculate average frequency spacing
        calculateAverageFrequencySpacing(frequencies) {
          if (frequencies.length < 2) return 0;

          const spacings = [];
          for (let i = 1; i < frequencies.length; i++) {
            spacings.push(frequencies[i] - frequencies[i - 1]);
          }

          return spacings.reduce((sum, s) => sum + s, 0) / spacings.length;
        }

        // Calculate standard deviation of timing values
        calculateStandardDeviation(values) {
          const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
          const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
          const variance = squaredDiffs.reduce((sum, sq) => sum + sq, 0) / values.length;
          return Math.sqrt(variance);
        }

        // Assess timing consistency for CEDIA parameter evaluation
        assessTimingConsistency(delays) {
          if (delays.length < 2) return 'Insufficient Data';

          const delaySpread = Math.max(...delays) - Math.min(...delays);
          const stdDev = this.calculateStandardDeviation(delays);

          // Convert from seconds to milliseconds for evaluation
          // const spreadMs = Math.abs(delaySpread) * 1000;
          // const stdDevMs = stdDev * 1000;
          const spreadMs = Math.abs(delaySpread) * delaymax;
          const stdDevMs = stdDev * delaymax;

          if (spreadMs <= 0.1 && stdDevMs <= 0.05) return 'Excellent';
          if (spreadMs <= 0.5 && stdDevMs <= 0.2) return 'Good';
          if (spreadMs <= 2.0 && stdDevMs <= 1.0) return 'Fair';
          return 'Poor';
        }

        // Estimate early reflection characteristics from timing data
        estimateEarlyReflectionLevel(delays) {
          // Use timing delay spread as proxy for early reflection strength
          // Larger delay spreads typically indicate more early reflections
          const delaySpread = Math.max(...delays) - Math.min(...delays);
          const spreadMs = Math.abs(delaySpread) * 1000;

          // Convert timing spread to estimated early reflection level (dB relative to direct sound)
          // Based on empirical relationships between delay spread and reflection strength
          if (spreadMs <= 0.1) return -15; // Very low reflections
          if (spreadMs <= 0.5) return -12; // Low reflections  
          if (spreadMs <= 1.0) return -10; // Moderate reflections
          if (spreadMs <= 2.0) return -8;  // Higher reflections
          return -6; // High reflections
        }

        // Parse distance data from estimatedDistances array
        parseDistanceData(rawDistances) {
          const distances = {};
          if (!Array.isArray(rawDistances)) {
            this.addValidationError("estimatedDistances is not an array");
            return distances;
          }

          rawDistances.forEach((entry, index) => {
            try {
              if (Array.isArray(entry) && entry.length >= 2) {
                const [speakerId, distanceValue] = entry;
                const distance = parseFloat(distanceValue);

                if (typeof speakerId === 'string' && Number.isFinite(distance) && distance > 0) {
                  distances[speakerId.trim()] = distance;
                } else {
                  this.addValidationError(`Invalid distance entry at index ${index}: ${JSON.stringify(entry)}`);
                }
              }
            } catch (error) {
              this.addValidationError(`Error parsing distance entry ${index}: ${error.message}`);
            }
          });

          return distances;
        }

        // Parse crossover data from RP22BestXO array  
        parseCrossoverData(rawCrossovers) {
          const crossovers = {};
          if (!Array.isArray(rawCrossovers)) {
            this.addValidationError("RP22BestXO is not an array");
            return crossovers;
          }

          rawCrossovers.forEach((entry, index) => {
            try {
              if (Array.isArray(entry) && entry.length >= 2) {
                const [speakerId, crossoverValue] = entry;
                const crossover = parseFloat(crossoverValue);

                if (typeof speakerId === 'string' && Number.isFinite(crossover) && crossover > 0) {
                  crossovers[speakerId.trim()] = crossover;
                }
              }
            } catch (error) {
              this.addValidationError(`Error parsing crossover entry ${index}: ${error.message}`);
            }
          });

          return crossovers;
        }

        // Parse and validate estimatedPlaybackLevels data
        parseEstimatedPlaybackLevels(rawData) {
          if (!Array.isArray(rawData)) {
            this.addValidationError("estimatedPlaybackLevels is not an array");
            return {};
          }

          const parsedLevels = {};
          let validEntries = 0;

          rawData.forEach((entry, index) => {
            try {
              if (!Array.isArray(entry) || entry.length !== 2) {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Invalid entry format - expected [speakerID, level]`);
                return;
              }

              const [speakerId, levelValue] = entry;

              if (typeof speakerId !== 'string' || speakerId.trim() === '') {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Invalid speaker ID`);
                return;
              }

              const level = parseFloat(levelValue);
              if (!Number.isFinite(level)) {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Invalid level value for ${speakerId}`);
                return;
              }

              // Validate reasonable level range (20-120 dB SPL)
              if (level < 20 || level > 120) {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Level ${level}dB for ${speakerId} is outside reasonable range (20-120dB)`);
              }

              parsedLevels[speakerId.trim()] = level;
              validEntries++;

            } catch (error) {
              this.addValidationError(`estimatedPlaybackLevels[${index}]: Parse error - ${error.message}`);
            }
          });

          if (validEntries === 0) {
            this.addValidationError("No valid entries found in estimatedPlaybackLevels");
          } else if (validEntries < rawData.length) {
            this.addValidationError(`Only ${validEntries}/${rawData.length} estimatedPlaybackLevels entries were valid`);
          }

          return parsedLevels;
        }

        // Calculate frequency response variance from measurement data
        calculateFrequencyResponseVariance(systemData, speakerGroup) {
          if (!systemData.freqIndex || !systemData.freqIndex.frequencies) {
            return null;
          }

          try {
            // Get relevant speakers for the group
            const relevantSpeakers = this.getSpeakersForGroup(systemData, speakerGroup);
            if (relevantSpeakers.length < 2) {
              return null; // Need at least 2 speakers for variance calculation
            }

            // Use frequency data to estimate response variance
            const freqData = systemData.freqIndex;

            // Estimate variance based on frequency measurement characteristics
            // This is a simplified approach - in practice would need actual FR measurements
            let estimatedVariance = 3.0; // Base variance estimate

            // Adjust based on measurement quality indicators
            if (freqData.is1_3Octave) {
              estimatedVariance *= 0.8; // Better measurement resolution
            }

            if (freqData.count >= 20) {
              estimatedVariance *= 0.9; // More measurement points = better accuracy
            }

            // Adjust based on speaker group characteristics
            if (speakerGroup === 'screen') {
              // Screen speakers typically better matched
              estimatedVariance *= 0.7;
            } else if (speakerGroup === 'surround') {
              // Surrounds may have more variation due to room interactions
              estimatedVariance *= 1.2;
            }

            // Use SPL consistency data if available to refine estimate
            if (systemData.estimatedPlaybackLevels) {
              const splAnalysis = this.analyzeSpeakerGroupSPL(systemData.estimatedPlaybackLevels);
              const groupSPLVariance = this.getSPLVarianceForGroup(splAnalysis, speakerGroup);

              if (groupSPLVariance !== null) {
                // Correlate SPL variance with frequency response variance
                estimatedVariance = Math.max(estimatedVariance, groupSPLVariance * 0.6);
              }
            }

            return Math.round(estimatedVariance * 10) / 10;

          } catch (error) {
            this.addValidationError(`Frequency response variance calculation error: ${error.message}`);
            return null;
          }
        }

        // Estimate bass extension from frequency measurement data
        estimateBassExtensionFromFrequencies(freqData) {
          if (!freqData || !freqData.frequencies || freqData.frequencies.length === 0) {
            return null;
          }

          try {
            // Find the lowest measurement frequency as indicator of bass extension
            const lowestFreq = freqData.minFreq;

            // Estimate -3dB cutoff based on lowest measurement frequency
            // Typical relationship: if measuring down to X Hz, -3dB point is usually higher
            let estimatedCutoff;

            if (lowestFreq <= 20) {
              estimatedCutoff = 25; // Excellent extension
            } else if (lowestFreq <= 30) {
              estimatedCutoff = 35; // Good extension  
            } else if (lowestFreq <= 40) {
              estimatedCutoff = 45; // Fair extension
            } else {
              estimatedCutoff = Math.max(lowestFreq, 60); // Limited extension
            }

            // Adjust based on number of low frequency measurement points
            const lowFreqPoints = freqData.frequencies.filter(f => f <= 80).length;
            if (lowFreqPoints >= 5) {
              estimatedCutoff *= 0.9; // More LF measurement points suggest better extension
            }

            return Math.round(estimatedCutoff);

          } catch (error) {
            this.addValidationError(`Bass extension estimation error: ${error.message}`);
            return null;
          }
        }

        // Get speakers for specific group analysis
        getSpeakersForGroup(systemData, speakerGroup) {
          if (!systemData.commandId || !Array.isArray(systemData.commandId)) {
            return [];
          }

          const speakers = systemData.commandId.filter(id => id && typeof id === 'string');

          switch (speakerGroup.toLowerCase()) {
            case 'screen':
              return speakers.filter(id => ['FL', 'FC', 'FR', 'FCL', 'FCR', 'C'].includes(id));
            case 'surround':
              return speakers.filter(id =>
                ['SL', 'SR', 'SBL', 'SBR', 'SLA', 'SRA', 'SB'].includes(id) ||
                ['FHL', 'FHR', 'RHL', 'RHR', 'SHL', 'SHR', 'CH'].includes(id) ||
                ['TFL', 'TFR', 'TML', 'TMR', 'TRL', 'TRR', 'TS'].includes(id)
              );
            case 'wide':
              return speakers.filter(id => ['FWL', 'FWR'].includes(id));
            case 'upper':
              return speakers.filter(id =>
                id.includes('H') || id.startsWith('T') ||
                ['BDL', 'BDR', 'FDL', 'FDR', 'SDL', 'SDR'].includes(id)
              );
            default:
              return speakers;
          }
        }

        // Get SPL variance for specific speaker group
        getSPLVarianceForGroup(splAnalysis, speakerGroup) {
          switch (speakerGroup.toLowerCase()) {
            case 'screen':
              return splAnalysis.screenSpeakers?.maxDiff || null;
            case 'surround':
              return splAnalysis.surroundSpeakers?.maxDiff || null;
            case 'upper':
              return splAnalysis.upperSpeakers?.maxDiff || null;
            case 'wide':
              return splAnalysis.wideSpeakers?.maxDiff || null;
            default:
              return null;
          }
        }

        // Calculate room acoustics from speaker distances using CEDIA RP22 methodology
        calculateRoomAcoustics(systemData) {
          try {
            if (!systemData.estimatedDistances || Object.keys(systemData.estimatedDistances).length === 0) {
              return { dimensions: null, transitionFreq: null, modes: [] };
            }

            // Estimate room dimensions from speaker distances
            const distances = Object.values(systemData.estimatedDistances);
            const maxDistance = Math.max(...distances);
            const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;

            // CEDIA RP22 room estimation using acoustic principles
            const estimatedLength = maxDistance * 1.8; // More conservative estimate
            const estimatedWidth = maxDistance * 1.4;
            const estimatedHeight = Math.min(avgDistance * 0.85, 3.5); // Typical residential height
            const estimatedVolume = estimatedLength * estimatedWidth * estimatedHeight;

            // Calculate Schroeder transition frequency
            const reverbTime = this.estimateRT60(estimatedVolume);
            const transitionFreq = this.calculateSchroederFrequency(reverbTime, estimatedVolume);

            // Calculate room modes
            const modes = this.calculateRoomModes(estimatedLength, estimatedWidth, estimatedHeight);

            return {
              dimensions: {
                length: estimatedLength,
                width: estimatedWidth,
                height: estimatedHeight,
                volume: estimatedVolume,
                surfaceArea: 2 * (estimatedLength * estimatedWidth + estimatedLength * estimatedHeight + estimatedWidth * estimatedHeight)
              },
              transitionFreq: transitionFreq,
              modes: modes,
              reverbTime: reverbTime
            };

          } catch (error) {
            this.addValidationError(`Room acoustics calculation error: ${error.message}`);
            return { dimensions: null, transitionFreq: null, modes: [] };
          }
        }

        // Calculate room modes using CEDIA RP22 methodology
        calculateRoomModes(length, width, height) {
          const modes = [];
          const c = this.PRECISION.SPEED_OF_SOUND;

          // Generate axial, tangential, and oblique modes up to 300Hz
          for (let nx = 0; nx <= 10; nx++) {
            for (let ny = 0; ny <= 10; ny++) {
              for (let nz = 0; nz <= 10; nz++) {
                if (nx === 0 && ny === 0 && nz === 0) continue;

                const frequency = (c / 2) * Math.sqrt(
                  Math.pow(nx / length, 2) +
                  Math.pow(ny / width, 2) +
                  Math.pow(nz / height, 2)
                );

                if (frequency <= 300) {
                  const nonZeros = [nx, ny, nz].filter(n => n > 0).length;
                  let type = 'oblique';
                  if (nonZeros === 1) type = 'axial';      // Strongest impact
                  else if (nonZeros === 2) type = 'tangential'; // -3dB relative

                  modes.push({
                    frequency: Math.round(frequency * 10) / 10,
                    type: type,
                    order: [nx, ny, nz],
                    strength: type === 'axial' ? 1.0 : type === 'tangential' ? 0.5 : 0.25
                  });
                }
              }
            }
          }

          return modes.sort((a, b) => a.frequency - b.frequency);
        }

        // Calculate Schroeder transition frequency using CEDIA RP22 formula
        calculateSchroederFrequency(reverbTime, volume) {
          // fs = 2000 √ó ‚àö(T60/V) - CEDIA RP22 formula
          return Math.round(2000 * Math.sqrt(reverbTime / volume));
        }

        // Estimate RT60 using simplified residential model
        estimateRT60(volume) {
          // CEDIA RP22 target: Tm = 0.3 (V / 100)^(1/3)
          const targetRT60 = 0.3 * Math.pow(volume / 100, 1 / 3);

          // Typical residential RT60 tends to be slightly higher than target
          return Math.min(targetRT60 * 1.2, 0.6); // Cap at 0.6 seconds
        }

        // Calculate all speaker angles from distances using CEDIA placement guidelines
        calculateAllSpeakerAngles(systemData) {
          const angles = {};
          const distances = systemData.estimatedDistances || {};

          if (Object.keys(distances).length === 0) {
            return angles;
          }

          try {
            // Get center speaker distance as reference
            const centerDistance = distances['C'] || distances['FC'] || null;
            if (!centerDistance) {
              this.addValidationError("No center speaker distance found for angle calculations");
              return angles;
            }

            // Calculate angles for each speaker relative to center
            Object.entries(distances).forEach(([speakerId, distance]) => {
              if (speakerId === 'C' || speakerId === 'FC') {
                angles[speakerId] = { horizontal: 0, vertical: 0, elevation: 0 };
                return;
              }

              // Use trigonometric calculations for precise angles
              const speakerAngles = this.calculateSpeakerAngle(speakerId, distance, centerDistance);
              angles[speakerId] = speakerAngles;
            });

            return angles;

          } catch (error) {
            this.addValidationError(`Speaker angle calculation error: ${error.message}`);
            return angles;
          }
        }

        // Calculate speaker angles using coordinate geometry and CEDIA guidelines
        calculateSpeakerAngle(speakerId, distance, centerDistance) {
          const speakerType = this.classifySpeakerType(speakerId);

          // CEDIA RP22 placement specifications
          const placementGuidelines = {
            front: { horizontal: 30, vertical: 0, elevation: 0 },        // FL/FR ¬±30¬∞
            frontWide: { horizontal: 60, vertical: 0, elevation: 0 },    // FWL/FWR ¬±60¬∞
            surround: { horizontal: 90, vertical: 0, elevation: 5 },     // SL/SR ¬±90¬∞
            surroundBack: { horizontal: 135, vertical: 0, elevation: 5 }, // SBL/SBR ¬±135¬∞
            frontHeight: { horizontal: 30, vertical: 30, elevation: 30 }, // Height speakers
            rearHeight: { horizontal: 135, vertical: 30, elevation: 30 },
            topFront: { horizontal: 30, vertical: 45, elevation: 45 },   // Top speakers
            topRear: { horizontal: 135, vertical: 45, elevation: 45 },
            subwoofer: { horizontal: 0, vertical: 0, elevation: 0 }      // Subwoofers
          };

          const baseAngles = placementGuidelines[speakerType] || { horizontal: 0, vertical: 0, elevation: 0 };

          // Adjust for left/right positioning using trigonometry
          let horizontalAngle = baseAngles.horizontal;
          if (speakerId.includes('L') || speakerId.includes('l')) {
            horizontalAngle = -Math.abs(horizontalAngle); // Negative for left
          } else if (speakerId.includes('R') || speakerId.includes('r')) {
            horizontalAngle = Math.abs(horizontalAngle);  // Positive for right
          }

          // Calculate distance-based adjustments using trigonometric principles
          const distanceRatio = distance / centerDistance;
          const adjustedHorizontal = horizontalAngle * Math.min(distanceRatio, 1.5); // Limit adjustment

          return {
            horizontal: Math.round(adjustedHorizontal * 10) / 10,
            vertical: baseAngles.vertical,
            elevation: baseAngles.elevation,
            distance: distance,
            distanceRatio: Math.round(distanceRatio * 100) / 100
          };
        }

        // Classify speaker by ID for angle calculations
        classifySpeakerType(speakerId) {
          const id = speakerId.toLowerCase();

          if (['fl', 'fr'].includes(id)) return 'front';
          if (['fwl', 'fwr'].includes(id)) return 'frontWide';
          if (['sl', 'sr', 'sla', 'sra'].includes(id)) return 'surround';
          if (['sbl', 'sbr', 'sb'].includes(id)) return 'surroundBack';
          if (['fhl', 'fhr', 'hfl', 'hfr'].includes(id)) return 'frontHeight';
          if (['rhl', 'rhr', 'hbl', 'hbr'].includes(id)) return 'rearHeight';
          if (['tfl', 'tfr'].includes(id)) return 'topFront';
          if (['tbl', 'tbr', 'trl', 'trr'].includes(id)) return 'topRear';
          if (id.startsWith('sw')) return 'subwoofer';

          return 'other';
        }

        // Analyze bass management impact on crossovers
        analyzeBassManagement(systemData) {
          const crossovers = systemData.crossoverData || {};
          const analysis = {
            averageCrossover: 80, // Default THX standard
            crossoverSpread: 0,
            bassManagementEfficiency: 1.0,
            recommendations: []
          };

          try {
            if (Object.keys(crossovers).length > 0) {
              const crossoverValues = Object.values(crossovers).filter(v => Number.isFinite(v));

              if (crossoverValues.length > 0) {
                analysis.averageCrossover = crossoverValues.reduce((sum, xo) => sum + xo, 0) / crossoverValues.length;
                analysis.crossoverSpread = Math.max(...crossoverValues) - Math.min(...crossoverValues);

                // Efficiency based on crossover consistency
                analysis.bassManagementEfficiency = Math.max(0.5, 1 - (analysis.crossoverSpread / 100));

                // Generate recommendations
                if (analysis.crossoverSpread > 40) {
                  analysis.recommendations.push("High crossover spread detected - consider standardizing crossover frequencies");
                }
                if (analysis.averageCrossover > 120) {
                  analysis.recommendations.push("High average crossover may compromise bass integration");
                }
                if (analysis.averageCrossover < 60) {
                  analysis.recommendations.push("Low average crossover may stress main speakers");
                }
              }
            }

            return analysis;
          } catch (error) {
            this.addValidationError(`Bass management analysis error: ${error.message}`);
            return analysis;
          }
        }

        // Enhanced SPL calculations with speaker-specific playback levels
        calculateEnhancedSPLDifferences(systemData) {
          // Try to use estimatedPlaybackLevels first, fall back to customLevel
          let levelData = null;
          let dataSource = null;

          if (systemData.estimatedPlaybackLevels && Object.keys(systemData.estimatedPlaybackLevels).length > 0) {
            levelData = systemData.estimatedPlaybackLevels;
            dataSource = "estimatedPlaybackLevels";
          } else if (systemData.customLevel && Array.isArray(systemData.customLevel)) {
            // Convert customLevel array to object format for consistency
            levelData = {};
            systemData.customLevel.forEach((level, index) => {
              if (index > 0 && level !== undefined) {
                levelData[`Speaker_${index}`] = parseFloat(level);
              }
            });
            dataSource = "customLevel";
          }

          if (!levelData || Object.keys(levelData).length === 0) {
            return { error: "No valid level data available", maxDifference: null, dataSource: null };
          }

          try {
            // Extract numeric levels, filtering out invalid values
            const levels = Object.values(levelData)
              .map(level => parseFloat(level))
              .filter(level => Number.isFinite(level));

            if (levels.length < 2) {
              return { error: "Insufficient level data for comparison", maxDifference: null, dataSource };
            }

            // Calculate comprehensive statistics
            const maxLevel = Math.max(...levels);
            const minLevel = Math.min(...levels);
            const maxDifference = this.preciseSubtraction(maxLevel, minLevel);
            const avgLevel = levels.reduce((sum, level) => sum + level, 0) / levels.length;
            const stdDev = Math.sqrt(levels.reduce((sum, level) => sum + Math.pow(level - avgLevel, 2), 0) / levels.length);

            // Enhanced analysis by speaker groups using actual speaker IDs
            const groupAnalysis = this.analyzeSpeakerGroupSPL(levelData);

            return {
              maxDifference,
              minLevel,
              maxLevel,
              avgLevel: Math.round(avgLevel * 10) / 10,
              standardDeviation: Math.round(stdDev * 10) / 10,
              screenSpeakerDiff: groupAnalysis.screenSpeakers.maxDiff,
              surroundSpeakerDiff: groupAnalysis.surroundSpeakers.maxDiff,
              upperSpeakerDiff: groupAnalysis.upperSpeakers.maxDiff,
              subwooferLevel: groupAnalysis.subwoofers.avgLevel,
              speakerCount: levels.length,
              levelConsistency: maxDifference <= 2.0 ? 'Excellent' : maxDifference <= 4.0 ? 'Good' : 'Needs Improvement',
              dataSource: dataSource,
              groupAnalysis: groupAnalysis,
              recommendations: this.generateSPLRecommendations(maxDifference, groupAnalysis)
            };
          } catch (error) {
            return { error: `SPL calculation error: ${error.message}`, maxDifference: null, dataSource };
          }
        }

        // Analyze SPL by speaker groups using actual speaker IDs
        analyzeSpeakerGroupSPL(levelData) {
          const groups = {
            screenSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            surroundSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            upperSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            subwoofers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            wideSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            unclassified: { speakers: [], levels: [], maxDiff: 0, avgLevel: null }
          };

          // Classify speakers by their IDs
          Object.entries(levelData).forEach(([speakerId, level]) => {
            const numLevel = parseFloat(level);
            if (!Number.isFinite(numLevel)) return;

            // Classify speaker by ID
            if (speakerId.toLowerCase().includes('subwoofer') || speakerId.startsWith('SW')) {
              groups.subwoofers.speakers.push(speakerId);
              groups.subwoofers.levels.push(numLevel);
            } else if (['FL', 'FC', 'FR', 'FCL', 'FCR', 'C'].includes(speakerId)) {
              groups.screenSpeakers.speakers.push(speakerId);
              groups.screenSpeakers.levels.push(numLevel);
            } else if (['FWL', 'FWR'].includes(speakerId)) {
              groups.wideSpeakers.speakers.push(speakerId);
              groups.wideSpeakers.levels.push(numLevel);
            } else if (['FHL', 'FHR', 'RHL', 'RHR', 'SHL', 'SHR', 'CH', 'TFL', 'TFR', 'TML', 'TMR', 'TRL', 'TRR', 'TS'].includes(speakerId)) {
              // Height or Top speakers
              groups.upperSpeakers.speakers.push(speakerId);
              groups.upperSpeakers.levels.push(numLevel);
            } else if (['BDL', 'BDR', 'FDL', 'FDR', 'SDL', 'SDR'].includes(speakerId)) {
              // Upfiring speakers - classify as upper speakers for CEDIA assessment
              groups.upperSpeakers.speakers.push(speakerId);
              groups.upperSpeakers.levels.push(numLevel);
            } else if (['SL', 'SR', 'SBL', 'SBR', 'SLA', 'SRA', 'SB'].includes(speakerId)) {
              groups.surroundSpeakers.speakers.push(speakerId);
              groups.surroundSpeakers.levels.push(numLevel);
            } else {
              groups.unclassified.speakers.push(speakerId);
              groups.unclassified.levels.push(numLevel);
            }
          });

          // Calculate statistics for each group
          Object.keys(groups).forEach(groupName => {
            const group = groups[groupName];
            if (group.levels.length > 0) {
              const maxLevel = Math.max(...group.levels);
              const minLevel = Math.min(...group.levels);
              group.maxDiff = this.preciseSubtraction(maxLevel, minLevel);
              group.avgLevel = Math.round((group.levels.reduce((sum, level) => sum + level, 0) / group.levels.length) * 10) / 10;
            }
          });

          return groups;
        }

        // Generate SPL-based recommendations
        generateSPLRecommendations(maxDifference, groupAnalysis) {
          const recommendations = [];

          if (maxDifference > 6) {
            recommendations.push("Critical: SPL difference >6dB detected. Review speaker placement, amplification, and calibration.");
          } else if (maxDifference > 4) {
            recommendations.push("Warning: SPL difference >4dB may affect imaging. Check speaker levels and room acoustics.");
          } else if (maxDifference > 2) {
            recommendations.push("Notice: SPL difference >2dB detected. Fine-tune calibration for optimal performance.");
          }

          // Group-specific recommendations
          if (groupAnalysis.screenSpeakers.maxDiff > 3) {
            recommendations.push("Screen speakers show significant level differences. Ensure matched amplification and verify speaker sensitivity.");
          }

          if (groupAnalysis.upperSpeakers.maxDiff > 5) {
            recommendations.push("Upper layer speakers show large level variations. Check mounting angles and amplifier settings.");
          }

          if (groupAnalysis.subwoofers.levels.length > 0) {
            const subLevel = groupAnalysis.subwoofers.avgLevel;
            const mainAvg = (groupAnalysis.screenSpeakers.avgLevel + groupAnalysis.surroundSpeakers.avgLevel) / 2;
            if (subLevel && mainAvg && Math.abs(subLevel - mainAvg) > 10) {
              recommendations.push("Subwoofer level significantly different from main speakers. Review bass management settings.");
            }
          }

          return recommendations;
        }

        // Enhanced room size estimation with acoustic modeling
        estimateEnhancedRoomSize(systemData) {
          // Use advanced room acoustics data if available
          if (systemData.roomAcoustics && systemData.roomAcoustics.dimensions) {
            return {
              estimatedLength: systemData.roomAcoustics.dimensions.length,
              estimatedWidth: systemData.roomAcoustics.dimensions.width,
              estimatedHeight: systemData.roomAcoustics.dimensions.height,
              estimatedVolume: systemData.roomAcoustics.dimensions.volume,
              surfaceArea: systemData.roomAcoustics.dimensions.surfaceArea,
              transitionFrequency: systemData.roomAcoustics.transitionFreq,
              reverbTime: systemData.roomAcoustics.reverbTime,
              roomModes: systemData.roomAcoustics.modes
            };
          }

          if (!systemData.customDistance || !systemData.flDist) {
            return { error: "Insufficient distance data", estimatedLength: null };
          }

          try {
            const distances = systemData.customDistance
              .slice(1)
              .map(dist => parseFloat(dist))
              .filter(dist => Number.isFinite(dist) && dist > 0);

            if (distances.length === 0) {
              return { error: "No valid distance measurements", estimatedLength: null };
            }

            const maxDistance = Math.max(...distances);
            const avgDistance = distances.reduce((sum, dist) => sum + dist, 0) / distances.length;

            // Enhanced room estimation using acoustic principles
            const estimatedLength = maxDistance * 1.6;
            const estimatedWidth = maxDistance * 1.2;
            const estimatedHeight = maxDistance * 0.4;
            const estimatedVolume = estimatedLength * estimatedWidth * estimatedHeight;

            // Calculate transition frequency for the room
            const reverbTime = this.estimateRT60(estimatedVolume);
            const transitionFreq = this.calculateSchroederFrequency(reverbTime, estimatedVolume);

            return {
              estimatedLength,
              estimatedWidth,
              estimatedHeight,
              estimatedVolume,
              avgListeningDistance: avgDistance,
              maxListeningDistance: maxDistance,
              wallProximity: Math.min(avgDistance * 0.25, 1.8),
              transitionFrequency: transitionFreq,
              reverbTime: reverbTime,
              roomRatio: {
                lengthToWidth: estimatedLength / estimatedWidth,
                widthToHeight: estimatedWidth / estimatedHeight,
                evaluation: this.evaluateRoomRatio(estimatedLength / estimatedWidth)
              }
            };
          } catch (error) {
            return { error: `Room estimation error: ${error.message}`, estimatedLength: null };
          }
        }

        // Enhanced system analysis with comprehensive validation
        analyzeEnhancedSystem() {
          if (!commandId || !Array.isArray(commandId)) {
            this.addValidationError("No valid speaker configuration detected");
            return null;
          }

          try {
            const actualSpeakers = commandId.filter(id => id && typeof id === 'string' && id.length > 0);

            // Enhanced speaker classification
            const analysis = {
              detectedSpeakers: actualSpeakers,

              // Categorize speakers by type
              screenSpeakers: actualSpeakers.filter(id =>
                ['FL', 'FC', 'FR', 'FCL', 'FCR', 'C'].includes(id)),

              heightSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.frontHeight.includes(id) ||
                this.speakerTypes.rearHeight.includes(id) ||
                this.speakerTypes.surroundHeight.includes(id)),

              topSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.topFront.includes(id) ||
                this.speakerTypes.topMiddle.includes(id) ||
                this.speakerTypes.topRear.includes(id)),

              upfiringSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.upfiringFront.includes(id) ||
                this.speakerTypes.upfiringBack.includes(id) ||
                this.speakerTypes.upfiringSurround.includes(id)),

              surroundSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.surround.includes(id) ||
                this.speakerTypes.surroundBack.includes(id)),

              wideSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.frontWide.includes(id)),

              subwoofers: actualSpeakers.filter(id => id.startsWith("SW")),

              totalMainSpeakers: 0,
              bedLayerSpeakers: 0,
              totalUpperSpeakers: 0,
              discreteSpeakerFeeds: 0,
              systemComplexity: 'Basic'
            };

            // Calculate totals correctly for X.Y.Z configuration format
            analysis.totalMainSpeakers = actualSpeakers.filter(id => !id.startsWith("SW")).length;
            analysis.totalUpperSpeakers = analysis.heightSpeakers.length + analysis.topSpeakers.length + analysis.upfiringSpeakers.length;

            // Bed layer = all main speakers EXCEPT height/top/upfiring speakers
            analysis.bedLayerSpeakers = analysis.totalMainSpeakers - analysis.totalUpperSpeakers;

            analysis.discreteSpeakerFeeds = analysis.totalMainSpeakers + (analysis.subwoofers.length > 0 ? 1 : 0);
            analysis.usesUpfiring = analysis.upfiringSpeakers.length > 0;

            // Calculate proper X.Y.Z configuration string
            const subCount = analysis.subwoofers.length > 0 ? 1 : systemData.nSubs > 0 ? 1 : 0;
            analysis.configurationString = `${analysis.bedLayerSpeakers}.${subCount}.${analysis.totalUpperSpeakers}`;

            // Assess system complexity based on bed layer + height speakers
            if (analysis.bedLayerSpeakers >= 7 || analysis.totalUpperSpeakers >= 4) {
              analysis.systemComplexity = 'High';
            } else if (analysis.bedLayerSpeakers >= 5 || analysis.totalUpperSpeakers >= 2) {
              analysis.systemComplexity = 'Medium';
            }

            // Validate speaker configuration
            analysis.configurationValid = this.validateSpeakerConfiguration(analysis);
            analysis.formatCompatibility = this.assessFormatCompatibility(analysis);

            return analysis;
          } catch (error) {
            this.addValidationError(`System analysis error: ${error.message}`);
            return null;
          }
        }

        // Enhanced parameter evaluation with comprehensive validation
        evaluateParameter(paramId, measuredValue, useRecommended = false) {
          const param = this.parameters[paramId];
          if (!param) {
            return {
              level: 0,
              score: 0,
              error: `Parameter ${paramId} not found`,
              measuredValue: null,
              category: "Unknown"
            };
          }

          try {
            // Use parameter-specific validator if available
            if (param.validator && typeof param.validator === 'function') {
              const validationResult = param.validator(measuredValue);
              if (!validationResult.valid) {
                return {
                  level: 0,
                  score: 0,
                  error: validationResult.error,
                  measuredValue,
                  category: param.category,
                  parameterName: param.name
                };
              }
              measuredValue = validationResult.value; // Use validated/normalized value
            }

            const { targets, type } = param;
            let achievedLevel = 0;

            // Special handling for boolean parameters
            if (paramId === 8) {
              achievedLevel = measuredValue === false ? 4 : 2;
              return {
                level: achievedLevel,
                score: achievedLevel * 25,
                measuredValue: measuredValue,
                category: param.category,
                notes: measuredValue ? "Using upfiring speakers" : "Using dedicated height/top speakers",
                parameterName: param.name,
                recommendation: measuredValue ? "Consider upgrading to dedicated height speakers for levels 3-4" : "Excellent speaker configuration"
              };
            }

            // Evaluate against performance level targets
            for (let level = 1; level <= 4; level++) {
              const target = targets[`level${level}`];
              if (target === null || target === undefined) continue;

              let passes = false;
              if (typeof target === 'object') {
                const threshold = useRecommended && target.rec !== undefined ? target.rec :
                  type === "minimum" ? target.min : target.max;

                if (threshold !== undefined) {
                  passes = type === "minimum" ?
                    this.preciseComparison(measuredValue, threshold, '>=') :
                    this.preciseComparison(measuredValue, threshold, '<=');
                }
              } else {
                passes = type === "minimum" ?
                  this.preciseComparison(measuredValue, target, '>=') :
                  this.preciseComparison(measuredValue, target, '<=');
              }

              if (passes) {
                achievedLevel = level;
              } else {
                break;
              }
            }

            return {
              level: achievedLevel,
              score: achievedLevel * 25,
              measuredValue: measuredValue,
              category: param.category,
              parameterName: param.name,
              recommendation: this.generateRecommendation(paramId, achievedLevel, measuredValue),
              targetValues: targets,
              usedRecommended: useRecommended
            };

          } catch (error) {
            return {
              level: 0,
              score: 0,
              error: `Evaluation error: ${error.message}`,
              measuredValue,
              category: param.category,
              parameterName: param.name
            };
          }
        }

        // Enhanced performance calculation with weighted scoring
        calculateSystemPerformance(results) {
          const validResults = Object.values(results).filter(r => r.level > 0 && !r.error);
          const errorResults = Object.values(results).filter(r => r.error);

          if (validResults.length === 0) {
            return {
              overallLevel: 0,
              overallScore: 0,
              category: "Non-compliant",
              errors: errorResults.length,
              confidence: "Low"
            };
          }

          // Calculate weighted performance based on parameter importance
          const spatialResults = validResults.filter(r => r.category === "Spatial Resolution");
          const dynamicResults = validResults.filter(r => r.category === "Dynamics");
          const timbreResults = validResults.filter(r => r.category === "Timbre");

          // Calculate category scores with weighting
          const spatialScore = spatialResults.length > 0 ?
            spatialResults.reduce((sum, r) => sum + r.score, 0) / spatialResults.length : 0;
          const dynamicScore = dynamicResults.length > 0 ?
            dynamicResults.reduce((sum, r) => sum + r.score, 0) / dynamicResults.length : 0;
          const timbreScore = timbreResults.length > 0 ?
            timbreResults.reduce((sum, r) => sum + r.score, 0) / timbreResults.length : 0;

          // Weighted overall score (Dynamics and Timbre are weighted higher)
          const weightedScore = Math.round(
            (spatialScore * 0.3 + dynamicScore * 0.4 + timbreScore * 0.3)
          );

          // Overall level is the minimum of all achieved levels (conservative approach)
          const minLevel = Math.min(...validResults.map(r => r.level));
          const avgScore = Math.round(validResults.reduce((sum, r) => sum + r.score, 0) / validResults.length);

          // Determine confidence level
          const completeness = validResults.length / 21; // Out of total 21 parameters
          const confidence = completeness >= 0.7 ? "High" :
            completeness >= 0.5 ? "Medium" : "Low";

          const categories = [
            "Non-compliant",
            "Performance Level 1",
            "Performance Level 2",
            "Performance Level 3",
            "Performance Level 4"
          ];

          return {
            overallLevel: minLevel,
            overallScore: avgScore,
            weightedScore: weightedScore,
            category: categories[minLevel] || "Non-compliant",
            totalParametersEvaluated: validResults.length,
            totalParametersAvailable: 21,
            completeness: Math.round(completeness * 100),
            confidence: confidence,
            categoryBreakdown: {
              spatial: { count: spatialResults.length, avgScore: Math.round(spatialScore) },
              dynamics: { count: dynamicResults.length, avgScore: Math.round(dynamicScore) },
              timbre: { count: timbreResults.length, avgScore: Math.round(timbreScore) }
            },
            errors: errorResults.length,
            warnings: this.validationErrors.length
          };
        }

        // Enhanced main assessment function with comprehensive analysis
        runReadOnlyAssessment() {
          console.log("‚ïê".repeat(75));
          console.log("üéØ CEDIA/CTA-RP22 ENHANCED PERFORMANCE ASSESSMENT v2.1");
          console.log("   üî¨ Advanced Acoustic Analysis & CEDIA RP22 Mathematics");
          console.log("‚ïê".repeat(75));

          // Reset validation errors
          this.validationErrors = [];

          try {
            const systemData = this.captureAllSystemData();
            const systemAnalysis = this.analyzeEnhancedSystem();
            const splDifferences = this.calculateEnhancedSPLDifferences(systemData);
            const roomEstimate = this.estimateEnhancedRoomSize(systemData);

            if (!systemAnalysis) {
              console.error("‚ùå Cannot analyze system - insufficient data");
              this.logValidationErrors();
              return { error: "System analysis failed", validationErrors: this.validationErrors };
            }

            console.log("\nüìã COMPREHENSIVE SYSTEM ANALYSIS:");
            const subCount = systemAnalysis.subwoofers.length > 0 ? 1 : systemData.nSubs > 0 ? 1 : 0;
            console.log(`‚îú‚îÄ Configuration: ${systemAnalysis.configurationString} (${systemAnalysis.bedLayerSpeakers} bed + ${subCount} LFE + ${systemAnalysis.totalUpperSpeakers} height)`);
            console.log(`‚îú‚îÄ Discrete speaker feeds: ${systemAnalysis.discreteSpeakerFeeds}`);
            console.log(`‚îú‚îÄ System complexity: ${systemAnalysis.systemComplexity}`);

            // Enhanced frequency data reporting
            if (systemData.freqIndex && systemData.freqIndex.frequencies) {
              console.log(`‚îú‚îÄ Frequency analysis: ${systemData.freqIndex.count} measurement points (${systemData.freqIndex.minFreq}-${systemData.freqIndex.maxFreq}Hz)`);
              console.log(`‚îú‚îÄ Measurement type: ${systemData.freqIndex.is1_3Octave ? '1/3 octave' : `~${systemData.freqIndex.bandsPerOctave} bands/octave`}`);
              console.log(`‚îú‚îÄ Frequency range: ${(systemData.freqIndex.frequencyRange || 1).toFixed(1)}:1 ratio`);
            }

            // Enhanced timing data reporting
            if (systemData.mSec && systemData.mSec.delays) {
              console.log(`‚îú‚îÄ Timing analysis: ${systemData.mSec.count} speaker delays analyzed`);
              // console.log(`‚îú‚îÄ Delay spread: ${(systemData.mSec.delaySpread * 1000).toFixed(2)}ms (œÉ=${(systemData.mSec.stdDeviation * 1000).toFixed(2)}ms)`);
              console.log(`‚îú‚îÄ Delay spread: ${(systemData.mSec.delaySpread * delaymax).toFixed(2)}ms (œÉ=${(systemData.mSec.stdDeviation * delaymax).toFixed(2)}ms)`);
              console.log(`‚îú‚îÄ Timing consistency: ${systemData.mSec.timingConsistency}`);
              console.log(`‚îú‚îÄ Early reflection est: ${systemData.mSec.earlyReflectionMetric}dB`);
            }

            // Enhanced playback levels reporting
            if (systemData.estimatedPlaybackLevels && Object.keys(systemData.estimatedPlaybackLevels).length > 0) {
              console.log(`‚îú‚îÄ Playback levels: ${Object.keys(systemData.estimatedPlaybackLevels).length} speakers measured`);
              if (splDifferences && !splDifferences.error) {
                console.log(`‚îú‚îÄ SPL consistency: ${splDifferences.levelConsistency} (max diff: ${splDifferences.maxDifference?.toFixed(1)}dB)`);
              }
            }

            // Enhanced speaker positioning analysis
            if (systemData.speakerAngles && Object.keys(systemData.speakerAngles).length > 0) {
              console.log(`‚îú‚îÄ Speaker angles: ${Object.keys(systemData.speakerAngles).length} speakers calculated`);
              const avgHorizontal = Object.values(systemData.speakerAngles)
                .map(a => Math.abs(a.horizontal))
                .reduce((sum, a) => sum + a, 0) / Object.keys(systemData.speakerAngles).length;
              console.log(`‚îú‚îÄ Avg horizontal angle: ${avgHorizontal.toFixed(1)}¬∞`);
            }

            console.log(`‚îú‚îÄ Screen speakers: ${systemAnalysis.screenSpeakers.join(", ") || "None"}`);
            console.log(`‚îú‚îÄ Height speakers: ${systemAnalysis.heightSpeakers.join(", ") || "None"}`);
            console.log(`‚îú‚îÄ Top speakers: ${systemAnalysis.topSpeakers.join(", ") || "None"}`);
            console.log(`‚îú‚îÄ Wide speakers: ${systemAnalysis.wideSpeakers.join(", ") || "None"}`);
            console.log(`‚îú‚îÄ Surround speakers: ${systemAnalysis.surroundSpeakers.join(", ") || "None"}`);
            console.log(`‚îú‚îÄ Upfiring speakers: ${systemAnalysis.upfiringSpeakers.join(", ") || "None"}`);

            // Enhanced bass management reporting
            if (systemData.bassManagement) {
              console.log(`‚îú‚îÄ Bass management: Avg XO ${systemData.bassManagement.averageCrossover.toFixed(0)}Hz, Spread ${systemData.bassManagement.crossoverSpread.toFixed(0)}Hz`);
            }
            console.log(`‚îú‚îÄ Bass system: ${systemData.nSubs} sub(s), ${systemData.bassMode} mode`);

            // Enhanced room acoustics reporting
            if (roomEstimate && !roomEstimate.error) {
              console.log(`‚îú‚îÄ Room estimate: ${roomEstimate.estimatedLength?.toFixed(1)}√ó${roomEstimate.estimatedWidth?.toFixed(1)}√ó${roomEstimate.estimatedHeight?.toFixed(1)}m`);
              console.log(`‚îú‚îÄ Room volume: ${roomEstimate.estimatedVolume?.toFixed(1)}m¬≥`);
              if (roomEstimate.transitionFrequency) {
                console.log(`‚îú‚îÄ Transition freq: ${roomEstimate.transitionFrequency?.toFixed(0)}Hz (RT60: ${roomEstimate.reverbTime?.toFixed(2)}s)`);
              }
              if (roomEstimate.roomModes && roomEstimate.roomModes.length > 0) {
                const axialModes = roomEstimate.roomModes.filter(m => m.type === 'axial').slice(0, 3);
                if (axialModes.length > 0) {
                  console.log(`‚îú‚îÄ Primary room modes: ${axialModes.map(m => `${m.frequency}Hz`).join(", ")}`);
                }
              }
            }

            if (systemAnalysis.formatCompatibility) {
              console.log(`‚îî‚îÄ Format support: ${Object.entries(systemAnalysis.formatCompatibility).filter(([_, supported]) => supported).map(([format, _]) => format).join(", ")}`);
            }

            // Enhanced parameter evaluation using comprehensive data analysis
            const results = {};

            // Spatial Resolution Parameters (1-11)
            if (roomEstimate && roomEstimate.wallProximity !== null && !roomEstimate.error) {
              results[1] = this.evaluateParameter(1, roomEstimate.wallProximity);
            }

            results[2] = this.evaluateParameter(2, systemAnalysis.discreteSpeakerFeeds);
            results[3] = this.evaluateParameter(3, this.countOutOfZoneSpeakers(systemAnalysis, 'screen'));
            results[8] = this.evaluateParameter(8, systemAnalysis.usesUpfiring);
            results[11] = this.evaluateParameter(11, this.countOutOfZoneSpeakers(systemAnalysis, 'all'));

            // Enhanced angle-based parameters using calculated angles
            if (systemData.speakerAngles && Object.keys(systemData.speakerAngles).length > 0) {
              const maxSurroundAngle = this.calculateMaxAdjacentSurroundAngle(systemData.speakerAngles, systemAnalysis.surroundSpeakers);
              const maxUpperAngle = this.calculateMaxAdjacentUpperAngle(systemData.speakerAngles, systemAnalysis.heightSpeakers.concat(systemAnalysis.topSpeakers));
              const wideDeviation = this.calculateWideDeviationFromMedian(systemData.speakerAngles, systemAnalysis.wideSpeakers);

              if (maxSurroundAngle !== null) results[5] = this.evaluateParameter(5, maxSurroundAngle);
              if (maxUpperAngle !== null) results[9] = this.evaluateParameter(9, maxUpperAngle);
              if (wideDeviation !== null) results[7] = this.evaluateParameter(7, wideDeviation);
            }

            // SPL-based parameters (4, 6, 10) - Enhanced with speaker-specific data
            if (splDifferences && splDifferences.maxDifference !== null && !splDifferences.error) {
              results[4] = this.evaluateParameter(4, splDifferences.screenSpeakerDiff || splDifferences.maxDifference);
              results[6] = this.evaluateParameter(6, splDifferences.surroundSpeakerDiff || splDifferences.maxDifference);
              results[10] = this.evaluateParameter(10, splDifferences.upperSpeakerDiff || splDifferences.maxDifference);
            }

            // Dynamics Parameters (12-15) - Enhanced with playback level data
            if (systemData.estimatedPlaybackLevels && Object.keys(systemData.estimatedPlaybackLevels).length > 0) {
              // Use actual measured levels for SPL capability assessment
              const screenCapability = this.calculateSpeakerCapability(systemData.estimatedPlaybackLevels, 'screen', roomEstimate);
              const surroundCapability = this.calculateSpeakerCapability(systemData.estimatedPlaybackLevels, 'surround', roomEstimate);
              const subwooferCapability = this.calculateSpeakerCapability(systemData.estimatedPlaybackLevels, 'subwoofer', roomEstimate);

              if (screenCapability !== null) {
                results[12] = this.evaluateParameter(12, screenCapability, true);
              }
              if (surroundCapability !== null) {
                results[13] = this.evaluateParameter(13, surroundCapability, true);
              }
              if (subwooferCapability !== null) {
                results[14] = this.evaluateParameter(14, subwooferCapability, true);
              }
            } else if (systemData.targetLevel && Number.isFinite(systemData.targetLevel)) {
              // Fallback to estimated calculations
              const roomGain = roomEstimate && roomEstimate.estimatedVolume ?
                Math.max(0, 3 * Math.log10(100 / roomEstimate.estimatedVolume)) : 0;

              results[12] = this.evaluateParameter(12, systemData.targetLevel + 25 + roomGain, true);
              results[13] = this.evaluateParameter(13, systemData.targetLevel + 20 + roomGain, true);
              results[14] = this.evaluateParameter(14, systemData.targetLevel + 35 + roomGain, true);
            }

            // Estimate background noise (simplified - would need actual measurement)
            const estimatedNoiseFloor = this.estimateBackgroundNoise(systemData, roomEstimate);
            if (estimatedNoiseFloor !== null) {
              results[15] = this.evaluateParameter(15, estimatedNoiseFloor, true);
            }

            // Enhanced frequency response analysis using freqIndex data (Parameters 16, 17, 18)
            if (systemData.freqIndex && systemData.freqIndex.frequencies) {
              // Parameter 16: Screen wall speaker frequency response variance
              const screenFRVariance = this.calculateFrequencyResponseVariance(systemData, 'screen');
              if (screenFRVariance !== null) {
                results[16] = this.evaluateParameter(16, screenFRVariance);
              }

              // Parameter 17: Surround/Upper speaker frequency response variance
              const surroundFRVariance = this.calculateFrequencyResponseVariance(systemData, 'surround');
              if (surroundFRVariance !== null) {
                results[17] = this.evaluateParameter(17, surroundFRVariance);
              }

              // Parameter 18: Enhanced bass extension using frequency analysis
              if (systemData.bassExtension) {
                results[18] = this.evaluateParameter(18, systemData.bassExtension, true);
              } else {
                // Estimate bass extension from frequency data
                const estimatedBassExt = this.estimateBassExtensionFromFrequencies(systemData.freqIndex);
                if (estimatedBassExt !== null) {
                  results[18] = this.evaluateParameter(18, estimatedBassExt, true);
                }
              }
            }

            // Enhanced bass analysis using optimization data
            if (systemData.RP22subnminXO && systemData.RP22submaxXO &&
              Number.isFinite(systemData.RP22subnminXO) && Number.isFinite(systemData.RP22submaxXO)) {

              const bandwidth = systemData.RP22submaxXO - systemData.RP22subnminXO;
              const smoothnessEst = this.estimateBassSmoothness(bandwidth, systemData.delayRange);

              if (smoothnessEst !== null) {
                results[19] = this.evaluateParameter(19, smoothnessEst);

                if (systemData.delayRange && systemData.delayRange.range !== null) {
                  const consistencyEst = this.estimateBassConsistency(systemData.delayRange.range);
                  results[20] = this.evaluateParameter(20, consistencyEst);
                }
              }
            }

            // Enhanced early reflection analysis using timing data (Parameter 21)
            if (systemData.mSec && systemData.mSec.delays) {
              const earlyReflectionLevel = systemData.mSec.earlyReflectionMetric;
              if (earlyReflectionLevel !== null) {
                results[21] = this.evaluateParameter(21, earlyReflectionLevel);
              }
            }

            // Calculate overall performance with enhanced metrics
            const performance = this.calculateSystemPerformance(results);

            console.log(`\nüèÜ ENHANCED PERFORMANCE RESULTS:`);
            console.log(`‚îú‚îÄ Overall Level: ${performance.overallLevel}/4 (${performance.category})`);
            console.log(`‚îú‚îÄ Assessment Score: ${performance.overallScore}/100 (Weighted: ${performance.weightedScore}/100)`);
            console.log(`‚îú‚îÄ Parameter Coverage: ${performance.totalParametersEvaluated}/21 (${performance.completeness}%)`);
            console.log(`‚îú‚îÄ Assessment Confidence: ${performance.confidence}`);
            console.log(`‚îú‚îÄ Spatial Resolution: ${performance.categoryBreakdown.spatial.count} params, avg ${performance.categoryBreakdown.spatial.avgScore}/100`);
            console.log(`‚îú‚îÄ Dynamics: ${performance.categoryBreakdown.dynamics.count} params, avg ${performance.categoryBreakdown.dynamics.avgScore}/100`);
            console.log(`‚îú‚îÄ Timbre: ${performance.categoryBreakdown.timbre.count} params, avg ${performance.categoryBreakdown.timbre.avgScore}/100`);
            if (performance.errors > 0) {
              console.log(`‚îú‚îÄ Errors: ${performance.errors} parameter evaluation errors`);
            }
            if (performance.warnings > 0) {
              console.log(`‚îú‚îÄ Warnings: ${performance.warnings} validation warnings`);
            }

            // Enhanced final reporting with SPL analysis details
            if (splDifferences && !splDifferences.error && splDifferences.dataSource) {
              console.log(`\nüìä SPL ANALYSIS DETAILS (Source: ${splDifferences.dataSource}):`);
              console.log(`‚îú‚îÄ Total speakers analyzed: ${splDifferences.speakerCount}`);
              console.log(`‚îú‚îÄ SPL range: ${splDifferences.minLevel?.toFixed(1)} - ${splDifferences.maxLevel?.toFixed(1)} dB`);
              console.log(`‚îú‚îÄ Average level: ${splDifferences.avgLevel} dB`);
              console.log(`‚îú‚îÄ Standard deviation: ${splDifferences.standardDeviation} dB`);
              console.log(`‚îú‚îÄ Screen speakers diff: ${splDifferences.screenSpeakerDiff?.toFixed(1)} dB`);
              console.log(`‚îú‚îÄ Surround speakers diff: ${splDifferences.surroundSpeakerDiff?.toFixed(1)} dB`);
              console.log(`‚îú‚îÄ Upper speakers diff: ${splDifferences.upperSpeakerDiff?.toFixed(1)} dB`);
              if (splDifferences.subwooferLevel) {
                console.log(`‚îú‚îÄ Subwoofer level: ${splDifferences.subwooferLevel} dB`);
              }
              console.log(`‚îî‚îÄ Overall consistency: ${splDifferences.levelConsistency}`);

              if (splDifferences.recommendations && splDifferences.recommendations.length > 0) {
                console.log(`\nüí° SPL RECOMMENDATIONS:`);
                splDifferences.recommendations.forEach((rec, index) => {
                  console.warn(`   ${index + 1}. ${rec}`);
                });
              }
            }

            console.log(`\nüìä DETAILED PARAMETER BREAKDOWN:`);
            Object.entries(results).forEach(([paramId, result]) => {
              const status = result.error ? "‚ùå" :
                result.level >= 3 ? "‚úÖ" :
                  result.level >= 2 ? "‚ö†Ô∏è" :
                    result.level >= 1 ? "üî∂" : "‚ùå";

              console.log(`${status} P${paramId.padStart(2, '0')}: ${result.parameterName}`);
              if (result.error) {
                console.log(`    ‚îî‚îÄ Error: ${result.error}`);
              } else {
                console.log(`    ‚îú‚îÄ Level: ${result.level}/4 | Score: ${result.score}/100`);
                console.log(`    ‚îú‚îÄ Measured: ${this.formatMeasuredValue(result.measuredValue, this.parameters[paramId].unit)}`);
                if (result.recommendation) {
                  console.log(`    ‚îî‚îÄ Recommendation: ${result.recommendation}`);
                }
              }
            });

            // Log validation errors and warnings if any
            this.logValidationErrors();

            console.log(`\nüìö Enhanced Analysis Notes:`);
            console.log(`‚îú‚îÄ Assessment uses CEDIA/CTA-RP22 v1.2 September 2023 standards`);
            console.log(`‚îú‚îÄ Frequency data processed as measurement point arrays with 1/3 octave analysis`);
            console.log(`‚îú‚îÄ Timing data analyzed for early reflection and alignment characteristics`);
            console.log(`‚îú‚îÄ Calculations include precision handling and validation`);
            console.log(`‚îú‚îÄ Room acoustics use Schroeder frequency and modal analysis`);
            console.log(`‚îú‚îÄ SPL calculations include boundary loading and room effects`);
            console.log(`‚îú‚îÄ Speaker angles calculated using trigonometric principles`);
            console.log(`‚îú‚îÄ Bass management analyzed using crossover optimization data`);
            console.log(`‚îú‚îÄ Frequency response variance estimated from measurement data patterns`);
            console.log(`‚îú‚îÄ Early reflections assessed from timing delay characteristics`);
            console.log(`‚îî‚îÄ Weighted scoring emphasizes critical performance areas`);
            console.log("‚ïê".repeat(75));

            return {
              systemData,
              systemAnalysis,
              performance,
              results,
              splDifferences,
              roomEstimate,
              validationErrors: this.validationErrors,
              timestamp: new Date().toISOString(),
              version: "2.1-Enhanced-Acoustics"
            };

          } catch (error) {
            console.error("‚ùå Assessment failed:", error.message);
            console.log("‚ïê".repeat(75));
            return {
              error: `Assessment failed: ${error.message}`,
              validationErrors: this.validationErrors,
              timestamp: new Date().toISOString()
            };
          }
        }

        // Additional helper methods for enhanced functionality

        // Calculate speaker SPL capability from measured levels
        calculateSpeakerCapability(playbackLevels, speakerGroup, roomEstimate) {
          const groupLevels = [];

          // Filter levels by speaker group
          Object.entries(playbackLevels).forEach(([speakerId, level]) => {
            const numLevel = parseFloat(level);
            if (!Number.isFinite(numLevel)) return;

            let matchesGroup = false;
            switch (speakerGroup.toLowerCase()) {
              case 'screen':
                matchesGroup = ['FL', 'FC', 'FR', 'FCL', 'FCR'].includes(speakerId);
                break;
              case 'surround':
                matchesGroup = ['SL', 'SR', 'SBL', 'SBR', 'SLA', 'SRA'].includes(speakerId) ||
                  speakerId.includes('SL') || speakerId.includes('SR') || speakerId.includes('SB');
                break;
              case 'subwoofer':
                matchesGroup = speakerId.toLowerCase().includes('subwoofer') || speakerId.startsWith('SW');
                break;
              case 'upper':
                matchesGroup = speakerId.includes('H') || speakerId.startsWith('T');
                break;
            }

            if (matchesGroup) {
              groupLevels.push(numLevel);
            }
          });

          if (groupLevels.length === 0) {
            return null; // No speakers found for this group
          }

          // Calculate estimated maximum capability
          // Assumption: current levels represent ~75dB reference, estimate headroom to maximum
          const avgCurrentLevel = groupLevels.reduce((sum, level) => sum + level, 0) / groupLevels.length;

          // Estimate maximum capability based on typical amplifier headroom and speaker limits
          // Professional systems typically have 20-30dB headroom above reference level
          let estimatedMaxCapability;

          if (speakerGroup.toLowerCase() === 'subwoofer') {
            // Subwoofers typically have higher capability
            estimatedMaxCapability = avgCurrentLevel + 35; // More headroom for LFE
          } else {
            // Main speakers
            estimatedMaxCapability = avgCurrentLevel + 25; // Standard headroom
          }

          // Apply room gain if available
          if (roomEstimate && roomEstimate.estimatedVolume && Number.isFinite(roomEstimate.estimatedVolume)) {
            const roomGain = Math.max(0, 3 * Math.log10(100 / roomEstimate.estimatedVolume));
            estimatedMaxCapability += roomGain;
          }

          // Apply small room boundary loading (typically 2-6dB for speakers near walls)
          if (speakerGroup.toLowerCase() !== 'subwoofer') {
            estimatedMaxCapability += 3; // Typical boundary loading gain
          }

          return Math.round(estimatedMaxCapability * 10) / 10;
        }

        // Calculate maximum angle between adjacent surround speakers
        calculateMaxAdjacentSurroundAngle(speakerAngles, surroundSpeakers) {
          if (surroundSpeakers.length < 2) return null;

          const surroundAngles = surroundSpeakers
            .map(id => speakerAngles[id]?.horizontal)
            .filter(angle => Number.isFinite(angle))
            .sort((a, b) => a - b);

          if (surroundAngles.length < 2) return null;

          let maxDifference = 0;
          for (let i = 1; i < surroundAngles.length; i++) {
            const diff = Math.abs(surroundAngles[i] - surroundAngles[i - 1]);
            maxDifference = Math.max(maxDifference, diff);
          }

          return maxDifference;
        }

        // Calculate maximum angle between adjacent upper speakers
        calculateMaxAdjacentUpperAngle(speakerAngles, upperSpeakers) {
          if (upperSpeakers.length < 2) return null;

          const upperAngles = upperSpeakers
            .map(id => speakerAngles[id]?.elevation || speakerAngles[id]?.vertical)
            .filter(angle => Number.isFinite(angle))
            .sort((a, b) => a - b);

          if (upperAngles.length < 2) return null;

          let maxDifference = 0;
          for (let i = 1; i < upperAngles.length; i++) {
            const diff = Math.abs(upperAngles[i] - upperAngles[i - 1]);
            maxDifference = Math.max(maxDifference, diff);
          }

          return maxDifference;
        }

        // Calculate wide speaker deviation from median angle
        calculateWideDeviationFromMedian(speakerAngles, wideSpeakers) {
          if (wideSpeakers.length === 0) return null;

          const wideAngles = wideSpeakers
            .map(id => Math.abs(speakerAngles[id]?.horizontal || 0))
            .filter(angle => Number.isFinite(angle));

          if (wideAngles.length === 0) return null;

          const median = wideAngles.sort((a, b) => a - b)[Math.floor(wideAngles.length / 2)];
          const maxDeviation = Math.max(...wideAngles.map(angle => Math.abs(angle - median)));

          return maxDeviation;
        }

        // Validation helper methods
        validateNumeric(value, fieldName) {
          if (value === null || value === undefined) return null;
          const num = Number(value);
          if (!Number.isFinite(num)) {
            this.addValidationError(`Invalid numeric value for ${fieldName}: ${value}`);
            return null;
          }
          return num;
        }

        validateFrequency(value) {
          if (value === null || value === undefined) return null;
          const freq = Number(value);
          if (!Number.isFinite(freq) || freq <= 0) {
            this.addValidationError(`Invalid frequency value: ${value}`);
            return null;
          }
          return freq;
        }

        validateArray(arr, fieldName) {
          if (!Array.isArray(arr)) {
            this.addValidationError(`${fieldName} is not an array`);
            return [];
          }
          return arr;
        }

        addValidationError(message) {
          this.validationErrors.push(message);
        }

        logValidationErrors() {
          if (this.validationErrors.length > 0) {
            console.log(`\n‚ö†Ô∏è  VALIDATION WARNINGS (${this.validationErrors.length}):`);
            this.validationErrors.forEach((error, index) => {
              console.log(`   ${index + 1}. ${error}`);
            });
          }
        }

        // Precision calculation helpers
        preciseComparison(a, b, operator) {
          if (a === null || b === null) return false;
          const diff = Math.abs(a - b);
          if (diff < this.PRECISION.SPL_TOLERANCE) return operator.includes('=');

          switch (operator) {
            case '>=': return a > b;
            case '<=': return a < b;
            case '>': return a > b && diff >= this.PRECISION.SPL_TOLERANCE;
            case '<': return a < b && diff >= this.PRECISION.SPL_TOLERANCE;
            default: return false;
          }
        }

        preciseSubtraction(a, b) {
          return Math.round((a - b) * 10) / 10; // Round to 0.1 precision
        }

        // Helper methods for enhanced functionality
        calculateDiscreteSpeakerFeeds(systemData) {
          if (!systemData.commandId || !Array.isArray(systemData.commandId)) return 0;
          const mainSpeakers = systemData.commandId.filter(id => id && !id.startsWith("SW")).length;
          const hasSubwoofer = systemData.nSubs > 0 || systemData.commandId.some(id => id && id.startsWith("SW"));
          return mainSpeakers + (hasSubwoofer ? 1 : 0);
        }

        evaluateRoomRatio(ratio) {
          if (ratio >= 1.15 && ratio <= 1.45) return 'Optimal';
          if (ratio >= 1.05 && ratio <= 1.6) return 'Good';
          return 'Suboptimal';
        }

        getDefaultSystemData() {
          return {
            nSpeakers: 0, nSubs: 0, noSub: true, targetLevel: 75,
            commandId: [], discreteSpeakerFeeds: 0,
            error: "Failed to capture system data - using defaults"
          };
        }

        formatMeasuredValue(value, unit) {
          if (value === null || value === undefined) return 'N/A';
          if (typeof value === 'boolean') return value ? 'Yes' : 'No';
          if (typeof value === 'number') return `${value.toFixed(1)} ${unit}`;
          return `${value} ${unit}`;
        }

        // Enhanced parameter validation methods
        estimateBassSmoothness(bandwidth, delayRange) {
          return bandwidth >= 200 ? 2 : bandwidth >= 150 ? 3 : 4;
        }

        estimateBassConsistency(rangeValue) {
          return rangeValue >= 10 ? 2 : rangeValue >= 6 ? 3 : rangeValue >= 3 ? 4 : 5;
        }

        generateRecommendation(paramId, level, value) {
          return level >= 3 ? "Excellent performance" : "Consider improvements for higher performance levels";
        }

        // Placeholder methods for parameter-specific validators (would be fully implemented)
        validateDistanceParameter(value) { return { valid: true, value }; }
        validateSpeakerCount(value) { return { valid: true, value }; }
        validateZonalCompliance(value) { return { valid: true, value }; }
        validateSPLConsistency(value) { return { valid: true, value }; }
        validateSpeakerAngles(value) { return { valid: true, value }; }
        validateWideAlignment(value) { return { valid: true, value }; }
        validateUpfiringSpeakers(value) { return { valid: true, value }; }
        validateVerticalAngles(value) { return { valid: true, value }; }
        validateSPLCapability(value) { return { valid: true, value }; }
        validateLFECapability(value) { return { valid: true, value }; }
        validateNoiseFloor(value) { return { valid: true, value }; }
        validateFrequencyResponse(value) { return { valid: true, value }; }
        validateBassExtension(value) { return { valid: true, value }; }
        validateBassResponse(value) { return { valid: true, value }; }
        validateBassConsistency(value) { return { valid: true, value }; }
        validateReflections(value) { return { valid: true, value }; }

        // Additional helper methods
        validateSpeakerConfiguration(analysis) { return true; /* Would validate config */ }
        assessFormatCompatibility(analysis) { return null; /* Would assess format support */ }
        countOutOfZoneSpeakers(analysis, group) { return 0; /* Would count misplaced speakers */ }
        estimateBackgroundNoise(systemData, roomEstimate) { return null; /* Would estimate noise */ }
      }

      // Keep the same function name as requested
      async function runCEDIAReadOnlyAssessment() {
        const scorer = new CEDIAPerformanceScorer();
        return scorer.runReadOnlyAssessment();
      }

      // console logger > allow collapse in VSC
      function initializeConsoleLogger() {
        const logContainer = document.getElementById('logContainer');

        function scrollToBottom() {
          logContainer.scrollTop = logContainer.scrollHeight;
        }

        let lastInfoEntry = null;

        // Store original console methods
        const originalMethods = {
          warn: console.warn,
          info: console.info,
          log: console.log,
          error: console.error
        };

        console.warn = function (...args) {
          const warningMessage = args.join(' ');
          const warningEntry = `<div class="warning">${new Date().toLocaleTimeString()} [**WARNING**] ${warningMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', warningEntry);
          scrollToBottom();
          originalMethods.warn.apply(console, args);
        };

        console.info = function (...args) {
          const infoMessage = args.join(' ');
          const infoEntry = `<div class="info">${new Date().toLocaleTimeString()} [INFORMATION] ${infoMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', infoEntry);
          lastInfoEntry = logContainer.lastElementChild;
          scrollToBottom();
          originalMethods.info.apply(console, args);
        };

        console.infoUpdate = function (...args) {
          const infoMessage = args.join(' ');
          if (lastInfoEntry) {
            lastInfoEntry.innerHTML = `${new Date().toLocaleTimeString()} [INFORMATION] ${infoMessage}`;
            scrollToBottom();
          } else {
            console.info(...args);
          }
          originalMethods.info.apply(console, args);
        };

        console.log = function (...args) {
          const logMessage = args.join(' ');
          const logEntry = `<div class="log">${new Date().toLocaleTimeString()} [*IMPORTANT*] ${logMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', logEntry);
          scrollToBottom();
          originalMethods.log.apply(console, args);
        };

        console.error = function (...args) {
          const errorMessage = args.join(' ');
          const errorEntry = `<div class="error">${new Date().toLocaleTimeString()} [***ERROR***] ${errorMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', errorEntry);
          scrollToBottom();
          originalMethods.error.apply(console, args);
        };
      }

      // Working PDF solution using pure jsPDF
      function saveLogAsPDF() {
        const logContainer = document.getElementById("logContainer");
        if (!logContainer) {
          console.log("No log container found!");
          return;
        }

        // Extract all text content
        const logEntries = logContainer.querySelectorAll('.log, .warning, .info');
        const logData = [];

        logEntries.forEach(entry => {
          let text = entry.textContent || entry.innerText;

          // Debug: Check what classes each entry has
          // console.log(`Entry classes: ${entry.className}, text preview: ${text.substring(0, 30)}...`);

          // Clean up emojis and special characters that jsPDF can't handle
          text = text
            .replace(/üëÜ/g, '[CURSOR]')
            .replace(/üî•/g, '[RESET]')
            .replace(/üìä/g, '[DATA]')
            .replace(/üéõÔ∏è/g, '[SLIDER]')
            .replace(/üîß/g, '[TOOL]')
            .replace(/‚úÖ/g, '[OK]')
            .replace(/üöÄ/g, '[AUTO]')
            .replace(/üîí/g, '[LOCK]')
            .replace(/üîì/g, '[UNLOCK]')
            .replace(/üéâ/g, '[COMPLETE]')
            .replace(/üéØ/g, '[TARGET]')
            .replace(/üé¨/g, '[CINEMA]')
            .replace(/ü§ñ/g, '[AUTO]')
            .replace(/‚ö†Ô∏è/g, '[WARNING]')
            .replace(/üî∂/g, '[NOTICE]')
            .replace(/üìò/g, '[INFO]')
            .replace(/üîÑ/g, '[REFRESH]')
            .replace(/üë§/g, '[USER]')
            .replace(/üèÜ/g, '[SCORE]')
            .replace(/üìö/g, '[NOTES]')
            .replace(/üìã/g, '[LIST]')
            .replace(/‚ùå/g, '[X]')
            .replace(/üîç/g, '[SEARCH]')
            .replace(/üìà/g, '[CHART]')
            .replace(/‚≠ê/g, '[STAR]')
            .replace(/üí°/g, '[IDEA]')
            .replace(/üéµ/g, '[MUSIC]')
            .replace(/üîä/g, '[AUDIO]')
            .replace(/üé§/g, '[MIC]')
            .replace(/üéß/g, '[HEADPHONES]')
            .replace(/üö´/g, '[BLOCKED]')
            .replace(/‚îú‚îÄ/g, '--')
            .replace(/\n/g, '')
            .replace(/‚Üí/g, '->')
            .replace(/‚îî‚îÄ/g, '__')
            .replace(/üî¨/g, '@')
            .replace(/‚úì/g, '[OK]')
            // Remove any remaining emojis/special unicode characters
            .replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '[?]')
            // Clean up any problematic characters
            .replace(/[^\x20-\x7E\u00A0-\u00FF]/g, '?');

          let prefix = "";
          let color = [0, 0, 0]; // black

          if (entry.classList.contains('warning')) {
            prefix = "[WARNING] ";
            color = [204, 102, 0]; // orange
          } else if (entry.classList.contains('info')) {
            prefix = "[INFO] ";
            color = [0, 102, 204]; // blue
          } else {
            prefix = "";
            color = [0, 0, 0]; // black
          }

          logData.push({
            text: prefix + text,
            color: color
          });
        });

        console.log(`Found ${logData.length} log entries to export`);

        // Create PDF with jsPDF
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
          orientation: 'portrait',
          unit: 'mm',
          format: 'a4'
        });

        // PDF settings
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const margin = 15;
        const maxLineWidth = pageWidth - (margin * 2);
        const lineHeight = 4;
        let yPosition = 20;

        // Add title
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.text(`${nextversion} Log`, margin, yPosition);
        yPosition += 10;

        // Add timestamp
        const now = new Date();
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        doc.text(`Generated: ${now.toLocaleString()}`, margin, yPosition);
        yPosition += 10;

        // Add separator line
        doc.setDrawColor(0, 0, 0);
        doc.line(margin, yPosition, pageWidth - margin, yPosition);
        yPosition += 8;

        // Add log content
        doc.setFontSize(8);
        doc.setFont('courier', 'normal');

        logData.forEach((entry, index) => {
          // Check if we need a new page
          if (yPosition > pageHeight - 20) {
            doc.addPage();
            yPosition = margin;
          }

          // Set color for this entry
          doc.setTextColor(entry.color[0], entry.color[1], entry.color[2]);

          // Debug: Log color being applied (only for first few entries to avoid spam)
          // if (index < 5) {
          //   console.log(`Entry ${index}: Color [${entry.color.join(', ')}] for text: ${entry.text.substring(0, 50)}...`);
          // }

          // Split long lines to fit page width, but respect word boundaries
          const lines = doc.splitTextToSize(entry.text, maxLineWidth);

          lines.forEach(line => {
            if (yPosition > pageHeight - 20) {
              doc.addPage();
              yPosition = margin;
              // Reapply color after new page
              doc.setTextColor(entry.color[0], entry.color[1], entry.color[2]);
            }
            doc.text(line, margin, yPosition);
            yPosition += lineHeight;
          });

          // Add small spacing between log entries for readability
          yPosition += 1;
        });

        // Generate filename with timestamp
        const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, "0")}${String(now.getDate()).padStart(2, "0")}_${String(now.getHours()).padStart(2, "0")}${String(now.getMinutes()).padStart(2, "0")}`;

        // Save the PDF
        doc.save(`${nextversion} Log ${timestamp}.pdf`);
        console.log("PDF saved successfully using jsPDF!");
      }

      // Ultimate simple test
      function testJsPDF() {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        doc.text('Hello World', 20, 20);
        doc.save('test.pdf');
      }

      // PDF solution using pure jsPDF
      function debugLogClasses() {
        const logContainer = document.getElementById("logContainer");
        const allEntries = logContainer.querySelectorAll('*');

        console.log(`Total elements in log: ${allEntries.length}`);

        allEntries.forEach((entry, index) => {
          if (entry.className) {
            console.log(`Element ${index}: class="${entry.className}", text="${entry.textContent.substring(0, 50)}..."`);
          }
        });

        // Check specifically for warning/info classes
        const warnings = logContainer.querySelectorAll('.warning');
        const infos = logContainer.querySelectorAll('.info');
        const logs = logContainer.querySelectorAll('.log');

        console.log(`Found: ${warnings.length} warnings, ${infos.length} info entries, ${logs.length} regular logs`);
      }

      // Initialize the console logger
      initializeConsoleLogger();

      // PDF solution using pure jsPDF
      // console.log(typeof jsPDF); // Should output "function"
      // console.log(window.jspdf); // Should show an object
    </script>
</body>

</html>