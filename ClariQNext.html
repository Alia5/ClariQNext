<!DOCTYPE html>
<html lang="en" class="notranslate" translate="no">

<head>
  <meta charset="UTF-8">
  <title>ClariQ Next - Nvexx 2025</title>
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/css/bootstrap.min.css'>
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css'>
  <link rel='stylesheet'
    href='https://cdnjs.cloudflare.com/ajax/libs/simple-line-icons/2.5.5/css/simple-line-icons.min.css'>
  <link rel="stylesheet" href="./style.css">
  <meta name="googlebot" content="notranslate" />
  <!-- stop cache -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <!-- stop cache -->
</head>

<body data-theme="dark">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    //ALL SETTINGS GO HERE
    const nextversion = "ClariQ Next 0.0.14 - 08-10-2025 @ 13:44";
    // ClearCurve
    let isClearCurve = false;
    const modelsSoS300 = ["-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011", "SR6011", "C-A110", "X3700H", "X4700H", "X6500H", "X6700H",
      "X8500H", "R-A110", "-S730H", "-S740H", "-S750H", "-S760H", "-S930H", "-S940H", "-S950H", "-S960H", "X1400H", "X1500H", "X1600H",
      "X1700H", "X2400H", "X2500H", "X2600H", "X2700H", "X3400H", "X3500H", "X3600H", "X3700H", "X4300H", "X4400H", "X4500H", "X4700H",
      "X6300H", "X6400H", "X6500H", "X6700H", "X8500H", "AV7703", "AV7704", "AV7705", "AV7706", "AV8805", "NR1608", "NR1609", "NR1710",
      "NR1711", "SR5012", "SR5013", "SR5014", "SR5015", "SR6012", "SR6013", "SR6014", "SR6015", "SR7011", "SR7012", "SR7013", "SR7015",
      "SR8012", "SR8015"];
    const micCalProb = ["-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011",
      "-S730H", "-S740H", "-S750H", "-S760H", "-S930H", "-S940H", "-S950H",
      "-S960H", "X1400H", "X1500H", "X1600H", "X1700H", "X2400H", "X2500H",
      "X2600H", "X2700H", "X3400H", "X3500H", "X3600H", "NR1608", "NR1609",
      "NR1710", "NR1711", "SR5012", "SR5013", "SR5014", "SR5015", "SR6013",
      "SR6014", "-S770H", "-S970H", "X1800H", "X2800H", "EMA 60", "MA 70s"];
    const noxo180 = ["-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011", "SR6011", "X6500H", "-S730H", "-S740H", "-S930H", "-S940H",
      "X1400H", "X1500H", "X2400H", "X2500H", "X3400H", "X3500H", "X4300H", "X4400H", "X4500H", "X6300H", "X6400H", "X6500H", "AV7703",
      "AV7704", "AV7705", "NR1608", "NR1609", "SR5012", "SR5013", "SR6012", "SR6013", "SR7011", "SR7012", "SR7013", "SR8012"];
    const models70xo = ["A-900H", "MA 70S", "-S970H", "X2800H", "-S670H", " AV 10", " AV 20", "VR-A1H", "VC-A1H", "X3800H", "X4800H",
      "EMA 30", "EMA 40", "EMA 50", "X6800H", "R-A10H", "C-A10H"];
    // https://www.dirac.com/online-store/ 18m supported  
    const modelsDirac = ["VR-A1H", "VC-A1H", "R-A10H", "C-A10H", "X6800H", "X4800H", "X3800H", " AV 10", " AV 20", "EMA 30", "EMA 40", "EMA 50"];
    let DiracEnabled = false;

    const baseUrl = 'http://localhost:4735/measurements', retryDelay = 500;
    let adyContents, fileName, sOs, isCirrusLogic, flDist, nChannels, nSpeakers, nSubs, noCenter;
    let targetCurvePath, targetCurveName, targetResponse, noInversion = false, swInvMsg = "";
    let bassMode = "Standard", noSub = false, subLoTrim, subHiTrim, subLoDelay, subHiDelay;
    let minXO = 40, maxXO = 250, previousDelay = null, swChannelCount = 0;
    const freqIndex = [40, 60, 80, 90, 100, 110, 120, 150, 200, 250];
    const customLevel = [], customDistance = [], customCrossover = [];
    const mSec = [], invertSub = [], commandId = [];
    const m3dBPoints = {};
    let targetLevel = 75.0; // Audyssey typically calibrates to 75 dB SPL
    let isCirrusLogictargetLevel = 75.0;
    // Advanced sorting check and correction
    let needsSorting = false, expectedOrder = [];
    // MODES
    let isDarkMode = true, isDyslexicMode = false;
    let isDolbymode = false, isTHXmode = false, isIMAXmode = false, supportsIMAX = false;
    let modeSubXOMin = 31.5, modeSubXOMax = 120, modeSpkMin = 20, modeSpkMax = 20000;
    // cedia specific
    let isRP22mode = false;
    let RP22subnminXO, RP22submaxXO, RP22subrequiredDelay, RP22hasAtmos, RP22hasDTSX, RP22hasAURO3D;
    let estimatedPlaybackLevels = [], estimatedDistances = [], RP22BestXO = [];
    // CONDENCED VERSION
    let AdvancedFilters = false, AdvancedFiltersType = "null";
    // SPEED DELAY BASED ON CPU CORES
    var cores = 1;
    const getOptimalDelay = () => {
      cores = navigator.hardwareConcurrency || 1; // Fallback to 1 if undefined
      let delay;
      if (cores <= 1) {
        delay = 256;
      } else if (cores <= 2) {
        delay = 236;
      } else if (cores <= 4) {
        delay = 216;
      } else if (cores <= 8) {
        delay = 196;
      } else if (cores <= 12) {
        delay = 176;
      } else if (cores <= 16) {
        delay = 156;
      } else if (cores <= 24) {
        delay = 136;
      } else if (cores <= 32) {
        delay = 116;
      } else {
        delay = 256;
      }
      console.warn(`Detected ${cores} logical CPU core(s). Assigned delay: ${delay}ms`);
      return delay;
    };
    let speedDelay = getOptimalDelay();
    // store more AVR default values
    let lfcSupport, enMultEQType, auro, dolbyVersion, dynamicEq, dynamicVolume, lfc, subwooferNum, subwooferLayout;
    let hasHeightChannel = false, isDebugMode = false;
    const heightChannelIds = ["FHL", "RHL", "SHL", "TFL", "TML", "TRL", "BDL", "FDL", "SDL", "TS", "CH"], delaymax = 1000;
    let lowFreq, highFreq;
    let IsCustomMeasurements = false;
  </script>

  <!-- CUSTOM FILTERS -->
  <script>
    var customFiltersArray = []; // Use var to ensure global scope

    function toggleCustomFilterBuilder() {
      const selectedType = document.getElementById('script_af_type').value;
      const builder = document.getElementById('customFilterBuilder');

      if (selectedType === 'CUSTOMadvanced') {
        builder.style.display = 'block';
        // Initialize with one empty filter if none exist
        if (customFiltersArray.length === 0) {
          addCustomFilter();
        }
      } else {
        builder.style.display = 'none';
      }
    }

    function addCustomFilter() {
      if (customFiltersArray.length >= 20) {
        alert('Maximum of 20 filters reached!');
        return;
      }

      const filterIndex = customFiltersArray.length;
      const filter = {
        type: 'PK',
        frequency: 1000,
        gaindB: 0,
        q: 1.0
      };

      customFiltersArray.push(filter);
      renderFiltersList();
      updateFilterCount();
    }

    function removeCustomFilter(index) {
      customFiltersArray.splice(index, 1);
      renderFiltersList();
      updateFilterCount();
    }

    function updateFilter(index, field, value) {
      if (field === 'type') {
        customFiltersArray[index][field] = value;
        // Reset Q for non-PK filters
        if (value !== 'PK') {
          customFiltersArray[index].q = 1.0;
        }
      } else if (field === 'frequency') {
        customFiltersArray[index][field] = parseFloat(value) || 1000;
      } else if (field === 'gaindB') {
        customFiltersArray[index][field] = parseFloat(value) || 0;
      } else if (field === 'q') {
        customFiltersArray[index][field] = parseFloat(value) || 1.0;
      }
      renderFiltersList(); // Re-render to show/hide Q field
    }

    function renderFiltersList() {
      const container = document.getElementById('customFiltersList');

      if (customFiltersArray.length === 0) {
        container.innerHTML = '<div class="alert alert-warning">No filters added. Click "Add Filter" to get started.</div>';
        return;
      }

      container.innerHTML = customFiltersArray.map((filter, index) => `
    <div class="filter-row">
      <div class="row align-items-center">
        <div class="col-auto">
          <span class="filter-number">${index + 1}</span>
        </div>
        
        <div class="col-md-2">
          <label class="form-label">Type</label>
          <select class="form-select" onchange="updateFilter(${index}, 'type', this.value)">
            <option value="PK" ${filter.type === 'PK' ? 'selected' : ''}>Peak (PK)</option>
            <option value="LS" ${filter.type === 'LS' ? 'selected' : ''}>Low Shelf (LS)</option>
            <option value="HS" ${filter.type === 'HS' ? 'selected' : ''}>High Shelf (HS)</option>
            <!-- HP and LP commented out - conflicts with bass management
            <option value="HP" ${filter.type === 'HP' ? 'selected' : ''}>High Pass (HP)</option>
            <option value="LP" ${filter.type === 'LP' ? 'selected' : ''}>Low Pass (LP)</option>
            -->
          </select>
        </div>
        
        <div class="col-md-2">
          <label class="form-label">Frequency (Hz)</label>
          <input type="number" class="form-control" value="${filter.frequency}" 
                 min="10" max="20000" step="1"
                 onchange="updateFilter(${index}, 'frequency', this.value)">
        </div>
        
        <div class="col-md-2">
          <label class="form-label">Gain (dB)</label>
          <input type="number" class="form-control" value="${filter.gaindB}" 
                 min="-20" max="20" step="0.1"
                 onchange="updateFilter(${index}, 'gaindB', this.value)">
        </div>
        
        ${filter.type === 'PK' ? `
        <div class="col-md-2">
          <label class="form-label">Q Factor</label>
          <input type="number" class="form-control" value="${filter.q}" 
                 min="0.1" max="10" step="0.1"
                 onchange="updateFilter(${index}, 'q', this.value)">
        </div>
        ` : '<div class="col-md-2"><small class="text-muted">Q N/A</small></div>'}
        
        <div class="col-md-2">
          <label class="form-label d-block">&nbsp;</label>
          <button type="button" class="btn btn-danger btn-sm w-100" 
                  onclick="removeCustomFilter(${index})">
            🗑️ Remove
          </button>
        </div>
      </div>
    </div>
  `).join('');
    }

    function updateFilterCount() {
      const count = customFiltersArray.length;
      document.getElementById('filterCount').textContent = count;
      document.getElementById('filterWarning').style.display = count >= 20 ? 'inline' : 'none';
    }

    function loadFilterTemplate(template) {
      customFiltersArray = [];

      switch (template) {
        case 'bass':
          customFiltersArray = [
            { type: 'PK', frequency: 60, gaindB: 4.0, q: 0.7 },
            { type: 'PK', frequency: 100, gaindB: 3.0, q: 1.0 },
            { type: 'PK', frequency: 200, gaindB: 2.0, q: 1.2 }
          ];
          break;

        case 'treble':
          customFiltersArray = [
            { type: 'PK', frequency: 5000, gaindB: 2.0, q: 1.5 },
            { type: 'PK', frequency: 8000, gaindB: 3.0, q: 1.5 },
            { type: 'HS', frequency: 10000, gaindB: 2.5, q: 1.0 }
          ];
          break;

        case 'vshape':
          customFiltersArray = [
            { type: 'PK', frequency: 60, gaindB: 4.0, q: 0.8 },
            { type: 'PK', frequency: 250, gaindB: -2.0, q: 1.0 },
            { type: 'PK', frequency: 1000, gaindB: -3.0, q: 0.8 },
            { type: 'PK', frequency: 3000, gaindB: 2.0, q: 1.5 },
            { type: 'PK', frequency: 8000, gaindB: 3.0, q: 1.5 },
            { type: 'HS', frequency: 12000, gaindB: 2.0, q: 1.0 }
          ];
          break;

        case 'flat':
          // Removed HP filter - use neutral PK instead
          customFiltersArray = [
            { type: 'PK', frequency: 1000, gaindB: 0, q: 1.0 }
          ];
          break;
      }

      renderFiltersList();
      updateFilterCount();
    }

    function clearAllFilters() {
      if (customFiltersArray.length > 0 && !confirm('Clear all filters?')) {
        return;
      }
      customFiltersArray = [];
      renderFiltersList();
      updateFilterCount();
    }

    // Export function to get custom filters for the main script
    function getCustomFilters() {
      return {
        filters: customFiltersArray,
        description: document.getElementById('customFilterDescription').value || 'Custom User-Defined EQ'
      };
    }

    function debugCustomFilters() {
      console.log("=== CUSTOM FILTERS DEBUG ===");
      console.log("customFiltersArray exists?", typeof customFiltersArray !== 'undefined');
      console.log("customFiltersArray value:", customFiltersArray);
      console.log("customFiltersArray length:", customFiltersArray ? customFiltersArray.length : 'N/A');
      console.log("getCustomFilters function exists?", typeof getCustomFilters !== 'undefined');

      if (typeof getCustomFilters === 'function') {
        const config = getCustomFilters();
        console.log("getCustomFilters() returns:", config);
      }

      alert("Check the console for debug information!");
    }

  </script>

  <!-- partial -->
  <script src="./script.js"></script>
  <!-- Include jsPDF library first -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <!-- partial:index.partial.html -->
  <div class="container">
    <div class="form-container">
      <div class="form-header">
        <div class="theme-toggle">
          <div class="toggle-switch active" id="themeToggle">
            <div class="toggle-slider">☀️</div>
          </div>
        </div>

        <div class="font-toggle">
          <div class="toggle-switch active" id="dyslexicToggle">
            <div class="toggle-slider">🔤</div>
          </div>
        </div>

        <h2><img src="https://www.nvexx.nl/audyssey/nvexx_128.png" class="centerimg" alt="Nvexx logo" />ClariQ Next</h2>
        <noscript>
          <div style="color: red; padding: 10px; border: 1px solid red;">
            JavaScript is disabled in your browser. Please enable it for full functionality.
          </div>
        </noscript>
      </div>

      <div class="progress">
        <div class="progress-bar" role="progressbar" style="width: 0%"></div>
      </div>

      <div class="step-indicator">
        <div class="step-line"></div>
        <div class="step-circle active">1</div>
        <div class="step-circle">2</div>
        <div class="step-circle">3</div>
        <div class="step-circle">4</div>
        <div class="step-circle">5</div>
        <div class="step-circle">6</div>
        <div class="step-circle">7</div>
        <div class="step-circle">8</div>
        <div class="step-circle">9</div>
        <div class="step-circle">10</div>
        <div class="step-circle">11</div>
        <div class="step-circle">12</div>
        <div class="step-circle">13</div>
        <div class="step-circle">14</div>
      </div>

      <form id="multiStepForm">
        <!-- Step 1: Basic settings -->
        <div class="form-step active" data-step="1">
          <h3 class="mb-4">Basic settings</h3>
          <div class="mb-4">
            <ul>
              <li>Sub inversion allowed</li>
              <ul>
                <li>Can you or are you willing to physically change subwoofer polarity?</li>
              </ul>
            </ul>
            <ul>
              <li>Script mode</li>
              <ul>
                <li>Full auto - the script goes through each step</li>
                <li>Manual - allows you to go through each step manually. (button clicks)</li>
              </ul>
            </ul>
            <ul>
              <li>Advanced Filters</li>
              <ul>
                <li>ClariQ Next custom filters including:</li>
                <ul>
                  <li>Advanced Dialog Enhancement</li>
                  <li>Hearing Loss</li>
                  <li>Gaming</li>
                </ul>
              </ul>
            </ul>
          </div>

          <hr />
          <div class="row g-4">
            <div class="col-md-4">
              <label for="sub_inversion_on">Sub inversion allowed</label><br>
              <input type="radio" id="sub_inversion_on" name="sub_inversion" value="0" required checked="checked">
            </div>
            <div class="col-md-4">
              <label for="sub_inversion_off">Sub inversion NOT! allowed!</label><br>
              <input type="radio" id="sub_inversion_off" name="sub_inversion" value="1">
            </div>
          </div>

          <hr />
          <div class="row g-4">
            <div class="col-md-4">
              <label for="radio_script_mode_auto">Fully automatic</label><br>
              <input type="radio" id="radio_script_mode_auto" name="script_mode" value="0" required checked="checked">
            </div>
            <div class="col-md-4">
              <label for="radio_script_mode_manual">Manual mode (manually select the next step)</label><br>
              <input type="radio" id="radio_script_mode_manual" name="script_mode" value="1">
            </div>
          </div>

          <hr />
          <div class="row g-4">
            <h3 class="mb-4">Advanced Filters</h3>
            <div class="col-md-4">
              <label for="radio_script_af_off">Advanced Filters OFF</label><br>
              <input type="radio" id="radio_script_af_off" name="script_af" value="0" required checked="checked">
            </div>
            <div class="col-md-4">
              <label for="radio_script_af_on">Advanced Filters ON</label><br>
              <input type="radio" id="radio_script_af_on" name="script_af" value="1">
            </div>
          </div>

          <div class="row g-4">
            <div class="col-md-4">
              <label for="script_af_type">Advanced Filters Type</label><br>
              <select name="script_af_type" id="script_af_type" onchange="toggleCustomFilterBuilder()">
                <option value="null" selected>none</option>
                <option value="CUSTOMadvanced">🎛️ Custom Filters (Build Your Own)</option>
                <option value="DIALOGadvanced">Advanced Dialog Enhancement - CEDIA RP22</option>
                <option value="HLOSSresearch">Hearing Loss >> Research-Based Hearing Loss Compensation (presbycusis
                  patterns)</option>
                <option value="HLOSSmoderate">Hearing Loss >> Moderate Hearing Loss Compensation (mild hearing loss)
                </option>
                <option value="HLOSSsevere">Hearing Loss >> Severe Hearing Loss Compensation (⚠️high gains)</option>
                <option value="HLOSSoriginal">Hearing Loss >> original / ClariQ Next 0.0.3 values</option>
                <option value="GAMINGcompetitive">Gaming >> Competitive Gaming EQ (Footsteps & Tactical Audio)</option>
                <option value="GAMINGimmersive">Gaming >> Immersive Gaming EQ (Cinematic Experience)</option>
                <option value="GAMINGvoice">Gaming >> Voice Chat Gaming EQ (Clear Communication)</option>
                <option value="GAMINGbalanced">Gaming >> Balanced Gaming EQ (All-Purpose)</option>
              </select>
            </div>
          </div>

          <!-- Custom Filter Builder (hidden by default) -->
          <div id="customFilterBuilder" style="display: none;" class="mt-4">
            <div class="card">
              <div class="card-header bg-primary text-white">
                <h5 class="mb-0">🎛️ Custom Filter Builder</h5>
                <small>Create up to 20 custom EQ filters (Peak, Low Shelf, High Shelf only)</small>
              </div>
              <div class="card-body">
                <!-- Filter Description -->
                <div class="row mb-3">
                  <div class="col-md-8">
                    <label for="customFilterDescription">Filter Set Name</label>
                    <input type="text" id="customFilterDescription" class="form-control" placeholder="My Custom EQ"
                      value="Custom User-Defined EQ">
                  </div>
                  <div class="col-md-4 d-flex align-items-end">
                    <button type="button" class="btn btn-success w-100" onclick="addCustomFilter()">
                      ➕ Add Filter
                    </button>
                  </div>
                </div>

                <!-- Filters List -->
                <div id="customFiltersList" class="mb-3">
                  <!-- Filters will be added here dynamically -->
                </div>

                <!-- Filter Count Display -->
                <div class="alert alert-info">
                  <strong>Filters: <span id="filterCount">0</span> / 20</strong>
                  <span id="filterWarning" style="display: none; color: #dc3545;"> - Maximum reached!</span>
                  <small class="d-block mt-1">
                    ℹ️ Custom filters override from high to low frequency (indices 20→1)<br>
                    This preserves critical low-frequency room correction
                  </small>
                </div>

                <!-- Preset Templates -->
                <div class="row mt-3">
                  <div class="col-12">
                    <label>Quick Templates:</label>
                    <div class="btn-group w-100" role="group">
                      <button type="button" class="btn btn-outline-secondary btn-sm"
                        onclick="loadFilterTemplate('bass')">Bass Boost</button>
                      <button type="button" class="btn btn-outline-secondary btn-sm"
                        onclick="loadFilterTemplate('treble')">Treble Boost</button>
                      <button type="button" class="btn btn-outline-secondary btn-sm"
                        onclick="loadFilterTemplate('vshape')">V-Shape</button>
                      <button type="button" class="btn btn-outline-secondary btn-sm"
                        onclick="loadFilterTemplate('flat')">Flat/Neutral</button>
                      <button type="button" class="btn btn-outline-danger btn-sm" onclick="clearAllFilters()">Clear
                        All</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <br />
          <div class="mb-4">
            <h3 class="mb-4 warning">Usage</h3>
            <ul>
              <li>Download and install the free room correction software Room EQ Wizard (v5.40
                Beta) on
                your computer
                <ul>
                  <li class="small-bullet">download link for the latest REW Beta version: <a
                      href="https://www.avnirvana.com/threads/rew-api-beta-releases.12981/" target="_blank">here</a>
                  </li>
                </ul>
              </li>
              <li>Choose your preferred basic settings</li>
              <li>When done click the '[.ady]' button below to go to the next step.</li>
            </ul>
          </div>
          <div class="d-flex justify-content-end mt-4">
            <button type="button" class="btn btn-primary btn-nav next-step">.ady file</button>
          </div>
        </div>

        <!-- Step 2: Professional Experience -->
        <div class="form-step" data-step="2">
          <div class="mb-4" id="BMs">
            <h3 class="mb-4">Basic Measurement settings</h3>
          </div>
          <div class="mb-4" id="adyf">
            <h3 class="mb-4">.ady file</h3>
            <ul>
              <li>upload your .ady file here</li>
              <ul>
                <li>browse to the Audyssey calibration file (.ady) generated by the MultEQ Editor (IOS/Android) app
                </li>
                <li>when prompted, download and 'save' the .zip (measurements) on your computer. Make sure the zip
                  file
                  is unblocked: right-click > properties > unblock</li>
                <li>start REW, go to the 'EQ' / 'House Curve', and select a target curve of your choice</li>
                <li>open the zip file and select ALL (keyboard shortcut: "CTRL+A" for Windows / "Command+A" for Mac)
                  the
                  files in that folder</li>
                <li>left click on the selection (inside the .zip file) and drag & drop them onto REW. Wait until all
                  measurements are imported
                  and '[SPL Adjustments →]' button is enabled</li>
              </ul>
              <li>You can also use custom measurements with ClariQ Next!</li>
              <ul>
                <li>naming still needs to follow $0/1/2/3/4/5/6/7/8/9/10/11/12/13/14/15 etc for normal speakers</li>
                <li>naming still needs to follow SW10/11/12/13/14/15/16/17/18/19/110/111/112/113/114/115 etc for
                  subwoofers</li>
                <li>naming still needs to follow SW20/21/22/23/24/25/26/27/28/29/210/211/212/213/214/215 etc for
                  subwoofers</li>
                <li>the order in REW doesn't matter only the naming (custom sorting by ClariQ Next)</li>
              </ul>
              <li>Frequency Range Selector</li>
              <ul>
                <li>once your .ady is uploaded and the measurements are loaded into REW the Frequency Range Selector
                  will be availble</li>
                <ul>
                  <li>Select a "preferred range" from the frequency index values supported by your AVR</li>
                  <ul></ul>
                  <li>* The final range used will depend on your suboofer(s) capabilities</li>
                </ul>
              </ul>
            </ul>
          </div>
          <label class="form-label" id="resumeUploadlabel" for="resumeUpload">Upload your .ady file here</label>
          <div class="file-upload" id="resumeUpload">
            <input type="file" id="resume" class="d-none" accept=".ady">
            <div class="upload-content">
              <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor"
                class="bi bi-cloud-upload mb-3" viewBox="0 0 16 16">
                <path fill-rule="evenodd"
                  d="M4.406 1.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 2 5.166 4.579C14.758 4.804 16 6.137 16 7.773 16 9.569 14.502 11 12.687 11H10a.5.5 0 0 1 0-1h2.688C13.979 10 15 8.988 15 7.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 2.825 10.328 1 8 1a4.53 4.53 0 0 0-2.941 1.1c-.757.652-1.153 1.438-1.153 2.055v.448l-.445.049C2.064 4.805 1 5.952 1 7.318 1 8.785 2.23 10 3.781 10H6a.5.5 0 0 1 0 1H3.781C1.708 11 0 9.366 0 7.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383z" />
                <path fill-rule="evenodd"
                  d="M7.646 4.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707V14.5a.5.5 0 0 1-1 0V5.707L5.354 7.854a.5.5 0 1 1-.708-.708l3-3z" />
              </svg>
              <p class="mb-1">Drag and drop your .ady here</p>
              <p class="text-muted small">or click to browse (.ady)</p>
            </div>
          </div>
          <hr />
          <div class="row g-4" id="cinemaModes">
            <strong class="error" id="unlock_cinema_modes">Please upload your .ady and import your measurements into
              REW</strong>
            <div class="col-md-4">
              <label for="radio_home_cinema">Home Cinema (75dB) default</label><br>
              <input type="radio" id="radio_home_cinema" name="cinema_type" value="75" required checked="checked"
                disabled>
              <ul>
                <li>Subwoofer -Hz - -Hz / system calculated</li>
                <li>Speakers -Hz - -kHz / system calculated</li>
              </ul>
            </div>
            <div class="col-md-4">
              <label for="radio_professional_cinema">Dolby mode! (82dB -SPL)</label><br>
              <input type="radio" id="radio_dolby_cinema" name="cinema_type" value="85.2" disabled>
              <ul>
                <li>Subwoofer 31.5hz - 120Hz</li>
                <li>Speakers 40hz - 16kHz</li>
              </ul>
            </div>
            <div class="col-md-4">
              <label for="radio_professional_cinema">Cedia RP22 mode! (85dB -SPL)</label><br>
              <input type="radio" id="radio_cedia_cinema" name="cinema_type" value="85.1" disabled>
              <ul>
                <li>Subwoofer -hz - -Hz / performance based</li>
                <li>Speakers -hz - -Hz / performance based</li>
              </ul>
            </div>
            <div class="col-md-4">
              <label for="radio_professional_cinema">THX mode! (85dB -SPL)</label><br>
              <input type="radio" id="radio_thx_cinema" name="cinema_type" value="85.3" disabled>
              <ul>
                <li>Subwoofer 20hz - 120Hz</li>
                <li>Speakers 80hz - 20kHz</li>
              </ul>
            </div>
            <div class="col-md-4">
              <label for="radio_professional_cinema">IMAX mode! (100dB -SPL)</label><br>
              <input type="radio" id="radio_imax_cinema" name="cinema_type" value="85.4" disabled>
              <ul>
                <li>Subwoofer 20hz - 70Hz</li>
                <li>Speakers 70hz - 20kHz</li>
                <li>AVR specific!</li>
              </ul>
            </div>
          </div>

          <hr />
          <li><strong class="warning">Please keep REW on 'SPL & Phase' tab and stay on this web page until
              optimization
              is
              completed!</strong></li>
          </ul>
          <br />

          <!-- BED LAYER Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container bed-layer" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - BED LAYER</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li>The final range used will depend on your subwoofer(s) capabilities</li>
                <li>We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-bed"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-bed"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-bed"></span> |
                Indices: <span id="indicesValue-bed"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-bed"></div>
              </div>
              <div class="slider-handle min" id="minHandle-bed"></div>
              <div class="slider-handle max" id="maxHandle-bed"></div>

              <div class="slider-ticks" id="sliderTicks-bed"></div>
            </div>
          </div>

          <!-- HEIGHT LAYER Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container height-layer" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - HEIGHT LAYER</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li>The final range used will depend on your subwoofer(s) capabilities</li>
                <li>We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-height"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-height"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-height"></span> |
                Indices: <span id="indicesValue-height"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-height"></div>
              </div>
              <div class="slider-handle min" id="minHandle-height"></div>
              <div class="slider-handle max" id="maxHandle-height"></div>

              <div class="slider-ticks" id="sliderTicks-height"></div>
            </div>
          </div>


          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">SPL Adjustments →</button>
          </div>
        </div>

        <!-- Step 3: Portfolio & Resume -->
        <div class="form-step" data-step="3">
          <h3 class="mb-4">SPL Adjustments</h3>
          <div class="mb-4">
            <ul>
              <li>
                <span id="target-level-display" class="warning">Select cinema type to see target level</span>
                <ul>
                  <li>Offset according to the chosen cinema mode </li>
                </ul>
              </li>
              <li>Makes it easier to read in REW</li>
              <ul>
                <li>Takes into account original MJ 120dB spl offsets</li>
                <li>Takes into account original MJC 78dB spl offsets</li>
                <li>Takes into account custom measurements</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">BootUP →</button>
          </div>
        </div>

        <!-- Step 4: Additional Information -->
        <div class="form-step" data-step="4">
          <h3 class="mb-4">Bootup</h3>
          <div class="mb-4">
            <ul>
              <li>Here we go.. Be patient!</li>
              <li>Applying Audyssey microphone calibration file to measurements if needed</li>
              <li>Resets, IR windows, EQ target shape, room curve settings and equalizer to
                'Generic/Generic' for all measurements..</li>
              <li>Checking measurement names, indices and sorting</li>
              <ul>
                <li>Custom sorting if custom measurements are not sorted correctly</li>
                <li>ClariQ Next sorting, the standard REW A-Z sorting doesn't suffice!</li>
              </ul>
              <li>Sets default target level according to the chosen cinema mode</li>
              <li>Logs current set optimization parameters</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">GroundWorks →</button>
          </div>
        </div>

        <!-- Step 5: Additional Information -->
        <div class="form-step" data-step="5">
          <h3 class="mb-4">Groundworks</h3>
          <div class="mb-4">
            <ul>
              <li>Sets initial trims using mlp measurements</li>
              <li>Time align speakers</li>
              <li>Initialize subwoofer(s) and converts 'directional bass' mode to 'standard bass'</li>
              <ul>
                <li>for multi-subwoofer setups</li>
                <li>properly aligns multi-subwoofer setups</li>
              </ul>
              <ul>
                <li>based on #measurement count per speaker (microphone positions)</li>
              </ul>
              <li>Spatial averaging of speakers and subwoofers</li>
              <li>normalizes trim levels (ClariQ Next !)</li>
              <ul>
                <li>based on cinema mode chosen</li>
                <li>makes sure trim levels are correct for modes that have a SPL of 75+db</li>
                <ul>
                  <li>Dolby mode (82dB -SPL)</li>
                  <li>Cedia RP22 mode (85dB -SPL)</li>
                  <li>THX mode (85dB -SPL)</li>
                  <li>IMAX mode (100dB -SPL)</li>
                </ul>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Speaker Calibration →</button>
          </div>
        </div>

        <!-- Step 6: Main Speaker Calibration Function -->
        <div class="form-step" data-step="6">
          <h3 class="mb-4">Speaker Calibration</h3>
          <div class="mb-4">
            <ul>
              <li>Calculates speaker(s) -3dB points against target curve</li>
              <li>Calculates High Frequency rolloffs</li>
              <ul>
                <li>Depending on the cinema mode chosen</li>
                <ul>
                  <li>Dolby mode - 16000Hz rolloff</li>
                  <li>Cedia RP22 mode - 15000Hz rolloff</li>
                  <li>THX mode - 20000Hz rolloff</li>
                  <li>IMAX mode - 20000Hz rolloff</li>
                  <li>default - calculates rolloff</li>
                </ul>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Subwoofer Calibration →</button>
          </div>
        </div>

        <!-- Step 7: Subwoofer(s) Calibration Function -->
        <div class="form-step" data-step="7">
          <h3 class="mb-4">Subwoofer Calibration</h3>
          <div class="mb-4">
            <ul>
              <li>Calculates subwoofer(s) -3dB points against target curve</li>
              <li>Calculates low frequency rolloffs</li>
              <ul>
                <li>Depending on the cinema mode chosen</li>
                <ul>
                  <li>Dolby mode - 16000Hz rolloff</li>
                  <li>Cedia RP22 mode - 15000Hz rolloff</li>
                  <li>THX mode - 20000Hz rolloff</li>
                  <li>IMAX mode - 20000Hz rolloff</li>
                  <li>default - calculates rolloff</li>
                </ul>
              </ul>
              <li>calculates availble bandwidth</li>
              <li>sets "estimated" XO range based on available bandwidth</li>
              <ul>
                <li>can be adjusted by using the slider range</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Generate filters →</button>
          </div>
        </div>

        <!-- Step 8: Generate Filters -->
        <div class="form-step" data-step="8">
          <h3 class="mb-4">Generate filters</h3>
          <div class="mb-4">
            <ul>
              <li class="warn">ClariQ Next PROPRIETARY FILTER GENERATION AND CHECKING !</li>
            </ul>
            <ul>
              <li class="warn">ClariQ Next SBIR detection before filter generation</li>
              <ul>
                <li>not 100% yet</li>
                <li>good indication of expected SBIR</li>
                <li>logs and gives an overview of expected nulls</li>
              </ul>
            </ul>
            <ul>
              <li class="warn">ClariQ Next SBIR filter optimizations</li>
              <ul>
                <li>Checks REW generated filters</li>
                <li>we don't want to boost above +3dB as we can't fix nulls with EQ!</li>
                <li>we don't want to cut more than -10dB as we can't fix nulls with EQ!</li>
                <li>logs and gives an overview of active REW generated filters</li>
                <li>logs and gives an overview of any BOOST VIOLATION FOUND</li>
                <li>logs and gives an overview of any CUT VIOLATION FOUND</li>
                <li>automatically corrects the filters to stay within +3dB and -10dB</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Finalize trims →</button>
          </div>
        </div>

        <!-- Step 9: Finalize trimming -->
        <div class="form-step" data-step="9">
          <h3 class="mb-4">Finalize trims</h3>
          <div class="mb-4">
            <ul>
              <li>Final speaker & subwoofer trims:</li>
              <ul>
                <li>Sets trims against targetcurve</li>
                <li>checks if they are within range</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Optimize subwoofer delay
              →</button>
          </div>
        </div>

        <!-- Step 10: Optimize subwoofer delay -->
        <div class="form-step" data-step="10">
          <h3 class="mb-4">Optimize subwoofer delay</h3>
          <div class="mb-4">
            <ul>
              <li>Optimize subwoofer(s) delay(s)</li>
              <ul>
                <li>Calculates the optimal subwoofer delay for ALL speakers using average initial calculated XO</li>
                <li>Calculates the optimal subwoofer delay within the available delay range</li>
                <li>takes into account the "Sub inversion allowed" option</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Finalize distances →</button>
          </div>
        </div>

        <!-- Step 11: Finalize distances -->
        <div class="form-step" data-step="11">
          <h3 class="mb-4">Finalize distances</h3>
          <div class="mb-4">
            <ul>
              <li>Finalize calculated distances</li>
              <ul>
                <li>speaker & subwoofer distances</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Finalize crossovers →</button>
          </div>
        </div>

        <!-- Step 12: Finalize crossovers -->
        <div class="form-step" data-step="12">
          <h3 class="mb-4">Finalize crossovers</h3>
          <div class="mb-4">
            <ul>
              <li>Finalize crossovers based on usable XO range</li>
              <ul>
                <li>based on (combined subwoofer bandwidth + slider range)</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Draw expected results →</button>
          </div>
        </div>

        <!-- Step 13: Draw expected results -->
        <div class="form-step" data-step="13">
          <h3 class="mb-4">Draw expected results</h3>
          <div class="mb-4">
            <ul>
              <li>Generating expected final outputs for each channel.</li>
              <li>Updating REW results to reflect the expected final outputs for each channel.</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Finalize .ady →</button>
          </div>
        </div>

        <!-- Step 14: Finalize .ady -->
        <div class="form-step" data-step="14">
          <h3 class="mb-4">Finalize .ady</h3>
          <div class="mb-4">
            <ul>
              <li>Constructing .ady files</li>
              <li>Generating final trims for .ady file</li>
              <li>Generating CEDIA RP22 report</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <!--<button type="button" class="btn btn-primary btn-nav next-step">Continue →</button>-->
          </div>
        </div>
      </form>
      <pre id="logContainer"></pre>
      <br />
      <br />
      <div class="row g-4">
        <div class="col-md-4" style="text-align: center;">
          <p>Socials:</p>
          <a href="https://ko-fi.com/nvexx" target="_blank" style="text-decoration: none;">Ko-fi <span
              class="icon-cup"></span></a>
          &nbsp;
          <a href="https://discord.com/invite/fyVzznE" target="_blank" style="text-decoration: none;">Discord
            <svg class="w-[48px] h-[48px] text-gray-800 dark:text-white" aria-hidden="true"
              xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
              <path
                d="M18.942 5.556a16.3 16.3 0 0 0-4.126-1.3 12.04 12.04 0 0 0-.529 1.1 15.175 15.175 0 0 0-4.573 0 11.586 11.586 0 0 0-.535-1.1 16.274 16.274 0 0 0-4.129 1.3 17.392 17.392 0 0 0-2.868 11.662 15.785 15.785 0 0 0 4.963 2.521c.41-.564.773-1.16 1.084-1.785a10.638 10.638 0 0 1-1.706-.83c.143-.106.283-.217.418-.331a11.664 11.664 0 0 0 10.118 0c.137.114.277.225.418.331-.544.328-1.116.606-1.71.832a12.58 12.58 0 0 0 1.084 1.785 16.46 16.46 0 0 0 5.064-2.595 17.286 17.286 0 0 0-2.973-11.59ZM8.678 14.813a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.918 1.918 0 0 1 1.8 2.047 1.929 1.929 0 0 1-1.8 2.045Zm6.644 0a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.919 1.919 0 0 1 1.8 2.047 1.93 1.93 0 0 1-1.8 2.045Z" />
            </svg>
          </a>
          &nbsp;
          <a href="https://github.com/NvexxNL/ClariQNext" target="_blank" style="text-decoration: none;">GitHub <span
              class="icon-social-github"></span></a>
        </div>

        <div class="col-md-4" style="text-align: center;">
          <a href="https://ko-fi.com/nvexx/tip" target="_blank"><img height="74" style="border: 0px; height: 74px"
              src="https://storage.ko-fi.com/cdn/brandasset/v2/support_me_on_kofi_badge_red.png"
              alt="Support me on ko-fi.com" /></a>
        </div>

        <div class="col-md-4" style="text-align: center;">
          <a href="https://open.spotify.com/playlist/0ADi7e8brgnKkzri4qfpHS"
            style="size: 48px; font-size: 48pt; color: #1db954; text-decoration: none;" target="_blank"><span
              class="icon-social-spotify"></span></a>
          <p style="color: #1db954; ">skull's Audio System Test Tracks</p>
        </div>
      </div>
    </div>

    <script>
      function extractAdy(event) {
        console.info(`Initializing ${nextversion}`);
        const file = event.target.files[0];
        fileName = file.name;
        console.info(`Audyssey calibration '${fileName}' has been uploaded!`)
        const reader = new FileReader();
        reader.onload = async function (e) {
          adyContents = e.target.result;
          const jsonData = JSON.parse(adyContents);
          let modelName = jsonData.targetModelName;
          const model = modelName.slice(-6);
          sOs = modelsSoS300.includes(model) ? 300.00 : 343.00;
          Object.freeze(sOs);
          isCirrusLogic = micCalProb.includes(model) ? true : false;
          Object.freeze(isCirrusLogic);
          if (!noxo180.includes(model)) {
            freqIndex.push(180);
          }
          if (models70xo.includes(model)) {
            freqIndex.push(70);
            supportsIMAX = true;
          }
          if (modelsDirac.includes(model)) {
            DiracEnabled = true;
          }
          freqIndex.sort(function (a, b) { return a - b; });
          Object.freeze(freqIndex);
          console.log(`Speed of sound setting has been automatically adjusted for your ${modelName} at ${sOs} m/s.`);
          const hasSWChannels = jsonData.detectedChannels.some(channel => channel.commandId && channel.commandId.startsWith("SW"));
          if (!hasSWChannels) {
            console.warn("No subwoofer detected in your calibration file. Mains will be set to Large/Full Range!");
            noSub = true;
          }
          Object.freeze(noSub);
          bassMode = jsonData.subwooferMode;
          Object.freeze(bassMode);
          //
          lfcSupport = jsonData.lfcSupport;
          Object.freeze(lfcSupport);
          enMultEQType = jsonData.enMultEQType;
          Object.freeze(enMultEQType);
          auro = jsonData.auro;
          Object.freeze(auro);
          dolbyVersion = jsonData.dolbyVersion;
          Object.freeze(dolbyVersion);
          dynamicEq = jsonData.dynamicEq;
          Object.freeze(dynamicEq);
          dynamicVolume = jsonData.dynamicVolume;
          Object.freeze(dynamicVolume);
          lfc = jsonData.lfc;
          Object.freeze(lfc);
          subwooferMode = jsonData.subwooferMode;
          Object.freeze(subwooferMode);
          subwooferNum = jsonData.subwooferNum;
          Object.freeze(subwooferNum);
          subwooferLayout = jsonData.subwooferLayout;
          Object.freeze(subwooferLayout);
          //
          noCenter = true;
          subLoTrim = Infinity;
          subHiTrim = -Infinity;
          subLoDelay = Infinity;
          subHiDelay = -Infinity;
          console.info("");
          console.info("title:", jsonData.title);
          console.info("enAmpAssignType:", jsonData.enAmpAssignType);
          console.info("dynamicVolume:", jsonData.dynamicVolume);
          console.info("enTargetCurveType:", jsonData.enTargetCurveType);
          console.info("lfcSupport:", jsonData.lfcSupport);
          console.info("targetModelName:", jsonData.targetModelName);
          console.info("interfaceVersion:", jsonData.interfaceVersion);
          console.info("dynamicEq:", jsonData.dynamicEq);
          console.info("ampAssignInfo:", jsonData.ampAssignInfo);
          console.info("lfc:", jsonData.lfc);
          console.info("systemDelay:", jsonData.systemDelay);
          console.info("auro:", jsonData.auro);
          console.info("dolbyVersion:", jsonData.dolbyVersion);
          console.info("upgradeInfo:", jsonData.upgradeInfo);
          console.info("enMultEQType:", jsonData.enMultEQType);
          console.info("adcLineup:", jsonData.adcLineup);
          console.info("subwooferNum:", jsonData.subwooferNum);
          console.info("subwooferMode:", jsonData.subwooferMode);
          console.info("subwooferLayout:", jsonData.subwooferLayout);
          console.info("measurementsPerPosition:", jsonData.measurementsPerPosition);
          // console.info("detectedChannels ")
          // log the full detected channels list in one line
          console.info("detectedChannels", jsonData.detectedChannels.map(ch => ch.commandId).join(","));
          // Populate commandId array with 1-based indexing
          jsonData.detectedChannels.forEach((channel, index) => {
            if (channel.commandId) {
              commandId[index + 1] = channel.commandId; // 1-based indexing
              console.info(`commandId[${index + 1}]: ${channel.commandId}`);
            }
          });
          console.info("");
          jsonData.detectedChannels.forEach(channel => {
            if (channel.commandId && channel.commandId === "C") {
              noCenter = false;
            }
            if (channel.commandId && channel.commandId.startsWith("SW")) {
              swChannelCount++;
              subLoTrim = Math.min(subLoTrim, parseFloat(channel.trimAdjustment));
              subHiTrim = Math.max(subHiTrim, parseFloat(channel.trimAdjustment));
              subLoDelay = Math.min(subLoDelay, parseFloat(channel.delayAdjustment));
              subHiDelay = Math.max(subHiDelay, parseFloat(channel.delayAdjustment));
              //
              channel.midrangeCompensation = true;
              channel.frequencyRangeRolloff = 250;
              if ("customCrossover" in channel) {
                delete channel.customCrossover;
              }
              if ("customSpeakerType" in channel) {
                delete channel.customSpeakerType;
              }
              if (swChannelCount === 1) {
                channel.customTargetCurvePoints = [];
              } else {
                if ("customTargetCurvePoints" in channel) {
                  delete channel.customTargetCurvePoints;
                }
              }
            } else {
              channel.customTargetCurvePoints = [];
              channel.midrangeCompensation = false;
              channel.frequencyRangeRolloff = 20000;
            }
            if (channel.commandId && heightChannelIds.includes(channel.commandId)) {
              hasHeightChannel = true;
            }
            /*
            console.info(channel.commandId);
            console.info("customEnSpeakerConnect", channel.channelReport.customEnSpeakerConnect);
            console.info("distance", channel.channelReport.distance);
            console.info("enSpeakerConnect", channel.channelReport.enSpeakerConnect);
            console.info("isReversePolarity", channel.channelReport.isReversePolarity);
            console.info("customCrossover", channel.customCrossover);
            console.info("customDistance", channel.customDistance);
            console.info("customLevel", channel.customLevel);
            console.info("customSpeakerType", channel.customSpeakerType);
            console.info("delayAdjustment", channel.delayAdjustment);
            console.info("enChannelType", channel.enChannelType);
            console.info("frequencyRangeRolloff", channel.frequencyRangeRolloff);
            console.info("isSkipMeasurement", channel.isSkipMeasurement);
            console.info("midrangeCompensation", channel.midrangeCompensation);
            console.info("trimAdjustment", channel.trimAdjustment);
            console.info("");
            */
          });
          Object.freeze(noCenter);
          Object.freeze(swChannelCount);
          subLoTrim = -12 + Math.abs(subLoTrim);
          subHiTrim = 12 - Math.abs(subHiTrim);
          Object.freeze(subLoTrim);
          Object.freeze(subHiTrim);
          subLoDelay /= sOs;
          subHiDelay /= sOs;
          Object.freeze(subLoDelay);
          Object.freeze(subHiDelay);
          flDist = getFLDistance(jsonData.detectedChannels);
          Object.freeze(flDist);
          console.info("Speaker measurements have been extracted from the uploaded calibration file.");
          let totalMeasurements = 0;
          const zip = new JSZip();
          const { detectedChannels } = jsonData;
          const filePromises = Object.entries(detectedChannels).map(([key, detectedChannel]) => {
            const { responseData, commandId } = detectedChannel;
            return Promise.all(Object.entries(responseData).map(([arrayKey, arrayData]) => {
              const dataString = arrayData.join('\n');
              const rewHeader = `* Impulse Response data saved by REW\n0 // Peak value before normalisation\n0 // Peak index\n16384 // Response length\n2.0833333333333333E-5 // Sample interval (seconds)\n0.0 // Start time (seconds)\n78.0 // Data offset (dB)\n* Data start\n${dataString}`;
              const measurementName = `${commandId}${arrayKey}.txt`;
              zip.file(measurementName, rewHeader);
              totalMeasurements++;
            }));
          });
          Object.freeze(totalMeasurements);
          if (isCirrusLogic) {
            zip.file("_micCal.txt", micCal);
          }
          console.log(`Please save ${fileName.substring(0, fileName.lastIndexOf('.'))}_extractedMeasurements.zip file when prompted.`);
          console.info("Checking for measurements...");
          await Promise.all(filePromises.flat());
          try {
            const content = await zip.generateAsync({ type: 'blob' });
            const urlZip = URL.createObjectURL(content);
            try {
              const downloadLink = document.createElement('a');
              downloadLink.href = urlZip;
              downloadLink.download = `${fileName.substring(0, fileName.lastIndexOf('.'))}_extractedMeasurements.zip`;
              downloadLink.style.display = 'none';
              document.body.appendChild(downloadLink);
              downloadLink.click();
              document.body.removeChild(downloadLink);
            } finally {
              // Always cleanup the URL object
              URL.revokeObjectURL(urlZip);
            }
          } catch (error) {
            console.error('Error generating or downloading zip file:', error);
          }
          let lastValidationState = null; // Track previous validation state
          let isFirstValidation = true; // Track if this is the first validation run
          const checkMeasurementCount = async () => {
            const measurements = await fetch_mREW();
            let mCount = Object.keys(measurements).length;
            if (isCirrusLogic) (mCount--);
            // Always validate measurement names against ADY file (regardless of count)
            try {
              const expectedMeasurements = new Set();
              // Extract expected measurement names from ADY
              jsonData.detectedChannels.forEach(channel => {
                const commandId = channel.commandId;  // e.g., "FL"
                const channelIndices = Object.keys(channel.responseData); // e.g., ["0", "1", "2"]
                // Generate expected REW names: FL0, FL1, FL2
                channelIndices.forEach(index => {
                  expectedMeasurements.add(`${commandId}${index}`);
                });
              });
              // Get actual REW measurement names
              const actualMeasurements = new Set();
              for (let i = 1; i <= mCount; i++) {
                actualMeasurements.add(measurements[i].title);
              }
              // Find discrepancies
              const missing = [...expectedMeasurements].filter(name => !actualMeasurements.has(name));
              const extra = [...actualMeasurements].filter(name => !expectedMeasurements.has(name));
              // Create current validation state for comparison
              const currentValidationState = JSON.stringify({ missing, extra, mCount });
              // Show validation messages on first run OR if state changed
              if (isFirstValidation || currentValidationState !== lastValidationState) {
                console.infoUpdate("Validating REW measurements against ADY file...");
                // Report findings
                if (missing.length === 0 && extra.length === 0) {
                  console.infoUpdate("✓ All REW measurements match ADY file expectations");
                } else {
                  if (missing.length > 0) {
                    console.warn(`⚠ Missing measurements (expected in ADY but not in REW): ${missing.join(', ')}`);
                  }
                  if (extra.length > 0) {
                    console.warn(`⚠ Extra measurements (in REW but not expected by ADY): ${extra.join(', ')}`);
                  }
                  console.warn("You can add/remove measurements in REW before continuing");
                }

                lastValidationState = currentValidationState;
                isFirstValidation = false;
              }
            } catch (error) {
              console.warn("Could not validate measurement names against ADY file:", error.message);
            }
            // Check if count matches for success logic
            if (mCount === totalMeasurements) {
              // Enhanced success logging with measurement names
              const importedMeasurements = [];
              for (let i = 1; i <= mCount; i++) {
                importedMeasurements.push(measurements[i].title);
              }
              // Original success logic
              console.infoUpdate(`All ${isCirrusLogic ? mCount + 1 : mCount} measurements have now been successfully imported!`);
              console.infoUpdate(`Successfully imported measurements: ${importedMeasurements.join(', ')}`);
              // communicate with script.js
              window.measurementsImported = true;
              window.updateContinueButtonState();
              clearInterval(intervalId);
              // At the end of your extractAdy function, after freqIndex is populated:
              if (window.onMeasurementsImported) {
                window.onMeasurementsImported();
                document.getElementById("resumeUpload").disabled = true;
                document.getElementById("resumeUpload").style.display = "none";
                document.getElementById("resumeUploadlabel").style.display = "none";
              }
            } else {
              console.infoUpdate(`Expecting ${totalMeasurements} measurements`
                + (isCirrusLogic ? " and Audyssey microphone calibration file" : "") + ` to be imported into REW...`);
            }
          }
          const intervalId = setInterval(checkMeasurementCount, 1000);
        }
        reader.readAsText(file);
      }

      // Delay utility functions - place after global variables
      const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
      const platformDelay = async () => {
        if (!isWindowsPlatform()) {
          await delay(speedDelay);
        }
      };

      const customDelay = async (ms) => {
        if (!isWindowsPlatform()) {
          await delay(ms);
        }
      };

      // Add this after your global variables
      function getCurrentMode() {
        if (isRP22mode) return 'RP22';
        if (isDolbymode) return 'DOLBY';
        if (isTHXmode) return 'THX';
        if (isIMAXmode) return 'IMAX';
        return 'DEFAULT';
      }

      // Also create a mode configuration object for mode-specific values
      const MODE_CONFIG = {
        RP22: {
          speaker: { min: 20, max: 20000 },
          subwoofer: { min: 20, max: 120 },
          rolloffHF: 15000,
          smoothing: '1/3'
        },
        DOLBY: {
          speaker: { min: 31.5, max: 16000 },
          subwoofer: { min: 31.5, max: 120 },
          rolloffHF: 16000,
          smoothing: '1/1'
        },
        THX: {
          speaker: { min: 20, max: 20000 },
          subwoofer: { min: 20, max: 120 },
          rolloffHF: 20000,
          smoothing: '1/1'
        },
        IMAX: {
          speaker: { min: 20, max: 20000 },
          subwoofer: { min: 20, max: 70 },
          rolloffHF: 20000,
          smoothing: '1/1'
        },
        DEFAULT: {
          speaker: { min: 20, max: 20000 },
          subwoofer: { min: 30, max: 80 },
          rolloffHF: null, // calculated dynamically
          smoothing: '1/1'
        }
      };

      // Not needed... Find solution later
      function SetTargetlevel() {
        const selectedRadio = document.querySelector('input[name="cinema_type"]:checked');
      }

      // Not needed... Find solution later
      function SetnoInversion() {
        const selectedRadio = document.querySelector('input[name="sub_inversion"]:checked');
        if (selectedRadio.value === "1") {
          // noInversion = false; // Inversion allowed
        } else {
          // noInversion = true;  // Inversion NOT allowed
        }
      }

      /* async function CorrectSPL() */
      // Constants for better maintainability
      const SPL_OFFSETS = {
        MJC_78DB: 78,
        STANDARD_88DB: 88,
        OLD_MJ_120DB: 120
      };

      const VALID_TARGET_LEVELS = [75, 82, 85, 100];
      const DEFAULT_TARGET_LEVEL = 75;

      // Helper function to set target level based on configuration
      function setTargetLevel(targetLevel, isCirrusLogic) {
        const validLevel = VALID_TARGET_LEVELS.includes(targetLevel) ? targetLevel : DEFAULT_TARGET_LEVEL;
        // Note: The original logic sets the same value regardless of isCirrusLogic flag
        // This suggests the flag might be for future use or legacy code
        return parseFloat(validLevel);
      }

      // Helper function to handle different SPL offset types
      function handleSplOffset(splOffsetdB, measurements, targetLevel, isCirrusLogic) {
        const offset = parseFloat(splOffsetdB);

        switch (offset) {
          case SPL_OFFSETS.MJC_78DB:
            console.warn("Measurements at 78.0dB MJC");
            return setTargetLevel(targetLevel, isCirrusLogic);
          case SPL_OFFSETS.STANDARD_88DB:
            console.warn("Measurements at 88.0dB");
            return setTargetLevel(targetLevel, isCirrusLogic);
          case SPL_OFFSETS.OLD_MJ_120DB:
            // Check if this is the deprecated old MJ format
            const requiredProperties = ['timingReference', 'delay', 'timingOffset', 'signalToNoisedB'];
            const hasRequiredProperties = requiredProperties.every(prop =>
              measurements[1].hasOwnProperty(prop)
            );
            if (!hasRequiredProperties) {
              console.error("120dB measurements (old MJ) are no longer supported!");
              console.error("Please use the ZIP that came with ClariQ Next");
              console.error("Or use custom measurements inside REW");
              throw new Error("Unsupported measurement type: 120dB old MJ format is deprecated");
            }
            return setTargetLevel(targetLevel, isCirrusLogic);
          default:
            console.warn(`Custom measurements detected. SPL offset: ${offset}dB`);
            IsCustomMeasurements = true;
            return setTargetLevel(targetLevel, isCirrusLogic);
        }
      }

      // Helper function for setup operations
      async function performSetupOperations(speedDelay) {
        const operations = [
          { fn: clearCommands, name: "clearCommands" },
          { fn: disableBlock, name: "disableBlock" },
          { fn: enableGraph, name: "enableGraph" },
          { fn: enableBlock, name: "enableBlock" },
          { fn: disableGraph, name: "disableGraph" },
          { fn: enableGraph, name: "enableGraph" }
        ];

        for (const operation of operations) {
          await operation.fn();
          await platformDelay();
        }
      }

      // Main function - now much cleaner and focused
      async function CorrectSPL() {
        try {
          // Setup operations
          await performSetupOperations(speedDelay);
          // Fetch measurements
          const measurements = await fetch_mREW();
          // Validate measurements
          if (!measurements || !measurements[1]) {
            throw new Error("Invalid measurements data");
          }
          // Get measurement count
          const measurementIds = Object.keys(measurements).filter(key => !isNaN(key));
          console.log(`Found ${measurementIds.length} measurements to check`);
          // Process SPL offset and set target level
          const splOffsetdB = measurements[1].splOffsetdB;
          if (splOffsetdB === undefined) {
            throw new Error("SPL offset not found in measurements");
          }
          isCirrusLogictargetLevel = handleSplOffset(
            splOffsetdB,
            measurements,
            targetLevel,
            isCirrusLogic
          );
          console.log(`Target level set to: ${isCirrusLogictargetLevel}dB`);
        } catch (error) {
          console.error("Error in CorrectSPL:", error.message);
          // Handle specific error types
          if (error.message.includes("Unsupported measurement type")) {
            isAutoMode = false;
            isScriptRunning = false;
            process.exit(1);
          }
          // Re-throw other errors for higher-level handling
          throw error;
        }
      }

      function getadyName(fileName, suffix) {
        const dotIndex = fileName.lastIndexOf(".");
        const modifiedName = fileName.substring(0, dotIndex) + suffix;
        return modifiedName;
      }

      function getFLDistance(channels) {
        let flIndex = 0;
        for (let i = 0; i < channels.length; i++) {
          if (channels[i].commandId === "FL") {
            flIndex = i;
            break;
          }
        }
        let dist = parseFloat(channels[flIndex].channelReport.distance);
        if (isNaN(dist) || dist === 0) {
          dist = parseFloat(channels[flIndex].customDistance);
          if (isNaN(dist) || dist === 0 || dist === null) {
            // Try the distance property as a fallback
            dist = parseFloat(channels[flIndex].distance);
            if (isNaN(dist) || dist === 0 || dist === null) {
              console.warn(`No distance found for ${channels[flIndex].commandId}! Defaulting to 6m.`)
              console.warn(`To fix: Open ady in MultEQ phone app then -\nSpeaker Detection Results > Change any crossover > Save and then retry.`);
              dist = 6.00;
            }
          }
        }
        return dist;
      }

      async function addmicCal() {
        console.info("Applying Audyssey microphone calibration file to measurements...");
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i < mCount; i++) {
          const name = measurements[i].title;
          console.infoUpdate(`Applying Audyssey microphone calibration file to ${name}...`);
          const irWindows = await fetchSafe('ir-windows', i);
          const leftW = parseFloat(irWindows.leftWindowWidthms);
          const rightW = parseFloat(irWindows.rightWindowWidthms);
          const refTime = parseFloat(irWindows.refTimems);
          await postNext('Arithmetic', [i, mCount], { function: "A * B" });
          await postSafe(`${baseUrl}/${mCount + i}/ir-windows`, { leftWindowWidthms: leftW, rightWindowWidthms: rightW, refTimems: refTime }, "Update processed");
          await fetch_mREW(mCount + i, 'PUT', { title: name });
        }
        console.infoUpdate("Deleting processed measurements...");
        for (let i = mCount; i >= 1; i--) {
          await postDelete(i);
        }
        console.infoUpdate("Completed applying Audyssey microphone calibration file to measurements.");
      }

      // Debugging function to help troubleshoot the user's specific environment
      async function debugUserEnvironment() {
        console.log("=== USER ENVIRONMENT DEBUG ===");
        // Check REW API connectivity and version
        try {
          const rewVersion = await fetch(`http://localhost:4735/version`);
          if (rewVersion.ok) {
            const rew = await rewVersion.json();
            console.log(`REW Version: ${rew.message}`);
          } else {
            console.error(`REW Version check failed: ${rewVersion.status}`);
          }
        } catch (error) {
          console.error("REW API connection failed:", error);
        }
        // Check what postNext function actually looks like
        console.log("postNext function type:", typeof postNext);
        if (typeof postNext === 'function') {
          console.log("postNext function source (first 200 chars):", postNext.toString().substring(0, 200));
        }
        // Check baseUrl
        console.log("baseUrl:", baseUrl);
        // Test simple REW API call
        try {
          const measurements = await fetch_mREW();
          console.log("fetch_mREW successful, measurement count:", Object.keys(measurements).length);
          // Test a simple command on measurement 1 if it exists
          if (measurements[1]) {
            console.log("Testing simple command on measurement 1...");
            const testResult = await postNext('Smooth', 1, { smoothing: "1/48" });
            console.log("Simple command test successful");
          }
        } catch (error) {
          console.error("Basic REW API test failed:", error);
        }
        console.log("=== END ENVIRONMENT DEBUG ===");
      }

      // Modified addmicCal with extensive logging but keeping original logic
      async function addmicCalDebug() {
        console.info("Applying Audyssey microphone calibration file to measurements...");
        // Add environment debug for problematic user
        await debugUserEnvironment();
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        console.log(`=== MICROCAL PROCESS START ===`);
        console.log(`Total measurements: ${mCount}`);
        console.log(`isCirrusLogic: ${isCirrusLogic}`);
        // Log all measurements
        for (let j = 1; j <= mCount; j++) {
          if (measurements[j]) {
            console.log(`  Measurement ${j}: ${measurements[j].title}`);
          } else {
            console.log(`  Measurement ${j}: MISSING`);
          }
        }
        for (let i = 1; i < mCount; i++) {
          if (!measurements[i]) {
            console.warn(`Skipping missing measurement ${i}`);
            continue;
          }
          console.log(`\n--- Processing ${i}/${mCount - 1}: ${measurements[i].title} ---`);
          try {
            const irWindows = await fetchSafe('ir-windows', i);
            console.log(`IR Windows retrieved for measurement ${i}`);
            const leftW = parseFloat(irWindows.leftWindowWidthms);
            const rightW = parseFloat(irWindows.rightWindowWidthms);
            const refTime = parseFloat(irWindows.refTimems);
            console.log(`IR Settings: Left=${leftW}, Right=${rightW}, Ref=${refTime}`);
            // Log exactly what we're about to send
            console.log(`About to call: postNext('Arithmetic', [${i}, ${mCount}], { function: "A * B" })`);
            // Check measurements still exist right before the call
            const preCallCheck = await fetch_mREW();
            if (!preCallCheck[i]) {
              throw new Error(`Measurement ${i} disappeared before arithmetic!`);
            }
            if (!preCallCheck[mCount]) {
              throw new Error(`Measurement ${mCount} (micCal) disappeared before arithmetic!`);
            }
            // THE ORIGINAL CALL - unchanged from working version
            const arithmeticResult = await postNext('Arithmetic', [i, mCount], { function: "A * B" });
            console.log(`✓ Arithmetic successful for measurement ${i}`);
            console.log(`Result:`, arithmeticResult);
            // Continue with original logic
            const resultIndex = Object.keys(arithmeticResult.results)[0];
            await postSafe(`${baseUrl}/${resultIndex}/ir-windows`, { leftWindowWidthms: leftW, rightWindowWidthms: rightW, refTimems: refTime }, "Update processed");
            const name = measurements[i].title;
            await fetch_mREW(resultIndex, 'PUT', { title: name });
            console.log(`✓ Completed processing measurement ${i}`);
          } catch (error) {
            console.error(`X FAILED processing measurement ${i} (${measurements[i].title}):`, error);
            // Additional debugging for the failed case
            console.log("=== FAILURE DEBUG ===");
            console.log("Error type:", error.constructor.name);
            console.log("Error message:", error.message);
            console.log("Error stack:", error.stack);
            // Check if measurements still exist after failure
            try {
              const postErrorCheck = await fetch_mREW();
              console.log(`Post-error measurement ${i} exists:`, !!postErrorCheck[i]);
              console.log(`Post-error measurement ${mCount} exists:`, !!postErrorCheck[mCount]);
            } catch (checkError) {
              console.log("Could not check measurements after error:", checkError);
            }
            throw error; // Re-throw to maintain original behavior
          }
        }
        console.log("\n=== CLEANUP PHASE ===");
        for (let i = mCount; i >= 1; i--) {
          console.log(`Deleting measurement ${i}`);
          await postDelete(i);
        }
        console.infoUpdate("Completed applying Audyssey microphone calibration file to measurements.");
      }

      // Fallback version that skips microcal if it fails > Not needed anymore.... Clean later
      async function addmicCalWithSkipOption() {
        try {
          // Try the original addmicCal first
          await addmicCalDebug();
        } catch (error) {
          console.error("X Microphone calibration failed:", error);
          // Ask user if they want to continue without microcal
          const skipMicCal = confirm(
            "Microphone calibration failed. This might be due to a REW version compatibility issue.\n\n" +
            "Would you like to continue WITHOUT microphone calibration?\n\n" +
            "(Click OK to skip microcal and continue, or Cancel to stop)"
          );
          if (skipMicCal) {
            console.warn("🚨 USER CHOSE TO SKIP MICROPHONE CALIBRATION");
            // Remove the microcal measurement to prevent issues later
            const measurements = await fetch_mREW();
            const mCount = Object.keys(measurements).length;
            if (measurements[mCount] && measurements[mCount].title.includes("micCal")) {
              console.log("Removing microphone calibration measurement...");
              await postDelete(mCount);
              console.log("✓ Microphone calibration measurement removed");
            }
            console.warn("⚠️ Continuing without microphone calibration - results may be less accurate");
            return; // Continue execution
          } else {
            console.error("User chose to stop due to microcal failure");
            throw error; // Re-throw to stop execution
          }
        }
      }

      async function enableRoomCurve() {
        await postSafe(`http://localhost:4735/eq/default-room-curve-settings`, {
          addRoomCurve: true, lowFreqRiseStartHz: 630, lowFreqRiseEndHz: 100, lowFreqRiseSlopedBPerOctave: 0.8,
          highFreqFallStartHz: 630, highFreqFallSlopedBPerOctave: 0.8
        }, "Update processed");
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i <= mCount; i++) {
          await postSafe(`${baseUrl}/${i}/room-curve-settings`, {
            addRoomCurve: true, lowFreqRiseStartHz: 630, lowFreqRiseEndHz: 100, lowFreqRiseSlopedBPerOctave: 0.8,
            highFreqFallStartHz: 630, highFreqFallSlopedBPerOctave: 0.8
          }, "Update processed");
        }
      }

      async function disableRoomCurve() {
        await postSafe(`http://localhost:4735/eq/default-room-curve-settings`, { addRoomCurve: false }, "Update processed");
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i <= mCount; i++) {
          await postSafe(`${baseUrl}/${i}/room-curve-settings`, { addRoomCurve: false }, "Update processed");
        }
      }

      function logCustomizations() {
        console.info(`****************************************************************************************************`);
        console.log("Optimization parameters:")
        const mode = getCurrentMode();
        if (targetCurveName === "") {
          console.info("  No target curve - 'ClariQ Next' - will EQ to a gentle downward slope & enable Dynamic EQ.");
        } else {
          console.info(`  Active target curve: ${targetCurveName}.`);
        }
        if (targetLevel == 75) {
          console.info(`  Target level set to ${targetLevel}dB`);
        } else {
          console.warn(`  Target level set to ${targetLevel}dB`);
        }
        if (mode !== 'DEFAULT') {
          console.warn(`  ${mode} mode active`);
          const config = MODE_CONFIG[mode];
          console.info(`    - Speaker range: ${config.speaker.min}-${config.speaker.max}Hz`);
          console.info(`    - Subwoofer range: ${config.subwoofer.min}-${config.subwoofer.max}Hz`);
          if (config.rolloffHF) {
            console.info(`    - HF rolloff: ${config.rolloffHF}Hz`);
          }
        } else {
          console.info(`  Standard mode active (DEFAULT)`);
        }
        if (freqIndex.includes(180)) {
          console.warn("  AVR supports 180Hz");
        }
        if (freqIndex.includes(70)) {
          console.warn("  AVR supports IMAX 70Hz");
        }
        if (DiracEnabled == true) {
          console.warn("  AVR supports Dirac");
          console.warn("  AVR max distance set to 18m");
        } else {
          console.info("  AVR does not! supports Dirac");
          console.info("  AVR max distance set to 6m");
        }
        if (noInversion) {
          console.warn(`  Subwoofer polarity inversion allowed: No.`);
        } else {
          console.info(`  Subwoofer polarity inversion allowed: Yes.`);
        }
        if (AdvancedFilters === true || AdvancedFilters === 1) {
          console.warn(`  Advanced Filters: ${AdvancedFilters}`);
        } else {
          console.info(`  Advanced Filters: ${AdvancedFilters}`);
        }

        if (AdvancedFilters == true && AdvancedFiltersType == "null") {
          console.info(`  Advanced Filters Type: none`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "CUSTOMadvanced") {
          console.warn(`  Advanced Filters Type: custom filters active`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "DIALOGadvanced") {
          console.warn(`  Advanced Filters Type: Advanced Dialog Enhancement CEDIA RP22`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSresearch") {
          console.warn(`  Advanced Filters Type: Research-Based Hearing Loss Compensation`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSmoderate") {
          console.warn(`  Advanced Filters Type: Moderate Hearing Loss Compensation`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSsevere") {
          console.warn(`  Advanced Filters Type: Severe Hearing Loss Compensation`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSoriginal") {
          console.warn(`  Advanced Filters Type: Original 0.0.3 Hearing Loss Compensation`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGcompetitive") {
          console.warn(`  Advanced Filters Type: Competitive Gaming EQ (Footsteps & Tactical Audio)`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGimmersive") {
          console.warn(`  Advanced Filters Type: Immersive Gaming EQ (Cinematic Experience)`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGvoice") {
          console.warn(`  Advanced Filters Type: Voice Chat Gaming EQ (Clear Communication)`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGbalanced") {
          console.infwarno(`  Advanced Filters Type: Balanced Gaming EQ (All-Purpose)`);
        }
        if (needsSorting) {
          console.warn(`  Measurements are custom sorted`);
        } else {
          console.info(`  Measurements are default sorted`);
        }
        console.info(`  Version: ${nextversion}`)
        console.info(`****************************************************************************************************`);
      }

      async function bootUp() {
        console.info("Resetting IR windows, equalizer & target settings for all measurements");
        const measurements = await fetch_mREW();
        const titles = {}; let titleIndices = {};
        let mCount = Object.keys(measurements).length;
        console.info(`Starting processing of ${mCount} measurements...`);
        for (let q = 1; q <= mCount; q++) {
          console.infoUpdate(`Counting measurement ${q} of ${mCount}`);
        }
        if (mCount > 100) {
          console.warn(`large amount of measurements found ${mCount} REW may seem unresponsive for some time`)
          console.warn(`Please be patient`)
        }
        if (!mCount) { console.error(`There are no measurements in REW!`); throw new Error; }
        // NEW: Identify and store mic calibration measurements before processing
        let micCalMeasurements = [];
        let actualMCount = mCount;
        for (let i = 1; i <= mCount; i++) {
          if (measurements[i].title.startsWith('_micCal')) {
            micCalMeasurements.push({
              index: i,
              title: measurements[i].title,
              data: measurements[i]
            });
            actualMCount--;
          }
        }
        // Use actualMCount for processing (excluding mic cal)
        if (isCirrusLogic) { actualMCount--; };
        let baseMessage = "Resetting IR windows, EQ type, target shape and smoothing for all measurements..."
        // Reset settings for ALL measurements (including mic cal)
        for (let q = 1; q <= mCount; q++) {
          await postSafe(`${baseUrl}/${q}/ir-windows`, { leftWindowType: "Rectangular", rightWindowType: "Rectangular" }, "Update processed");
          await customDelay(speedDelay / 3);
          await postSafe(`${baseUrl}/${q}/equaliser`, { manufacturer: "Generic", model: "Generic" }, "Equaliser selected");
          await customDelay(speedDelay / 3);
          await postSafe(`${baseUrl}/${q}/target-settings`, { shape: "None" }, "Update processed");
          await customDelay(speedDelay / 3);
          await postNext('Smooth', q, { smoothing: "1/48" });
          await customDelay(speedDelay / 3);
          console.infoUpdate(`${baseMessage} (${q}/${mCount})`);
        }
        await console.infoUpdate("Resetting default equalizer to 'Generic/Generic'...");
        await postSafe(`http://localhost:4735/eq/default-equaliser`, { manufacturer: "Generic", model: "Generic" }, "Default equaliser changed");
        await customDelay(speedDelay / 3);
        await console.infoUpdate(`Resetting default target level to ${targetLevel}dB...`);
        await fetch("http://localhost:4735/eq/default-target-level", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: Number(targetLevel).toFixed(1),
        });
        await customDelay(speedDelay / 3);
        const firstTitle = measurements[1].title;
        console.infoUpdate(`Checking measurement names, indices and sorting...`);
        // MODIFIED: Build titleIndices excluding mic calibration measurements
        for (let i = 1; i <= mCount; i++) {
          const title = measurements[i].title;
          // Skip mic calibration measurements for sorting logic
          if (title.startsWith('_micCal')) {
            continue;
          }
          const titleKey = title.replace(/\d+/g, '');
          if (!/^\D+(\d+)?$/.test(titleKey)) {
            console.error(`Speaker name ${titleKey} does not end with a numeric index.`);
            throw new Error;
          }
          if (!titles[titleKey]) {
            titles[titleKey] = true;
            titleIndices[titleKey] = [];
          }
          const matchResult = title.match(/\d+/);
          if (matchResult && matchResult.length > 0) {
            titleIndices[titleKey].push(parseInt(matchResult[0]));
          } else {
            console.error(`No indices found in speaker name: ${title}`);
            throw new Error;
          }
        }
        // Build expected order: regular speakers first, then subwoofers (mic cal will be handled separately)
        const regularGroups = Object.keys(titleIndices).filter(key => !key.startsWith('SW')).sort();
        const swGroups = Object.keys(titleIndices).filter(key => key.startsWith('SW')).sort();
        for (const groupKey of [...regularGroups, ...swGroups]) {
          for (const index of titleIndices[groupKey].sort((a, b) => a - b)) {
            expectedOrder.push(groupKey + index);
          }
        }
        // MODIFIED: Check if current REW order matches expected order (excluding mic cal)
        let currentOrderWithoutMicCal = [];
        for (let i = 1; i <= mCount; i++) {
          if (!measurements[i].title.startsWith('_micCal')) {
            currentOrderWithoutMicCal.push(measurements[i].title);
          }
        }
        for (let i = 0; i < expectedOrder.length; i++) {
          if (currentOrderWithoutMicCal[i] !== expectedOrder[i]) {
            needsSorting = true;
            console.info(`Order mismatch at position ${i + 1}: found "${currentOrderWithoutMicCal[i]}", expected "${expectedOrder[i]}"`);
            break;
          }
        }
        if (needsSorting) {
          console.infoUpdate("Measurements need reordering. Performing manual sort for proper numeric ordering...");
          disableGraph();
          try {
            // Get current measurements
            const currentMeasurements = await fetch_mREW();
            const currentMCount = Object.keys(currentMeasurements).length;
            // MODIFIED: Separate mic cal measurements from regular measurements
            const regularMeasurements = [];
            const micCalMeasurementsForSorting = [];
            for (let i = 1; i <= currentMCount; i++) {
              const name = currentMeasurements[i].title;
              if (name.startsWith('_micCal')) {
                micCalMeasurementsForSorting.push({
                  originalIndex: i,
                  name: name,
                  index: 999999 // Ensure mic cal sorts last
                });
              } else {
                regularMeasurements.push({
                  originalIndex: i,
                  name: name
                });
              }
            }
            // Parse regular measurements and group them
            const measurementGroups = {};
            for (const measurement of regularMeasurements) {
              const name = measurement.name;
              const titleKey = name.replace(/\d+/g, '');
              const matchResult = name.match(/\d+/);
              if (matchResult && matchResult.length > 0) {
                const groupKey = titleKey;
                const index = parseInt(matchResult[0]);
                if (!measurementGroups[groupKey]) {
                  measurementGroups[groupKey] = [];
                }
                measurementGroups[groupKey].push({
                  originalIndex: measurement.originalIndex,
                  name: name,
                  index: index
                });
              } else {
                console.error(`No indices found in speaker name: ${name}`);
                throw new Error;
              }
            }
            // Sort each group numerically by index
            const sortedGroups = {};
            for (const groupKey in measurementGroups) {
              sortedGroups[groupKey] = measurementGroups[groupKey].sort((a, b) => a.index - b.index);
            }
            // Determine copy order: regular speakers first, then SW groups, then mic cal
            const copyOrder = [];
            const regularGroups = Object.keys(sortedGroups).filter(key => !key.startsWith('SW')).sort();
            const swGroups = Object.keys(sortedGroups).filter(key => key.startsWith('SW')).sort();
            // Add regular and SW measurements
            for (const groupKey of [...regularGroups, ...swGroups]) {
              copyOrder.push(...sortedGroups[groupKey]);
            }
            // MODIFIED: Add mic cal measurements at the end
            copyOrder.push(...micCalMeasurementsForSorting);
            console.infoUpdate(`Copying ${copyOrder.length} measurements in correct numeric order...`);
            // Copy all measurements in the correct order
            for (let i = 0; i < copyOrder.length; i++) {
              const measurement = copyOrder[i];
              await postSafe(`http://localhost:4735/measurements/${measurement.originalIndex}/command`, { command: "Response copy" }, "Completed");
              await platformDelay();
              console.infoUpdate(`Copying measurements... (${i + 1}/${copyOrder.length})`);
            }
            console.infoUpdate("Removing original measurements...");
            // Delete all original measurements (backwards to avoid index shifting)
            for (let i = currentMCount; i >= 1; i--) {
              await postDelete(i);
              await platformDelay();
              console.infoUpdate(`Removing original measurements... (${currentMCount - i + 1}/${currentMCount})`);
            }
            console.infoUpdate("Renaming copied measurements to remove '-copy' suffixes...");
            // Re-fetch to get the remaining measurements (all should be -copy versions now)
            const copiedMeasurements = await fetch_mREW();
            const newMCount = Object.keys(copiedMeasurements).length;
            // Rename all measurements that have "-copy" suffix
            for (let q = 1; q <= newMCount; q++) {
              const name = copiedMeasurements[q].title;
              if (name.endsWith("-copy")) {
                const newname = name.replace(/-copy/gim, "");
                const requestOptions = {
                  method: "PUT",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ title: newname }),
                };
                await fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
                await platformDelay();
                console.infoUpdate(`Renaming measurements... (${q}/${newMCount})`);
              }
            }
            console.infoUpdate("ClariQ Next sorting completed. Mic calibration preserved at end.");
            // Re-fetch and rebuild measurement data
            const sortedMeasurements = await fetch_mREW();
            mCount = Object.keys(sortedMeasurements).length;
            // Recalculate actualMCount after sorting
            actualMCount = mCount;
            for (let i = 1; i <= mCount; i++) {
              if (sortedMeasurements[i].title.startsWith('_micCal')) {
                actualMCount--;
              }
            }
            if (isCirrusLogic) { actualMCount--; };
            // Clear and rebuild the titles and indices with sorted data (excluding mic cal)
            Object.keys(titles).forEach(key => delete titles[key]);
            Object.keys(titleIndices).forEach(key => delete titleIndices[key]);
            for (let i = 1; i <= mCount; i++) {
              const title = sortedMeasurements[i].title;
              // Skip mic calibration measurements
              if (title.startsWith('_micCal')) {
                continue;
              }
              const titleKey = title.replace(/\d+/g, '');
              if (!titles[titleKey]) {
                titles[titleKey] = true;
                titleIndices[titleKey] = [];
              }
              const matchResult = title.match(/\d+/);
              if (matchResult && matchResult.length > 0) {
                titleIndices[titleKey].push(parseInt(matchResult[0]));
              }
            };
            console.info("ClariQ Next sorting and re-indexing completed successfully.");
            enableGraph();
          } catch (error) {
            console.error("Failed to perform ClariQ Next sorting:", error);
            console.error("Please report your issue on discord!");
            throw new Error;
          }
        }
        // Continue with rest of original logic using actualMCount
        nSpeakers = 0;
        nSubs = 0;
        for (const titleKey in titleIndices) {
          const indices = titleIndices[titleKey];
          if (indices[0] != Math.min(...indices)) {
            console.error(`MLP measurement needs to be the first measurement for ${titleKey} channel!`);
            throw new Error;
          }
          if (titleKey === "SWMIX") {
            nSubs = 1;
          }
          else if (titleKey.startsWith("SW")) {
            for (let i = 0; i < titleIndices[titleKey].length; i++) {
              swIdx = String(titleIndices[titleKey][i]);
              if (swIdx.length === 2 && swIdx.endsWith("0")) {
                nSubs++;
              }
            }
          }
          else {
            nSpeakers++;
          }
        }
        Object.freeze(nSpeakers);
        Object.freeze(nSubs);
        nChannels = Object.keys(titles).length;
        Object.freeze(nChannels);
        const rewVersion = await fetch(`http://localhost:4735/version`);
        if (rewVersion.ok) {
          const rew = await rewVersion.json();
          console.infoUpdate(`Integrity checks completed successfully. Running Room EQ Wizard version ${rew.message}`);
        }
        else {
          console.error('There seems to be a problem with REW installation!');
          throw new Error;
        }
        // only apply if all sanity checks pass
        if (isCirrusLogic) {
          try {
            await addmicCal();
          } catch (error) {
            console.error("Microphone calibration failed:", error);
            const skipMicCal = confirm("Microphone calibration failed. Continue without it?");
            if (skipMicCal) {
              // Remove microcal measurement and continue
              const measurements = await fetch_mREW();
              const mCount = Object.keys(measurements).length;
              await postDelete(mCount);
              console.warn("Continuing without microphone calibration");
            } else {
              throw error;
            }
          }
        }
        const tcResponse = await fetch('http://localhost:4735/eq/house-curve');
        if (tcResponse.ok) {
          const target = await tcResponse.json();
          targetCurvePath = String(target);
          if (target && targetCurvePath) {
            targetCurveName = targetCurvePath.replace(/^.*[\\/]/, '').split(".")[0];
            Object.freeze(targetCurveName);
            Object.freeze(targetCurvePath);
            await disableRoomCurve();
            await postSafe(`http://localhost:4735/eq/house-curve`, targetCurvePath, "House curve set");
          }
          else {
            targetCurveName = "";
            await enableRoomCurve();
          }
          await fetchSafe('target-level', 1, targetLevel)
          const targetCurve = await postNext('Generate target measurement', 1);
          const targetCurveIdx = Object.keys(targetCurve.results)[0];
          targetResponse = await fetchSafe(`frequency-response?smoothing=1%2F48&ppo=96`, targetCurveIdx);

          if (isDebugMode) {
            console.log("=== TARGET CURVE SPL DEBUG ===");
            const targetArray200to2000 = response2array(targetResponse, 200, 2000);
            const targetSPL200to2000 = targetArray200to2000.reduce((acc, val) => acc + val, 0) / targetArray200to2000.length;
            console.log(`Target curve average SPL (200-2000Hz): ${targetSPL200to2000.toFixed(1)}dB`);
            const targetArray30to80 = response2array(targetResponse, 30, 80);
            const targetSPL30to80 = targetArray30to80.reduce((acc, val) => acc + val, 0) / targetArray30to80.length;
            console.log(`Target curve average SPL (30-80Hz): ${targetSPL30to80.toFixed(1)}dB`);
            console.log(`Target level setting: ${targetLevel}dB`);
            console.log("=== END TARGET CURVE DEBUG ===");
          }
          Object.freeze(targetResponse);
          await postDelete(targetCurveIdx);
        }
        else {
          console.error(`Failed to fetch target curve, please make sure to have started REW API server! HTTP status code: ${tcResponse.status}.`);
          throw new Error;
        }
        const indicesCounts = Object.values(titleIndices).map(indices => indices.length);
        const isIndicesEqual = indicesCounts.every(count => count === indicesCounts[0]);
        if (!isIndicesEqual) {
          const problemG = [];
          for (const [titleKey, indices] of Object.entries(titleIndices)) {
            if (indices.length !== indicesCounts[0]) {
              problemG.push(titleKey);
            }
          }
          if (problemG.some(group => group.startsWith('SW')) && bassMode === "Directional") {
            console.info(`'Directional bass' mode with '${nSubs}' subwoofers detected!`);
          } else {
            console.error('Speaker names have different numbers of indices.');
            throw new Error();
          }
        }
        logCustomizations();
        return;
      }

      function getDelayHeadroom(startIdx, endIdx) {
        const minM = Math.min(...mSec.slice(startIdx, endIdx + 1));
        const maxM = Math.max(...mSec.slice(startIdx, endIdx + 1));
        const maxDist = DiracEnabled === true ? 18 : 6;
        const limInsec = maxDist / sOs;
        const msecMin = maxM - limInsec;
        const msecMax = minM + limInsec;
        const maxNegative = msecMin * delaymax;
        const maxPositive = msecMax * delaymax;
        if (maxNegative > maxPositive) {
          console.error("Ran out of delay range!");
          throw new Error;
        }
        return [maxNegative, maxPositive];
      }

      // returns range that "thisDelay" can be shifted by
      function getDelayRangeOf(thisDelay, startIdx, endIdx) {
        const [maxNegative, maxPositive] = getDelayHeadroom(startIdx, endIdx);
        const delayms = thisDelay * delaymax;
        const loDelay = maxNegative - delayms;
        const hiDelay = maxPositive - delayms;
        if (loDelay > hiDelay) {
          console.error("Ran out of delay range!");
          throw new Error;
        }
        return [loDelay, hiDelay];
      }

      function getDelayRangeOfFinalSub() {
        let [loDelay, hiDelay] = getDelayRangeOf(mSec[nChannels], 1, nSpeakers);
        // directional subwoofer delay(s)
        if (bassMode === "Directional") {
          const loDelaySub = Math.min(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          const hiDelaySub = Math.max(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          [loDelay,] = getDelayRangeOf(loDelaySub, 1, nSpeakers);
          [, hiDelay] = getDelayRangeOf(hiDelaySub, 1, nSpeakers);
        }
        // standard bass relative delay(s)
        else if (subLoDelay != 0 || subHiDelay != 0) {
          [loDelay,] = getDelayRangeOf(mSec[nChannels] + subLoDelay, 1, nSpeakers);
          [, hiDelay] = getDelayRangeOf(mSec[nChannels] + subHiDelay, 1, nSpeakers);
        }
        if (loDelay > hiDelay) {
          console.error("Ran out of delay range!");
          throw new Error;
        }
        return [loDelay, hiDelay];
      }

      async function groundWorks() {
        let measurements = await fetch_mREW();
        let mCount = Object.keys(measurements).length;
        const micPositions = mCount / (nSpeakers + nSubs);
        if (bassMode === "Directional") {
          console.info(`'Directional bass' mode with '${swChannelCount}' subwoofers detected.`);
        }
        if (bassMode != "Directional" && swChannelCount > 1) {
          bassMode = "Standard";
          console.info(`'Standard bass' mode with '${swChannelCount}' subwoofers detected.`);
        }
        if (bassMode != "Directional" && swChannelCount === 1) {
          bassMode = "Standard";
          console.info(`'Standard bass' mode with '${swChannelCount}' subwoofer detected.`);
        }
        console.log("Optimizing spatial averaging, volume & time alignment...");
        // STEP 1: Initialize Trims using MLP measurements only
        console.info("Initializing trims...");
        let count = 1;
        let title = {};
        for (let i = 1; i <= mCount; i += micPositions) {
          const indices = Array.from({ length: micPositions }, (_, j) => i + j);
          title[count] = measurements[i].title.slice(0, -1) + "o";
          // trim determination using the MLP measurement ONLY (indices[0])
          const mlpIndex = indices[0]; // This is the MLP measurement (C0, FHL0, etc.)
          console.info(`├─ Calculating MLP trim for channel ${count}: ${title[count]} (using MLP measurement index ${mlpIndex} - ${measurements[mlpIndex].title})`);
          if (title[count].startsWith("SW")) {
            customLevel[count] = await getSubTrim(mlpIndex);
          } else {
            customLevel[count] = await getSpeakerTrim(mlpIndex);
          }
          console.log(`├─ MLP trim result for ${title[count]}: ${customLevel[count]}dB`);
          // shift all measurements for this channel based on MLP trim
          for (let j = 0; j < indices.length; j++) {
            await postNext('Add SPL offset', indices[j], { offset: customLevel[count] });
          }
          // attempt to fix android volume bug where measurements are off by multiples of +/-6dB
          if (isCirrusLogic && IsCustomMeasurements == false) {
            await fixVolBug(indices);
          }
          count++;
        }
        console.info("Initialized trims.");
        // STEP 2: Time align speakers
        console.info("Time aligning speakers...");
        const mlpSPIndices = [];
        const mlpSWIndices = [];
        // Build MLP indices arrays based on current data structure
        count = 1;
        for (let i = 1; i <= mCount; i += micPositions) {
          if (title[count].startsWith("SW")) {
            mlpSWIndices.push(i); // MLP subwoofer measurement
          } else {
            mlpSPIndices.push(i); // MLP speaker measurement  
          }
          mSec[count] = 0; // initialize
          count++;
        }
        console.info(`├─ MLP Speaker indices: [${mlpSPIndices.join(', ')}]`);
        console.info(`├─ MLP Subwoofer indices: [${mlpSWIndices.join(', ')}]`);
        // calculate the average IR start delay for normalization
        measurements = await fetch_mREW();
        let IRStartDelay = 0;
        for (let i = 0; i < mlpSPIndices.length; i++) {
          IRStartDelay += measurements[mlpSPIndices[i]].timeOfIRStartSeconds;
        }
        IRStartDelay /= nSpeakers;
        console.info(`├─ Average IR start delay: ${IRStartDelay.toFixed(6)}s`);
        // time align & normalize speaker delays
        await postNext('Time align', mlpSPIndices);
        measurements = await fetch_mREW();
        for (let i = 0; i < mlpSPIndices.length; i++) {
          mSec[i + 1] = IRStartDelay - measurements[mlpSPIndices[i]].cumulativeIRShiftSeconds;
          console.info(`├─ Speaker ${i + 1} delay: ${mSec[i + 1].toFixed(6)}s`);
        }
        // shift subwoofer IRs by the same offset used to normalize speaker delays
        // note: this ensures relative delay of SW compared to speakers stay intact
        for (let i = 0; i < mlpSWIndices.length; i++) {
          await postNext('Offset t=0', mlpSWIndices[i], { offset: IRStartDelay, unit: "seconds" });
          console.info(`├─ Applied ${IRStartDelay.toFixed(6)}s offset to subwoofer MLP measurement ${mlpSWIndices[i]}`);
        }
        console.info("Time aligned speakers.");
        // STEP 3: Initialize Subwoofers
        if (noSub) { return; }
        if (bassMode === "Directional") {
          console.warn("⏸️ Directional bass detected - deferring conversion until after ART optimization...");
          console.info("This allows ART to optimize each subwoofer independently before combining.");
          // DON'T convert yet - let ART optimize individual subs first
          // Conversion will happen in convertDirectionalIfNeeded() after ART runs

          // But still need to do the median alignment that was in directional2standard
          const loSWDelay = Math.min(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          const hiSWDelay = Math.max(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          const medianSWDelay = (loSWDelay + hiSWDelay) / 2;

          // Apply median offset to all subs for initial alignment
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            const firstMeasurement = (i - nSpeakers - 1) * micPositions + (nSpeakers * micPositions) + 1;
            for (let j = 0; j < micPositions; j++) {
              await postNext('Offset t=0', firstMeasurement + j, { offset: -medianSWDelay, unit: "seconds" });
            }
            mSec[i] -= medianSWDelay;
          }
          console.info(`Applied median delay offset of ${medianSWDelay.toFixed(6)}s to ${nSubs} subs for preliminary alignment`);

        } else if (subLoDelay != 0 || subHiDelay != 0) {
          // normalize standard bass subwoofer median IR to t=0
          const IROffset = (subLoDelay + subHiDelay) / 2;
          // Find the subwoofer MLP index (equivalent to cmdIdMeasurements[commandId[nChannels]][0])
          let stdSubMLPIdx = null;
          count = 1;
          for (let i = 1; i <= mCount; i += micPositions) {
            if (title[count].startsWith("SW")) {
              stdSubMLPIdx = i; // This is the MLP measurement for the subwoofer
              break;
            }
            count++;
          }
          if (stdSubMLPIdx) {
            await postNext('Offset t=0', stdSubMLPIdx, { offset: IROffset, unit: "seconds" });
            mSec[nChannels] -= IROffset;
            console.info(`├─ Applied ${IROffset.toFixed(6)}s IROffset to subwoofer MLP measurement ${stdSubMLPIdx}`);
          }
        }
        // align combined subwoofer median IR to median IR of speakers
        // note: this ensures min/max delays are negative/positive, otherwise REW crashes
        const loSPDelay = Math.min(...mSec.slice(1, nSpeakers + 1));
        const hiSPDelay = Math.max(...mSec.slice(1, nSpeakers + 1));
        const medianSPDelay = (loSPDelay + hiSPDelay) / 2;
        console.info(`├─ Speaker delay range: ${loSPDelay.toFixed(6)}s to ${hiSPDelay.toFixed(6)}s (median: ${medianSPDelay.toFixed(6)}s)`);
        // Find subwoofer MLP index and apply median speaker delay offset (equivalent to SWIndices[0])
        count = 1;
        for (let i = 1; i <= mCount; i += micPositions) {
          if (title[count].startsWith("SW")) {
            await postNext('Offset t=0', i, { offset: -medianSPDelay, unit: "seconds" });
            console.info(`├─ Applied ${(-medianSPDelay).toFixed(6)}s offset to subwoofer MLP measurement ${i}`);
            // Check response variation if multiple microphone positions (equivalent to SWIndices.length > 1)
            if (micPositions > 1 && typeof calculateMaxDeltaOfResponses !== 'undefined') {
              const SWIndices = Array.from({ length: micPositions }, (_, j) => i + j);
              const SWMaxDelta = await calculateMaxDeltaOfResponses(SWIndices, 30, 80);
              console.log(`├─ ${title[count]} response variation between ${SWIndices.length} microphone positions: ±${(SWMaxDelta / 2).toFixed(2)}dB`);
            }
            break;
          }
          count++;
        }
        // Update subwoofer delays
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          mSec[i] += medianSPDelay;
        }
        // STEP 4: Spatial Average
        console.info("Starting spatial averaging...");
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        const originalMCount = mCount; // Store original count
        // Use the original micPositions calculation - it should still be correct
        const currentChannels = nSpeakers + nSubs;
        console.info(`├─ Total measurements: ${mCount}, Current channels: ${currentChannels}`);
        console.info(`├─ Using original mic positions: ${micPositions}`);
        console.info(`├─ Title array contents: [${Object.keys(title).map(k => `${k}:"${title[k]}"`).join(', ')}]`);
        count = 1;
        for (let i = 1; i <= originalMCount; i += micPositions) {
          // Safety check: don't process beyond available titles
          if (count > currentChannels || !title[count]) {
            console.warn(`├─ Stopping spatial averaging - no more channels to process (count: ${count}, max: ${currentChannels})`);
            break;
          }
          console.infoUpdate(`🔊 Computing optimal spatial averaging configuration for channel ${count}/${currentChannels} (${title[count]})`);
          const indices = Array.from({ length: micPositions }, (_, j) => i + j);
          console.info(`├─ Processing microphone positions: indices [${indices.join(', ')}]`)
          if (micPositions > 1) {
            console.info(`├─ Cross-correlating ${micPositions} microphone positions...`);
            await postNext('Cross corr align', indices);
            console.log(`├─ Cross-correlation alignment completed`);
          }
          let newMeasurementResult;
          if (micPositions === 1) {
            console.info(`├─ Single microphone position - copying measurement`);
            newMeasurementResult = await postSafe(`${baseUrl}/${i}/command`, { command: "Response copy" }, "Completed");
          } else {
            console.info(`├─ Averaging ${micPositions} microphone positions...`);
            newMeasurementResult = await postNext('Magn plus phase average', indices);
            console.log(`├─ Spatial averaging completed for ${micPositions} positions`);
          }
          // Get the actual index of the newly created measurement
          let newMeasurementIdx;
          if (newMeasurementResult && newMeasurementResult.results) {
            // Extract the new measurement index from the result
            const resultKeys = Object.keys(newMeasurementResult.results);
            newMeasurementIdx = parseInt(resultKeys[0]);
            console.info(`├─ Got measurement index ${newMeasurementIdx} from operation result`);
          } else {
            // Fallback: refresh measurements and find the newest one
            const freshMeasurements = await fetch_mREW();
            const freshMCount = Object.keys(freshMeasurements).length;
            newMeasurementIdx = freshMCount; // Newest measurement should be the last index
            console.info(`├─ Using fallback measurement index ${newMeasurementIdx} (latest measurement)`);
          }
          console.info(`├─ Created averaged measurement: Index ${newMeasurementIdx} - target title: "${title[count]}"`);
          // Update the measurement title
          await fetch_mREW(newMeasurementIdx, 'PUT', { title: title[count] });
          console.info(`├─ Calculating trim for averaged result - Index ${newMeasurementIdx}`);
          // o vs target curve
          const volAdjust = title[count].startsWith("SW") ? await getSubTrim(newMeasurementIdx) : await getSpeakerTrim(newMeasurementIdx);
          console.log(`├─ Averaged trim result: ${volAdjust}dB`);
          await postNext('Add SPL offset', newMeasurementIdx, { offset: volAdjust });
          console.info(`└─ Applied ${volAdjust}dB SPL offset to averaged measurement`);
          console.info(`─────────────────────────────────────────────────────────`);
          // go to next channel
          count++;
        }
        console.infoUpdate("Deleting processed measurements...");
        // Get current measurement count for cleanup
        measurements = await fetch_mREW();
        const finalMCount = Object.keys(measurements).length;
        const numAveragedMeasurements = nSpeakers + nSubs;
        // Delete original measurements (keep the averaged ones)
        for (let i = originalMCount; i >= 1; i--) {
          await postDelete(i);
        }
        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          commandId[i] = title[i].slice(0, -1);
        }
        // Normalize Trim levels targetLevel vs 75dB
        normalizeTrimLevels();
        console.info("Completed averaging, volume & time alignment!");
        // Final subwoofer processing
        if (noSub) { return; }
        const [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        console.info(`Available bass system volume adjustment range → { ${subLoTrim}dB : ${subHiTrim}dB }`);
        console.info(`Total subwoofer 'delay headroom' available → ${(hiDelay - loDelay).toFixed(2)}ms`);
        const dynamicBassFilldB = await getDynamicBassFill(nChannels);
        if (dynamicBassFilldB != 0) {
          console.warn(`***Adding ${dynamicBassFilldB}dB dynamic bass fill to compensate for dips!***`);
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += dynamicBassFilldB;
            console.info(`${commandId[i].padStart(3, ".")} - shifted: ${customLevel[i] - dynamicBassFilldB}dB → ${customLevel[i]}dB`);
          }
          await postNext('Add SPL offset', nChannels, { offset: dynamicBassFilldB });
        }
        // Store directional bass state for ART optimization
        window.hasDirectionalBass = (bassMode === "Directional" && nSubs > 1);
        window.preCombinedSubCount = nSubs;
      }

      async function calculateMaxDeltaOfResponses(indices, start, end) {
        if (indices.length <= 1) { return 0; }
        const responseArrays = [];
        for (let i = 0; i < indices.length; i++) {
          const freqResponse = await fetchSafe("frequency-response?smoothing=Psy&ppo=96", indices[i]);
          const freqArray = response2array(freqResponse, start, end);
          responseArrays.push(freqArray);
        }
        // find the max difference in SPL across the responses
        let maxDelta = 0;
        for (let i = 0; i < responseArrays[0].length; i++) {
          const points = responseArrays.map(row => row[i]);
          const minVal = Math.min(...points);
          const maxVal = Math.max(...points);
          maxDelta = Math.max(maxVal - minVal, maxDelta);
        }
        return maxDelta;
      }

      async function getALOffset(idx, isSub) {
        const fltResponse = await fetchSafe('frequency-response?smoothing=1%2F1&ppo=96', idx);
        // let lowFreq, highFreq;
        if (isRP22mode) {
          lowFreq = 20; highFreq = 120;
        } else if (isDolbymode) {
          lowFreq = 31.5; highFreq = 120;
        } else if (isTHXmode) {
          lowFreq = 20; highFreq = 120;
        } else if (isIMAXmode) {
          lowFreq = 20; highFreq = 70;
        } else {
          lowFreq = 30; highFreq = 80;
        }
        const fltArray = isSub ? await response2array(fltResponse, lowFreq, highFreq) : await response2array(fltResponse, 500, 2000);
        const offset = fltArray.reduce((acc, val) => acc + val, 0) / fltArray.length;
        return offset;
      }

      // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
      // PROPRIETARY FILTER GENERATION AND CHECKING ! 
      // CAN NOT BE USED WITHOUT EXPLICIT PERMISSION OF NVEXX !
      // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
      // async function generateFilters() {

      // Before calling generateFilters(), get the custom config
      AdvancedFiltersType = document.getElementById('script_af_type').value;
      let customFiltersConfig = null;

      if (AdvancedFiltersType === 'CUSTOMadvanced') {
        customFiltersConfig = getCustomFilters();
        console.log("Custom filters config:", customFiltersConfig); // Debug log
      }

      async function generateFilters(customFiltersConfig = null) {
        console.log(`Generating min. phase EQ filters...`);
        // ===== FILTER CONFIGURATION =====
        // Set these variables to enable different filter types:
        // Hearing loss compensation: "research", "moderate", "severe", "original", or null
        // const hearingLossType = "research";
        // Gaming EQ optimization: "competitive", "immersive", "voice", "balanced", or null  
        // - "competitive": Optimized for footsteps, gunshots, tactical audio (FPS games)
        // - "immersive": Cinematic experience with enhanced atmosphere (RPG/Adventure) 
        // - "voice": Clear voice chat communication with game audio
        // - "balanced": All-purpose gaming enhancement
        // const gamingEQType = "competitive";
        // Dialog enhancement: controlled by existing RP22DialogEnhancementFilter boolean
        // Disabled all HP as the filters get messed up!
        // Smart filter creation helper - handles REW API parameter requirements
        const createREWFilter = (index, type, frequency, gaindB = 0, q = 1.0) => ({
          index,
          type,
          enabled: true,
          isAuto: false,
          frequency,
          ...(type !== "HP" && { gaindB }), // All except HP have gaindB
          ...(type === "PK" && { q })        // Only PK filters have q
        });

        const getAdvancedFilters = (type) => {
          switch (type) {
            case "CUSTOMadvanced":
              // Read custom filters directly from the global array
              let customFilters = [];
              let customDescription = "Custom User-Defined EQ";

              if (typeof customFiltersArray !== 'undefined' && customFiltersArray.length > 0) {
                customFilters = customFiltersArray;
                const descInput = document.getElementById('customFilterDescription');
                if (descInput) {
                  customDescription = descInput.value || customDescription;
                }
              } else if (typeof getCustomFilters === 'function') {
                const config = getCustomFilters();
                customFilters = config.filters || [];
                customDescription = config.description || customDescription;
              }

              // Validate
              if (!customFilters || customFilters.length === 0) {
                console.warn("Custom filter type selected but no custom filters defined!");
                return null;
              }

              if (customFilters.length > 20) {
                console.error(`Custom filters exceed maximum of 20 filters (found ${customFilters.length})`);
                return null;
              }

              console.log("✓ Loading custom filters:", customFilters);

              // CRITICAL: Start from index 20 and count DOWN (reverse order)
              // This preserves critical low-frequency REW filters and overwrites high-frequency ones first
              // REW fills 1→15 (low to high freq), custom fills 20→1 (high to low freq)
              const startIndex = 20;
              const rewFilters = customFilters.map((filter, idx) => {
                const filterIndex = startIndex - idx; // 20, 19, 18, 17, 16...
                console.log(`Creating custom filter at index ${filterIndex}:`, filter);
                return createREWFilter(
                  filterIndex,
                  filter.type,
                  filter.frequency,
                  filter.gaindB || 0,
                  filter.q || 1.0
                );
              });

              // Sort filters by index (descending) to apply from high to low
              rewFilters.sort((a, b) => b.index - a.index);

              // Generate target descriptions
              const targets = customFilters.map((filter) => {
                let desc = `- ${filter.frequency}Hz: `;
                if (filter.type === "PK") {
                  desc += `${filter.gaindB >= 0 ? '+' : ''}${filter.gaindB}dB (Q=${filter.q})`;
                } else if (filter.type === "HS" || filter.type === "LS") {
                  desc += `${filter.gaindB >= 0 ? '+' : ''}${filter.gaindB}dB ${filter.type} shelf`;
                }
                /* HP and LP commented out - conflicts with bass management
                else if (filter.type === "HP") {
                  desc += `High-pass filter`;
                } else if (filter.type === "LP") {
                  desc += `Low-pass filter`;
                }
                */
                return desc;
              });

              return {
                filters: rewFilters,
                description: customDescription,
                targets: targets
              };

            case "DIALOGadvanced":
              return {
                filters: [
                  createREWFilter(16, "PK", 1600, 2.5, 1.2),   // Peak speech intelligibility
                  createREWFilter(17, "PK", 3000, 3.0, 1.5),   // Critical consonant clarity
                  createREWFilter(18, "PK", 800, 1.5, 0.8),    // Speech warmth and body
                  createREWFilter(19, "PK", 4500, 2.0, 1.8),   // Upper consonant definition
                  createREWFilter(20, "HS", 5000, -1.0)        // Sibilance control
                ],
                description: "Advanced Dialog Enhancement CEDIA RP22",
                targets: [
                  "- 800Hz: +1.5dB (Speech warmth and body)",
                  "- 1.6kHz: +2.5dB (Peak speech intelligibility",
                  "- 3kHz: +3.0dB (Critical consonant clarity)",
                  "- 4.5kHz: +2.0dB (Upper consonant definition)",
                  "- 5kHz+: -1.0dB (Sibilance control)"
                ]
              };
            case "HLOSSresearch":
              return {
                filters: [
                  createREWFilter(11, "PK", 2000, 2.0, 1.0),   // Presbycusis difficulty onset
                  createREWFilter(12, "PK", 4000, 4.0, 1.2),   // Critical consonant clarity
                  createREWFilter(13, "PK", 6000, 6.0, 1.5),   // Major presbycusis loss frequency  
                  createREWFilter(14, "HS", 8000, 4.0)         // High-frequency presbycusis
                ],
                description: "Research-Based Hearing Loss Compensation",
                targets: [
                  "- 2kHz: +2.0dB (Presbycusis difficulty onset)",
                  "- 4kHz: +4.0dB (Critical consonant clarity)",
                  "- 6kHz: +6.0dB (Major presbycusis loss frequency)",
                  "- 8kHz+: +4.0dB (High-frequency compensation)"
                ]
              };
            case "HLOSSmoderate":
              return {
                filters: [
                  // createREWFilter(11, "HP", 80),               // Remove low-frequency masking
                  createREWFilter(12, "PK", 2500, 3.0, 1.0),   // Speech intelligibility range
                  createREWFilter(13, "PK", 4000, 5.0, 1.3),   // 4kHz notch compensation
                  createREWFilter(14, "HS", 6000, 3.0)         // General high-frequency lift
                ],
                description: "Moderate Hearing Loss Compensation",
                targets: [
                  // "- 80Hz: High-pass filter (remove masking)",
                  "- 2.5kHz: +3.0dB (Speech intelligibility)",
                  "- 4kHz: +5.0dB (Notch compensation)",
                  "- 6kHz+: +3.0dB (High-frequency lift)"
                ]
              };
            case "HLOSSsevere":
              return {
                filters: [
                  // createREWFilter(11, "HP", 100),              // Aggressive low-cut
                  createREWFilter(12, "PK", 2000, 6.0, 1.0),   // Strong speech boost
                  createREWFilter(13, "PK", 4000, 10.0, 1.5),  // Maximum 4kHz compensation
                  createREWFilter(14, "PK", 6000, 12.0, 1.5),  // Strong 6kHz boost
                  createREWFilter(15, "HS", 8000, 8.0)         // Aggressive high-frequency
                ],
                description: "Severe Hearing Loss Compensation",
                targets: [
                  // "- 100Hz: High-pass filter (aggressive low-cut)",
                  "- 2kHz: +6.0dB (Strong speech boost)",
                  "- 4kHz: +10.0dB (Maximum compensation)",
                  "- 6kHz: +12.0dB (Strong high-frequency boost)",
                  "- 8kHz+: +8.0dB (Aggressive compensation)"
                ]
              };
            case "HLOSSoriginal":
              return {
                filters: [
                  createREWFilter(11, "PK", 1000, 1.5, 0.9),   // Speech body and presence
                  createREWFilter(12, "PK", 2500, 3.0, 1.2),   // Consonant intelligibility
                  createREWFilter(13, "PK", 4000, 4.0, 1.5),   // High consonant clarity boost
                  createREWFilter(14, "PK", 6000, 3.0, 1.8),   // Upper speech and sibilant detail
                  createREWFilter(15, "HS", 8000, 2.0)         // High frequency audibility
                ],
                description: "Original 0.0.3 Hearing Loss Compensation",
                targets: [
                  "- 1kHz: +1.5dB (Speech body and presence)",
                  "- 2.5kHz: +3.0dB (Consonant intelligibility)",
                  "- 4kHz: +4.0dB (High consonant clarity boost)",
                  "- 6kHz: +3.0dB (Upper speech and sibilant detail)",
                  "- 8kHz+: +2.0dB (High frequency audibility)"
                ]
              };
            case "GAMINGcompetitive":
              return {
                filters: [
                  // createREWFilter(5, "HP", 60),            // Remove low-frequency rumble
                  createREWFilter(6, "PK", 400, -2.0, 1.0),   // Reduce muddiness that masks footsteps
                  createREWFilter(7, "PK", 2000, 3.0, 1.2),   // Boost footstep frequency range
                  createREWFilter(8, "PK", 4000, 4.0, 1.5),   // Critical footstep/gunshot clarity
                  createREWFilter(9, "PK", 8000, 3.0, 1.8),   // High-frequency tactical sounds
                  createREWFilter(10, "HS", 10000, 2.0)       // Enhance detail/positioning cues
                ],
                description: "Competitive Gaming EQ (Footsteps & Tactical Audio)",
                targets: [
                  // "- 60Hz: High-pass (remove rumble that masks footsteps)",
                  "- 400Hz: -2.0dB (reduce muddiness)",
                  "- 2kHz: +3.0dB (footstep detection range)",
                  "- 4kHz: +4.0dB (critical footsteps & gunshots)",
                  "- 8kHz: +3.0dB (tactical audio positioning)",
                  "- 10kHz+: +2.0dB (detail & directional cues)"
                ]
              };
            case "GAMINGimmersive":
              return {
                filters: [
                  createREWFilter(5, "PK", 80, 2.0, 0.8),     // Enhanced bass for explosions/atmosphere
                  createREWFilter(6, "PK", 200, 3.0, 1.0),    // Low-mid warmth and impact
                  createREWFilter(7, "PK", 1000, 1.0, 0.9),   // Balanced mid-range
                  createREWFilter(8, "PK", 3000, 2.0, 1.2),   // Speech and effects clarity
                  createREWFilter(9, "PK", 6000, 1.5, 1.5),   // Detail without harshness
                  createREWFilter(10, "HS", 8000, 1.0)        // Subtle air and openness
                ],
                description: "Immersive Gaming EQ (Cinematic Experience)",
                targets: [
                  "- 80Hz: +2.0dB (bass impact for explosions)",
                  "- 200Hz: +3.0dB (warmth and atmosphere)",
                  "- 1kHz: +1.0dB (balanced mid-range)",
                  "- 3kHz: +2.0dB (speech and effects clarity)",
                  "- 6kHz: +1.5dB (detail without fatigue)",
                  "- 8kHz+: +1.0dB (subtle air and space)"
                ]
              };
            case "GAMINGvoice":
              return {
                filters: [
                  // createREWFilter(5, "HP", 100),           // Remove low-frequency noise
                  createREWFilter(6, "PK", 300, -1.0, 1.0),   // Reduce boom in voice
                  createREWFilter(7, "PK", 1500, 3.0, 1.0),   // Core voice intelligibility
                  createREWFilter(8, "PK", 3000, 4.0, 1.5),   // Voice clarity and consonants
                  createREWFilter(9, "PK", 5000, 2.0, 2.0),   // Voice presence without sibilance
                  createREWFilter(10, "HS", 8000, -1.0)       // Reduce harshness
                ],
                description: "Voice Chat Gaming EQ (Clear Communication)",
                targets: [
                  // "- 100Hz: High-pass (remove voice noise)",
                  "- 300Hz: -1.0dB (reduce voice boom)",
                  "- 1.5kHz: +3.0dB (core voice intelligibility)",
                  "- 3kHz: +4.0dB (voice clarity & consonants)",
                  "- 5kHz: +2.0dB (presence without sibilance)",
                  "- 8kHz+: -1.0dB (reduce harshness)"
                ]
              };
            case "GAMINGbalanced":
              return {
                filters: [
                  // createREWFilter(5, "HP", 40),            // Gentle low-cut
                  createREWFilter(6, "PK", 150, 1.0, 0.8),    // Subtle bass enhancement
                  createREWFilter(7, "PK", 1000, 1.5, 1.0),   // Mid-range presence
                  createREWFilter(8, "PK", 3000, 2.0, 1.3),   // Speech/effects balance
                  createREWFilter(9, "PK", 6000, 1.5, 1.5),   // Detail and clarity
                  createREWFilter(10, "HS", 10000, 1.0)       // Subtle high-end extension
                ],
                description: "Balanced Gaming EQ (All-Purpose)",
                targets: [
                  // "- 40Hz: High-pass (gentle low-cut)",
                  "- 150Hz: +1.0dB (subtle bass enhancement)",
                  "- 1kHz: +1.5dB (mid-range presence)",
                  "- 3kHz: +2.0dB (speech & effects balance)",
                  "- 6kHz: +1.5dB (detail and clarity)",
                  "- 10kHz+: +1.0dB (subtle high-end)"
                ]
              };
            default:
              return null;
          }
        };

        for (let i = 1; i <= nChannels; i++) {
          console.info(`${commandId[i].padStart(3, ".")} - equalizing channel...`);
          const isSub = commandId[i].startsWith("SW");
          const tcLevelOffset = isSub ? 0 : await getTCTrim(i, 200, 2000); // getTCTrim already uses Var
          await fetchSafe('target-level', i, targetLevel - tcLevelOffset);
          await postNext('Smooth', i, { smoothing: "Var" });
          await postSafe(`${baseUrl}/${i}/target-settings`, {
            shape: isSub ? "Subwoofer" : "Full range",
            lowFreqCutoffHz: (isSub && m3dBPoints[i][0] === 10) ? 0 : m3dBPoints[i][0],
            lowFreqSlopedBPerOctave: 48, // steep slope to EQ without effect and keep REW happy
            bassManagementCutoffHz: (isSub && m3dBPoints[i][1] === 320) ? 20000 : m3dBPoints[i][1],
            bassManagementSlopedBPerOctave: 48 // steep slope to EQ without effect and keep REW happy
          }, "Update processed");

          await postSafe(`http://localhost:4735/eq/match-target-settings`, {
            startFrequency: m3dBPoints[i][0],
            endFrequency: m3dBPoints[i][1],
            individualMaxBoostdB: isSub ? 3 : 3,
            overallMaxBoostdB: isSub ? 0 : 0,
            flatnessTargetdB: 1,
            allowNarrowFiltersBelow200Hz: true,
            varyQAbove200Hz: false,
            allowLowShelf: isSub,
            lowShelfMin: -6,
            lowShelfMax: 6,
            allowHighShelf: !isSub,
            highShelfMin: -6,
            highShelfMax: 6
          }, "Update processed");

          try {
            await postNext('Match target', i);
          }
          catch (error) {
            // not really an issue if it fails
            console.debug(`${commandId[i]} could not be equalized!`);
          }

          // SANITY CHECK: Ensure no filters exceed +3dB boost or -10dB cut limits
          try {
            const filters = await getFilters(i);
            const violations = sanityCheck(filters);
            if (violations) {
              const boostViolations = violations.filter(v => v.currentGain > 3).length;
              const cutViolations = violations.filter(v => v.currentGain < -10).length;

              if (boostViolations && cutViolations) {
                console.warn(`${commandId[i]} - Fixed ${boostViolations} boost and ${cutViolations} cut filter violations`);
              } else if (boostViolations) {
                console.warn(`${commandId[i]} - Fixed ${boostViolations} filter(s) exceeding +3dB boost limit`);
              } else {
                console.warn(`${commandId[i]} - Fixed ${cutViolations} filter(s) exceeding -10dB cut limit`);
              }

              await updateFilters(i, violations);
            }
            // ADD THIS SBIR CHECK RIGHT HERE:
            await checkAndDisableSBIRFilters(i, filters);
          }

          catch (error) {
            console.debug(`${commandId[i]} - Sanity check failed:`, error);
          }

          // Apply Advanced Filters (if enabled, has a type other than null and is not subwoofer) 
          if (AdvancedFilters && AdvancedFiltersType !== "null" && commandId[i] !== "SW" && commandId[i] !== "SW1" && commandId[i] !== "SWMIX") {
            // For DIALOGadvanced, ONLY apply to center channel
            if (AdvancedFiltersType === "DIALOGadvanced") {
              if (commandId[i] === "C") {
                // Apply DIALOGadvanced filter to center channel
                const AdvanedFiltersConfig = getAdvancedFilters(AdvancedFiltersType, customFiltersConfig);
                if (AdvanedFiltersConfig) {
                  console.log(`APPLYING ${AdvanedFiltersConfig.description} to:`, commandId[i]);
                  console.info("Advanced Filter Optimization Targets:");
                  // Apply filters sequentially with delays
                  for (let j = 0; j < AdvanedFiltersConfig.filters.length; j++) {
                    await postSafe(`${baseUrl}/${i}/filters`, {
                      filters: [AdvanedFiltersConfig.filters[j]]
                    }, "Filters set");
                    await customDelay(speedDelay / 2);
                  }
                  // Log all targets
                  AdvanedFiltersConfig.targets.forEach(target => console.info(target));
                  console.log(`${AdvanedFiltersConfig.description} applied successfully to:`, commandId[i]);
                }
              }
              // If not center channel, do nothing (skip)
            } else {
              // For all other filter types, apply to all non-subwoofer channels
              const AdvanedFiltersConfig = getAdvancedFilters(AdvancedFiltersType, customFiltersConfig);
              if (AdvanedFiltersConfig) {
                console.log(`APPLYING ${AdvanedFiltersConfig.description} to:`, commandId[i]);
                console.info("Advanced Filter Optimization Targets:");
                // Apply filters sequentially with delays
                for (let j = 0; j < AdvanedFiltersConfig.filters.length; j++) {
                  await postSafe(`${baseUrl}/${i}/filters`, {
                    filters: [AdvanedFiltersConfig.filters[j]]
                  }, "Filters set");
                  await customDelay(speedDelay / 2);
                }
                // Log all targets
                AdvanedFiltersConfig.targets.forEach(target => console.info(target));
                console.log(`${AdvanedFiltersConfig.description} applied successfully to:`, commandId[i]);
              }
            }
          }

          // generate filters & auto level it
          const filter = await postNext('Generate filters measurement', i);
          const filterIdx = Object.keys(filter.results)[0];
          const filterName = `${commandId[i]}-filters`;
          await fetch_mREW(filterIdx, 'PUT', { title: filterName });
          // FIXED: Only calculate and apply auto-level offset (no tcLevelOffset)
          const ALOffset = await getALOffset(filterIdx, isSub);
          if (isDebugMode) {
            console.log(`=== AUTO-LEVEL DEBUG for ${commandId[i]} ===`);
            console.log(`Auto-level offset calculated: ${ALOffset.toFixed(2)}dB`);
            console.log(`This will be SUBTRACTED from the filter response`);
          }
          // Apply auto-level compensation to filter
          await postNext('Add SPL offset', filterIdx, { offset: -ALOffset });
          // generate predicted equalized response using the auto leveled filter
          const eqResponse = await postNext('Arithmetic', [i, filterIdx], { function: "A * B" });
          const eqResponseIdx = Object.keys(eqResponse.results)[0];
          const eqResponseName = `${commandId[i]}-equalized`;
          await fetch_mREW(eqResponseIdx, 'PUT', { title: eqResponseName });
          // Only apply auto-level offset (rounded to nearest 0.5dB)
          let logUpdate = `${commandId[i].padStart(3, ".")} - equalized`;
          const trimOffset = tcLevelOffset + Math.round(ALOffset * 2) / 2; //round to nearest 0.5
          if (trimOffset != 0) {
            // Apply offset to equalized response for consistency
            await postNext('Add SPL offset', eqResponseIdx, { offset: trimOffset });
            // Update custom levels to reflect the change
            const customLevelOriginal = customLevel[i];
            if (isSub) {
              for (let j = nSpeakers + 1; j <= nSpeakers + nSubs; j++) {
                customLevel[j] += trimOffset;
              }
            }
            else {
              customLevel[i] += trimOffset;
            }
            logUpdate += ` | auto-level offset: ${customLevelOriginal}dB → ${customLevel[i]}dB (${trimOffset}dB)`;
            if (isDebugMode) {
              console.log(`=== TRIM OFFSET DEBUG for ${commandId[i]} ===`);
              console.log(`Auto-level offset: ${ALOffset.toFixed(2)}dB`);
              console.log(`Rounded trim offset applied: ${trimOffset.toFixed(2)}dB`);
              console.log(`customLevel change: ${customLevelOriginal.toFixed(1)}dB → ${customLevel[i].toFixed(1)}dB`);
            }
          }
          console.infoUpdate(logUpdate);
        }
        // clean up EQ params
        for (let i = nChannels + 1; i <= nChannels * 3; i++) {
          await postSafe(`${baseUrl}/${i}/target-settings`, { shape: "None" }, "Update processed");
        }
      }

      async function getFilters(measurementId) {
        const response = await fetch(`http://localhost:4735/measurements/${measurementId}/filters`, {
          method: 'GET',
          headers: { 'accept': 'application/json' }
        });
        return await response.json();
      }

      function sanityCheck(filters) {
        const violations = [];
        // Filter out inactive filters (type = "None")
        const activeFilters = filters.filter(filter => filter.type !== "None");
        // Header logging
        console.log(`🔍 VALIDATING REW-GENERATED FILTERS...`);
        console.log(`├─ Found ${activeFilters.length} active filters (of ${filters.length} slots):`);
        activeFilters.forEach(filter => {
          if (filter.hasOwnProperty('gaindB')) {
            // Build detailed filter description
            let filterDesc = `Filter ${filter.index}: ${filter.type}`;

            if (filter.frequency) {
              filterDesc += ` at ${filter.frequency.toFixed(2)}Hz`;
            }
            filterDesc += `, Gain: ${filter.gaindB.toFixed(1)}dB`;
            if (filter.q && filter.type === "PK") {
              filterDesc += `, Q: ${filter.q.toFixed(1)}`;
            }
            // Log the detailed filter info
            console.info(`├─ ${filterDesc}`);
            let violation = null;
            const originalGain = filter.gaindB;
            if (filter.gaindB > 3) {
              violation = 'BOOST';
              filter.gaindB = 3;
            } else if (filter.gaindB < -10) {
              violation = 'CUT';
              filter.gaindB = -10;
            }
            if (violation) {
              // REW API constraint: HS filters cannot be set to auto
              if (filter.type === "HS") {
                filter.isAuto = false;
              }
              console.warn(`*** ${violation} VIOLATION FOUND: Filter ${filter.index} corrected to ${filter.gaindB}dB`);
              violations.push({
                index: filter.index,
                currentGain: originalGain,
                filter: filter
              });
            }
          }
        });
        console.log(`└─ Total violations found: ${violations.length}`);
        return violations.length > 0 ? violations : null;
      }

      async function updateFilters(measurementId, violations) {
        // Update only the filters that had violations
        for (const violation of violations) {
          const response = await fetch(`http://localhost:4735/measurements/${measurementId}/filters`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'accept': 'application/json'
            },
            body: JSON.stringify(violation.filter)  // Send single filter object directly
          });
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`PUT failed: ${response.status} - ${errorText}`);
          }
          const result = await response.json();
          console.log(`Filter ${violation.filter.index} updated:`, result.message);
        }
      }

      // Main SBIR detection
      async function detectSBIRFromMeasurements() {
        console.log("Analyzing for Speaker Boundary Interference Response (SBIR)...");
        const c = sOs;
        const sbirPatterns = [];
        for (let i = 1; i <= nSpeakers; i++) {
          const title = commandId[i];
          console.info(`Analyzing ${title} for SBIR patterns...`);
          const response = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', i);
          const nulls = await findNulls(response, i);
          if (nulls.length >= 2) {
            const sbirInfo = analyzeSBIRPattern(nulls, c);
            if (sbirInfo.isSBIR) {
              sbirPatterns.push({
                speaker: title,
                speakerIndex: i,
                estimatedBoundaryDistance: sbirInfo.distance,
                nullFrequencies: sbirInfo.frequencies,
                severity: sbirInfo.severity
              });

              console.warn(`${title}: SBIR detected! Boundary at ~${sbirInfo.distance.toFixed(2)}m`);
              console.warn(`  Nulls at: ${sbirInfo.frequencies.map(f => f.toFixed(0) + 'Hz').join(', ')}`);
              console.warn(`  Severity: ${sbirInfo.severity.toUpperCase()}`);
            }
          }
        }
        window.detectedSBIR = sbirPatterns;
        return sbirPatterns;
      }

      // Find nulls helper
      async function findNulls(response, measurementIdx, threshold = -6) {
        const fullResponse = response2array(response, 20, 500);
        const nulls = [];
        let freq = 20;
        const octave = Math.pow(2, 1 / 96);
        const avgLevel = fullResponse.reduce((sum, val) => sum + val, 0) / fullResponse.length;
        for (let i = 1; i < fullResponse.length - 1; i++) {
          freq *= octave;
          if (fullResponse[i] < fullResponse[i - 1] &&
            fullResponse[i] < fullResponse[i + 1] &&
            fullResponse[i] < avgLevel + threshold) {
            const depth = avgLevel - fullResponse[i];
            const q = (freq / 10); // Simplified Q calculation
            nulls.push({
              frequency: freq,
              depth: depth,
              q: q
            });
          }
        }
        return nulls.sort((a, b) => a.frequency - b.frequency);
      }

      // Analyze SBIR pattern
      function analyzeSBIRPattern(nulls, speedOfSound) {
        if (nulls.length < 2) return { isSBIR: false };
        const firstNull = nulls[0].frequency;
        const expectedDistance = speedOfSound / (4 * firstNull);
        let matchCount = 0;
        const detectedFrequencies = [firstNull];
        for (let n = 2; n <= 4; n++) {
          const expectedFreq = firstNull * (2 * n - 1);
          const tolerance = expectedFreq * 0.15;
          const foundNull = nulls.find(nullPoint =>
            Math.abs(nullPoint.frequency - expectedFreq) < tolerance
          );
          if (foundNull) {
            matchCount++;
            detectedFrequencies.push(foundNull.frequency);
          }
        }
        const isSBIR = matchCount >= 1;
        let severity = 'low';
        if (nulls[0].depth > 10 && nulls[0].q > 3) {
          severity = 'severe';
        } else if (nulls[0].depth > 6) {
          severity = 'moderate';
        }
        return {
          isSBIR: isSBIR,
          distance: expectedDistance,
          frequencies: detectedFrequencies,
          severity: severity
        };
      }

      // Display SBIR results
      function displaySBIRResults() {
        if (!window.detectedSBIR || window.detectedSBIR.length === 0) return;
        console.log("");
        console.log("🔊 SBIR (BOUNDARY INTERFERENCE) ANALYSIS:");
        console.log("═".repeat(50));
        for (const sbir of window.detectedSBIR) {
          // console.warn(`\n${sbir.speaker}:`);
          console.warn(`${sbir.speaker}:`);
          console.log(`├─ Estimated boundary distance: ${sbir.estimatedBoundaryDistance.toFixed(2)}m`);
          console.log(`├─ Severity: ${sbir.severity.toUpperCase()}`);
          console.log(`└─ Null frequencies: ${sbir.nullFrequencies.map(f => f.toFixed(0) + 'Hz').join(', ')}`);
          if (sbir.estimatedBoundaryDistance < 0.6) {
            console.log(`└─ ⚠️ RECOMMENDATION: Move speaker at least ${(0.6 - sbir.estimatedBoundaryDistance).toFixed(1)}m away from wall`);
            console.log(`--`);
          } else if (sbir.severity === 'severe') {
            console.log(`   X Severe SBIR detected - EQ cannot fix this, repositioning required!`);
            console.log(`--`);
          } else {
            console.log(`--`);
          }
        }
      }

      async function checkAndDisableSBIRFilters(speakerIdx, filters) {
        if (!window.detectedSBIR) return;
        const speakerSBIR = window.detectedSBIR.find(s => s.speakerIndex === speakerIdx);
        if (!speakerSBIR) return;
        let modified = false;
        // Only check active filters
        filters.forEach(filter => {
          // Skip inactive filter slots
          if (filter.type === "None") return;
          for (const nullFreq of speakerSBIR.nullFrequencies) {
            const ratio = filter.frequency / nullFreq;
            // If filter is within 10% of SBIR null frequency
            if (ratio > 0.9 && ratio < 1.1) {
              if (speakerSBIR.severity === 'severe' && filter.gaindB > 0) {
                filter.enabled = false;
                console.warn(`    SBIR: Disabled boost at ${filter.frequency.toFixed(0)}Hz (severe null at ${nullFreq.toFixed(0)}Hz)`);
                modified = true;
              } else if (speakerSBIR.severity === 'moderate' && filter.gaindB > 2) {
                filter.gaindB = 2;
                console.warn(`    SBIR: Limited boost at ${filter.frequency.toFixed(0)}Hz to 2dB (moderate null at ${nullFreq.toFixed(0)}Hz)`);
                modified = true;
              }
            }
          }
        });

        if (modified) {
          await postSafe(`${baseUrl}/${speakerIdx}/filters`, { filters }, "Filters set");
        }
      }
      /* ============== */
      /* SBIR DETECTION */
      // ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
      // PROPRIETARY FILTER GENERATION AND CHECKING ! 
      // CAN NOT BE USED WITHOUT EXPLICIT PERMISSION OF NVEXX !
      // ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

      function finalizeTrims() {
        if (isDebugMode) {
          console.log("=== FINAL TRIMS DEBUG ===");
          console.log("Raw customLevel values BEFORE sanity check:");
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            console.log(`  ${commandId[i]}: ${customLevel[i].toFixed(1)}dB`);
          }
        }
        // console.log("DEBUG!!!! Raw customLevel values before sanity check:", customLevel.slice(1, nSpeakers + nSubs + 1));
        // console.log("These look like absolute SPL measurements (sound pressure level readings), not relative trim adjustments!")
        sanityCheckSpeakerTrims();
        console.log("Final speaker" + (noSub ? "" : " & subwoofer") + " trims:")
        for (let i = 1; i <= nSpeakers; i++) {
          const customLevelOriginal = customLevel[i];
          customLevel[i] = Math.max(-12, customLevel[i]);
          customLevel[i] = Math.min(customLevel[i], 12);
          if (customLevelOriginal != customLevel[i]) {
            console.warn(`${commandId[i].padStart(3, ".")} required volume adjustment beyond hardware limits - shifted: ${customLevelOriginal}dB → ${customLevel[i]}dB`);
          }
          else {
            console.info(`${commandId[i].padStart(3, ".")} - applied adjustment: ${customLevel[i]}dB`);
          }
        }
        if (noSub) { return; } // no need to go further without subwoofer
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          const customLevelOriginal = customLevel[i];
          customLevel[i] = Math.max(subLoTrim, customLevel[i]);
          customLevel[i] = Math.min(customLevel[i], subHiTrim);
          if (customLevelOriginal != customLevel[i]) {
            console.warn(`${commandId[i].padStart(3, ".")} required volume adjustment beyond hardware limits - shifted: ${customLevelOriginal}dB → ${customLevel[i]}dB`);
          }
          else {
            console.info(`${commandId[i].padStart(3, ".")} - applied adjustment: ${customLevel[i]}dB`);
          }
        }
      }

      function sanityCheckSpeakerTrims() {
        // if a speaker is too sensitive or not sensitive enough, it may end up outside +/-12dB
        const minSpeakerTrim = Math.min(...customLevel.slice(1, nSpeakers + 1));
        const maxSpeakerTrim = Math.max(...customLevel.slice(1, nSpeakers + 1));
        let offset = 0;
        if (minSpeakerTrim < -12 && maxSpeakerTrim < 12) {
          const requiredOffset = -12 - minSpeakerTrim;
          offset = Math.min(requiredOffset, 12 - maxSpeakerTrim); // limited by maxSpeakerTrim
        }
        else if (maxSpeakerTrim > 12 && minSpeakerTrim > -12) {
          const requiredOffset = 12 - maxSpeakerTrim;
          offset = Math.max(requiredOffset, -12 - minSpeakerTrim); // limited by minSpeakerTrim
        }
        if (offset != 0) {
          console.warn(`Trims are being shifted by ${offset}dB to best stay within hardware limits!`)
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += offset;
          }
        }
      }

      function isSingleChannel(channelCmdId) {
        if (channelCmdId.endsWith("L") && commandId.includes(channelCmdId.slice(0, -1) + "R")) { return false; } // L and R
        if (channelCmdId.endsWith("R") && commandId.includes(channelCmdId.slice(0, -1) + "L")) { return false; } // R and L
        if (channelCmdId.includes("L") && commandId.includes(channelCmdId.replace("L", "R"))) { return false; } // edge case for SLA/SRA type cmdIds
        if (channelCmdId.includes("R") && commandId.includes(channelCmdId.replace("R", "L"))) { return false; } // where L/R is in the middle
        return true;
      }

      function findNearestXO(freq) {
        let xo = Infinity;
        let minDelta = Infinity;
        for (let i = 0; i < freqIndex.length; i++) {
          const delta = Math.abs(freqIndex[i] - freq);
          if (delta < minDelta) {
            minDelta = delta;
            xo = freqIndex[i];
          }
        }
        return xo;
      }

      // CURVE LOW!!
      async function getLow3dBPoint(idx, start = 10, end = 320) {
        const mode = getCurrentMode();
        const smoothing = MODE_CONFIG[mode].smoothing;
        const response = await fetchSafe(`frequency-response?smoothing=${smoothing}&ppo=96`, idx);
        console.info(`getLow3dBPoint: applying ${mode} - ${smoothing} smoothing`);
        const rpArray = response2array(response, start, end);
        const tcArray = response2array(targetResponse, start, end);
        const arrLength = Math.min(rpArray.length, tcArray.length);
        const octave = Math.pow(2, 1 / 96);
        // find -3dB point
        let rolloff = start;
        for (let i = 0; i < arrLength; i++) {
          if ((rpArray[i] - tcArray[i]) >= -3) { break; }
          rolloff *= octave;
        }
        if (isDebugMode) {
          // ADD THIS ABSOLUTE LEVEL CHECK HERE ↓
          console.log("=== ABSOLUTE LEVEL CHECK ===");
          // Find speaker's actual peak level in measurement range
          let maxLevel = -Infinity;
          let maxLevelFreq = start;
          for (let i = 0; i < rpArray.length; i++) {
            if (rpArray[i] > maxLevel) {
              maxLevel = rpArray[i];
              maxLevelFreq = start * Math.pow(octave, i);
            }
          }
          // Find true -3dB rolloff from speaker's own maximum
          let absoluteRolloff = start;
          for (let i = 0; i < rpArray.length; i++) {
            // True -3dB from speaker's own maximum, not target-relative
            if ((rpArray[i] - maxLevel) >= -3) { break; }
            absoluteRolloff *= octave;
          }
          console.log(`Speaker peak: ${maxLevel.toFixed(1)}dB at ${maxLevelFreq.toFixed(1)}Hz`);
          console.log(`Target-relative rolloff: ${rolloff.toFixed(1)}Hz`);
          console.log(`Absolute -3dB rolloff: ${absoluteRolloff.toFixed(1)}Hz`);
          // Audioholics reality check
          if (rolloff < 40) {
            console.warn(`⚠️  ${rolloff.toFixed(1)}Hz rolloff detected - likely room gain effect`);
            console.warn("   Audioholics recommends ground plane measurements for true speaker response");
          }
          if (Math.abs(rolloff - absoluteRolloff) > 20) {
            console.warn(`⚠️  Large difference between target-relative (${rolloff.toFixed(1)}Hz) and absolute (${absoluteRolloff.toFixed(1)}Hz) rolloffs`);
            console.warn("   This suggests target curve issues or room acoustics effects");
          }
          console.log("=== END ABSOLUTE LEVEL CHECK ===");
          // END ADDITION ↑
        }
        return Math.min(rolloff, end);
      }

      // CURVE HIGH!!
      async function getHigh3dBPoint(idx, start = 10, end = 320) {
        const mode = getCurrentMode();
        const smoothing = MODE_CONFIG[mode].smoothing;
        const response = await fetchSafe(`frequency-response?smoothing=${smoothing}&ppo=96`, idx);
        console.info(`getHigh3dBPoint: applying ${mode} - ${smoothing} smoothing`);
        const rpArray = response2array(response, start, end);
        const tcArray = response2array(targetResponse, start, end);
        const arrLength = Math.min(rpArray.length, tcArray.length);
        const octave = Math.pow(2, 1 / 96);
        // find -3dB point
        let rolloff = end;
        for (let i = arrLength - 1; i >= 0; i--) {
          if ((rpArray[i] - tcArray[i]) >= -3) { break; }
          rolloff /= octave;
        }
        if (isDebugMode) {
          // ADD THIS ABSOLUTE LEVEL CHECK HERE ↓
          console.log("=== ABSOLUTE LEVEL CHECK ===");
          // Find speaker's actual peak level in measurement range
          let maxLevel = -Infinity;
          let maxLevelFreq = start;
          for (let i = 0; i < rpArray.length; i++) {
            if (rpArray[i] > maxLevel) {
              maxLevel = rpArray[i];
              maxLevelFreq = start * Math.pow(octave, i);
            }
          }
          // Find true -3dB rolloff from speaker's own maximum
          let absoluteRolloff = start;
          for (let i = 0; i < rpArray.length; i++) {
            // True -3dB from speaker's own maximum, not target-relative
            if ((rpArray[i] - maxLevel) >= -3) { break; }
            absoluteRolloff *= octave;
          }
          console.log(`Speaker peak: ${maxLevel.toFixed(1)}dB at ${maxLevelFreq.toFixed(1)}Hz`);
          console.log(`Target-relative rolloff: ${rolloff.toFixed(1)}Hz`);
          console.log(`Absolute -3dB rolloff: ${absoluteRolloff.toFixed(1)}Hz`);
          // Audioholics reality check
          if (rolloff < 40) {
            console.warn(`⚠️  ${rolloff.toFixed(1)}Hz rolloff detected - likely room gain effect`);
            console.warn("   Audioholics recommends ground plane measurements for true speaker response");
          }
          if (Math.abs(rolloff - absoluteRolloff) > 20) {
            console.warn(`⚠️  Large difference between target-relative (${rolloff.toFixed(1)}Hz) and absolute (${absoluteRolloff.toFixed(1)}Hz) rolloffs`);
            console.warn("   This suggests target curve issues or room acoustics effects");
          }
          console.log("=== END ABSOLUTE LEVEL CHECK ===");
          // END ADDITION ↑
        }
        return Math.max(rolloff, start);
      }

      // let modeSubXOMin = 31.5; let modeSubXOMax = 120;
      async function getAbsLow3dBPointForSub(idx, start = 10, end = 300) {
        const response = await fetchSafe('frequency-response?smoothing=1/48&ppo=96', idx);
        const rpArray = response2array(response, start, end);
        const subArray = response2array(response, modeSubXOMin - 10, modeSubXOMax + 10);
        const subSPL = subArray.reduce((acc, val) => acc + val, 0) / subArray.length;
        const octave = Math.pow(2, 1 / 96);
        let rolloff = start;
        for (let i = 0; i < rpArray.length; i++) {
          if ((rpArray[i] - subSPL) >= -3) { break; }
          rolloff *= octave;
        }
        return Math.min(rolloff, end);
      }

      // let modeSubXOMin = 31.5; let modeSubXOMax = 120;
      async function getAbsHigh3dBPointForSub(idx, start = 10, end = 300) {
        const response = await fetchSafe('frequency-response?smoothing=1/48&ppo=96', idx);
        const rpArray = response2array(response, start, end);
        const subArray = response2array(response, modeSubXOMin - 10, modeSubXOMax + 10);
        const subSPL = subArray.reduce((acc, val) => acc + val, 0) / subArray.length;
        const octave = Math.pow(2, 1 / 96);
        let rolloff = end;
        for (let i = rpArray.length - 1; i >= 0; i--) {
          if ((rpArray[i] - subSPL) >= -3) { break; }
          rolloff /= octave;
        }
        return Math.max(rolloff, start);
      }

      /*
      // let modeSpkMin = 20; let modeSpkMax = 20000;
      async function getAbsLow3dBPointForSpk(idx, start = modeSpkMin, end = modeSpkMax) {
        // finds high -3dB point from mean SPL in speaker's optimal midrange >> Use midrange reference band for speakers (not bass range like subs)  
        const response = await fetchSafe('frequency-response?smoothing=1/48&ppo=96', idx);
        const rpArray = response2array(response, start, end);
        const refArray = response2array(response, 500, 2000);  // Speaker midrange reference
        const refSPL = refArray.reduce((acc, val) => acc + val, 0) / refArray.length;
        const octave = Math.pow(2, 1 / 96);
        let rolloff = start;
        for (let i = 0; i < rpArray.length; i++) {
          if ((rpArray[i] - refSPL) >= -3) { break; }
          rolloff *= octave;
        }
        return Math.min(rolloff, end);
      }
      */
      // let modeSpkMin = 20; let modeSpkMax = 20000;
      async function getAbsLow3dBPointForSpk(idx, start = modeSpkMin, end = modeSpkMax, forNART = false) {
        const response = await fetchSafe('frequency-response?smoothing=1/48&ppo=96', idx);
        const rpArray = response2array(response, start, end);
        const refArray = response2array(response, 500, 2000);
        const refSPL = refArray.reduce((acc, val) => acc + val, 0) / refArray.length;
        const octave = Math.pow(2, 1 / 96);
        let rolloff = start;
        // ✓ For NART, allow -10dB (speakers can still help with modal cancellation)
        // For normal use, keep -3dB (speaker should be at full capability)
        const threshold = forNART ? -10 : -3;
        for (let i = 0; i < rpArray.length; i++) {
          if ((rpArray[i] - refSPL) >= threshold) { break; }
          rolloff *= octave;
        }
        return Math.min(rolloff, end);
      }

      // let modeSpkMin = 20; let modeSpkMax = 20000;
      async function getAbsHigh3dBPointForSpk(idx, start = modeSpkMin, end = modeSpkMax) {
        // finds high -3dB point from mean SPL in speaker's optimal midrange >> Use midrange reference band for speakers (not bass range like subs)  
        const response = await fetchSafe('frequency-response?smoothing=1/48&ppo=96', idx);
        const rpArray = response2array(response, start, end);
        const refArray = response2array(response, 500, 2000);  // Speaker midrange reference
        const refSPL = refArray.reduce((acc, val) => acc + val, 0) / refArray.length;
        const octave = Math.pow(2, 1 / 96);
        let rolloff = end;
        for (let i = rpArray.length - 1; i >= 0; i--) {
          if ((rpArray[i] - refSPL) >= -3) { break; }
          rolloff /= octave;
        }
        return Math.max(rolloff, start);
      }

      // get high frequency rolloff
      async function getSpeakerHFRolloff(idx, start = 10000, end = 20000) {
        // goal of this function is to find the roll-off past 10k before any HF peaks that can mess with the high shelf
        const response = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', idx);
        const rpArray = response2array(response, start, end);
        const tcArray = response2array(targetResponse, start, end);
        const arrLength = Math.min(rpArray.length, tcArray.length);
        const octave = Math.pow(2, 1 / 96);
        let checkFreq = start;
        let rolloff = checkFreq;
        let lowestSPL = rpArray[0];
        for (let i = 0; i < arrLength; i++) {
          if (rpArray[i] < lowestSPL) {
            lowestSPL = rpArray[i];
            rolloff = checkFreq;
          }
          // if HF peak exceeds lowest point by 3dB, set roll-off before that peak
          // also if HF drops below target by 3dB, stop there otherwise high shelf will fail
          if ((rpArray[i] - lowestSPL >= 3) || (rpArray[i] - tcArray[i] <= -3)) {
            break;
          }
          checkFreq *= octave;
        }
        return Math.min(rolloff, end);
      }

      async function calculateRolloffs() {
        console.log("Calculating speaker -3dB points from target curve...");
        if (isDebugMode) {
          // ADD THIS DEBUG CODE HERE ↓
          console.log("=== TARGET CURVE DEBUG ===");
          console.log("Target curve in bass region:");
          const debugTcArray = response2array(targetResponse, 20, 120);
          for (let i = 0; i < debugTcArray.length; i += 8) { // Every 8th point to avoid spam
            const freq = 20 * Math.pow(2, i / 96);
            if (freq <= 100) {
              console.log(`${freq.toFixed(1)}Hz: ${debugTcArray[i].toFixed(1)}dB`);
            }
          }
          console.log("=== END TARGET CURVE DEBUG ===");
          // END DEBUG CODE ↑
        }
        const measurements = await fetch_mREW();
        for (let i = 1; i <= nSpeakers; i++) {
          const title = measurements[i].title;
          // check if single channel or speaker pair
          const singleChannel = isSingleChannel(commandId[i]);
          const cmdIds = (singleChannel ? commandId[i] : `${commandId[i]} & ${commandId[i + 1]}`).padStart(9, ".");
          // rolloff determination logic
          let idx = i;
          if (!singleChannel) {
            const pairAvg = await postNext('Magn plus phase average', [i, i + 1]); // do not use VA. it unfairly benefits single channel speakers
            idx = Object.keys(pairAvg.results)[0];
          }
          const rolloff = await getLow3dBPoint(idx);
          // const rolloffHF = await getSpeakerHFRolloff(i); // speaker specific, not pair specific
          let initialXO = findNearestXO(rolloff);
          // edge case for no subwoofer
          if (noSub && cmdIds.endsWith("FL & FR")) {
            initialXO = "L";
          }
          customCrossover[i] = initialXO;
          // used for EQ limits
          const mode = getCurrentMode();
          const config = MODE_CONFIG[mode];
          const rolloffLF = await getLow3dBPoint(i);
          const rolloffHF = await getSpeakerHFRolloff(i);
          if (mode === 'DEFAULT') {
            m3dBPoints[i] = [Math.round(rolloffLF), Math.round(rolloffHF)];
            console.info(`calculateRolloffs: applying Default - ${Math.round(rolloffHF)} rolloff`);
          } else {
            m3dBPoints[i] = [Math.round(rolloffLF), config.rolloffHF];
            console.info(`calculateRolloffs: applying ${mode} - ${config.rolloffHF} rolloff`);
          }
          if (!singleChannel) {
            customCrossover[i + 1] = initialXO;
            await postDelete(idx); // cleanup
            const rolloffLFR = await getLow3dBPoint(i + 1);
            const rolloffHFR = await getSpeakerHFRolloff(i + 1);
            if (mode === 'DEFAULT') {
              m3dBPoints[i + 1] = [Math.round(rolloffLFR), Math.round(rolloffHFR)];
              console.info(`calculateRolloffs: applying Default - ${Math.round(rolloffHFR)} rolloff`);
            } else {
              m3dBPoints[i + 1] = [Math.round(rolloffLFR), config.rolloffHF];
              console.info(`calculateRolloffs: applying ${mode} - ${config.rolloffHF} rolloff`);
            }
            i++;
          }
          const logMessage = initialXO === "L" ? "Large/Full Range" : `Initial XO: ${initialXO}hz`;
          console.info(`${cmdIds} - roll-off: ${rolloff.toFixed(2)}Hz → ${logMessage}`);
        }
      }

      async function calculateSubBandwidth() {
        if (noSub) { return; } // no need to go further without subwoofer
        // Create temporary freqIndex with 20Hz added for subwoofer calculations
        // const tempFreqIndex = [...freqIndex, 20].sort((a, b) => a - b);
        // DROP 200 and 250, add 20Hz for subwoofer
        const tempFreqIndex = [...freqIndex.filter(freq => freq !== 200 && freq !== 250), 20].sort((a, b) => a - b);
        // Create local function that uses tempFreqIndex
        const findNearestXOWithSub = (freq) => {
          let xo = Infinity;
          let minDelta = Infinity;
          for (let i = 0; i < tempFreqIndex.length; i++) {
            const delta = Math.abs(tempFreqIndex[i] - freq);
            if (delta < minDelta) {
              minDelta = delta;
              xo = tempFreqIndex[i];
            }
          }
          return xo;
        };
        console.log("Calculating subwoofer -3dB points from target curve...")
        // find low freq -3dB point & set minXO
        const subLowFreq = await getLow3dBPoint(nChannels);
        minXO = findNearestXOWithSub(2 * subLowFreq);
        // find high freq -3dB point and set maxXO
        const subHighFreq = await getHigh3dBPoint(nChannels);
        maxXO = findNearestXOWithSub(subHighFreq);
        if (minXO >= maxXO) {
          minXO = maxXO;
          console.warn(`Subwoofer has very little bandwidth and can only support ${minXO}hz crossover!`);
        }
        m3dBPoints[nChannels] = [Math.round(subLowFreq), Math.round(subHighFreq)];
        Object.freeze(minXO);
        Object.freeze(maxXO);
        console.log(`${commandId[nChannels].padStart(3, ".")} bandwidth: ${subLowFreq.toFixed(2)}hz - ${subHighFreq.toFixed(2)}hz → Usable XO range: ${minXO}hz - ${maxXO}hz`);
        RP22subnminXO = subLowFreq.toFixed(2);
        RP22submaxXO = subHighFreq.toFixed(2);
        sanityCheckInitialXO(); // update initialXOs based on subwoofer bandwidth
      }

      function sanityCheckInitialXO() {
        if (noSub) { return; } // no need to go further without subwoofer
        for (let i = 1; i <= nSpeakers; i++) {
          const singleChannel = isSingleChannel(commandId[i]);
          const cmdIds = (singleChannel ? commandId[i] : `${commandId[i]} & ${commandId[1 + i]}`).padStart(9, ".");
          const initialXO = customCrossover[i];
          customCrossover[i] = Math.max(minXO, customCrossover[i]);
          if (!singleChannel) {
            customCrossover[i + 1] = customCrossover[i];
            i++;
          }
          if (initialXO != customCrossover[i]) {
            console.warn(`${cmdIds} initial XO below usable XO range - shifted: ${initialXO}hz → ${customCrossover[i]}hz`);
          }
        }
      }

      async function optimizeSubDelay() {
        if (noSub) { return; } // no need to go further without subwoofer
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        let eqResults = [], initialXOs = 0, avgInitialXO = 80;
        let count = 1;
        for (let i = nChannels + 2; i <= nChannels * 3; i += 2) {
          const title = measurements[i].title;
          if (!title.endsWith("-equalized")) { continue; }
          if (commandId[count].startsWith("SW")) { continue; }
          eqResults.push(i);
          initialXOs += parseFloat(customCrossover[count++]);
        }
        if (initialXOs > 0) { avgInitialXO = initialXOs / eqResults.length; }
        Object.freeze(avgInitialXO);
        console.log(`Calculating optimal subwoofer delay for ALL speakers using average initial XO ${avgInitialXO.toFixed(2)}hz...`);
        const avgSpeaker = await postNext('Magn plus phase average', Array.from(eqResults)); // same results with RMS & VA since goal is max output
        const avgSpeakerIdx = Object.keys(avgSpeaker.results)[0]
        const avgSpeakerWithHPF = await genSpeaker(avgSpeakerIdx, avgInitialXO);
        const avgSpeakerWithHPFIdx = Object.keys(avgSpeakerWithHPF.results)[0];
        const subwooferWithLPF = await genSub(mCount, avgInitialXO);
        const subwooferWithLPFIdx = Object.keys(subwooferWithLPF.results)[0];
        // let [isPossible, requiredDelay, isInverted] = await align4system(avgSpeakerWithHPFIdx, subwooferWithLPFIdx, avgInitialXO);
        let [isPossible, requiredDelay, isInverted] = await align4system(avgSpeakerWithHPFIdx, subwooferWithLPFIdx);
        // cleanup
        await postDelete(subwooferWithLPFIdx);
        await postDelete(avgSpeakerWithHPFIdx);
        await postDelete(avgSpeakerIdx);
        // apply optimal delay
        let subMoves = 0;
        if (isPossible) {
          subMoves = requiredDelay;
        } else {
          console.warn(`Required delay for alignment is too large! Subwoofer(s) set to max possible distance but results will not be optimal.`);
          const [loDelay,] = getDelayRangeOfFinalSub();
          subMoves = loDelay;
          isInverted = false;
        }
        if (isInverted) { await postSafe(`${baseUrl}/${nChannels * 3}/command`, { command: "Invert" }, "Invert completed"); }
        subMoves /= delaymax;
        await postNext('Offset t=0', nChannels * 3, { offset: -subMoves, unit: "seconds" });
        if (bassMode === "Directional") {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            mSec[i] += subMoves;
            invertSub[i] = isInverted ? !invertSub[i] : invertSub[i];
          }
        } else {
          mSec[nChannels] += subMoves;
          invertSub[nChannels] = isInverted;
        }
      }

      function getFLIndex() {
        let flIndex = 1;
        for (let i = 1; i <= nChannels; i++) {
          if (commandId[i].startsWith("FL")) {
            flIndex = i;
            break;
          }
        }
        return flIndex;
      }

      function initializeDistances() {
        // initialize to 0
        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          customDistance[i] = 0;
        }
        if (noSub) { return; }
        const flIndex = getFLIndex();
        let distMinSub = Infinity;
        let distMaxSub = -Infinity;
        // check if any directional subwoofer needs negative distance
        if (bassMode === "Directional") {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            const distSub = flDist + (mSec[flIndex] - mSec[i]) * sOs;
            distMinSub = Math.min(distMinSub, distSub);
            distMaxSub = Math.max(distMaxSub, distSub);
          }
        }
        // check if any SWMIX subwoofer needs negative distance
        else {
          const distMainSub = flDist + (mSec[flIndex] - mSec[nChannels]) * sOs;
          const distLoSub = distMainSub - subLoDelay * sOs;
          const distHiSub = distMainSub - subHiDelay * sOs;
          distMinSub = Math.min(distLoSub, distHiSub);
          distMaxSub = Math.max(distLoSub, distHiSub);
        }
        if (distMinSub < 0) {
          const distShift = 0 - distMinSub;
          console.warn(`Distances are being shifted by ${distShift.toFixed(2)}m to accommodate the required subwoofer delay!`);
          console.info("This adjustment will ONLY improve overall sound quality.");
          console.info("The receiver only accounts for relative time delays between speakers which are being kept intact.");
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            customDistance[i] += distShift;
          }
        }
        if (distMaxSub > 18) {
          const distShift = 18 - distMaxSub;
          console.warn(`Distances are being shifted by ${distShift.toFixed(2)}m to accommodate the required subwoofer delay!`);
          console.info("This adjustment will ONLY improve overall sound quality.");
          console.info("The receiver only accounts for relative time delays between speakers which are being kept intact.");
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            customDistance[i] += distShift;
          }
        }
      }

      function finalizeDistances() {
        initializeDistances();
        const flIndex = getFLIndex();
        // Clear the estimatedDistances array before populating
        estimatedDistances = [];
        console.log("Final speaker" + (noSub ? "" : " & subwoofer") + " distances:");
        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          customDistance[i] += flDist + (mSec[flIndex] - mSec[i]) * sOs;
          customDistance[i] = Math.round(parseFloat(customDistance[i]) * 100) / 100;
          // Store the distance in the estimatedDistances array
          estimatedDistances.push([commandId[i], customDistance[i].toFixed(2)]);
          if (i > nSpeakers) {
            console.warn(`${commandId[i].padStart(3, ".")} - distance: ${customDistance[i].toFixed(2)}m, ${invertSub[i] ? "please SWITCH this subwoofer's POLARITY!!!" : "keep this subwoofer's polarity 'as is'."}`);
            swInvMsg += invertSub[i] ? `inv${commandId[i]}_` : "";
          } else {
            console.info(`${commandId[i].padStart(3, ".")} - distance: ${customDistance[i].toFixed(2)}m`);
          }
        }
        if (swChannelCount > 1 && invertSub.every(isInv => isInv === true)) {
          console.warn(`You will need to switch polarity of EACH of your ${swChannelCount} subwoofers!`);
        }
      }

      async function finalizeXO(start = 20, end = 250) {
        if (noSub) { return; } // no need to go further without subwoofer
        // Helper function to generate frequency array for RMS calculation
        function generateFrequencyArray(startFreq, endFreq, length) {
          const freqArray = [];
          let iFreq = startFreq;
          const step = Math.pow(endFreq / startFreq, 1 / (length - 1));
          for (let k = 0; k < length; k++) {
            freqArray.push(iFreq);
            iFreq *= step;
          }
          return freqArray;
        }
        // Helper function to extract phase data from REW response
        function response2arrayPhase(response, start, end) {
          if (!response.phase) {
            return null;
          }
          const bytes = Uint8Array.from(atob(response.phase), (c) => c.charCodeAt(0));
          const buffer = bytes.buffer;
          const data = new DataView(buffer);
          const phaseArray = [];
          const maxIndex = Math.floor(data.byteLength / 4) - 1;
          const startIndex = Math.round((start - 0.3662109375) / 0.3662109375);
          const endIndex = Math.min(Math.round((end - 0.3662109375) / 0.3662109375), maxIndex);
          for (let i = startIndex; i <= endIndex; i++) {
            if (i * 4 + 3 < data.byteLength) {
              phaseArray.push(data.getFloat32(i * 4));
            }
          }
          // Additional unwrapping in case REW unwrap didn't catch everything
          for (let i = 1; i < phaseArray.length; i++) {
            let diff = phaseArray[i] - phaseArray[i - 1];
            while (diff > 180) {
              phaseArray[i] -= 360;
              diff = phaseArray[i] - phaseArray[i - 1];
            }
            while (diff < -180) {
              phaseArray[i] += 360;
              diff = phaseArray[i] - phaseArray[i - 1];
            }
          }
          return phaseArray;
        }
        // Add this function before calculateExpectedCrossoverPhase
        function estimatePhaseSlope(frequencyArray, phaseArray, crossoverFreq) {
          const low = crossoverFreq / 2;
          const high = crossoverFreq * 2;
          const points = frequencyArray
            .map((f, i) => ({ f, phase: phaseArray[i] }))
            .filter(p => p.f >= low && p.f <= high);
          console.info(`├─ Slope estimation for ${crossoverFreq}Hz: using ${points.length} points from ${low}Hz to ${high}Hz`);
          if (points.length < 2) return null;
          const x = points.map(p => Math.log2(p.f));
          const y = points.map(p => p.phase);
          const n = x.length;
          const meanX = x.reduce((a, b) => a + b, 0) / n;
          const meanY = y.reduce((a, b) => a + b, 0) / n;
          let num = 0, den = 0;
          for (let i = 0; i < n; i++) {
            num += (x[i] - meanX) * (y[i] - meanY);
            den += (x[i] - meanX) ** 2;
          }
          const slope = den === 0 ? null : num / den;
          console.info(`├─ Calculated slope: ${slope?.toFixed(1)}°/octave`);
          return slope;
        }

        function calculateExpectedCrossoverPhase(frequencyArray, crossoverFreq, actualPhaseArray = null) {
          if (actualPhaseArray) {
            const slope = estimatePhaseSlope(frequencyArray, actualPhaseArray, crossoverFreq) ?? -90;
            // Find the closest frequency to the crossover frequency (keep existing logic)
            let closestIndex = 0;
            let minDiff = Math.abs(frequencyArray[0] - crossoverFreq);
            for (let i = 1; i < frequencyArray.length; i++) {
              const diff = Math.abs(frequencyArray[i] - crossoverFreq);
              if (diff < minDiff) {
                minDiff = diff;
                closestIndex = i;
              }
            }
            const xoIndex = closestIndex;
            const xoPhase = actualPhaseArray[xoIndex];
            console.info(`├─ Phase target calc: slope=${slope.toFixed(1)}°/oct, anchor freq=${frequencyArray[xoIndex].toFixed(1)}Hz, anchor phase=${xoPhase.toFixed(1)}°`);
            return frequencyArray.map(freq => {
              const octaves = Math.log2(freq / crossoverFreq);
              return xoPhase + slope * octaves; // Return unwrapped values for calculations
            });
          }

          // Fallback
          return frequencyArray.map(freq => {
            if (freq < crossoverFreq) {
              const phaseRad = -2 * Math.atan(freq / crossoverFreq);
              return phaseRad * (180 / Math.PI);
            } else {
              const phaseRad = -Math.PI / 2 - 2 * Math.atan(crossoverFreq / freq);
              return phaseRad * (180 / Math.PI);
            }
          });
        }

        // Speaker type mappings
        const speakerMappings = {
          BED: {
            front: ["FL", "FR"],
            frontWide: ["FWL", "FWR"],
            surroundBack: ["SBL", "SBR"],
            surroundBackSingle: ["SB"],
            surround: ["SLA", "SRA"],
            center: ["C"]
          },
          HEIGHT: {
            frontHeight: ["FHL", "FHR"],
            rearHeight: ["RHL", "RHR"],
            surroundHeight: ["SHL", "SHR"],
            topFront: ["TFL", "TFR"],
            topMiddle: ["TML", "TMR"],
            topRear: ["TRL", "TRR"],
            upfiringBack: ["BDL", "BDR"],
            upfiringFront: ["FDL", "FDR"],
            upfiringSurround: ["SDL", "SDR"],
            topSurround: ["TS"],
            centerHeight: ["CH"]
          }
        };
        // Create flat arrays for easy lookup
        const bedSpeakers = Object.values(speakerMappings.BED).flat();
        const heightSpeakers = Object.values(speakerMappings.HEIGHT).flat();
        // Function to determine speaker layer type
        function getSpeakerLayer(speakerId) {
          if (bedSpeakers.includes(speakerId)) {
            return 'BED';
          } else if (heightSpeakers.includes(speakerId)) {
            return 'HEIGHT';
          } else {
            return 'UNKNOWN';
          }
        }
        // Get ranges from both sliders
        const bedSliderRange = sliderInstances.bed ? sliderInstances.bed.getSelectedRange() : null;
        const heightSliderRange = sliderInstances.height ? sliderInstances.height.getSelectedRange() : null;
        // Extract frequency ranges based on slider mode
        let bedMinFreq, bedMaxFreq, heightMinFreq, heightMaxFreq;
        if (bedSliderRange) {
          if (bedSliderRange.mode === "single") {
            bedMinFreq = bedMaxFreq = bedSliderRange.value;
          } else {
            bedMinFreq = bedSliderRange.min;
            bedMaxFreq = bedSliderRange.max;
          }
        } else {
          bedMinFreq = bedMaxFreq = null;
        }
        if (heightSliderRange) {
          if (heightSliderRange.mode === "single") {
            heightMinFreq = heightMaxFreq = heightSliderRange.value;
          } else {
            heightMinFreq = heightSliderRange.min;
            heightMaxFreq = heightSliderRange.max;
          }
        } else {
          heightMinFreq = heightMaxFreq = null;
        }
        console.log(`BED layer range: ${bedMinFreq}Hz - ${bedMaxFreq}Hz`);
        console.log(`HEIGHT layer range: ${heightMinFreq}Hz - ${heightMaxFreq}Hz`);
        console.info("Finalizing crossover frequencies to best follow the target curve...");
        // Function to get the appropriate frequency range for a speaker
        function getSpeakerFreqRange(speakerId) {
          const layer = getSpeakerLayer(speakerId);
          if (layer === 'BED' && bedMinFreq !== null && bedMaxFreq !== null) {
            return { min: bedMinFreq, max: bedMaxFreq, layer: 'BED' };
          } else if (layer === 'HEIGHT' && heightMinFreq !== null && heightMaxFreq !== null) {
            return { min: heightMinFreq, max: heightMaxFreq, layer: 'HEIGHT' };
          } else {
            // Fallback to default range if no slider available or speaker type unknown
            console.warn(`Using default range for ${speakerId} (${layer} layer)`);
            return { min: 20, max: 250, layer: 'DEFAULT' };
          }
        }
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        const targetArray = response2array(targetResponse, start, end);
        let count = 1;
        for (let i = nChannels + 2; i <= nChannels * 3; i += 2) {
          if (commandId[count].startsWith("SW")) { continue; }
          // check if single channel or speaker pair
          const singleChannel = isSingleChannel(commandId[count]);
          const cmdIds = (singleChannel ? commandId[count] : `${commandId[count]} & ${commandId[1 + count]}`).padStart(9, ".");
          // Get the appropriate frequency range for this speaker
          const primarySpeakerId = commandId[count];
          const speakerRange = getSpeakerFreqRange(primarySpeakerId);
          console.info(`${cmdIds} using ${speakerRange.layer} layer range: ${speakerRange.min}Hz - ${speakerRange.max}Hz`);
          // Calculate effective usable range for this speaker
          const effectiveMinXO = Math.max(minXO, speakerRange.min);
          const effectiveMaxXO = Math.min(maxXO, speakerRange.max);
          // Warning if ranges don't fully overlap
          if (speakerRange.min < minXO || speakerRange.max > maxXO) {
            console.warn(`${cmdIds} slider range (${speakerRange.min}Hz - ${speakerRange.max}Hz) extends beyond subwoofer bandwidth (${minXO}Hz - ${maxXO}Hz)`);
          }
          // Filter freqIndex to only include frequencies within this speaker's range
          const filteredFreqIndex = freqIndex.filter(freq =>
            freq >= effectiveMinXO && freq <= effectiveMaxXO
          );
          console.info(`${cmdIds} filtered frequency range: ${filteredFreqIndex.length} frequencies from ${filteredFreqIndex[0] || 'none'}Hz to ${filteredFreqIndex[filteredFreqIndex.length - 1] || 'none'}Hz`);
          // finalize xo that is closest match to target curve
          const initialXO = parseFloat(customCrossover[count]);
          // Warning checks for this speaker's effective range
          if (initialXO > effectiveMaxXO) {
            console.warn(`${cmdIds} initial XO (${initialXO}Hz) is above effective range (${effectiveMaxXO}Hz) - may not find optimal setting`);
          }
          if (initialXO < effectiveMinXO) {
            console.warn(`${cmdIds} initial XO (${initialXO}Hz) is below effective range (${effectiveMinXO}Hz) - may not find optimal setting`);
          }
          let bestXO = initialXO, minRmsError = Infinity;
          console.info(`Starting optimization for ${cmdIds}...`);
          // Use filtered frequency range from appropriate slider
          for (let j = 0; j < filteredFreqIndex.length; j++) {
            let checkXO = filteredFreqIndex[j];
            // FIXED: Remove initial XO from range check - slider range should be authoritative
            if (checkXO < effectiveMinXO || checkXO > effectiveMaxXO) { continue; }
            // final XO determination logic
            // console.info(`${cmdIds} - Initial XO: ${initialXO}hz → Checking XO: ${checkXO}hz (RMS: ${rmsError.toFixed(3)}) [${speakerRange.layer} layer]`);
            // console.info(`${cmdIds} - Initial XO: ${initialXO}hz → Checking XO: ${checkXO}hz [${speakerRange.layer} layer]`);
            console.info(`→`);
            console.info(`├─ ${cmdIds} - Initial XO: ${initialXO}hz → Testing XO: ${checkXO}hz [${speakerRange.layer} layer]`);
            if (singleChannel) {
              await genSpeaker(i, checkXO);
            } else {
              await postNext('Magn plus phase average', [i, i + 2]); // do not use VA. it unfairly benefits single channel speakers
              await genSpeaker(mCount + 1, checkXO);
              await postDelete(mCount + 1);
            }
            await genSub(mCount, checkXO);
            await postNext('Arithmetic', [mCount + 1, mCount + 2], { function: "A + B" }); // response using checkXO
            // Enhanced RMS calculation with PHASE-AWARE optimization
            const checkXOResponse = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', mCount + 3);
            // const checkXOResponse = await fetchSafe('frequency-response?smoothing=1/2&ppo=96', mCount + 3);
            const checkXOArray = response2array(checkXOResponse, start, end);
            // Generate frequency array for the response
            const responseFrequencyArray = generateFrequencyArray(start, end, checkXOArray.length);
            // Extract and unwrap phase data from REW response
            let phaseArray = null;
            let targetPhaseArray = null;
            if (checkXOResponse.phase) {
              // UNWRAP phase first using crossover frequency as reference
              await postSafe(`${baseUrl}/${mCount + 3}/command`, {
                command: "Unwrap phase",
                parameters: { frequency: checkXO }
              }, "Unwrap phase completed");
              // Get the unwrapped phase response  
              const unwrappedResponse = await fetchSafe('frequency-response?smoothing=Psy&ppo=96', mCount + 3);
              phaseArray = response2arrayPhase(unwrappedResponse, start, end);
              if (phaseArray) {
                targetPhaseArray = calculateExpectedCrossoverPhase(responseFrequencyArray, checkXO, phaseArray);
                console.info(`├─ DEBUG: Crossover ${checkXO}Hz phase analysis:`);
                // Add null checks for debugging
                if (phaseArray && phaseArray.length > 0) {
                  console.info(`├─ Actual phase at ${checkXO}Hz: ${phaseArray[Math.floor(phaseArray.length / 2)].toFixed(1)}°`);
                  if (responseFrequencyArray && responseFrequencyArray.length > 1) {
                    const phaseSlope = (phaseArray[phaseArray.length - 1] - phaseArray[0]) / (responseFrequencyArray[responseFrequencyArray.length - 1] - responseFrequencyArray[0]);
                    console.info(`├─ Actual phase slope: ${phaseSlope.toFixed(2)}°/Hz`);
                  }
                }
                if (targetPhaseArray && targetPhaseArray.length > 0) {
                  console.info(`├─ Expected phase at ${checkXO}Hz: ${targetPhaseArray[Math.floor(targetPhaseArray.length / 2)].toFixed(1)}°`);
                } else {
                  console.warn(`ERROR: targetPhaseArray is null or empty`);
                }
                console.info(`├─ Phase optimization enabled for ${checkXO}Hz crossover`);
              }
            }
            // Calculate RMS error with magnitude AND phase optimization
            const rmsError = calculateRMSError(
              checkXOArray,
              targetArray,
              responseFrequencyArray,
              targetLevel,
              phaseArray !== null, // Enable phase optimization if phase data available
              phaseArray,
              targetPhaseArray,
              checkXO // Pass the actual crossover frequency being tested
            );
            console.log(`└─ ${cmdIds} - XO: ${checkXO}hz → Result: RMS: ${rmsError.toFixed(3)}`);
            // console.info(`←`);
            if (rmsError < minRmsError) {
              minRmsError = rmsError;
              bestXO = checkXO;
            }
            // final XO determination logic
            // console.info(`${cmdIds} - Initial XO: ${initialXO}hz → Checking XO: ${checkXO}hz (RMS: ${rmsError.toFixed(3)}) [${speakerRange.layer} layer]`);
            for (let k = mCount + 3; k > mCount; k--) {
              await postDelete(k);
            }
          }
          customCrossover[count] = bestXO;
          // Store the result in RP22BestXO array with layer information
          RP22BestXO.push([commandId[count], bestXO.toString(), speakerRange.layer]);
          if (!singleChannel) {
            customCrossover[1 + count] = bestXO;
            // Store the second channel result with layer information
            const secondarySpeakerId = commandId[1 + count];
            const secondaryLayer = getSpeakerLayer(secondarySpeakerId);
            RP22BestXO.push([secondarySpeakerId, bestXO.toString(), secondaryLayer]);
            i += 2;
            count++;
          }
          count++;
          // console.log(`${cmdIds} - Initial XO: ${initialXO}hz → Best XO: ${bestXO}hz (RMS: ${minRmsError.toFixed(3)}) [${speakerRange.layer} layer]`);
          console.log(`→`);
          console.log(`${cmdIds} - Initial XO: ${initialXO}hz → Best XO: ${bestXO}hz (RMS: ${minRmsError.toFixed(3)}) [${speakerRange.layer} layer]`);
          console.log(`←`);
          // Get the detailed RMS info for the best crossover
          // console.log(`${cmdIds} - Initial XO: ${initialXO}hz → Best XO: ${bestXO}hz [${speakerRange.layer} layer]`);
          // console.log(`${cmdIds} - Final result: Combined RMS: ${minRmsError.toFixed(3)} (Magnitude + Phase optimization)`);
        }
        // Log the final results grouped by layer
        const bedResults = RP22BestXO.filter(result => result[2] === 'BED');
        const heightResults = RP22BestXO.filter(result => result[2] === 'HEIGHT');
        const unknownResults = RP22BestXO.filter(result => result[2] === 'DEFAULT' || result[2] === 'UNKNOWN');
        console.log("=== FINAL CROSSOVER OPTIMIZATION RESULTS ===");
        for (let i = 0; i < RP22BestXO.length; i++) {
          const [code, frequency, layer] = RP22BestXO[i];
          console.log(`${code} → ${frequency}Hz → [${layer} layer]`);
        }
        return RP22BestXO;
      }

      /*
      async function directional2standard() {
        let measurements = await fetch_mREW();
        let mCount = Object.keys(measurements).length;
        // Isolate SW commandIds & peak IR times (from your working version)
        const swCmdIdsWithIRPeak = {};
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          if (commandId[i] && commandId[i].startsWith("SW")) {
            // Find the measurement index for this subwoofer
            let measurementIdx = i;
            // Adjust for measurement indexing if needed
            for (let j = 1; j <= mCount; j++) {
              if (measurements[j].title.startsWith(commandId[i])) {
                measurementIdx = j;
                break;
              }
            }
            if (measurements[measurementIdx]) {
              swCmdIdsWithIRPeak[commandId[i]] = measurements[measurementIdx].timeOfIRPeakSeconds;
            }
          }
        }
        // Sort subs using peak IR time based on closest to farthest
        const sortedSwList = Object.entries(swCmdIdsWithIRPeak).sort((a, b) => a[1] - b[1]).map(row => row[0]);
        console.info(`Alignment order based on IR peak time: ${sortedSwList}`);
        // Build sorted indices arrays - find existing measurements like SW10, SW11, etc.
        const swIndices = [];
        for (let i = 0; i < sortedSwList.length; i++) {
          const swName = sortedSwList[i]; // e.g., "SW1", "SW2", "SW3"
          const subNumber = swName.slice(-1); // Extract "1", "2", "3"
          // Find all measurements for this subwoofer (SW10, SW11, SW12, etc.)
          const subMeasurements = [];
          for (let j = 1; j <= mCount; j++) {
            if (measurements[j] && measurements[j].title.startsWith(`SW${subNumber}`)) {
              subMeasurements.push(j);
            }
          }
          if (subMeasurements.length > 0) {
            // Sort by position number (SW10, SW11, SW12...)
            subMeasurements.sort((a, b) => {
              const posA = parseInt(measurements[a].title.slice(2));
              const posB = parseInt(measurements[b].title.slice(2));
              return posA - posB;
            });
            swIndices.push(subMeasurements);
          }
        }
        // Validate swIndices array structure
        if (!swIndices || swIndices.length === 0) {
          console.error("No subwoofer indices found for directional2standard conversion");
          throw new Error("Invalid swIndices array");
        }
        if (!swIndices[0] || swIndices[0].length === 0) {
          console.error("First subwoofer group is empty");
          throw new Error("Invalid swIndices[0] array");
        }
        let currSubIdx = swIndices[0][0];
        let cmdIds = measurements[currSubIdx].title.slice(0, -1);
        let startFreq = Math.round(await getAbsLow3dBPointForSub(currSubIdx));
        let endFreq = Math.round(await getAbsHigh3dBPointForSub(currSubIdx));
        for (let i = 1; i < swIndices.length; i++) {
          let thisSubIdx = swIndices[i][0];
          const thisSubCmdId = measurements[thisSubIdx].title.slice(0, -1);
          const thisSubNumber = parseInt(thisSubCmdId.slice(-1));
          console.log(`Aligning ${thisSubCmdId} to ${cmdIds}...`);
          startFreq = Math.min(startFreq, Math.round(await getAbsLow3dBPointForSub(thisSubIdx)));
          endFreq = Math.max(endFreq, Math.round(await getAbsHigh3dBPointForSub(thisSubIdx)));
          const [loDelay, hiDelay] = getDelayRangeOf(mSec[nSpeakers + thisSubNumber], nSpeakers + 1, nSpeakers + nSubs);
          const [isPossible, requiredDelay, isInverted, sumIndex] = await alignMsub(currSubIdx, thisSubIdx, startFreq, endFreq, loDelay, hiDelay);
          if (!isPossible || !sumIndex) {
            console.error("Failed to align multiple subwoofers!");
            throw new Error("Subwoofer alignment failed");
          }
          currSubIdx = sumIndex;
          mSec[nSpeakers + thisSubNumber] += (requiredDelay / delaymax);
          invertSub[nSpeakers + thisSubNumber] = isInverted;
          cmdIds += ` & ${thisSubCmdId}`;
          // Apply delay and inversion directly to measurements
          for (let j = 0; j < swIndices[i].length; j++) {
            await postNext('Offset t=0', swIndices[i][j], { offset: -mSec[nSpeakers + thisSubNumber], unit: "seconds" });
            if (isInverted) {
              await postSafe(`${baseUrl}/${swIndices[i][j]}/command`, { command: "Invert" }, "Invert completed");
            }
          }
        }
        // Cleanup intermediate alignment measurements
        for (let i = currSubIdx - 1; i > mCount; i--) {
          await postDelete(i);
        }
        // Normalize median subwoofer delay to t=0
        const loSWDelay = Math.min(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
        const hiSWDelay = Math.max(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
        const medianSWDelay = (loSWDelay + hiSWDelay) / 2;
        for (let i = 0; i < swIndices.length; i++) {
          for (let j = 0; j < swIndices[i].length; j++) {
            await postNext('Offset t=0', swIndices[i][j], { offset: medianSWDelay, unit: "seconds" });
          }
          // Extract actual subwoofer number from measurement title
          const firstMeasurementIdx = swIndices[i][0];
          const measurementTitle = measurements[firstMeasurementIdx].title;
          const actualSubNumber = parseInt(measurementTitle.slice(2, -1)); // Extract from "SW30" -> "3"
          mSec[nSpeakers + actualSubNumber] -= medianSWDelay;
        }
        // Combine subs at the individual position level
        console.info("Generating combined subwoofer response(s)...");
        let volAdjust = 0;
        for (let i = 0; i < swIndices[0].length; i++) {
          console.infoUpdate(`Generating combined subwoofer response for position #${i + 1}`);
          const iPosSWIdxs = swIndices.map(row => row[i]);
          const iPosCombinedSW = await postNext('Vector sum', iPosSWIdxs);
          const iPosCombinedSWIdx = Object.keys(iPosCombinedSW.results)[0];
          await fetch_mREW(iPosCombinedSWIdx, 'PUT', { title: `SW1${i}` });
          if (i === 0) {
            // Offset multi-sub gain using MLP measurement
            volAdjust = await getSubTrim(iPosCombinedSWIdx);
          }
          await postNext('Add SPL offset', iPosCombinedSWIdx, { offset: volAdjust });
        }
        console.infoUpdate(`Generated combined subwoofer response(s) for all positions.`);
        // Cleanup individual sub measurements
        console.info("Cleaning up individual subwoofer response(s)...");
        const individualSWIndices = swIndices.flat().sort(function (a, b) { return a - b; });
        for (let i = individualSWIndices.length - 1; i >= 0; i--) {
          await postDelete(individualSWIndices[i]);
        }
        console.infoUpdate("Cleaned up individual subwoofer response(s).");
        // Apply custom level adjustments for newer AVRs
        if (sOs === 300 && volAdjust != 0) {
          console.log(`Adjusting combined sub level by ${volAdjust}dB to best follow the target curve...`);
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += volAdjust;
            console.info(`${commandId[i].padStart(3, ".")} - shifted: ${customLevel[i] - volAdjust}dB → ${customLevel[i]}dB`);
          }
        }
        // cleanup "Aligned sum" leftover ...
        measurements = await fetch_mREW();
        const titles = {};
        let titleIndices = {};
        mCount = Object.keys(measurements).length;
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name == "Aligned sum") {
            console.info("Deleting", name);
            await postDelete(i);
            // await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        // Update the SW name to SW1o
        // cleanup "Aligned sum" leftover ...
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          const newname = "SW1o";
          if (name == "SW10") {
            console.info("Updating subwoofer name", name);
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${i}`, requestOptions);
          }
        }

      }
      */
      async function directional2standard() {
        let measurements = await fetch_mREW();
        let mCount = Object.keys(measurements).length;

        // Check if NART already optimized
        const nartOptimized = (window.nartOptimizationComplete === true);
        if (nartOptimized) {
          console.warn("🎯 NART Mode: Using frequency-dependent alignment (preserving NART optimization)");
        } else {
          console.warn("🎯 Traditional Mode: Calculating magnitude-based alignment");
        }


        // Isolate SW commandIds & peak IR times (from your working version)
        const swCmdIdsWithIRPeak = {};
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          if (commandId[i] && commandId[i].startsWith("SW")) {
            // Find the measurement index for this subwoofer
            let measurementIdx = i;
            // Adjust for measurement indexing if needed
            for (let j = 1; j <= mCount; j++) {
              if (measurements[j].title.startsWith(commandId[i])) {
                measurementIdx = j;
                break;
              }
            }
            if (measurements[measurementIdx]) {
              swCmdIdsWithIRPeak[commandId[i]] = measurements[measurementIdx].timeOfIRPeakSeconds;
            }
          }
        }
        // Sort subs using peak IR time based on closest to farthest
        const sortedSwList = Object.entries(swCmdIdsWithIRPeak).sort((a, b) => a[1] - b[1]).map(row => row[0]);
        console.info(`Alignment order based on IR peak time: ${sortedSwList}`);
        // Build sorted indices arrays - find existing measurements like SW10, SW11, etc.
        const swIndices = [];
        for (let i = 0; i < sortedSwList.length; i++) {
          const swName = sortedSwList[i]; // e.g., "SW1", "SW2", "SW3"
          const subNumber = swName.slice(-1); // Extract "1", "2", "3"
          // Find all measurements for this subwoofer (SW10, SW11, SW12, etc.)
          const subMeasurements = [];
          for (let j = 1; j <= mCount; j++) {
            if (measurements[j] && measurements[j].title.startsWith(`SW${subNumber}`)) {
              subMeasurements.push(j);
            }
          }
          if (subMeasurements.length > 0) {
            // Sort by position number (SW10, SW11, SW12...)
            subMeasurements.sort((a, b) => {
              const posA = parseInt(measurements[a].title.slice(2));
              const posB = parseInt(measurements[b].title.slice(2));
              return posA - posB;
            });
            swIndices.push(subMeasurements);
          }
        }
        // Validate swIndices array structure
        if (!swIndices || swIndices.length === 0) {
          console.error("No subwoofer indices found for directional2standard conversion");
          throw new Error("Invalid swIndices array");
        }
        if (!swIndices[0] || swIndices[0].length === 0) {
          console.error("First subwoofer group is empty");
          throw new Error("Invalid swIndices[0] array");
        }
        let currSubIdx = swIndices[0][0];
        let cmdIds = measurements[currSubIdx].title.slice(0, -1);
        let startFreq = Math.round(await getAbsLow3dBPointForSub(currSubIdx));
        let endFreq = Math.round(await getAbsHigh3dBPointForSub(currSubIdx));
        for (let i = 1; i < swIndices.length; i++) {
          let thisSubIdx = swIndices[i][0];
          const thisSubCmdId = measurements[thisSubIdx].title.slice(0, -1);
          const thisSubNumber = parseInt(thisSubCmdId.slice(-1));

          startFreq = Math.min(startFreq, Math.round(await getAbsLow3dBPointForSub(thisSubIdx)));
          endFreq = Math.max(endFreq, Math.round(await getAbsHigh3dBPointForSub(thisSubIdx)));

          let requiredDelay, isInverted, sumIndex;

          if (nartOptimized) {
            // ✓ NART MODE: Use the delays NART already calculated
            console.log(`├─ ${thisSubCmdId}: Using NART-optimized alignment...`);

            // NART already stored the optimal delays in mSec[] array
            // We just need to apply them and combine the subs

            // Apply NART's delay to this sub's measurements
            for (let j = 0; j < swIndices[i].length; j++) {
              const currentDelay = mSec[nSpeakers + thisSubNumber];
              await postNext('Offset t=0', swIndices[i][j], { offset: -currentDelay, unit: "seconds" });
            }

            // Apply NART's inversion if needed
            isInverted = invertSub[nSpeakers + thisSubNumber];
            if (isInverted) {
              for (let j = 0; j < swIndices[i].length; j++) {
                await postSafe(`${baseUrl}/${swIndices[i][j]}/command`, { command: "Invert" }, "Invert completed");
              }
            }

            // Combine this sub with previous combined result
            const combineResult = await postNext('Vector sum', [currSubIdx, thisSubIdx]);
            sumIndex = parseInt(Object.keys(combineResult.results)[0]);

            console.log(`├─ ${thisSubCmdId}: NART delay preserved, inverted: ${isInverted}`);

          } else {
            // X TRADITIONAL MODE: Calculate new alignment from scratch
            console.log(`Aligning ${thisSubCmdId} to ${cmdIds}...`);

            const [loDelay, hiDelay] = getDelayRangeOf(mSec[nSpeakers + thisSubNumber], nSpeakers + 1, nSpeakers + nSubs);
            const [isPossible, newDelay, newInvert, newSumIndex] =
              await alignMsub(currSubIdx, thisSubIdx, startFreq, endFreq, loDelay, hiDelay);

            if (!isPossible || !newSumIndex) {
              console.error("Failed to align multiple subwoofers!");
              throw new Error("Subwoofer alignment failed");
            }

            requiredDelay = newDelay;
            isInverted = newInvert;
            sumIndex = newSumIndex;

            mSec[nSpeakers + thisSubNumber] += (requiredDelay / delaymax);
            invertSub[nSpeakers + thisSubNumber] = isInverted;

            // Apply delay and inversion to measurements
            for (let j = 0; j < swIndices[i].length; j++) {
              await postNext('Offset t=0', swIndices[i][j], { offset: -mSec[nSpeakers + thisSubNumber], unit: "seconds" });
              if (isInverted) {
                await postSafe(`${baseUrl}/${swIndices[i][j]}/command`, { command: "Invert" }, "Invert completed");
              }
            }
          }

          // Update for next iteration (UNCHANGED)
          currSubIdx = sumIndex;
          cmdIds += ` & ${thisSubCmdId}`;
        }
        // Cleanup intermediate alignment measurements
        for (let i = currSubIdx - 1; i > mCount; i--) {
          await postDelete(i);
        }

        // ✓ NEW: Cleanup the intermediate "Vector sum" or "Aligned sum" from NART mode
        if (nartOptimized) {
          const cleanupMeasurements = await fetch_mREW();
          const cleanupCount = Object.keys(cleanupMeasurements).length;

          for (let i = 1; i <= cleanupCount; i++) {
            const title = cleanupMeasurements[i]?.title;
            if (title === "Vector sum" || title === "Aligned sum") {
              console.info(`Cleaning up intermediate NART combination: ${title}`);
              await postDelete(i);
              break; // Only delete the first one found
            }
          }
        }

        // Normalize median subwoofer delay to t=0
        const loSWDelay = Math.min(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
        const hiSWDelay = Math.max(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
        const medianSWDelay = (loSWDelay + hiSWDelay) / 2;
        for (let i = 0; i < swIndices.length; i++) {
          for (let j = 0; j < swIndices[i].length; j++) {
            await postNext('Offset t=0', swIndices[i][j], { offset: medianSWDelay, unit: "seconds" });
          }
          // Extract actual subwoofer number from measurement title
          const firstMeasurementIdx = swIndices[i][0];
          const measurementTitle = measurements[firstMeasurementIdx].title;
          const actualSubNumber = parseInt(measurementTitle.slice(2, -1)); // Extract from "SW30" -> "3"
          mSec[nSpeakers + actualSubNumber] -= medianSWDelay;
        }
        // Combine subs at the individual position level
        console.info("Generating combined subwoofer response(s)...");
        let volAdjust = 0;
        for (let i = 0; i < swIndices[0].length; i++) {
          console.infoUpdate(`Generating combined subwoofer response for position #${i + 1}`);
          const iPosSWIdxs = swIndices.map(row => row[i]);
          const iPosCombinedSW = await postNext('Vector sum', iPosSWIdxs);
          const iPosCombinedSWIdx = Object.keys(iPosCombinedSW.results)[0];
          await fetch_mREW(iPosCombinedSWIdx, 'PUT', { title: `SW1${i}` });
          if (i === 0) {
            // Offset multi-sub gain using MLP measurement
            volAdjust = await getSubTrim(iPosCombinedSWIdx);
          }
          await postNext('Add SPL offset', iPosCombinedSWIdx, { offset: volAdjust });
        }
        console.infoUpdate(`Generated combined subwoofer response(s) for all positions.`);
        // Cleanup individual sub measurements
        console.info("Cleaning up individual subwoofer response(s)...");
        const individualSWIndices = swIndices.flat().sort(function (a, b) { return a - b; });
        for (let i = individualSWIndices.length - 1; i >= 0; i--) {
          await postDelete(individualSWIndices[i]);
        }
        console.infoUpdate("Cleaned up individual subwoofer response(s).");
        // Apply custom level adjustments for newer AVRs
        if (sOs === 300 && volAdjust != 0) {
          console.log(`Adjusting combined sub level by ${volAdjust}dB to best follow the target curve...`);
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += volAdjust;
            console.info(`${commandId[i].padStart(3, ".")} - shifted: ${customLevel[i] - volAdjust}dB → ${customLevel[i]}dB`);
          }
        }
        // cleanup "Aligned sum" leftover ...
        measurements = await fetch_mREW();
        const titles = {};
        let titleIndices = {};
        mCount = Object.keys(measurements).length;
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name == "Aligned sum") {
            console.info("Deleting", name);
            await postDelete(i);
            // await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
          }
        }

        // Update the SW name to SW1o
        // cleanup "Aligned sum" leftover ...
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        for (i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          const newname = "SW1o";
          if (name == "SW10") {
            console.info("Updating subwoofer name", name);
            const requestOptions = {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: newname }),
            };
            fetch(`http://localhost:4735/measurements/${i}`, requestOptions);
          }
        }

      }

      // directional2standard helper for NART 
      async function combineSubsWithExistingDelays(sub1Idx, sub2Idx, delayMs, invert) {
        // Apply the pre-calculated delay and inversion to sub2
        if (invert) {
          await postSafe(`${baseUrl}/${sub2Idx}/command`, { command: "Invert" }, "Invert completed");
        }
        await postNext('Offset t=0', sub2Idx, { offset: -delayMs / 1000, unit: "seconds" });
        // Vector sum (or magnitude average) the aligned subs
        const sumResult = await postNext('Vector sum', [sub1Idx, sub2Idx]);
        const sumIndex = Object.keys(sumResult.results)[0];
        return parseInt(sumIndex);
      }

      function response2array(response, start, end, phase = false) {
        let startFreq = response.startFreq;
        let k1 = start, k2 = end;
        if ('freqStep' in response) {
          const freqStep = response.freqStep;
          k1 = Math.round((k1 - startFreq) / freqStep);
          k2 = Math.round((k2 - startFreq) / freqStep);
        } else if ('ppo' in response) {
          const responsePpo = response.ppo;
          k1 = Math.round(Math.log2(k1 / startFreq) * responsePpo);
          k2 = Math.round(Math.log2(k2 / startFreq) * responsePpo);
        }
        const bytes = Uint8Array.from(atob(phase ? response.phase : response.magnitude), c => c.charCodeAt(0));
        const buffer = bytes.buffer;
        const data = new DataView(buffer);
        const responseArray = [];
        for (let k = k1; k <= k2; k++) {
          const sumMagnitude = data.getFloat32(k * 4);
          responseArray.push(sumMagnitude);
        }
        return responseArray;
      }

      function calculateRMSError(rpArray, targetArray, frequencyArray = null, playbackLevel = null, includePhase = false, phaseArray = null, targetPhaseArray = null, crossoverFreq = null) {
        if (rpArray.length === 0 || targetArray.length === 0) {
          console.warn("Failed to calculate RMS error!");
          return Infinity;
        }
        const arrayLength = Math.min(rpArray.length, targetArray.length);
        // Calculate traditional magnitude RMS
        let magnitudeSumOfSquares = 0;
        for (let i = 0; i < arrayLength; i++) {
          const diff = rpArray[i] - targetArray[i];
          magnitudeSumOfSquares += diff * diff;
        }
        const magnitudeRMS = Math.sqrt(magnitudeSumOfSquares / arrayLength);
        // If no phase data provided, return magnitude-only RMS
        if (!includePhase || !phaseArray || !targetPhaseArray) {
          console.log(`📊 RMS: Magnitude-only optimization: ${magnitudeRMS.toFixed(6)}`);
          return magnitudeRMS;
        }
        // Helper function for shortest angular distance
        function phaseErrorDeg(actual, expected) {
          let diff = actual - expected;
          return ((diff + 180) % 360) - 180; // shortest path
        }
        // Calculate phase RMS error
        let phaseSumOfSquares = 0;
        let phasePoints = 0;
        const phaseLength = Math.min(phaseArray.length, targetPhaseArray.length, arrayLength);
        for (let i = 0; i < phaseLength; i++) {
          if (frequencyArray && frequencyArray[i]) {
            const frequency = frequencyArray[i];

            // Focus on frequency band around actual crossover (ChatGPT's improvement)
            if (crossoverFreq !== null) {
              const freqLow = crossoverFreq / Math.sqrt(2);  // ~0.7x crossover
              const freqHigh = crossoverFreq * Math.sqrt(2); // ~1.4x crossover
              if (frequency >= freqLow && frequency <= freqHigh) {
                // Calculate shortest angular distance between unwrapped values
                const phaseDiff = phaseErrorDeg(phaseArray[i], targetPhaseArray[i]);
                // Weight phase errors more heavily near the actual crossover frequency
                const frequencyDistanceFromXO = Math.abs(frequency - crossoverFreq);
                const crossoverWeight = frequencyDistanceFromXO <= 15 ? 2.0 : 1.0; // Within ±15Hz of crossover
                phaseSumOfSquares += (phaseDiff * phaseDiff * crossoverWeight);
                phasePoints++;
              }
            } else {
              // Fallback to broad frequency range if no crossover specified
              if (frequency >= 40 && frequency <= 200) {
                const phaseDiff = phaseErrorDeg(phaseArray[i], targetPhaseArray[i]);
                phaseSumOfSquares += (phaseDiff * phaseDiff);
                phasePoints++;
              }
            }
          }
        }
        const phaseRMS = phasePoints > 0 ? Math.sqrt(phaseSumOfSquares / phasePoints) : 0;
        const normalizedPhaseRMS = phaseRMS / 180; // Scale to [0..1] 
        // const phaseWeight = 5.0; // Adjust contribution
        const phaseWeight = 5.0; // Adjust contribution
        const combinedError = magnitudeRMS + (normalizedPhaseRMS * phaseWeight);
        console.log(`├─ 📊 RMS: Magnitude: ${magnitudeRMS.toFixed(6)}, Phase: ${phaseRMS.toFixed(2)}°, NormPhase: ${normalizedPhaseRMS.toFixed(4)}, Combined: ${combinedError.toFixed(6)}`);
        return combinedError;
      }

      async function getTrim(idx, start, end) {
        const targetArray = response2array(targetResponse, start, end);
        const targetSPL = targetArray.reduce((acc, val) => acc + val, 0) / targetArray.length;
        const isSubwoofer = (end <= 150);
        const mode = getCurrentMode();
        // Use mode-specific smoothing or default based on device type
        const smoothing = isSubwoofer ? '1/1' : '1/1'; // Can be adjusted per mode if needed
        const freqResponse = await fetchSafe(`frequency-response?smoothing=${smoothing}&ppo=96`, idx);
        console.info(`├─ getTrim: ${mode} ${isSubwoofer ? 'subwoofer' : 'speaker'} (${start}-${end}Hz) - ${smoothing} smoothing`);
        const freqArray = response2array(freqResponse, start, end);
        const freqSPL = freqArray.reduce((acc, val) => acc + val, 0) / freqArray.length;
        if (isDebugMode) {
          console.log(`*** TRIM DEBUG for measurement ${idx} (${start}-${end}Hz) ***`);
          console.log(`Device type detected: ${isSubwoofer ? 'SUBWOOFER' : 'SPEAKER'}`);
          console.log(`Target curve average SPL: ${targetSPL.toFixed(1)}dB`);
          console.log(`Measurement average SPL: ${freqSPL.toFixed(1)}dB`);
          console.log(`Calculated trim: ${(targetSPL - freqSPL).toFixed(1)}dB`);
          const measurements = await fetch_mREW();
          const currentSplOffset = parseFloat(measurements[idx].splOffsetdB);
          console.log(`Current measurement SPL offset: ${currentSplOffset}dB`);
          console.log(`Effective measurement level: ${(freqSPL + currentSplOffset).toFixed(1)}dB`);
        }
        const offset = targetSPL - freqSPL;
        return Math.round(offset * 2) / 2; // round to nearest 0.5
      }

      // Target Cruve trim only with Var smoothing
      async function getTCTrim(idx, start, end) {
        const targetArray = response2array(targetResponse, start, end);
        const targetSPL = targetArray.reduce((acc, val) => acc + val, 0) / targetArray.length;
        const freqResponse = await fetchSafe(`frequency-response?smoothing=Var&ppo=96`, idx);
        const freqArray = response2array(freqResponse, start, end);
        const freqSPL = freqArray.reduce((acc, val) => acc + val, 0) / freqArray.length;
        const offset = targetSPL - freqSPL;
        return Math.round(offset * 2) / 2; // round to nearest 0.5
      }

      // Currently hard set to 30-80 for trim
      async function getSpeakerTrim(idx) {
        const mode = getCurrentMode();
        const config = MODE_CONFIG[mode];
        // Measure actual speaker capabilities once
        let actualLow = Math.round(await getAbsLow3dBPointForSpk(idx));
        let actualHigh = Math.round(await getAbsHigh3dBPointForSpk(idx));
        const param2 = Math.max(actualLow, config.speaker.min);
        const param3 = mode === 'DEFAULT' ?
          Math.min(actualHigh, 20000) :
          Math.max(actualHigh, config.speaker.max);
        modeSpkMin = config.speaker.min;
        modeSpkMax = config.speaker.max;
        return await getTrim(idx, 500, 2000);
      }

      // Currently hard set to 30-80 for trim
      async function getSubTrim(idx) {
        const mode = getCurrentMode();
        const config = MODE_CONFIG[mode];
        // Measure actual subwoofer capabilities
        let actualLow = Math.round(await getAbsLow3dBPointForSub(idx));
        let actualHigh = Math.round(await getAbsHigh3dBPointForSub(idx));
        const param2 = Math.max(actualLow, config.subwoofer.min);
        const param3 = Math.max(actualHigh, config.subwoofer.max);
        modeSubXOMin = config.subwoofer.min;
        modeSubXOMax = config.subwoofer.max;
        let warnings = [];
        // Mode-specific warnings
        if (mode === 'DOLBY' && actualLow > 31.5) {
          warnings.push(`Sub ${idx}: Low end ${actualLow}Hz exceeds Dolby spec (31.5Hz)`);
        } else if (mode === 'THX' && actualLow > 20) {
          warnings.push(`Sub ${idx}: Low end ${actualLow}Hz doesn't meet THX requirement (20Hz)`);
        } else if (mode === 'IMAX' && actualHigh < 70) {
          warnings.push(`Sub ${idx}: High end ${actualHigh}Hz below IMAX crossover (70Hz)`);
        }
        if (warnings.length > 0) {
          console.warn('Subwoofer compliance warnings:', warnings);
        }
        return await getTrim(idx, 30, 80);
      }

      // attempt to fix android volume bug where measurements are off by multiples of +/-6dB
      async function fixVolBug(indices) {
        if (indices.length <= 1) { return; }
        const measurements = await fetch_mREW();
        const mlpIdx = indices[0];
        const mlpVolume = measurements[mlpIdx].title.startsWith("SW") ? await getSubTrim(mlpIdx) : await getSpeakerTrim(mlpIdx);
        for (let i = 0; i < indices.length; i++) {
          if (indices[i] === mlpIdx) { continue; }
          const idxVolume = measurements[indices[i]].title.startsWith("SW") ? await getSubTrim(indices[i]) : await getSpeakerTrim(indices[i]);
          const delta = idxVolume - mlpVolume;
          if (Math.abs(delta) > 5) {
            const correction = Math.round(delta / 6) * 6;
            console.warn(`${measurements[indices[i]].title} shifted by ${correction}dB due to a known MultEQ volume bug.`);
            await postNext('Add SPL offset', indices[i], { offset: correction });
          }
        }
      }

      async function getDynamicBassFill(idx) {
        // vs -from target curve (start and end)
        const startFreq = Math.round(await getLow3dBPoint(idx, modeSubXOMin, modeSubXOMax));
        const endFreq = Math.round(await getHigh3dBPoint(idx, modeSubXOMin, modeSubXOMax));
        const subFreqResponse = await fetchSafe('frequency-response?smoothing=1%2F6&ppo=96', idx);
        const subArray = response2array(subFreqResponse, startFreq, endFreq);
        const targetArray = response2array(targetResponse, startFreq, endFreq);
        const arrayLength = Math.min(subArray.length, targetArray.length);
        let totalDips = 0;
        for (let i = 0; i < arrayLength; i++) {
          totalDips += Math.min(subArray[i] - targetArray[i], 0);
        }
        const dynamicBassFill = Math.round(-2 * (totalDips / arrayLength)) / 2; // round to nearest 0.5
        return dynamicBassFill;
      }

      async function align4system(ind1, ind2) {
        // const start = Math.round(xo / 2), end = Math.round(xo * 2);
        const start = 20, end = 250;
        // let [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        const [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        // loDelay = Math.max(-delaymax, Math.min(0, -Math.abs(loDelay))); // force negative
        // hiDelay = Math.max(0, Math.min(delaymax, Math.abs(hiDelay)));   // force positive
        console.info(`Available delay range: ${loDelay.toFixed(2)}ms <-> ${hiDelay.toFixed(2)}ms`);
        let isInverted = false, isPossible = false, requiredDelay = NaN, bestFreq = NaN, maxSum = -Infinity;
        await postNext('Smooth', ind1, { smoothing: "Var" });
        await postNext('Smooth', ind2, { smoothing: "Var" });
        await postSafe("http://localhost:4735/alignment-tool/index-a", ind1, "selected as measurement A");
        await postSafe("http://localhost:4735/alignment-tool/index-b", ind2, "selected as measurement B");
        await postAlign('Reset all');
        await postSafe("http://localhost:4735/alignment-tool/mode", "Impulse", "Mode set");
        await postSafe("http://localhost:4735/alignment-tool/max-negative-delay", loDelay, "Maximum negative delay set to");
        await postSafe("http://localhost:4735/alignment-tool/max-positive-delay", hiDelay, "Maximum positive delay set to");
        console.info("Starting...")
        for (let checkFreq = 20; checkFreq <= 250; checkFreq++) {
          const postAlignResult = await postAlign('Align IRs', checkFreq);
          if (postAlignResult.message === 'Delay too large') { continue; }

          const invertB = await fetchAlign('invert-b');
          const delayB = parseFloat(await fetchAlign('delay-b'));
          if (noInversion && invertB) { continue; };

          // const tempSum = await fetchAlign('aligned-frequency-response?smoothing=Psy&ppo=96');
          const tempSum = await fetchAlign('aligned-frequency-response?smoothing=1/6&ppo=96');
          const tempSumArray = response2array(tempSum, start, end);
          const tempMagSum = tempSumArray.reduce((acc, val) => acc + val, 0);
          if (maxSum < tempMagSum) {
            maxSum = tempMagSum;
            bestFreq = checkFreq;
            isPossible = true;
            requiredDelay = delayB;
            isInverted = invertB;
          }
          const bestDelayStr = isNaN(requiredDelay) ? "N/A" : requiredDelay.toFixed(2);
          const bestFreqStr = isNaN(bestFreq) ? "N/A" : bestFreq;
          console.infoUpdate(`Checking: @${checkFreq}Hz, Best: ${bestDelayStr}ms @${bestFreqStr}hz Inverted: ${isInverted}`);
        }
        if (isPossible) {
          const postAlignResult = await postAlign('Align IRs', bestFreq);
          const delayB = await fetchAlign('delay-b');
          requiredDelay = parseFloat(delayB);
          isInverted = await fetchAlign('invert-b');
          const alignedSum = await postAlign('Aligned sum');
          const parsed = JSON.parse(alignedSum.message);
          const key = Object.keys(parsed.results)[0];
          const sumIndex = parseInt(key);
          await postDelete(sumIndex);
          console.infoUpdate(`Optimal alignment: @${bestFreq}Hz, required delay: ${requiredDelay.toFixed(2)}ms, isInverted: ${isInverted}`);
        }
        RP22subrequiredDelay = requiredDelay;
        return [isPossible, requiredDelay, isInverted];
      }

      async function alignMsub(ind1, ind2, start, end, loDelay, hiDelay) {
        console.info(`Available delay range: ${loDelay.toFixed(2)}ms <-> ${hiDelay.toFixed(2)}ms`);
        let isInverted = false, isPossible = false, requiredDelay = NaN, bestFreq = NaN, maxSum = -Infinity, sumIndex = null;
        // await postNext('Smooth', ind1, { smoothing: "Var" });
        // await postNext('Smooth', ind2, { smoothing: "Var" });
        await postNext('Smooth', ind1, { smoothing: "1/48" });
        await postNext('Smooth', ind2, { smoothing: "1/48" });
        await postSafe("http://localhost:4735/alignment-tool/index-a", ind1, "selected as measurement A");
        await postSafe("http://localhost:4735/alignment-tool/index-b", ind2, "selected as measurement B");
        await postAlign('Reset all');
        await postSafe("http://localhost:4735/alignment-tool/mode", "Impulse", "Mode set");
        await postSafe("http://localhost:4735/alignment-tool/max-negative-delay", loDelay, "Maximum negative delay set to");
        await postSafe("http://localhost:4735/alignment-tool/max-positive-delay", hiDelay, "Maximum positive delay set to");
        console.info("Starting alignment optimization...");
        for (let checkFreq = 20; checkFreq <= 250; checkFreq++) {
          const postAlignResult = await postAlign('Align IRs', checkFreq);
          // Handle delay too large errors (improved from newer version)
          if (postAlignResult.message === 'Delay too large' && previousDelay != postAlignResult.delay) {
            previousDelay = postAlignResult.delay;
            continue;
          }
          const invertB = await fetchAlign('invert-b');
          const delayB = parseFloat(await fetchAlign('delay-b'));
          // Skip if inversion is not allowed
          if (noInversion && invertB) {
            continue;
          }
          // Get aligned frequency response with consistent smoothing (from newer version)
          const tempSum = await fetchAlign('aligned-frequency-response?smoothing=1%2F6&ppo=96');
          const tempSumArray = response2array(tempSum, start, end);
          const tempMagSum = tempSumArray.reduce((acc, val) => acc + val, 0);
          if (maxSum < tempMagSum) {
            maxSum = tempMagSum;
            bestFreq = checkFreq;
            isPossible = true;
            requiredDelay = delayB;
            isInverted = invertB;
          }
          // Better progress reporting (from newer version approach)
          const bestDelayStr = isNaN(requiredDelay) ? "N/A" : requiredDelay.toFixed(2);
          const bestFreqStr = isNaN(bestFreq) ? "N/A" : bestFreq;
          console.infoUpdate(`Checking: @${checkFreq}Hz, Best: ${bestDelayStr}ms @${bestFreqStr}Hz Inverted: ${isInverted}`);
        }
        if (isPossible) {
          // Apply optimal alignment
          const postAlignResult = await postAlign('Align IRs', bestFreq);
          const delayB = await fetchAlign('delay-b');
          requiredDelay = parseFloat(delayB);
          isInverted = await fetchAlign('invert-b');
          // Get updated measurements and create aligned sum
          const measurements = await fetch_mREW();
          const mCount = Object.keys(measurements).length;
          const alignedSum = await postAlign('Aligned sum');
          const parsed = JSON.parse(alignedSum.message);
          const key = Object.keys(parsed.results)[0];
          sumIndex = parseInt(key);
          console.infoUpdate(`Optimal alignment: @${bestFreq}Hz, required delay: ${requiredDelay.toFixed(2)}ms, isInverted: ${isInverted}`);
        } else {
          console.warn("No suitable alignment found within delay constraints");
        }
        return [isPossible, requiredDelay, isInverted, sumIndex];
      }

      async function genSub(i, freq) {
        // if no freq provided, just copy response
        if (!freq) {
          return await postSafe(`${baseUrl}/${i}/command`, { command: "Response copy" }, "Completed");
        }
        await postSafe(`${baseUrl}/${i}/filters`, {
          filters: [{
            "index": 21,
            "type": "Low pass",
            "enabled": true,
            "isAuto": false,
            "frequency": freq,
            "shape": "L-R",
            "slopedBPerOctave": 24
          }]
        }, "Filters set");
        return await postNext('Generate predicted measurement', i);
      }

      async function genSpeaker(i, freq) {
        // if no freq provided, just copy response
        if (!freq) {
          return await postSafe(`${baseUrl}/${i}/command`, { command: "Response copy" }, "Completed");
        }
        await postSafe(`${baseUrl}/${i}/filters`, {
          filters: [{
            "index": 21,
            "type": "High pass",
            "enabled": true,
            "isAuto": false,
            "frequency": freq,
            "shape": "BU",
            "slopedBPerOctave": 12
          }]
        }, "Filters set");
        return await postNext('Generate predicted measurement', i);
      }

      // ═══════════════════════════════════════════════════════════════════════════
      // NART > ART-INSPIRED MULTI-SPEAKER BASS OPTIMIZATION
      // Place these functions AFTER your SBIR detection functions
      // Call them in the order specified below
      // ═══════════════════════════════════════════════════════════════════════════

      // ───────────────────────────────────────────────────────────────────────────
      // HELPER: Extract phase data from REW response (moved from finalizeXO scope)
      // ───────────────────────────────────────────────────────────────────────────
      function response2arrayPhase(response, start, end) {
        if (!response.phase) {
          return null;
        }
        const bytes = Uint8Array.from(atob(response.phase), (c) => c.charCodeAt(0));
        const buffer = bytes.buffer;
        const data = new DataView(buffer);
        const phaseArray = [];
        const maxIndex = Math.floor(data.byteLength / 4) - 1;
        const startIndex = Math.round((start - 0.3662109375) / 0.3662109375);
        const endIndex = Math.min(Math.round((end - 0.3662109375) / 0.3662109375), maxIndex);
        for (let i = startIndex; i <= endIndex; i++) {
          if (i * 4 + 3 < data.byteLength) {
            phaseArray.push(data.getFloat32(i * 4));
          }
        }
        // Additional unwrapping in case REW unwrap didn't catch everything
        for (let i = 1; i < phaseArray.length; i++) {
          let diff = phaseArray[i] - phaseArray[i - 1];
          while (diff > 180) {
            phaseArray[i] -= 360;
            diff = phaseArray[i] - phaseArray[i - 1];
          }
          while (diff < -180) {
            phaseArray[i] += 360;
            diff = phaseArray[i] - phaseArray[i - 1];
          }
        }
        return phaseArray;
      }

      // ───────────────────────────────────────────────────────────────────────────
      // STEP 1: Enhanced Room Mode Detection (beyond SBIR boundary interference)
      // ───────────────────────────────────────────────────────────────────────────
      async function analyzeRoomModesEnhanced() {
        console.log("├─ ANALYZING ROOM MODES (Standing Waves)...");
        console.log("═".repeat(60));

        const roomModes = {
          axial: [],      // Between two parallel surfaces
          tangential: [], // Between four surfaces  
          oblique: [],    // Between all six surfaces
          speakers: {}    // Modal data per speaker
        };

        // Analyze each speaker's modal response
        for (let i = 1; i <= nSpeakers; i++) {
          const speakerId = commandId[i];
          console.info(`Analyzing ${speakerId} for room modes...`);

          const response = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', i);
          const modes = await detectModalFrequencies(response, i);

          if (modes.length > 0) {
            roomModes.speakers[speakerId] = {
              speakerIndex: i,
              modes: modes,
              position: customDistance[i]
            };

            console.log(`├─ ${speakerId}: Found ${modes.length} modal frequencies`);
            modes.forEach(mode => {
              console.log(`   ├─ ${mode.frequency.toFixed(1)}Hz: ${mode.type}, ${mode.isPositive ? 'PEAK' : 'DIP'} ${Math.abs(mode.magnitude).toFixed(1)}dB`);
            });
          }
        }

        // Store globally for use by other functions
        window.detectedRoomModes = roomModes;

        console.log("");
        console.log("📊 ROOM MODE SUMMARY:");
        const allModes = Object.values(roomModes.speakers)
          .flatMap(s => s.modes)
          .map(m => m.frequency)
          .filter((f, i, arr) => arr.indexOf(f) === i)
          .sort((a, b) => a - b);

        console.log(`Total unique modal frequencies detected: ${allModes.length}`);
        if (allModes.length > 0) {
          console.log(`Frequency range: ${allModes[0].toFixed(1)}Hz - ${allModes[allModes.length - 1].toFixed(1)}Hz`);
        }

        return roomModes;
      }

      // Helper: Detect modal frequencies from response
      async function detectModalFrequencies(response, measurementIdx, start = 20, end = 150) {
        const fullResponse = response2array(response, start, end);
        const modes = [];
        let freq = start;
        const octave = Math.pow(2, 1 / 96);

        // Calculate average level for reference
        const avgLevel = fullResponse.reduce((sum, val) => sum + val, 0) / fullResponse.length;

        // Find peaks (positive modes) and dips (negative modes)
        for (let i = 2; i < fullResponse.length - 2; i++) {
          freq *= octave;

          // Look for local maxima (peaks)
          if (fullResponse[i] > fullResponse[i - 1] &&
            fullResponse[i] > fullResponse[i + 1] &&
            fullResponse[i] > fullResponse[i - 2] &&
            fullResponse[i] > fullResponse[i + 2] &&
            fullResponse[i] > avgLevel + 3) { // At least 3dB above average

            modes.push({
              frequency: freq,
              magnitude: fullResponse[i] - avgLevel,
              isPositive: true,
              type: classifyMode(freq),
              index: i
            });
          }

          // Look for local minima (dips)
          if (fullResponse[i] < fullResponse[i - 1] &&
            fullResponse[i] < fullResponse[i + 1] &&
            fullResponse[i] < fullResponse[i - 2] &&
            fullResponse[i] < fullResponse[i + 2] &&
            fullResponse[i] < avgLevel - 3) { // At least 3dB below average

            modes.push({
              frequency: freq,
              magnitude: fullResponse[i] - avgLevel,
              isPositive: false,
              type: classifyMode(freq),
              index: i
            });
          }
        }

        return modes;
      }

      // Classify mode type based on frequency
      function classifyMode(frequency) {
        if (frequency < 60) return 'axial';
        if (frequency < 100) return 'tangential';
        return 'oblique';
      }

      // ───────────────────────────────────────────────────────────────────────────
      // STEP 2: Multi-Speaker Bass Optimization (NART > ART-inspired)
      // ───────────────────────────────────────────────────────────────────────────
      async function optimizeMultiSpeakerBass() {
        if (noSub) {
          console.log("⚠️ No subwoofer detected - skipping multi-speaker bass optimization");
          return;
        }

        console.log("");
        console.log("🔊 NART MULTI-SPEAKER BASS OPTIMIZATION");
        console.log("═".repeat(60));
        console.log("Analyzing which speakers can contribute to modal cancellation...");

        const roomModes = window.detectedRoomModes;
        if (!roomModes || Object.keys(roomModes.speakers).length === 0) {
          console.warn("No room mode data available - run analyzeRoomModesEnhanced() first");
          return;
        }

        // Identify bass-capable speakers (can play below 150Hz)
        const bassCapableSpeakers = [];

        for (let i = 1; i <= nSpeakers; i++) {
          const lowPoint = await getAbsLow3dBPointForSpk(i, 20, 150, true);  // for NART=true
          const highPoint = await getAbsHigh3dBPointForSpk(i, 20, 150);

          if (highPoint >= 100) { // Can reach at least 100Hz
            bassCapableSpeakers.push({
              index: i,
              commandId: commandId[i],
              lowExtension: lowPoint,
              highExtension: highPoint
            });
            console.log(`├─ ${commandId[i]}: Bass capable (${lowPoint.toFixed(0)}Hz - ${highPoint.toFixed(0)}Hz)`);
          }
        }

        if (bassCapableSpeakers.length === 0) {
          console.warn("No bass-capable speakers found for optimization");
          return;
        }

        console.log("");
        console.log(`✓ Found ${bassCapableSpeakers.length} bass-capable speakers`);
        console.log("Calculating optimal multi-speaker alignment for modal control...");
        console.log("");

        // Optimize in frequency bands (ART-style)
        const optimizationResults = {
          '20-60Hz': await optimizeBassInBand(bassCapableSpeakers, 20, 60, 'axial'),
          '60-100Hz': await optimizeBassInBand(bassCapableSpeakers, 60, 100, 'tangential'),
          '100-150Hz': await optimizeBassInBand(bassCapableSpeakers, 100, 150, 'oblique')
        };

        // Store results globally
        window.multiSpeakerBassOptimization = optimizationResults;

        // Display results
        console.log("");
        console.log("📊 OPTIMIZATION RESULTS:");
        console.log("─".repeat(60));
        for (const [band, result] of Object.entries(optimizationResults)) {
          console.log("");
          console.log(`${band}:`);
          console.log(`├─ Improvement: ${result.improvement.toFixed(1)}dB reduction in modal peaks`);
          console.log(`├─ Speakers contributing: ${result.contributingSpeakers.join(', ')}`);
          if (result.recommendedDelays && Object.keys(result.recommendedDelays).length > 0) {
            console.log(`├─ Recommended delay adjustments:`);
            for (const [spkr, delay] of Object.entries(result.recommendedDelays)) {
              console.log(`   ├─ ${spkr}: ${delay.toFixed(2)}ms`);
            }
          }
        }

        return optimizationResults;
      }

      // Optimize bass response in a specific frequency band
      async function optimizeBassInBand(bassCapableSpeakers, startFreq, endFreq, modeType) {
        console.log(`Optimizing ${startFreq}-${endFreq}Hz (${modeType} modes)...`);

        const measurements = await fetch_mREW();
        const contributingSpeakers = [];
        const recommendedDelays = {};

        // Get subwoofer response as baseline
        const subResponse = await fetchSafe('frequency-response?smoothing=1%2F12&ppo=96', nChannels);
        const subArray = response2array(subResponse, startFreq, endFreq);
        const subModalPeaks = calculateModalPeaks(subArray);

        console.log(`├─ Subwoofer modal peaks in band: ${subModalPeaks.toFixed(1)}dB`);

        // Test each bass-capable speaker's contribution
        let bestImprovement = 0;

        for (const speaker of bassCapableSpeakers) {
          // ✓ Skip ONLY if speaker's range doesn't overlap the band at all
          if (speaker.highExtension < startFreq) {
            // Speaker's highest frequency is below the band - truly can't contribute
            continue;
          }

          const spkResponse = await fetchSafe('frequency-response?smoothing=1%2F12&ppo=96', speaker.index);
          const spkArray = response2array(spkResponse, startFreq, endFreq);

          // Test phase alignments: 0°, 90°, 180°, 270°
          const phaseTests = [
            { phase: 0, delay: 0, invert: false },
            { phase: 90, delay: 0.25 * (1000 / ((startFreq + endFreq) / 2)), invert: false },
            { phase: 180, delay: 0, invert: true },
            { phase: 270, delay: 0.75 * (1000 / ((startFreq + endFreq) / 2)), invert: false }
          ];

          /*
          const phaseTests = [];
          const centerFreq = (startFreq + endFreq) / 2;
          const wavelengthMs = 1000 / centerFreq;

          // Test delays in 1ms increments from -10ms to +10ms
          for (let delayMs = -10; delayMs <= 10; delayMs += 1) {
            phaseTests.push({
              phase: (delayMs / wavelengthMs) * 360,
              delay: delayMs,
              invert: false
            });
          }
          */

          for (const test of phaseTests) {
            // Simulate combined response
            const combinedArray = subArray.map((val, idx) => {
              let spkContribution = spkArray[idx];
              if (test.invert) spkContribution *= -1;
              return val + spkContribution;
            });

            const combinedModalPeaks = calculateModalPeaks(combinedArray);
            const improvement = subModalPeaks - combinedModalPeaks;

            if (improvement > bestImprovement) {
              bestImprovement = improvement;
              recommendedDelays[speaker.commandId] = test.delay;

              if (!contributingSpeakers.includes(speaker.commandId)) {
                contributingSpeakers.push(speaker.commandId);
              }
            }
          }
        }

        console.log(`├─ Best improvement: ${bestImprovement.toFixed(1)}dB with ${contributingSpeakers.length} speakers`);

        return {
          band: `${startFreq}-${endFreq}Hz`,
          modeType: modeType,
          improvement: bestImprovement,
          contributingSpeakers: contributingSpeakers,
          recommendedDelays: recommendedDelays,
          baselineModalPeaks: subModalPeaks
        };
      }

      // Calculate sum of modal peaks (how "peaky" the response is)
      function calculateModalPeaks(responseArray) {
        const avgLevel = responseArray.reduce((sum, val) => sum + val, 0) / responseArray.length;
        let peakSum = 0;

        for (let i = 0; i < responseArray.length; i++) {
          const deviation = responseArray[i] - avgLevel;
          if (deviation > 0) { // Only count peaks
            peakSum += deviation;
          }
        }

        return peakSum / responseArray.length;
      }

      // ───────────────────────────────────────────────────────────────────────────
      // STEP 3: Frequency-Dependent Alignment (replaces/enhances optimizeSubDelay)
      // ───────────────────────────────────────────────────────────────────────────
      async function frequencyDependentAlignment() {
        if (noSub) {
          console.log("⚠️ No subwoofer - skipping frequency-dependent alignment");
          return;
        }

        console.log("");
        console.log("🎛️ NART FREQUENCY-DEPENDENT ALIGNMENT");
        console.log("═".repeat(60));
        console.log("Using different alignment strategies per frequency band...");

        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;

        // Define frequency bands with different alignment strategies
        const bands = [
          {
            name: "Deep Bass (20-40Hz)",
            start: 20,
            end: 40,
            strategy: "maximize_output",
            description: "Maximize total output (ignore phase)"
          },
          {
            name: "Low Bass (40-80Hz)",
            start: 40,
            end: 80,
            strategy: "phase_coherent",
            description: "Phase-coherent alignment (smoothness)"
          },
          {
            name: "Upper Bass (80-150Hz)",
            start: 80,
            end: 150,
            strategy: "precise_timing",
            description: "Precise timing alignment (localization)"
          }
        ];

        const alignmentResults = [];

        for (const band of bands) {
          console.log("");
          console.log(`${band.name}:`);
          console.log(`├─ Strategy: ${band.strategy}`);
          console.log(`├─ Goal: ${band.description}`);

          // Find the averaged measurements (created in groundWorks)
          let speakerIndices = [];
          const measurements = await fetch_mREW();
          for (let i = 1; i <= nSpeakers; i++) {
            const title = measurements[i]?.title;
            if (title && title.endsWith('o')) {  // Averaged measurements end with 'o'
              speakerIndices.push(i);
            }
          }
          console.warn(`[DEBUG] >> ├─ Found ${speakerIndices.length} averaged speaker measurements`);

          if (speakerIndices.length === 0) {
            console.warn("No speaker measurements found - skipping band");
            continue;
          }

          console.info(`├─ Using ${speakerIndices.length} speaker measurements`);

          const avgSpeaker = await postNext('Magn plus phase average', Array.from(speakerIndices));
          const avgSpeakerIdx = Object.keys(avgSpeaker.results)[0];

          // Find the subwoofer index
          let subIdx = nChannels;

          // If we have directional bass (multiple subs), use the first one for now
          if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
            subIdx = nSpeakers + 1; // First subwoofer
          }

          console.info(`├─ Using subwoofer index: ${subIdx}`);

          // Apply strategy-specific alignment
          let result;
          switch (band.strategy) {
            case "maximize_output":
              result = await alignForMaxOutput(avgSpeakerIdx, subIdx, band.start, band.end);
              break;
            case "phase_coherent":
              result = await alignForPhaseCoherence(avgSpeakerIdx, subIdx, band.start, band.end);
              break;
            case "precise_timing":
              result = await alignForPreciseTiming(avgSpeakerIdx, subIdx, band.start, band.end);
              break;
          }

          alignmentResults.push({
            band: band.name,
            frequency: `${band.start}-${band.end}Hz`,
            strategy: band.strategy,
            ...result
          });

          // Cleanup
          await postDelete(avgSpeakerIdx);

          console.log(`└─ Result: ${result.requiredDelay.toFixed(2)}ms delay, inverted: ${result.isInverted}`);
        }

        // Calculate weighted average delay (prioritize crossover region)
        const weightedDelay = calculateWeightedDelay(alignmentResults);
        const finalInversion = alignmentResults.find(r => r.strategy === 'phase_coherent').isInverted;

        console.log("\n🎯 FINAL ALIGNMENT:");
        console.log(`├─ Weighted average delay: ${weightedDelay.toFixed(2)}ms`);
        console.log(`├─ Subwoofer inversion: ${finalInversion ? 'YES' : 'NO'}`);

        // Apply the alignment to the actual subwoofer measurement
        const actualSubIdx = window.hasDirectionalBass ? nSpeakers + 1 : nChannels;

        if (finalInversion) {
          await postSafe(`${baseUrl}/${actualSubIdx}/command`, { command: "Invert" }, "Invert completed");
        }

        const subMoves = weightedDelay / delaymax;
        await postNext('Offset t=0', actualSubIdx, { offset: -subMoves, unit: "seconds" });

        // Update all subs if directional
        if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            mSec[i] += subMoves;
            invertSub[i] = finalInversion;
          }
        } else {
          mSec[nChannels] += subMoves;
          invertSub[nChannels] = finalInversion;
        }

        console.log("└─ ✓ Frequency-dependent alignment applied\n");

        return { alignmentResults, finalDelay: weightedDelay, finalInversion };
      }

      // Strategy 1: Maximize output (vector sum magnitude)
      async function alignForMaxOutput(speakerIdx, subIdx, startFreq, endFreq) {
        console.info(`   Optimizing for maximum output...`);

        await postNext('Smooth', speakerIdx, { smoothing: "1/12" });
        await postNext('Smooth', subIdx, { smoothing: "1/12" });

        // const [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        // Use appropriate delay range based on whether we have directional subs
        let loDelay, hiDelay;
        if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
          [loDelay, hiDelay] = getDelayRangeOf(mSec[nSpeakers + 1], 1, nSpeakers);
        } else {
          [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        }
        let maxOutput = -Infinity;
        let bestDelay = 0;
        let bestInvert = false;

        // Test delays
        for (let testDelay = loDelay; testDelay <= hiDelay; testDelay += 0.5) {
          for (const invert of [false, true]) {
            if (noInversion && invert) continue;

            // Simulate alignment
            const output = await simulateAlignment(speakerIdx, subIdx, testDelay, invert, startFreq, endFreq);

            if (output > maxOutput) {
              maxOutput = output;
              bestDelay = testDelay;
              bestInvert = invert;
            }
          }
        }

        return {
          requiredDelay: bestDelay,
          isInverted: bestInvert,
          metric: maxOutput,
          metricName: "Total Output (dB)"
        };
      }

      // Strategy 2: Phase coherence (minimize phase variation)
      async function alignForPhaseCoherence(speakerIdx, subIdx, startFreq, endFreq) {
        console.info(`   Optimizing for phase coherence...`);

        // Reuse your existing align4system logic but focus on phase linearity
        await postNext('Smooth', speakerIdx, { smoothing: "Var" });
        await postNext('Smooth', subIdx, { smoothing: "Var" });

        await postSafe("http://localhost:4735/alignment-tool/index-a", speakerIdx, "selected as measurement A");
        await postSafe("http://localhost:4735/alignment-tool/index-b", subIdx, "selected as measurement B");
        await postAlign('Reset all');

        // const [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        // Use appropriate delay range based on whether we have directional subs
        let loDelay, hiDelay;
        if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
          [loDelay, hiDelay] = getDelayRangeOf(mSec[nSpeakers + 1], 1, nSpeakers);
        } else {
          [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        }
        await postSafe("http://localhost:4735/alignment-tool/mode", "Impulse", "Mode set");
        await postSafe("http://localhost:4735/alignment-tool/max-negative-delay", loDelay, "Maximum negative delay set to");
        await postSafe("http://localhost:4735/alignment-tool/max-positive-delay", hiDelay, "Maximum positive delay set to");

        let bestPhaseCoherence = Infinity;
        let bestDelay = 0;
        let bestInvert = false;

        // Scan through band
        for (let checkFreq = startFreq; checkFreq <= endFreq; checkFreq += 5) {
          const postAlignResult = await postAlign('Align IRs', checkFreq);
          if (postAlignResult.message === 'Delay too large') continue;

          const invertB = await fetchAlign('invert-b');
          const delayB = parseFloat(await fetchAlign('delay-b'));
          if (noInversion && invertB) continue;

          // Measure phase coherence
          const tempSum = await fetchAlign('aligned-frequency-response?smoothing=Var&ppo=96');
          const phaseCoherence = measurePhaseCoherence(tempSum, startFreq, endFreq);

          if (phaseCoherence < bestPhaseCoherence) {
            bestPhaseCoherence = phaseCoherence;
            bestDelay = delayB;
            bestInvert = invertB;
          }
        }

        return {
          requiredDelay: bestDelay,
          isInverted: bestInvert,
          metric: bestPhaseCoherence,
          metricName: "Phase Variation (degrees)"
        };
      }

      // Strategy 3: Precise timing (group delay alignment)
      async function alignForPreciseTiming(speakerIdx, subIdx, startFreq, endFreq) {
        console.info(`   Optimizing for precise timing...`);

        // Use group delay for precise timing alignment
        const speakerGD = await fetchSafe(`group-delay?smoothing=1/6`, speakerIdx);
        const subGD = await fetchSafe(`group-delay?smoothing=1/6`, subIdx);

        const spkGDArray = response2array(speakerGD, startFreq, endFreq);
        const subGDArray = response2array(subGD, startFreq, endFreq);

        // Calculate average group delay difference
        const avgGDDiff = spkGDArray.reduce((sum, val, idx) =>
          sum + (val - subGDArray[idx]), 0) / spkGDArray.length;

        const requiredDelay = avgGDDiff * 1000; // Convert to ms
        // const [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        // Use appropriate delay range based on whether we have directional subs
        let loDelay, hiDelay;
        if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
          [loDelay, hiDelay] = getDelayRangeOf(mSec[nSpeakers + 1], 1, nSpeakers);
        } else {
          [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        }

        // Constrain to available range
        const finalDelay = Math.max(loDelay, Math.min(hiDelay, requiredDelay));

        return {
          requiredDelay: finalDelay,
          isInverted: false,
          metric: Math.abs(avgGDDiff),
          metricName: "Group Delay Match (ms)"
        };
      }

      // Helper: Simulate alignment and return output level
      async function simulateAlignment(speakerIdx, subIdx, delay, invert, startFreq, endFreq) {
        // This is a simplified simulation - in practice you'd use REW's alignment tool
        const spkResponse = await fetchSafe('frequency-response?smoothing=1%2F12&ppo=96', speakerIdx);
        const subResponse = await fetchSafe('frequency-response?smoothing=1%2F12&ppo=96', subIdx);

        const spkArray = response2array(spkResponse, startFreq, endFreq);
        const subArray = response2array(subResponse, startFreq, endFreq);

        // Simplistic magnitude sum (real implementation would use complex math)
        let totalOutput = 0;
        for (let i = 0; i < spkArray.length; i++) {
          const spkMag = Math.pow(10, spkArray[i] / 20);
          let subMag = Math.pow(10, subArray[i] / 20);
          if (invert) subMag *= -1;

          const combined = spkMag + subMag;
          totalOutput += 20 * Math.log10(Math.abs(combined));
        }

        return totalOutput / spkArray.length;
      }

      // Helper: Measure phase coherence (lower is better)
      function measurePhaseCoherence(response, startFreq, endFreq) {
        const phaseArray = response2arrayPhase(response, startFreq, endFreq);
        if (!phaseArray) return Infinity;

        // Calculate phase variation
        let maxPhaseChange = 0;
        for (let i = 1; i < phaseArray.length; i++) {
          const change = Math.abs(phaseArray[i] - phaseArray[i - 1]);
          maxPhaseChange = Math.max(maxPhaseChange, change);
        }

        return maxPhaseChange;
      }

      // Calculate weighted average delay (prioritize crossover region 60-100Hz)
      function calculateWeightedDelay(alignmentResults) {
        const weights = {
          "Deep Bass (20-40Hz)": 0.2,
          "Low Bass (40-80Hz)": 0.5,    // Highest weight - crossover region
          "Upper Bass (80-150Hz)": 0.3
        };

        let weightedSum = 0;
        let totalWeight = 0;

        for (const result of alignmentResults) {
          const weight = weights[result.band] || 0.33;
          weightedSum += result.requiredDelay * weight;
          totalWeight += weight;
        }

        return weightedSum / totalWeight;
      }

      // ═══════════════════════════════════════════════════════════════════════════
      // INTEGRATION HELPER: Modified optimizeSubDelay() replacement
      // ═══════════════════════════════════════════════════════════════════════════
      async function optimizeSubDelayART() {
        console.log("");
        console.log("╔═══════════════════════════════════════════════════════════════╗");
        console.log("║  NART > ART-INSPIRED BASS OPTIMIZATION                        ║");
        console.log("╚═══════════════════════════════════════════════════════════════╝");

        // Check if we have directional subs that need special handling
        if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
          console.log(`├─ Detected ${window.preCombinedSubCount} directional subwoofers`);
          console.log("ART will optimize each subwoofer independently before combining");
        }

        // Step 1: Analyze room modes (enhanced version)
        await analyzeRoomModesEnhanced();

        // Step 2: Optimize multi-speaker bass (all capable speakers + individual subs)
        await optimizeMultiSpeakerBass();

        // Step 3: Frequency-dependent alignment (on individual subs if directional)
        await frequencyDependentAlignment();

        console.log("✓ NART > ART-INSPIRED bass optimization complete!");

        if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
          console.log(`✓ Optimized ${window.preCombinedSubCount} subwoofers independently`);
          console.log("They will be combined in the next step with optimized alignment preserved\n");
        }
      }

      // ───────────────────────────────────────────────────────────────────────────
      // Convert directional bass AFTER ART optimization
      // ───────────────────────────────────────────────────────────────────────────
      async function convertDirectionalIfNeeded() {
        if (!window.hasDirectionalBass || window.preCombinedSubCount <= 1) {
          console.info("✓ No directional bass conversion needed");
          return;
        }
        console.log("\n⚡ CONVERTING DIRECTIONAL BASS TO STANDARD (Post-Optimization)");
        console.log("═".repeat(60));
        console.warn("Converting optimized directional subs to combined standard bass...");

        window.nartOptimizationComplete = true;
        await directional2standard();

        console.warn("✓ Directional to standard conversion completed");
        console.log("═".repeat(60));
      }

      async function drawResults() {
        console.log("Generating expected final outputs for each channel...");
        console.info("Starting...");
        for (let i = 1; i <= nSpeakers; i++) {
          console.infoUpdate(`Generating final output for channel - ${commandId[i]}`);
          const isLarge = customCrossover[i] === "L";
          let finalResponseName = commandId[i] + "final";
          finalResponseName += (commandId[i] === "C" && AdvancedFilters && AdvancedFiltersType === "DIALOGadvanced") ? "-ADF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "HLOSSresearch") ? "-AHF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "HLOSSmoderate") ? "-AHF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "HLOSSsevere") ? "-AHF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "HLOSSoriginal") ? "-AHF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "GAMINGcompetitive") ? "-AGF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "GAMINGimmersive") ? "-AGF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "GAMINGvoice") ? "-AGF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "GAMINGbalanced") ? "-AGF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "CUSTOMadvanced") ? "-ACF" : "";
          finalResponseName += isLarge ? "-Large" : `-${customCrossover[i]}hz-xo`;
          const eqSpeaker = nChannels + 2 * i;
          const spWithHPF = await genSpeaker(eqSpeaker, customCrossover[i]);
          const spWithHPFIdx = (isLarge ? nChannels * 3 + i : Object.keys(spWithHPF.results)[0]);
          if (noSub) {
            await fetch_mREW(spWithHPFIdx, 'PUT', { title: finalResponseName });
            continue;
          }
          const subWithLPF = await genSub(nChannels * 3, customCrossover[i]);
          const subWithLPFIdx = Object.keys(subWithLPF.results)[0];
          const finalResponse = await postNext('Arithmetic', [spWithHPFIdx, subWithLPFIdx], { function: "A + B" });
          const finalResponseIdx = Object.keys(finalResponse.results)[0];
          await fetch_mREW(finalResponseIdx, 'PUT', { title: finalResponseName });
          await postDelete(subWithLPFIdx);
          await postDelete(spWithHPFIdx);
        }
        if (!noSub) {
          console.infoUpdate("Generating final output for channel - LFE");
          const LFEChannel = await genSub(nChannels * 3, 120);
          const LFEChannelIdx = Object.keys(LFEChannel.results)[0];
          await fetch_mREW(LFEChannelIdx, 'PUT', { title: "LFEfinal-120hz-LPF" });
        }
        // await fetchSafe('target-level', nChannels * 3, 75.0);
        await fetchSafe('target-level', nChannels * 3, targetLevel);
        const targetCurve = await postNext('Generate target measurement', nChannels * 3);
        const targetCurveIdx = Object.keys(targetCurve.results)[0];
        // const targetName = (targetCurveName === "" ? "TC-DEQ" : targetCurveName) + " @ 75dB";
        const targetName = `${targetCurveName === "" ? "TC-DEQ" : targetCurveName} @ ${String(targetLevel)}dB`;
        await fetch_mREW(targetCurveIdx, 'PUT', { title: targetName });
        // room curve no longer needed. keeping it enabled will only confuse on next run
        if (targetCurveName === "") { await disableRoomCurve(); }
        // use 1/6 smoothing for results
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i <= mCount; i++) {
          titleM = await fetch_mREW(i);
          const title = titleM.title;
          // if (title.endsWith("-filters") || title.endsWith(" @ 75dB")) { continue; }
          if (title.endsWith("-filters") || title.endsWith(` @ ${String(targetLevel)}dB`)) { continue; }
          await postNext('Smooth', i, { smoothing: "1/6" });
        }
        console.infoUpdate("Completed generating final outputs for all channels!");
      }

      async function updateAdy() {
        console.log("Starting ADY file processing...");
        function estimatePlaybackLevelSpeakers(dataView) {
          let avgSensitivity = 0;
          let count = 0;
          // Sample from middle range (mid frequencies)
          const maxSafeIndex = Math.floor(dataView.byteLength / 4) - 1;
          const startIndex = Math.min(200, maxSafeIndex);
          const endIndex = Math.min(800, maxSafeIndex);
          for (let k = startIndex; k <= endIndex; k++) {
            const value = dataView.getFloat32(k * 4);
            if (Number.isFinite(value) && Math.abs(value) < 100) {
              avgSensitivity += value;
              count++;
            }
          }
          avgSensitivity = count > 0 ? avgSensitivity / count : 0;
          return targetLevel + avgSensitivity;
        }
        function estimatePlaybackLevelSubwoofer(dataView) {
          let avgSensitivity = 0;
          let count = 0;
          // Sample from early indices (low frequencies are typically first)
          const maxSafeIndex = Math.floor(dataView.byteLength / 4) - 1;
          const endIndex = Math.min(50, maxSafeIndex); // Sample first 50 points for bass
          for (let k = 0; k <= endIndex; k++) {
            const value = dataView.getFloat32(k * 4);
            if (Number.isFinite(value) && Math.abs(value) < 100) {
              avgSensitivity += value;
              count++;
            }
          }
          avgSensitivity = count > 0 ? avgSensitivity / count : 0;
          return targetLevel + avgSensitivity;
        }
        for (let i = 1; i <= nSpeakers; i++) {
          if (customCrossover[i] === "L") { continue; };
          if (customCrossover[i] > 90) { customCrossover[i] /= 10; }
        }
        const jsonData = JSON.parse(adyContents);
        if (bassMode === "Directional") {
          let ii = 54;
          for (let i = nChannels - 1; i < jsonData.detectedChannels.length; i++) {
            const swChannel = jsonData.detectedChannels[i];
            swChannel.enChannelType = ii;
            ii++;
            if (swChannel.customCrossover) { delete swChannel.customCrossover };
            if (swChannel.customSpeakerType) { delete swChannel.customSpeakerType };
            if (swChannel.customTargetCurvePoints && (i != (nChannels - 1))) { delete swChannel.customTargetCurvePoints };
          }
        }
        jsonData.dynamicVolume = false;
        jsonData.lfc = false;
        jsonData.dynamicEq = (targetCurveName === "");
        jsonData.enTargetCurveType = 1;
        jsonData.detectedChannels.forEach((channel, index) => {
          const responseData = channel.responseData;
          const zerosArray = Array(16383).fill("0");
          zerosArray.unshift("1");
          let count = 0;
          for (const arrayKey in responseData) {
            if (responseData.hasOwnProperty(arrayKey)) {
              if (isCirrusLogic) {
                responseData[arrayKey] = antiMicCal;
              } else {
                responseData[arrayKey] = zerosArray;
              }
              if (count >= 3) {
                delete responseData[arrayKey];
              }
              count++;
            }
          }
          if (index > nSpeakers) {
            channel.responseData = {};
          }
        });
        const octave = Math.pow(2, 1 / 96);
        // Enhanced speaker processing with logging
        console.log("Processing main speakers...");
        for (let i = 1; i <= nSpeakers; i++) {
          const fltArray = [];
          const fltResponse = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', 2 * i + (nChannels - 1));
          const bytes = Uint8Array.from(atob(fltResponse.magnitude), c => c.charCodeAt(0));
          const buffer = bytes.buffer;
          const data = new DataView(buffer);
          // Estimate playback level and store in array (500-2000 Hz for speakers)
          const estimatedLevel = estimatePlaybackLevelSpeakers(data);
          console.log(`Speaker ${commandId[i]}: Estimated playback level ${estimatedLevel.toFixed(1)}dB`);
          // Store speaker ID and estimated level
          estimatedPlaybackLevels.push([commandId[i], estimatedLevel.toFixed(1)]);
          let freq = fltResponse.startFreq;
          for (let k = 0; k <= 1531; k++) {
            const fltMagnitude = data.getFloat32(k * 4);
            fltArray.push([freq, fltMagnitude + antiHFRolloff[k]]);
            freq *= octave;
          }
          // Store original values for logging
          const originalLevel = customLevel[i];
          const finalLevel = customLevel[i];
          const customTargetCurvePoints = fltArray.map(point => `{${point[0]}, ${point[1]}}`);
          const thisChannel = jsonData.detectedChannels.find(channel => channel.commandId === commandId[i]);
          thisChannel.customTargetCurvePoints = customTargetCurvePoints;
          thisChannel.midrangeCompensation = false;
          thisChannel.frequencyRangeRolloff = 20000;
          thisChannel.customLevel = customLevel[i].toFixed(1);
          thisChannel.customDistance = customDistance[i];
          thisChannel.customCrossover = customCrossover[i] === "L" ? "F" : String(customCrossover[i]);
          thisChannel.customSpeakerType = customCrossover[i] === "L" ? "L" : "S";
          thisChannel.channelReport.customEnSpeakerConnect = customCrossover[i] === "L" ? 2 : 1;
          // Enhanced logging
          console.warn(`Speaker ${commandId[i]}: FINAL TRIM VALUES: ${finalLevel.toFixed(1)}dB`);
          console.warn(`Speaker ${commandId[i]}: Distance: ${customDistance[i]}m, Crossover: ${thisChannel.customCrossover}, Type: ${thisChannel.customSpeakerType}`);
        }
        // Enhanced subwoofer processing with logging
        if (!noSub) {
          console.log("Processing subwoofer(s)...");
          const subArray = [];
          const subResponse = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', nChannels * 3 - 1);
          const bytesSub = Uint8Array.from(atob(subResponse.magnitude), c => c.charCodeAt(0));
          const bufferSub = bytesSub.buffer;
          const dataSub = new DataView(bufferSub);
          // Estimate subwoofer playback level and store in array (30-80 Hz for subwoofers)
          const subEstimatedLevel = estimatePlaybackLevelSubwoofer(dataSub);
          console.log(`Subwoofer: Estimated playback level ${subEstimatedLevel.toFixed(1)}dB`);
          estimatedPlaybackLevels.push(["Subwoofer", subEstimatedLevel.toFixed(1)]);
          let freq = subResponse.startFreq;
          for (let k = 0; k <= 1531; k++) {
            const subMagnitude = dataSub.getFloat32(k * 4);
            subArray.push([freq, subMagnitude]);
            freq *= octave;
          }
          const customTargetCurvePointsSub = subArray.map(point => `{${point[0]}, ${point[1]}}`);
          const subChannel = jsonData.detectedChannels[nChannels - 1];
          subChannel.customTargetCurvePoints = customTargetCurvePointsSub;
          let k = 0;
          for (let channel of jsonData.detectedChannels) {
            if (channel.commandId.startsWith("SW")) {
              const customDistanceValue = parseFloat(customDistance[nChannels + k]) - parseFloat(channel.delayAdjustment);
              const originalSubLevel = parseFloat(customLevel[nChannels + k]) + parseFloat(channel.trimAdjustment);
              let customLevelValue = originalSubLevel;
              channel.customDistance = Math.round(parseFloat(customDistanceValue) * 100) / 100;
              channel.customLevel = customLevelValue.toFixed(1);
              channel.frequencyRangeRolloff = 250;
              // Enhanced subwoofer logging
              console.warn(`${channel.commandId}: FINAL TRIM VALUES: ${customLevelValue.toFixed(1)}dB`);
              console.warn(`${channel.commandId}: Distance: ${channel.customDistance}m`);
              if (bassMode === "Directional") { k++ };
            }
          }
          if (bassMode === "Directional") {
            jsonData.subwooferLayout = "N/A";
            sOs === 343 ? jsonData.subwooferMode = "Standard" : jsonData.subwooferMode = "N/A";
          }
        }
        // LOG THE COLLECTED PLAYBACK LEVELS ARRAY
        console.log("Estimated Playback Levels Array:", estimatedPlaybackLevels);
        console.log("Array contents:");
        estimatedPlaybackLevels.forEach((item, index) => {
          console.log(`${index}: Speaker ${item[0]} = ${item[1]}dB`);
        });
        const ady = JSON.stringify(jsonData);
        const blob = new Blob([ady], { type: 'application/json' });
        const urlBlob = URL.createObjectURL(blob);
        let downloadLink;
        let downloadFileName;
        try {
          downloadLink = document.createElement("a");
          const now = new Date();
          const year = now.getFullYear();
          const month = String(now.getMonth() + 1).padStart(2, '0');
          const day = String(now.getDate()).padStart(2, '0');
          const hours = String(now.getHours()).padStart(2, '0');
          const minutes = String(now.getMinutes()).padStart(2, '0');
          const timestamp = `${year}-${month}${day}-${hours}${minutes}`;
          const tcName = targetCurveName === "" ? "DEQ" : targetCurveName;
          downloadLink.href = urlBlob;
          downloadFileName = getadyName(fileName, "_"
            + (AdvancedFiltersType === "DIALOGadvanced" ? "ADF_" : "")
            + (AdvancedFiltersType === "HLOSSresearch" ? "AHF_" : "")
            + (AdvancedFiltersType === "HLOSSmoderate" ? "AHF_" : "")
            + (AdvancedFiltersType === "HLOSSsevere" ? "AHF_" : "")
            + (AdvancedFiltersType === "HLOSSoriginal" ? "AHF_" : "")
            + (AdvancedFiltersType === "GAMINGcompetitive" ? "AGF_" : "")
            + (AdvancedFiltersType === "GAMINGimmersive" ? "AGF_" : "")
            + (AdvancedFiltersType === "GAMINGvoice" ? "AGF_" : "")
            + (AdvancedFiltersType === "GAMINGbalanced" ? "AGF_" : "")
            + (AdvancedFiltersType === "CUSTOMadvanced" ? "ACF_" : "")
            + (isRP22mode ? "RP22_" : "")
            + (isDolbymode ? "DOLBY_" : "")
            + (isTHXmode ? "THX_" : "")
            + (isIMAXmode ? "IMAX_" : "")
            + swInvMsg + `${tcName}_ClariQNext_${timestamp}.ady`);
          downloadLink.download = downloadFileName;
          downloadLink.style.display = "none";
          document.body.appendChild(downloadLink);
          downloadLink.click();
          document.body.removeChild(downloadLink);
        } finally {
          // Cleanup with a small delay to ensure download starts
          setTimeout(() => URL.revokeObjectURL(urlBlob), 300);
        }
        console.log("Processing completed successfully!");
        console.log(`ADY file generated: ${downloadFileName}`);  // Use downloadFileName instead
        // RETURN THE ARRAY IF NEEDED
        return estimatedPlaybackLevels;
      }

      // New fetch_mREW
      async function fetch_mREW(indice = null, method = 'GET', _body = null) {
        await platformDelay();  // Use your new helper
        let body;
        let requestUrl;
        if (indice === null) {
          requestUrl = baseUrl;
        } else {
          requestUrl = baseUrl + `/${indice}`;
        }
        if (method === 'PUT') {
          body = _body;
        }
        // Keep the exact same retry logic
        const maxRetries = 10;
        let retryCount = 0;
        while (retryCount < maxRetries) {
          try {
            const response = await fetch(requestUrl, {
              method: method,
              headers: { 'Content-Type': 'application/json' },
              body: body ? JSON.stringify(body) : null
            });

            if (!response.ok) {
              retryCount++;
              if (retryCount >= maxRetries) {
                throw new Error(`Max retries reached. Status: ${response.status}`);
              }
              await delay(retryDelay);  // Use your delay helper
            } else {
              const data = await response.json();
              return data;
            }
          } catch (error) {
            retryCount++;
            if (retryCount >= maxRetries) {
              throw new Error(`Network error after ${maxRetries} attempts: ${error.message}`);
            }
            await delay(retryDelay);  // Use your delay helper
          }
        }
      }

      // Enhanced fetchSafe with better cross-browser support
      async function fetchSafe(extUrl, indice, parameters = null) {
        await platformDelay();
        const requestUrl = `${baseUrl}/${indice}/${extUrl}`;
        let options;
        if (parameters === null) {
          options = {
            method: 'GET'
          };
        } else {
          options = {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(parameters)
          };
        }
        const maxRetries = 10;
        let retryCount = 0;
        while (retryCount < maxRetries) {
          try {
            const response = await safeFetch(requestUrl, options);

            if (!response.ok) {
              retryCount++;
              if (retryCount >= maxRetries) {
                throw new Error(`Max retries reached. Status: ${response.status}`);
              }
              await new Promise(resolve => setTimeout(resolve, retryDelay));
            } else {
              const data = await response.json();
              return data;
            }
          } catch (error) {
            retryCount++;
            if (retryCount >= maxRetries) {
              throw new Error(`Network error after ${maxRetries} attempts: ${error.message}`);
            }
            await new Promise(resolve => setTimeout(resolve, retryDelay));
          }
        }
      }

      async function fetchAlign(extUrl) {
        await platformDelay();
        try {
          const requestUrl = `http://localhost:4735/alignment-tool/${extUrl}`;
          const response = await fetch(requestUrl, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }
          const data = await response.json();
          return data;
        } catch (error) {
          throw new Error('Error fetching result:', error);
        }
      }

      async function postNext(processName, indices, parameters = null) {
        await platformDelay();  // Use your new helper
        let requestUrl;
        let body;
        if (Array.isArray(indices)) {
          requestUrl = `${baseUrl}/process-measurements`;
        } else {
          requestUrl = parameters === null ? `${baseUrl}/${indices}/eq/command` : `${baseUrl}/${indices}/command`;
        }
        if (requestUrl.endsWith('/command')) {
          body = { command: processName };
        } else {
          body = { processName: processName };
        }
        if (parameters != null) {
          body = { ...body, parameters: parameters };
        }
        if (Array.isArray(indices)) {
          body = { ...body, measurementIndices: indices };
        }
        const fetchData = async () => {
          const response = await fetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });
          if (!response.ok) {
            throw new Error('Network response was not OK!');
          }
          const data = await response.json();
          return data;
        }
        const checkResponse = async (data) => {
          if (data.message && data.message.includes('ompleted')) {
            const resultUrl = `${baseUrl}/process-result`;
            const resultResponse = await fetch(resultUrl);
            if (!resultResponse.ok) {
              throw new Error('Failed to fetch result data!');
            }
            const resultData = await resultResponse.json();
            return resultData;
          } else if (data.message.includes('in progress') || data.message.includes('running')) {
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
            return checkResponse(await fetchData());
          } else {
            return data;
          }
        }
        try {
          const data = await fetchData();
          const result = await checkResponse(data);
          return result;
        } catch (error) {
          throw new Error('Error fetching result:', error);
        }
      }

      async function postSafe(requestUrl, parameters, message) {
        await platformDelay();  // Use your new helper
        const fetchData = async () => {
          const response = await fetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(parameters),
          });
          if (!response.ok) {
            throw new Error('Network response was not OK!');
          }
          const data = await response.json();
          return data;
        }
        const checkResponse = async (data) => {
          if (data.message.includes(message)) {
            return data;
          } else if (data.message.includes('in progress') || data.message.includes('running')) {
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
            return checkResponse(await fetchData());
          } else {
            throw new Error(`Unexpected response: ${data.message}`);
          }
        }
        try {
          const data = await fetchData();
          const result = await checkResponse(data);
          return result;
        } catch (error) {
          throw new Error('Error fetching result:', error);
        }
      }

      // Enhanced postAlign with better error parsing
      async function postAlign(processName, frequency = null) {
        await platformDelay();
        const requestUrl = `http://localhost:4735/alignment-tool/command`;
        const body = { command: processName };
        if (frequency != null) {
          body.frequency = frequency;
        }
        try {
          const response = await safeFetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });
          const responseText = await response.text();
          if (!response.ok) {
            let errorData;
            try {
              errorData = JSON.parse(responseText);
            } catch (parseError) {
              throw new Error(`Network response was not OK! Status: ${response.status}`);
            }
            if (errorData.message) {
              let parsedMessage;
              try {
                parsedMessage = JSON.parse(errorData.message);
              } catch (parseError) {
                throw new Error('Failed to parse the error message');
              }
              if (parsedMessage.results &&
                parsedMessage.results[0] &&
                parsedMessage.results[0].Error) {
                const errorMessage = parsedMessage.results[0].Error;
                // More robust regex that works across all browsers
                const delayMatch = errorMessage.match(/delay required to align the responses.*?(-?[\d.]+)\s*ms/);

                if (delayMatch) {
                  return {
                    message: 'Delay too large',
                    error: errorMessage,
                    delay: parseFloat(delayMatch[1])
                  };
                }
              }
            }
            throw new Error(`Network response was not OK! Status: ${response.status}`);
          }
          let data;
          try {
            data = JSON.parse(responseText);
          } catch (parseError) {
            throw new Error('Failed to parse the response data');
          }
          if (data.message && data.message.includes('completed')) {
            const resultUrl = `http://localhost:4735/alignment-tool/result`;
            const resultResponse = await safeFetch(resultUrl);
            if (!resultResponse.ok) {
              throw new Error('Failed to fetch result data!');
            }
            const resultData = await resultResponse.json();
            if (resultData.results &&
              resultData.results[0] &&
              resultData.results[0].Error) {
              const errorMessage = resultData.results[0].Error;
              const delayMatch = errorMessage.match(/delay required to align the responses.*?(-?[\d.]+)\s*ms/);

              if (delayMatch) {
                return {
                  message: 'Delay too large',
                  error: errorMessage,
                  delay: parseFloat(delayMatch[1])
                };
              }
            }
            return resultData;
          }
          return data;
        } catch (error) {
          console.error('Error in postAlign:', error);
          throw error;
        }
      }

      // New postDelete
      async function postDelete(indice) {
        await platformDelay();  // Use your new helper
        const mDeleted = `Measurement ${indice} deleted`;
        while (true) {  // This infinite loop is intentional!
          try {
            const response = await fetch(`${baseUrl}/${indice}`, {
              method: 'DELETE',
              headers: { 'Content-Type': 'application/json' },
            });
            if (!response.ok) {
              throw new Error('Network response was not OK!');
            }
            const data = await response.json();
            if (data.message === mDeleted) {
              return indice;
            } else {
              await new Promise(resolve => setTimeout(resolve, retryDelay));
            }
          } catch (error) {
            throw new Error('Error fetching result:', error);
          }
        }
      }

      async function enableBlock() {
        await fetch('http://localhost:4735/application/blocking', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: true
        });
      }

      async function disableBlock() {
        await fetch('http://localhost:4735/application/blocking', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: false
        });
      }

      async function enableGraph() {
        await fetch('http://localhost:4735/application/inhibit-graph-updates', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: false
        });
      }

      async function disableGraph() {
        await fetch('http://localhost:4735/application/inhibit-graph-updates', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: true
        });
      }

      async function clearCommands() {
        const body = { command: 'Clear command in progress' };
        await fetch('http://localhost:4735/application/command', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
      }

      // Better platform detection
      function isWindowsPlatform() {
        try {
          // Multiple fallbacks for platform detection
          const userAgent = navigator.userAgent || '';
          const platform = navigator.platform || '';
          return userAgent.includes('Windows') ||
            platform.includes('Win') ||
            platform.startsWith('Win');
        } catch (e) {
          // Fallback if navigator is blocked (like in some Tor configurations)
          console.warn('Platform detection failed, assuming non-Windows');
          return false;
        }
      }

      // Fetch with fallback support
      function createFetchWrapper() {
        if (typeof fetch !== 'undefined') {
          return fetch;
        }
        // Fallback for older browsers using XMLHttpRequest
        return function (url, options = {}) {
          return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            const method = options.method || 'GET';
            xhr.open(method, url);
            // Set headers
            if (options.headers) {
              Object.entries(options.headers).forEach(([key, value]) => {
                xhr.setRequestHeader(key, value);
              });
            }
            xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                const response = {
                  ok: xhr.status >= 200 && xhr.status < 300,
                  status: xhr.status,
                  json: () => Promise.resolve(JSON.parse(xhr.responseText)),
                  text: () => Promise.resolve(xhr.responseText)
                };

                if (response.ok) {
                  resolve(response);
                } else {
                  reject(new Error(`HTTP ${xhr.status}`));
                }
              }
            };
            xhr.onerror = () => reject(new Error('Network error'));
            xhr.send(options.body || null);
          });
        };
      }
      const safeFetch = createFetchWrapper();

      // Feature detection utility
      function checkBrowserSupport() {
        const support = {
          fetch: typeof fetch !== 'undefined',
          asyncAwait: (async function () { })() instanceof Promise,
          json: typeof JSON !== 'undefined' &&
            typeof JSON.parse !== 'undefined' &&
            typeof JSON.stringify !== 'undefined',
          promises: typeof Promise !== 'undefined',
          setTimeout: typeof setTimeout !== 'undefined'
        };
        console.log('Browser support check:', support);
        const unsupported = Object.entries(support)
          .filter(([feature, supported]) => !supported)
          .map(([feature]) => feature);
        if (unsupported.length > 0) {
          console.error('Unsupported features:', unsupported);
          return false;
        }
        return true;
      }

      // Initialize with compatibility check
      function initializeApp() {
        if (!checkBrowserSupport()) {
          alert('Your browser may not fully support this application. Please update to a modern browser.');
          return false;
        }
        console.log('Browser compatibility check passed');
        return true;
      }

      // Validate config on groundWorks() step
      function validateConfiguration() {
        console.log('=== CONFIGURATION VALIDATION ===');
        // console.log(`nSpeakers: ${nSpeakers}`);
        // console.log(`numSub: ${numSub}`);
        console.log('=== ===');
        console.log(`nChannels: ${nChannels}`);
        console.log(`nSpeakers: ${nSpeakers}`);
        console.log(`nSubs: ${nSubs}`);
        console.log('=== ===');
        console.log(`Total channels: ${nSpeakers + nSubs}`);
        // Check commandId array
        const validCommands = Object.keys(commandId).filter(k => !isNaN(k) && parseInt(k) > 0);
        console.log(`CommandID entries: ${validCommands.length}`);
        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          if (!commandId[i]) {
            console.error(`X Missing commandId[${i}]`);
            return false;
          }
          console.log(`✓ commandId[${i}] = ${commandId[i]}`);
        }
        return true;
      }

      function normalizeTrimLevels() {
        console.log("Normalizing trim levels to industry standard (75dB reference)...");
        // Calculate target level offset from industry standard
        const standardReference = 75.0; // Industry standard SPL reference
        const targetOffset = targetLevel - standardReference;
        console.log(`├─ Target level: ${targetLevel}dB, Standard reference: ${standardReference}dB`);
        console.log(`├─ Target level offset: ${targetOffset.toFixed(1)}dB`);
        if (Math.abs(targetOffset) > 0.5) {
          console.log(`└─ Converting trims from ${targetLevel}dB target to ${standardReference}dB standard...`);
          console.info(`─────────────────────────────────────────────────────────`);
        } else {
          console.log("└─ Target level matches standard reference - no conversion needed.");
          console.info(`─────────────────────────────────────────────────────────`);
        }
        // Calculate original trim statistics
        const totalChannels = noSub ? nSpeakers : nSpeakers + nSubs;
        const originalTrims = [...customLevel]; // Store copy of original values
        // Log original values
        console.log("🔊 Original trim values (relative to current target):");
        console.log("--- SPEAKERS ---");
        for (let i = 1; i <= nSpeakers; i++) {
          console.log(`├─ ${commandId[i]}: ${customLevel[i].toFixed(1)}dB`);
        }
        if (!noSub) {
          console.log("--- SUBWOOFERS ---");
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            console.log(`└─ ${commandId[i]}: ${customLevel[i].toFixed(1)}dB`);
          }
          console.info(`─────────────────────────────────────────────────────────`);
        }
        // Apply target level correction to all channels
        for (let i = 1; i <= nSpeakers; i++) {
          customLevel[i] -= targetOffset;
          customLevel[i] = Math.round(customLevel[i] * 2) / 2; // Round to nearest 0.5dB
        }
        if (!noSub) {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] -= targetOffset;
            customLevel[i] = Math.round(customLevel[i] * 2) / 2; // Round to nearest 0.5dB
          }
        }
        if (Math.abs(targetOffset) > 0.5) {
          console.log(`Applied ${targetOffset.toFixed(1)}dB correction to normalize to 75dB standard.`);
        }
        // Log the BEFORE → AFTER comparison
        console.log("🔊 BEFORE → AFTER comparison (normalized to 75dB standard):");
        console.log("--- SPEAKERS ---");
        for (let i = 1; i <= nSpeakers; i++) {
          const change = customLevel[i] - originalTrims[i];
          console.log(`├─ ${commandId[i]}: ${originalTrims[i].toFixed(1)}dB → ${customLevel[i].toFixed(1)}dB (${change >= 0 ? '+' : ''}${change.toFixed(1)}dB)`);
        }
        if (!noSub) {
          console.log("--- SUBWOOFERS ---");
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            const change = customLevel[i] - originalTrims[i];
            console.log(`└─ ${commandId[i]}: ${originalTrims[i].toFixed(1)}dB → ${customLevel[i].toFixed(1)}dB (${change >= 0 ? '+' : ''}${change.toFixed(1)}dB)`);
          }
          console.info(`─────────────────────────────────────────────────────────`);
        }
        // Final analysis relative to 75dB standard
        const normalizedTrims = customLevel.slice(1, totalChannels + 1);
        const maxTrim = Math.max(...normalizedTrims);
        const minTrim = Math.min(...normalizedTrims);
        const averageTrim = normalizedTrims.reduce((sum, trim) => sum + trim, 0) / normalizedTrims.length;
        console.log(`✓ Normalized trim range: ${minTrim.toFixed(1)}dB to ${maxTrim.toFixed(1)}dB`);
        console.log(`✓ Average trim: ${averageTrim.toFixed(1)}dB (relative to 75dB standard)`);
        // Check against industry recommendations
        const recommendedTrims = normalizedTrims.filter(trim => Math.abs(trim) <= 10);
        const excessiveTrims = normalizedTrims.filter(trim => Math.abs(trim) > 10);
        if (excessiveTrims.length === 0) {
          console.info("✓ All trim levels within ±10dB recommended range");
        } else {
          console.warn(`${excessiveTrims.length} channels exceed ±10dB recommended range - consider speaker/room adjustments`);
        }
        // Check hardware limits
        const withinLimits = normalizedTrims.filter(trim => trim >= -12 && trim <= 12);
        if (withinLimits.length === normalizedTrims.length) {
          console.info("✓ All trim levels within ±12dB hardware limits");
        } else {
          console.error(`${normalizedTrims.length - withinLimits.length} channels exceed ±12dB hardware limits`);
        }
        // Headroom analysis
        const positiveTrims = normalizedTrims.filter(trim => trim > 0);
        if (positiveTrims.length > 0) {
          const maxPositive = Math.max(...positiveTrims);
          console.log(`📊 Headroom impact: ${positiveTrims.length} channels with positive trims (max: ${maxPositive.toFixed(1)}dB)`);
          console.log(`📊 Reference level achieved at Master Volume ${-maxPositive.toFixed(1)}dB`);
        } else {
          console.info("✓ No positive trims - maximum headroom preserved");
        }
      }

      // CEDIA Assessment - Enhanced Implementation with Professional Standards and Advanced Acoustics
      class CEDIAPerformanceScorer {
        constructor() {
          // Precision constants for calculations
          this.PRECISION = {
            SPL_TOLERANCE: 0.1,
            DISTANCE_TOLERANCE: 0.01,
            FREQUENCY_TOLERANCE: 1.0,
            SPEED_OF_SOUND: 343, // m/s at 20°C
            DB_PER_DISTANCE_DOUBLING: 6.0
          };
          // Advanced acoustic constants from CEDIA RP22 specification
          this.ACOUSTIC_CONSTANTS = {
            REFERENCE_IMPEDANCE: 8, // Ohms
            REFERENCE_DISTANCE: 1,  // meters
            SABINE_CONSTANT_METRIC: 0.161,
            SABINE_CONSTANT_IMPERIAL: 0.049,
            BOUNDARY_LOADING: {
              freeField: 0,      // No boundaries
              halfSpace: 6,      // Against wall
              quarterSpace: 12,  // Wall-floor junction
              eighthSpace: 18    // Corner placement
            },
            MATERIAL_ABSORPTION_COEFFS: {
              concrete: 0.02,
              gypsumBoard: 0.08,
              hardwood: 0.04,
              carpet_light: 0.15,
              carpet_heavy: 0.30,
              curtains_light: 0.30,
              curtains_heavy: 0.70,
              acousticFoam_2inch: 0.85,
              fiberglass_2inch: 0.90,
              upholsteredFurniture: 0.50,
              person: 0.45  // Per person in sabins
            }
          };
          // Enhanced speaker types with validation
          this.speakerTypes = {
            front: ["FL", "FR"],
            frontWide: ["FWL", "FWR"],
            surroundBack: ["SBL", "SBR"],
            surround: ["SLA", "SRA", "SL", "SR"],
            frontHeight: ["FHL", "FHR"],
            rearHeight: ["RHL", "RHR"],
            surroundHeight: ["SHL", "SHR"],
            topFront: ["TFL", "TFR"],
            topMiddle: ["TML", "TMR"],
            topRear: ["TRL", "TRR"],
            upfiringBack: ["BDL", "BDR"],
            upfiringFront: ["FDL", "FDR"],
            upfiringSurround: ["SDL", "SDR"],
            center: ["C"],
            topSurround: ["TS"],
            centerHeight: ["CH"],
            surroundBackSingle: ["SB"]
          };
          // Complete 21 CEDIA parameters with enhanced validation
          this.parameters = {
            // Spatial Resolution (11 parameters)
            1: {
              name: "Minimum Distance Between Listening Area and Room Walls",
              unit: "m", category: "Spatial Resolution",
              targets: { level1: { min: 0.5 }, level2: { min: 0.8 }, level3: { min: 1.2 }, level4: { min: 1.5 } },
              type: "minimum",
              validator: this.validateDistanceParameter.bind(this)
            },
            2: {
              name: "Decoder/Renderer Capability and Discretely Rendered Speaker Configuration",
              unit: "discrete speakers", category: "Spatial Resolution",
              targets: { level1: { min: 5 }, level2: { min: 11 }, level3: { min: 15 }, level4: { min: 15 } },
              type: "minimum",
              validator: this.validateSpeakerCount.bind(this)
            },
            3: {
              name: "Number of Screen Wall Speakers Outside Recommended Zonal Locations",
              unit: "speakers", category: "Spatial Resolution",
              targets: { level1: { max: 0 }, level2: { max: 0 }, level3: { max: 0 }, level4: { max: 0 } },
              type: "maximum",
              validator: this.validateZonalCompliance.bind(this)
            },
            4: {
              name: "Maximum SPL Difference Between Screen Wall Speakers",
              unit: "dB", category: "Spatial Resolution",
              targets: { level1: { max: 6 }, level2: { max: 5 }, level3: { max: 4 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateSPLConsistency.bind(this)
            },
            5: {
              name: "Maximum Allowable Horizontal Angle Between Adjacent Surround Speakers",
              unit: "degrees", category: "Spatial Resolution",
              targets: { level1: null, level2: { max: 80 }, level3: { max: 60 }, level4: { max: 50 } },
              type: "maximum",
              validator: this.validateSpeakerAngles.bind(this)
            },
            6: {
              name: "Maximum SPL Difference Between Surround Speakers",
              unit: "dB", category: "Spatial Resolution",
              targets: { level1: { max: 10 }, level2: { max: 6 }, level3: { max: 4 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateSPLConsistency.bind(this)
            },
            7: {
              name: "Wide Speakers Maximum Allowable Horizontal Deviation from Median Angle",
              unit: "degrees", category: "Spatial Resolution",
              targets: { level1: { max: 10 }, level2: { max: 7 }, level3: { max: 5 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateWideAlignment.bind(this)
            },
            8: {
              name: "Upfiring/Elevation Speakers Allowed",
              unit: "yes/no", category: "Spatial Resolution",
              targets: { level1: true, level2: true, level3: false, level4: false },
              type: "boolean",
              validator: this.validateUpfiringSpeakers.bind(this)
            },
            9: {
              name: "Maximum Allowable Vertical Angle Between Adjacent Upper Speakers",
              unit: "degrees", category: "Spatial Resolution",
              targets: { level1: null, level2: { max: 80 }, level3: { max: 60 }, level4: { max: 50 } },
              type: "maximum",
              validator: this.validateVerticalAngles.bind(this)
            },
            10: {
              name: "Maximum SPL Difference Between Upper Speakers",
              unit: "dB", category: "Spatial Resolution",
              targets: { level1: { max: 12 }, level2: { max: 8 }, level3: { max: 5 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateSPLConsistency.bind(this)
            },
            11: {
              name: "Number of Surround/Wide/Upper Speakers Outside Zonal Locations",
              unit: "speakers", category: "Spatial Resolution",
              targets: { level1: null, level2: { max: 0 }, level3: { max: 0 }, level4: { max: 0 } },
              type: "maximum",
              validator: this.validateZonalCompliance.bind(this)
            },
            // Dynamics (4 parameters)
            12: {
              name: "Screen Speakers SPL Capability at RSP",
              unit: "dB SPL(C)", category: "Dynamics",
              targets: { level1: { min: 99, rec: 102 }, level2: { min: 102, rec: 105 }, level3: { min: 105, rec: 108 }, level4: { min: 108, rec: 111 } },
              type: "minimum",
              validator: this.validateSPLCapability.bind(this)
            },
            13: {
              name: "Non-Screen Speakers SPL Capability at RSP",
              unit: "dB SPL(C)", category: "Dynamics",
              targets: { level1: { min: 96, rec: 99 }, level2: { min: 99, rec: 102 }, level3: { min: 102, rec: 105 }, level4: { min: 105, rec: 108 } },
              type: "minimum",
              validator: this.validateSPLCapability.bind(this)
            },
            14: {
              name: "LFE Frequencies Total SPL Capability at RSP",
              unit: "dB SPL(C)", category: "Dynamics",
              targets: { level1: { min: 109, rec: 114 }, level2: { min: 112, rec: 117 }, level3: { min: 115, rec: 120 }, level4: { min: 118, rec: 123 } },
              type: "minimum",
              validator: this.validateLFECapability.bind(this)
            },
            15: {
              name: "Background Noise Floor",
              unit: "NCB rating", category: "Dynamics",
              targets: { level1: { max: 35, rec: 26 }, level2: { max: 26, rec: 22 }, level3: { max: 22, rec: 18 }, level4: { max: 18, rec: 15 } },
              type: "maximum",
              validator: this.validateNoiseFloor.bind(this)
            },
            // Timbre (6 parameters)
            16: {
              name: "Seat-to-Seat Frequency Response Variance - Screen Wall Speakers",
              unit: "±dB", category: "Timbre",
              targets: { level1: { max: 5 }, level2: { max: 3 }, level3: { max: 1.5 }, level4: { max: 1.5 } },
              type: "maximum",
              validator: this.validateFrequencyResponse.bind(this)
            },
            17: {
              name: "Seat-to-Seat Frequency Response Variance - Surround/Upper Speakers",
              unit: "±dB", category: "Timbre",
              targets: { level1: null, level2: null, level3: { max: 3 }, level4: { max: 1.5 } },
              type: "maximum",
              validator: this.validateFrequencyResponse.bind(this)
            },
            18: {
              name: "In-Room Bass Extension -3dB Cutoff Frequency",
              unit: "Hz", category: "Timbre",
              targets: { level1: { max: 35, rec: 30 }, level2: { max: 30, rec: 25 }, level3: { max: 20, rec: 18 }, level4: { max: 18, rec: 15 } },
              type: "maximum",
              validator: this.validateBassExtension.bind(this)
            },
            19: {
              name: "Frequency Response Below Room's Transition Frequency at RSP",
              unit: "±dB", category: "Timbre",
              targets: { level1: { max: 5 }, level2: { max: 4 }, level3: { max: 3 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateBassResponse.bind(this)
            },
            20: {
              name: "Seat-to-Seat Frequency Response Below Room's Transition Frequency",
              unit: "±dB", category: "Timbre",
              targets: { level1: null, level2: { max: 4 }, level3: { max: 3 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateBassConsistency.bind(this)
            },
            21: {
              name: "Level of Early Reflections Relative to Direct Sound",
              unit: "dB", category: "Timbre",
              targets: { level1: null, level2: { min: -8 }, level3: { min: -10 }, level4: { min: -12 } },
              type: "minimum",
              validator: this.validateReflections.bind(this)
            }
          };
          // Validation error tracking
          this.validationErrors = [];
        }
        // Enhanced data capture with comprehensive validation
        captureAllSystemData() {
          try {
            const systemData = {
              // Basic system info with validation
              nSpeakers: this.validateNumeric(typeof nSpeakers !== 'undefined' ? nSpeakers : 0, 'nSpeakers'),
              nSubs: this.validateNumeric(typeof nSubs !== 'undefined' ? nSubs : 0, 'nSubs'),
              noSub: typeof noSub !== 'undefined' ? Boolean(noSub) : false,
              targetLevel: this.validateNumeric(typeof targetLevel !== 'undefined' ? targetLevel : 75, 'targetLevel'),
              swChannelCount: this.validateNumeric(typeof swChannelCount !== 'undefined' ? swChannelCount : 0, 'swChannelCount'),
              // Speaker configuration with enhanced validation
              commandId: typeof commandId !== 'undefined' ? commandId : [],
              discreteSpeakerFeeds: 0, // Will be calculated
              // Enhanced playback level data with validation
              estimatedPlaybackLevels: this.parseEstimatedPlaybackLevels(typeof estimatedPlaybackLevels !== 'undefined' ? estimatedPlaybackLevels : []),
              // Advanced: Parse distance and crossover data
              estimatedDistances: this.parseDistanceData(typeof estimatedDistances !== 'undefined' ? estimatedDistances : []),
              crossoverData: this.parseCrossoverData(typeof RP22BestXO !== 'undefined' ? RP22BestXO : []),
              // Bass system data with precision handling
              bassExtension: this.validateFrequency(m3dBPoints && nChannels ? m3dBPoints[nChannels]?.[0] : null),
              bassHighFreq: this.validateFrequency(m3dBPoints && nChannels ? m3dBPoints[nChannels]?.[1] : null),
              bassMode: typeof bassMode !== 'undefined' ? String(bassMode) : 'Unknown',
              // Subwoofer optimization data with precision
              RP22subnminXO: this.validateFrequency(typeof RP22subnminXO !== 'undefined' ? RP22subnminXO : null),
              RP22submaxXO: this.validateFrequency(typeof RP22submaxXO !== 'undefined' ? RP22submaxXO : null),
              requiredDelay: this.validateNumeric(typeof RP22subrequiredDelay !== 'undefined' ? RP22subrequiredDelay : null, 'requiredDelay'),
              optimalFreq: this.validateFrequency(typeof bestFreq !== 'undefined' ? bestFreq : null),
              delayRange: (typeof loDelay !== 'undefined' && typeof hiDelay !== 'undefined') ? {
                min: this.validateNumeric(loDelay, 'loDelay'),
                max: this.validateNumeric(hiDelay, 'hiDelay'),
                range: this.validateNumeric(hiDelay - loDelay, 'delayRange')
              } : null,
              // Level and distance data with validation
              customLevel: typeof customLevel !== 'undefined' ? this.validateArray(customLevel, 'customLevel') : [],
              customDistance: typeof customDistance !== 'undefined' ? this.validateArray(customDistance, 'customDistance') : [],
              customCrossover: typeof customCrossover !== 'undefined' ? this.validateArray(customCrossover, 'customCrossover') : [],
              flDist: this.validateNumeric(typeof flDist !== 'undefined' ? flDist : null, 'flDist'),
              // System characteristics - Enhanced parsing for measurement arrays
              sOs: typeof sOs !== 'undefined' ? String(sOs) : 'Unknown',
              isCirrusLogic: typeof isCirrusLogic !== 'undefined' ? Boolean(isCirrusLogic) : false,
              freqIndex: this.parseFrequencyArray(typeof freqIndex !== 'undefined' ? freqIndex : null),
              //RP22DialogEnhancementFilter: typeof RP22DialogEnhancementFilter !== 'undefined' ? Boolean(RP22DialogEnhancementFilter) : false,
              needsSorting: typeof needsSorting !== 'undefined' ? Boolean(needsSorting) : false,
              // Time alignment - Enhanced parsing for timing data
              mSec: this.parseTimingArray(typeof mSec !== 'undefined' ? mSec : null)
            };
            // Calculate discrete speaker feeds
            systemData.discreteSpeakerFeeds = this.calculateDiscreteSpeakerFeeds(systemData);
            // Enhanced room analysis using advanced acoustics
            systemData.roomAcoustics = this.calculateRoomAcoustics(systemData);
            systemData.speakerAngles = this.calculateAllSpeakerAngles(systemData);
            systemData.bassManagement = this.analyzeBassManagement(systemData);
            return systemData;
          } catch (error) {
            console.warn("Error capturing system data:", error.message);
            return this.getDefaultSystemData();
          }
        }
        // Parse frequency measurement points array from freqIndex
        parseFrequencyArray(rawFreqIndex) {
          if (!rawFreqIndex) return null;
          try {
            // Handle comma-separated frequency values
            const freqString = String(rawFreqIndex).trim();
            if (freqString === '') return null;
            const frequencies = freqString.split(',')
              .map(f => parseFloat(f.trim()))
              .filter(f => Number.isFinite(f) && f > 0);
            if (frequencies.length === 0) {
              this.addValidationError("No valid frequency points found in freqIndex");
              return null;
            }
            // Sort frequencies in ascending order
            frequencies.sort((a, b) => a - b);
            // Calculate frequency response analysis metrics
            const analysis = {
              frequencies: frequencies,
              count: frequencies.length,
              minFreq: Math.min(...frequencies),
              maxFreq: Math.max(...frequencies),
              frequencyRange: Math.max(...frequencies) / Math.min(...frequencies),
              avgSpacing: this.calculateAverageFrequencySpacing(frequencies),
              is1_3Octave: this.checkIfOneThirdOctave(frequencies),
              bandsPerOctave: this.estimateBandsPerOctave(frequencies)
            };
            return analysis;
          } catch (error) {
            this.addValidationError(`Error parsing freqIndex: ${error.message}`);
            return null;
          }
        }
        // Parse timing delay array from mSec  
        parseTimingArray(rawMSec) {
          if (!rawMSec) return null;
          try {
            // Handle comma-separated timing values (may have leading comma)
            const timingString = String(rawMSec).trim();
            if (timingString === '') return null;
            // Split and remove empty entries (handles leading comma)
            const timingValues = timingString.split(',')
              .map(t => t.trim())
              .filter(t => t !== '')
              .map(t => parseFloat(t))
              .filter(t => Number.isFinite(t));
            if (timingValues.length === 0) {
              this.addValidationError("No valid timing values found in mSec");
              return null;
            }
            // Calculate timing analysis metrics
            const analysis = {
              delays: timingValues,
              count: timingValues.length,
              minDelay: Math.min(...timingValues),
              maxDelay: Math.max(...timingValues),
              delaySpread: Math.max(...timingValues) - Math.min(...timingValues),
              avgDelay: timingValues.reduce((sum, d) => sum + d, 0) / timingValues.length,
              stdDeviation: this.calculateStandardDeviation(timingValues),
              timingConsistency: this.assessTimingConsistency(timingValues),
              earlyReflectionMetric: this.estimateEarlyReflectionLevel(timingValues)
            };
            return analysis;
          } catch (error) {
            this.addValidationError(`Error parsing mSec: ${error.message}`);
            return null;
          }
        }
        // Check if frequency array represents 1/3 octave measurements
        checkIfOneThirdOctave(frequencies) {
          if (frequencies.length < 3) return false;
          // Check if frequency ratios are close to 2^(1/3) ≈ 1.26
          const expectedRatio = Math.pow(2, 1 / 3);
          const tolerance = 0.05;
          for (let i = 1; i < Math.min(frequencies.length, 10); i++) {
            const ratio = frequencies[i] / frequencies[i - 1];
            if (Math.abs(ratio - expectedRatio) > tolerance) {
              return false;
            }
          }
          return true;
        }
        // Estimate bands per octave from frequency spacing
        estimateBandsPerOctave(frequencies) {
          if (frequencies.length < 2) return null;
          // Calculate average ratio between adjacent frequencies
          const ratios = [];
          for (let i = 1; i < Math.min(frequencies.length, 10); i++) {
            ratios.push(frequencies[i] / frequencies[i - 1]);
          }
          const avgRatio = ratios.reduce((sum, r) => sum + r, 0) / ratios.length;
          // Convert ratio to bands per octave: bandsPerOctave = log(2) / log(ratio)
          return Math.round(Math.log(2) / Math.log(avgRatio));
        }
        // Calculate average frequency spacing
        calculateAverageFrequencySpacing(frequencies) {
          if (frequencies.length < 2) return 0;
          const spacings = [];
          for (let i = 1; i < frequencies.length; i++) {
            spacings.push(frequencies[i] - frequencies[i - 1]);
          }
          return spacings.reduce((sum, s) => sum + s, 0) / spacings.length;
        }
        // Calculate standard deviation of timing values
        calculateStandardDeviation(values) {
          const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
          const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
          const variance = squaredDiffs.reduce((sum, sq) => sum + sq, 0) / values.length;
          return Math.sqrt(variance);
        }
        // Assess timing consistency for CEDIA parameter evaluation
        assessTimingConsistency(delays) {
          if (delays.length < 2) return 'Insufficient Data';
          const delaySpread = Math.max(...delays) - Math.min(...delays);
          const stdDev = this.calculateStandardDeviation(delays);
          // Convert from seconds to milliseconds for evaluation
          // const spreadMs = Math.abs(delaySpread) * 1000;
          // const stdDevMs = stdDev * 1000;
          const spreadMs = Math.abs(delaySpread) * delaymax;
          const stdDevMs = stdDev * delaymax;
          if (spreadMs <= 0.1 && stdDevMs <= 0.05) return 'Excellent';
          if (spreadMs <= 0.5 && stdDevMs <= 0.2) return 'Good';
          if (spreadMs <= 2.0 && stdDevMs <= 1.0) return 'Fair';
          return 'Poor';
        }
        // Estimate early reflection characteristics from timing data
        estimateEarlyReflectionLevel(delays) {
          // Use timing delay spread as proxy for early reflection strength
          // Larger delay spreads typically indicate more early reflections
          const delaySpread = Math.max(...delays) - Math.min(...delays);
          const spreadMs = Math.abs(delaySpread) * delaymax;
          // Convert timing spread to estimated early reflection level (dB relative to direct sound)
          // Based on empirical relationships between delay spread and reflection strength
          if (spreadMs <= 0.1) return -15; // Very low reflections
          if (spreadMs <= 0.5) return -12; // Low reflections  
          if (spreadMs <= 1.0) return -10; // Moderate reflections
          if (spreadMs <= 2.0) return -8;  // Higher reflections
          return -6; // High reflections
        }
        // Parse distance data from estimatedDistances array
        parseDistanceData(rawDistances) {
          const distances = {};
          if (!Array.isArray(rawDistances)) {
            this.addValidationError("estimatedDistances is not an array");
            return distances;
          }
          rawDistances.forEach((entry, index) => {
            try {
              if (Array.isArray(entry) && entry.length >= 2) {
                const [speakerId, distanceValue] = entry;
                const distance = parseFloat(distanceValue);

                if (typeof speakerId === 'string' && Number.isFinite(distance) && distance > 0) {
                  distances[speakerId.trim()] = distance;
                } else {
                  this.addValidationError(`Invalid distance entry at index ${index}: ${JSON.stringify(entry)}`);
                }
              }
            } catch (error) {
              this.addValidationError(`Error parsing distance entry ${index}: ${error.message}`);
            }
          });
          return distances;
        }
        // Parse crossover data from RP22BestXO array  
        parseCrossoverData(rawCrossovers) {
          const crossovers = {};
          if (!Array.isArray(rawCrossovers)) {
            this.addValidationError("RP22BestXO is not an array");
            return crossovers;
          }
          rawCrossovers.forEach((entry, index) => {
            try {
              if (Array.isArray(entry) && entry.length >= 2) {
                const [speakerId, crossoverValue] = entry;
                const crossover = parseFloat(crossoverValue);

                if (typeof speakerId === 'string' && Number.isFinite(crossover) && crossover > 0) {
                  crossovers[speakerId.trim()] = crossover;
                }
              }
            } catch (error) {
              this.addValidationError(`Error parsing crossover entry ${index}: ${error.message}`);
            }
          });
          return crossovers;
        }
        // Parse and validate estimatedPlaybackLevels data
        parseEstimatedPlaybackLevels(rawData) {
          if (!Array.isArray(rawData)) {
            this.addValidationError("estimatedPlaybackLevels is not an array");
            return {};
          }
          const parsedLevels = {};
          let validEntries = 0;
          rawData.forEach((entry, index) => {
            try {
              if (!Array.isArray(entry) || entry.length !== 2) {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Invalid entry format - expected [speakerID, level]`);
                return;
              }
              const [speakerId, levelValue] = entry;
              if (typeof speakerId !== 'string' || speakerId.trim() === '') {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Invalid speaker ID`);
                return;
              }
              const level = parseFloat(levelValue);
              if (!Number.isFinite(level)) {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Invalid level value for ${speakerId}`);
                return;
              }
              // Validate reasonable level range (20-120 dB SPL)
              if (level < 20 || level > 120) {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Level ${level}dB for ${speakerId} is outside reasonable range (20-120dB)`);
              }
              parsedLevels[speakerId.trim()] = level;
              validEntries++;
            } catch (error) {
              this.addValidationError(`estimatedPlaybackLevels[${index}]: Parse error - ${error.message}`);
            }
          });
          if (validEntries === 0) {
            this.addValidationError("No valid entries found in estimatedPlaybackLevels");
          } else if (validEntries < rawData.length) {
            this.addValidationError(`Only ${validEntries}/${rawData.length} estimatedPlaybackLevels entries were valid`);
          }
          return parsedLevels;
        }
        // Calculate frequency response variance from measurement data
        calculateFrequencyResponseVariance(systemData, speakerGroup) {
          if (!systemData.freqIndex || !systemData.freqIndex.frequencies) {
            return null;
          }
          try {
            // Get relevant speakers for the group
            const relevantSpeakers = this.getSpeakersForGroup(systemData, speakerGroup);
            if (relevantSpeakers.length < 2) {
              return null; // Need at least 2 speakers for variance calculation
            }
            // Use frequency data to estimate response variance
            const freqData = systemData.freqIndex;
            // Estimate variance based on frequency measurement characteristics
            // This is a simplified approach - in practice would need actual FR measurements
            let estimatedVariance = 3.0; // Base variance estimate
            // Adjust based on measurement quality indicators
            if (freqData.is1_3Octave) {
              estimatedVariance *= 0.8; // Better measurement resolution
            }
            if (freqData.count >= 20) {
              estimatedVariance *= 0.9; // More measurement points = better accuracy
            }
            // Adjust based on speaker group characteristics
            if (speakerGroup === 'screen') {
              // Screen speakers typically better matched
              estimatedVariance *= 0.7;
            } else if (speakerGroup === 'surround') {
              // Surrounds may have more variation due to room interactions
              estimatedVariance *= 1.2;
            }
            // Use SPL consistency data if available to refine estimate
            if (systemData.estimatedPlaybackLevels) {
              const splAnalysis = this.analyzeSpeakerGroupSPL(systemData.estimatedPlaybackLevels);
              const groupSPLVariance = this.getSPLVarianceForGroup(splAnalysis, speakerGroup);
              if (groupSPLVariance !== null) {
                // Correlate SPL variance with frequency response variance
                estimatedVariance = Math.max(estimatedVariance, groupSPLVariance * 0.6);
              }
            }
            return Math.round(estimatedVariance * 10) / 10;
          } catch (error) {
            this.addValidationError(`Frequency response variance calculation error: ${error.message}`);
            return null;
          }
        }
        // Estimate bass extension from frequency measurement data
        estimateBassExtensionFromFrequencies(freqData) {
          if (!freqData || !freqData.frequencies || freqData.frequencies.length === 0) {
            return null;
          }
          try {
            // Find the lowest measurement frequency as indicator of bass extension
            const lowestFreq = freqData.minFreq;
            // Estimate -3dB cutoff based on lowest measurement frequency
            // Typical relationship: if measuring down to X Hz, -3dB point is usually higher
            let estimatedCutoff;
            if (lowestFreq <= 20) {
              estimatedCutoff = 25; // Excellent extension
            } else if (lowestFreq <= 30) {
              estimatedCutoff = 35; // Good extension  
            } else if (lowestFreq <= 40) {
              estimatedCutoff = 45; // Fair extension
            } else {
              estimatedCutoff = Math.max(lowestFreq, 60); // Limited extension
            }
            // Adjust based on number of low frequency measurement points
            const lowFreqPoints = freqData.frequencies.filter(f => f <= 80).length;
            if (lowFreqPoints >= 5) {
              estimatedCutoff *= 0.9; // More LF measurement points suggest better extension
            }
            return Math.round(estimatedCutoff);
          } catch (error) {
            this.addValidationError(`Bass extension estimation error: ${error.message}`);
            return null;
          }
        }
        // Get speakers for specific group analysis
        getSpeakersForGroup(systemData, speakerGroup) {
          if (!systemData.commandId || !Array.isArray(systemData.commandId)) {
            return [];
          }
          const speakers = systemData.commandId.filter(id => id && typeof id === 'string');
          switch (speakerGroup.toLowerCase()) {
            case 'screen':
              return speakers.filter(id => ['FL', 'FC', 'FR', 'FCL', 'FCR', 'C'].includes(id));
            case 'surround':
              return speakers.filter(id =>
                ['SL', 'SR', 'SBL', 'SBR', 'SLA', 'SRA', 'SB'].includes(id) ||
                ['FHL', 'FHR', 'RHL', 'RHR', 'SHL', 'SHR', 'CH'].includes(id) ||
                ['TFL', 'TFR', 'TML', 'TMR', 'TRL', 'TRR', 'TS'].includes(id)
              );
            case 'wide':
              return speakers.filter(id => ['FWL', 'FWR'].includes(id));
            case 'upper':
              return speakers.filter(id =>
                id.includes('H') || id.startsWith('T') ||
                ['BDL', 'BDR', 'FDL', 'FDR', 'SDL', 'SDR'].includes(id)
              );
            default:
              return speakers;
          }
        }
        // Get SPL variance for specific speaker group
        getSPLVarianceForGroup(splAnalysis, speakerGroup) {
          switch (speakerGroup.toLowerCase()) {
            case 'screen':
              return splAnalysis.screenSpeakers?.maxDiff || null;
            case 'surround':
              return splAnalysis.surroundSpeakers?.maxDiff || null;
            case 'upper':
              return splAnalysis.upperSpeakers?.maxDiff || null;
            case 'wide':
              return splAnalysis.wideSpeakers?.maxDiff || null;
            default:
              return null;
          }
        }
        // Calculate room acoustics from speaker distances using CEDIA RP22 methodology
        calculateRoomAcoustics(systemData) {
          try {
            if (!systemData.estimatedDistances || Object.keys(systemData.estimatedDistances).length === 0) {
              return { dimensions: null, transitionFreq: null, modes: [] };
            }
            // Estimate room dimensions from speaker distances
            const distances = Object.values(systemData.estimatedDistances);
            const maxDistance = Math.max(...distances);
            const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;
            // CEDIA RP22 room estimation using acoustic principles
            const estimatedLength = maxDistance * 1.8; // More conservative estimate
            const estimatedWidth = maxDistance * 1.4;
            const estimatedHeight = Math.min(avgDistance * 0.85, 3.5); // Typical residential height
            const estimatedVolume = estimatedLength * estimatedWidth * estimatedHeight;
            // Calculate Schroeder transition frequency
            const reverbTime = this.estimateRT60(estimatedVolume);
            const transitionFreq = this.calculateSchroederFrequency(reverbTime, estimatedVolume);
            // Calculate room modes
            const modes = this.calculateRoomModes(estimatedLength, estimatedWidth, estimatedHeight);
            return {
              dimensions: {
                length: estimatedLength,
                width: estimatedWidth,
                height: estimatedHeight,
                volume: estimatedVolume,
                surfaceArea: 2 * (estimatedLength * estimatedWidth + estimatedLength * estimatedHeight + estimatedWidth * estimatedHeight)
              },
              transitionFreq: transitionFreq,
              modes: modes,
              reverbTime: reverbTime
            };

          } catch (error) {
            this.addValidationError(`Room acoustics calculation error: ${error.message}`);
            return { dimensions: null, transitionFreq: null, modes: [] };
          }
        }
        // Calculate room modes using CEDIA RP22 methodology
        calculateRoomModes(length, width, height) {
          const modes = [];
          const c = this.PRECISION.SPEED_OF_SOUND;
          // Generate axial, tangential, and oblique modes up to 300Hz
          for (let nx = 0; nx <= 10; nx++) {
            for (let ny = 0; ny <= 10; ny++) {
              for (let nz = 0; nz <= 10; nz++) {
                if (nx === 0 && ny === 0 && nz === 0) continue;
                const frequency = (c / 2) * Math.sqrt(
                  Math.pow(nx / length, 2) +
                  Math.pow(ny / width, 2) +
                  Math.pow(nz / height, 2)
                );
                if (frequency <= 300) {
                  const nonZeros = [nx, ny, nz].filter(n => n > 0).length;
                  let type = 'oblique';
                  if (nonZeros === 1) type = 'axial';      // Strongest impact
                  else if (nonZeros === 2) type = 'tangential'; // -3dB relative

                  modes.push({
                    frequency: Math.round(frequency * 10) / 10,
                    type: type,
                    order: [nx, ny, nz],
                    strength: type === 'axial' ? 1.0 : type === 'tangential' ? 0.5 : 0.25
                  });
                }
              }
            }
          }
          return modes.sort((a, b) => a.frequency - b.frequency);
        }
        // Calculate Schroeder transition frequency using CEDIA RP22 formula
        calculateSchroederFrequency(reverbTime, volume) {
          // fs = 2000 × √(T60/V) - CEDIA RP22 formula
          return Math.round(2000 * Math.sqrt(reverbTime / volume));
        }
        // Estimate RT60 using simplified residential model
        estimateRT60(volume) {
          // CEDIA RP22 target: Tm = 0.3 (V / 100)^(1/3)
          const targetRT60 = 0.3 * Math.pow(volume / 100, 1 / 3);
          // Typical residential RT60 tends to be slightly higher than target
          return Math.min(targetRT60 * 1.2, 0.6); // Cap at 0.6 seconds
        }
        // Calculate all speaker angles from distances using CEDIA placement guidelines
        calculateAllSpeakerAngles(systemData) {
          const angles = {};
          const distances = systemData.estimatedDistances || {};
          if (Object.keys(distances).length === 0) {
            return angles;
          }
          try {
            // Get center speaker distance as reference
            const centerDistance = distances['C'] || distances['FC'] || null;
            if (!centerDistance) {
              this.addValidationError("No center speaker distance found for angle calculations");
              return angles;
            }
            // Calculate angles for each speaker relative to center
            Object.entries(distances).forEach(([speakerId, distance]) => {
              if (speakerId === 'C' || speakerId === 'FC') {
                angles[speakerId] = { horizontal: 0, vertical: 0, elevation: 0 };
                return;
              }
              // Use trigonometric calculations for precise angles
              const speakerAngles = this.calculateSpeakerAngle(speakerId, distance, centerDistance);
              angles[speakerId] = speakerAngles;
            });
            return angles;
          } catch (error) {
            this.addValidationError(`Speaker angle calculation error: ${error.message}`);
            return angles;
          }
        }
        // Calculate speaker angles using coordinate geometry and CEDIA guidelines
        calculateSpeakerAngle(speakerId, distance, centerDistance) {
          const speakerType = this.classifySpeakerType(speakerId);
          // CEDIA RP22 placement specifications
          const placementGuidelines = {
            front: { horizontal: 30, vertical: 0, elevation: 0 },        // FL/FR ±30°
            frontWide: { horizontal: 60, vertical: 0, elevation: 0 },    // FWL/FWR ±60°
            surround: { horizontal: 90, vertical: 0, elevation: 5 },     // SL/SR ±90°
            surroundBack: { horizontal: 135, vertical: 0, elevation: 5 }, // SBL/SBR ±135°
            frontHeight: { horizontal: 30, vertical: 30, elevation: 30 }, // Height speakers
            rearHeight: { horizontal: 135, vertical: 30, elevation: 30 },
            topFront: { horizontal: 30, vertical: 45, elevation: 45 },   // Top speakers
            topRear: { horizontal: 135, vertical: 45, elevation: 45 },
            subwoofer: { horizontal: 0, vertical: 0, elevation: 0 }      // Subwoofers
          };
          const baseAngles = placementGuidelines[speakerType] || { horizontal: 0, vertical: 0, elevation: 0 };
          // Adjust for left/right positioning using trigonometry
          let horizontalAngle = baseAngles.horizontal;
          if (speakerId.includes('L') || speakerId.includes('l')) {
            horizontalAngle = -Math.abs(horizontalAngle); // Negative for left
          } else if (speakerId.includes('R') || speakerId.includes('r')) {
            horizontalAngle = Math.abs(horizontalAngle);  // Positive for right
          }
          // Calculate distance-based adjustments using trigonometric principles
          const distanceRatio = distance / centerDistance;
          const adjustedHorizontal = horizontalAngle * Math.min(distanceRatio, 1.5); // Limit adjustment
          return {
            horizontal: Math.round(adjustedHorizontal * 10) / 10,
            vertical: baseAngles.vertical,
            elevation: baseAngles.elevation,
            distance: distance,
            distanceRatio: Math.round(distanceRatio * 100) / 100
          };
        }
        // Classify speaker by ID for angle calculations
        classifySpeakerType(speakerId) {
          const id = speakerId.toLowerCase();
          if (['fl', 'fr'].includes(id)) return 'front';
          if (['fwl', 'fwr'].includes(id)) return 'frontWide';
          if (['sl', 'sr', 'sla', 'sra'].includes(id)) return 'surround';
          if (['sbl', 'sbr', 'sb'].includes(id)) return 'surroundBack';
          if (['fhl', 'fhr', 'hfl', 'hfr'].includes(id)) return 'frontHeight';
          if (['rhl', 'rhr', 'hbl', 'hbr'].includes(id)) return 'rearHeight';
          if (['tfl', 'tfr'].includes(id)) return 'topFront';
          if (['tbl', 'tbr', 'trl', 'trr'].includes(id)) return 'topRear';
          if (id.startsWith('sw')) return 'subwoofer';
          return 'other';
        }
        // Analyze bass management impact on crossovers
        analyzeBassManagement(systemData) {
          const crossovers = systemData.crossoverData || {};
          const analysis = {
            averageCrossover: 80, // Default THX standard
            crossoverSpread: 0,
            bassManagementEfficiency: 1.0,
            recommendations: []
          };
          try {
            if (Object.keys(crossovers).length > 0) {
              const crossoverValues = Object.values(crossovers).filter(v => Number.isFinite(v));
              if (crossoverValues.length > 0) {
                analysis.averageCrossover = crossoverValues.reduce((sum, xo) => sum + xo, 0) / crossoverValues.length;
                analysis.crossoverSpread = Math.max(...crossoverValues) - Math.min(...crossoverValues);
                // Efficiency based on crossover consistency
                analysis.bassManagementEfficiency = Math.max(0.5, 1 - (analysis.crossoverSpread / 100));
                // Generate recommendations
                if (analysis.crossoverSpread > 40) {
                  analysis.recommendations.push("High crossover spread detected - consider standardizing crossover frequencies");
                }
                if (analysis.averageCrossover > 120) {
                  analysis.recommendations.push("High average crossover may compromise bass integration");
                }
                if (analysis.averageCrossover < 60) {
                  analysis.recommendations.push("Low average crossover may stress main speakers");
                }
              }
            }
            return analysis;
          } catch (error) {
            this.addValidationError(`Bass management analysis error: ${error.message}`);
            return analysis;
          }
        }
        // Enhanced SPL calculations with speaker-specific playback levels
        calculateEnhancedSPLDifferences(systemData) {
          // Try to use estimatedPlaybackLevels first, fall back to customLevel
          let levelData = null;
          let dataSource = null;
          if (systemData.estimatedPlaybackLevels && Object.keys(systemData.estimatedPlaybackLevels).length > 0) {
            levelData = systemData.estimatedPlaybackLevels;
            dataSource = "estimatedPlaybackLevels";
          } else if (systemData.customLevel && Array.isArray(systemData.customLevel)) {
            // Convert customLevel array to object format for consistency
            levelData = {};
            systemData.customLevel.forEach((level, index) => {
              if (index > 0 && level !== undefined) {
                levelData[`Speaker_${index}`] = parseFloat(level);
              }
            });
            dataSource = "customLevel";
          }
          if (!levelData || Object.keys(levelData).length === 0) {
            return { error: "No valid level data available", maxDifference: null, dataSource: null };
          }
          try {
            // Extract numeric levels, filtering out invalid values
            const levels = Object.values(levelData)
              .map(level => parseFloat(level))
              .filter(level => Number.isFinite(level));
            if (levels.length < 2) {
              return { error: "Insufficient level data for comparison", maxDifference: null, dataSource };
            }
            // Calculate comprehensive statistics
            const maxLevel = Math.max(...levels);
            const minLevel = Math.min(...levels);
            const maxDifference = this.preciseSubtraction(maxLevel, minLevel);
            const avgLevel = levels.reduce((sum, level) => sum + level, 0) / levels.length;
            const stdDev = Math.sqrt(levels.reduce((sum, level) => sum + Math.pow(level - avgLevel, 2), 0) / levels.length);
            // Enhanced analysis by speaker groups using actual speaker IDs
            const groupAnalysis = this.analyzeSpeakerGroupSPL(levelData);
            return {
              maxDifference,
              minLevel,
              maxLevel,
              avgLevel: Math.round(avgLevel * 10) / 10,
              standardDeviation: Math.round(stdDev * 10) / 10,
              screenSpeakerDiff: groupAnalysis.screenSpeakers.maxDiff,
              surroundSpeakerDiff: groupAnalysis.surroundSpeakers.maxDiff,
              upperSpeakerDiff: groupAnalysis.upperSpeakers.maxDiff,
              subwooferLevel: groupAnalysis.subwoofers.avgLevel,
              speakerCount: levels.length,
              levelConsistency: maxDifference <= 2.0 ? 'Excellent' : maxDifference <= 4.0 ? 'Good' : 'Needs Improvement',
              dataSource: dataSource,
              groupAnalysis: groupAnalysis,
              recommendations: this.generateSPLRecommendations(maxDifference, groupAnalysis)
            };
          } catch (error) {
            return { error: `SPL calculation error: ${error.message}`, maxDifference: null, dataSource };
          }
        }
        // Analyze SPL by speaker groups using actual speaker IDs
        analyzeSpeakerGroupSPL(levelData) {
          const groups = {
            screenSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            surroundSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            upperSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            subwoofers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            wideSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            unclassified: { speakers: [], levels: [], maxDiff: 0, avgLevel: null }
          };
          // Classify speakers by their IDs
          Object.entries(levelData).forEach(([speakerId, level]) => {
            const numLevel = parseFloat(level);
            if (!Number.isFinite(numLevel)) return;
            // Classify speaker by ID
            if (speakerId.toLowerCase().includes('subwoofer') || speakerId.startsWith('SW')) {
              groups.subwoofers.speakers.push(speakerId);
              groups.subwoofers.levels.push(numLevel);
            } else if (['FL', 'FC', 'FR', 'FCL', 'FCR', 'C'].includes(speakerId)) {
              groups.screenSpeakers.speakers.push(speakerId);
              groups.screenSpeakers.levels.push(numLevel);
            } else if (['FWL', 'FWR'].includes(speakerId)) {
              groups.wideSpeakers.speakers.push(speakerId);
              groups.wideSpeakers.levels.push(numLevel);
            } else if (['FHL', 'FHR', 'RHL', 'RHR', 'SHL', 'SHR', 'CH', 'TFL', 'TFR', 'TML', 'TMR', 'TRL', 'TRR', 'TS'].includes(speakerId)) {
              // Height or Top speakers
              groups.upperSpeakers.speakers.push(speakerId);
              groups.upperSpeakers.levels.push(numLevel);
            } else if (['BDL', 'BDR', 'FDL', 'FDR', 'SDL', 'SDR'].includes(speakerId)) {
              // Upfiring speakers - classify as upper speakers for CEDIA assessment
              groups.upperSpeakers.speakers.push(speakerId);
              groups.upperSpeakers.levels.push(numLevel);
            } else if (['SL', 'SR', 'SBL', 'SBR', 'SLA', 'SRA', 'SB'].includes(speakerId)) {
              groups.surroundSpeakers.speakers.push(speakerId);
              groups.surroundSpeakers.levels.push(numLevel);
            } else {
              groups.unclassified.speakers.push(speakerId);
              groups.unclassified.levels.push(numLevel);
            }
          });
          // Calculate statistics for each group
          Object.keys(groups).forEach(groupName => {
            const group = groups[groupName];
            if (group.levels.length > 0) {
              const maxLevel = Math.max(...group.levels);
              const minLevel = Math.min(...group.levels);
              group.maxDiff = this.preciseSubtraction(maxLevel, minLevel);
              group.avgLevel = Math.round((group.levels.reduce((sum, level) => sum + level, 0) / group.levels.length) * 10) / 10;
            }
          });
          return groups;
        }
        // Generate SPL-based recommendations
        generateSPLRecommendations(maxDifference, groupAnalysis) {
          const recommendations = [];
          if (maxDifference > 6) {
            recommendations.push("Critical: SPL difference >6dB detected. Review speaker placement, amplification, and calibration.");
          } else if (maxDifference > 4) {
            recommendations.push("Warning: SPL difference >4dB may affect imaging. Check speaker levels and room acoustics.");
          } else if (maxDifference > 2) {
            recommendations.push("Notice: SPL difference >2dB detected. Fine-tune calibration for optimal performance.");
          }
          // Group-specific recommendations
          if (groupAnalysis.screenSpeakers.maxDiff > 3) {
            recommendations.push("Screen speakers show significant level differences. Ensure matched amplification and verify speaker sensitivity.");
          }
          if (groupAnalysis.upperSpeakers.maxDiff > 5) {
            recommendations.push("Upper layer speakers show large level variations. Check mounting angles and amplifier settings.");
          }
          if (groupAnalysis.subwoofers.levels.length > 0) {
            const subLevel = groupAnalysis.subwoofers.avgLevel;
            const mainAvg = (groupAnalysis.screenSpeakers.avgLevel + groupAnalysis.surroundSpeakers.avgLevel) / 2;
            if (subLevel && mainAvg && Math.abs(subLevel - mainAvg) > 10) {
              recommendations.push("Subwoofer level significantly different from main speakers. Review bass management settings.");
            }
          }
          return recommendations;
        }
        // Enhanced room size estimation with acoustic modeling
        estimateEnhancedRoomSize(systemData) {
          // Use advanced room acoustics data if available
          if (systemData.roomAcoustics && systemData.roomAcoustics.dimensions) {
            return {
              estimatedLength: systemData.roomAcoustics.dimensions.length,
              estimatedWidth: systemData.roomAcoustics.dimensions.width,
              estimatedHeight: systemData.roomAcoustics.dimensions.height,
              estimatedVolume: systemData.roomAcoustics.dimensions.volume,
              surfaceArea: systemData.roomAcoustics.dimensions.surfaceArea,
              transitionFrequency: systemData.roomAcoustics.transitionFreq,
              reverbTime: systemData.roomAcoustics.reverbTime,
              roomModes: systemData.roomAcoustics.modes
            };
          }
          if (!systemData.customDistance || !systemData.flDist) {
            return { error: "Insufficient distance data", estimatedLength: null };
          }
          try {
            const distances = systemData.customDistance
              .slice(1)
              .map(dist => parseFloat(dist))
              .filter(dist => Number.isFinite(dist) && dist > 0);

            if (distances.length === 0) {
              return { error: "No valid distance measurements", estimatedLength: null };
            }
            const maxDistance = Math.max(...distances);
            const avgDistance = distances.reduce((sum, dist) => sum + dist, 0) / distances.length;
            // Enhanced room estimation using acoustic principles
            const estimatedLength = maxDistance * 1.6;
            const estimatedWidth = maxDistance * 1.2;
            const estimatedHeight = maxDistance * 0.4;
            const estimatedVolume = estimatedLength * estimatedWidth * estimatedHeight;
            // Calculate transition frequency for the room
            const reverbTime = this.estimateRT60(estimatedVolume);
            const transitionFreq = this.calculateSchroederFrequency(reverbTime, estimatedVolume);
            return {
              estimatedLength,
              estimatedWidth,
              estimatedHeight,
              estimatedVolume,
              avgListeningDistance: avgDistance,
              maxListeningDistance: maxDistance,
              wallProximity: Math.min(avgDistance * 0.25, 1.8),
              transitionFrequency: transitionFreq,
              reverbTime: reverbTime,
              roomRatio: {
                lengthToWidth: estimatedLength / estimatedWidth,
                widthToHeight: estimatedWidth / estimatedHeight,
                evaluation: this.evaluateRoomRatio(estimatedLength / estimatedWidth)
              }
            };
          } catch (error) {
            return { error: `Room estimation error: ${error.message}`, estimatedLength: null };
          }
        }
        // Enhanced system analysis with comprehensive validation
        analyzeEnhancedSystem() {
          if (!commandId || !Array.isArray(commandId)) {
            this.addValidationError("No valid speaker configuration detected");
            return null;
          }
          try {
            const actualSpeakers = commandId.filter(id => id && typeof id === 'string' && id.length > 0);
            // Enhanced speaker classification
            const analysis = {
              detectedSpeakers: actualSpeakers,
              // Categorize speakers by type
              screenSpeakers: actualSpeakers.filter(id =>
                ['FL', 'FC', 'FR', 'FCL', 'FCR', 'C'].includes(id)),
              heightSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.frontHeight.includes(id) ||
                this.speakerTypes.rearHeight.includes(id) ||
                this.speakerTypes.surroundHeight.includes(id)),
              topSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.topFront.includes(id) ||
                this.speakerTypes.topMiddle.includes(id) ||
                this.speakerTypes.topRear.includes(id)),
              upfiringSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.upfiringFront.includes(id) ||
                this.speakerTypes.upfiringBack.includes(id) ||
                this.speakerTypes.upfiringSurround.includes(id)),
              surroundSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.surround.includes(id) ||
                this.speakerTypes.surroundBack.includes(id)),
              wideSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.frontWide.includes(id)),
              subwoofers: actualSpeakers.filter(id => id.startsWith("SW")),
              totalMainSpeakers: 0,
              bedLayerSpeakers: 0,
              totalUpperSpeakers: 0,
              discreteSpeakerFeeds: 0,
              systemComplexity: 'Basic'
            };
            // Calculate totals correctly for X.Y.Z configuration format
            analysis.totalMainSpeakers = actualSpeakers.filter(id => !id.startsWith("SW")).length;
            analysis.totalUpperSpeakers = analysis.heightSpeakers.length + analysis.topSpeakers.length + analysis.upfiringSpeakers.length;
            // Bed layer = all main speakers EXCEPT height/top/upfiring speakers
            analysis.bedLayerSpeakers = analysis.totalMainSpeakers - analysis.totalUpperSpeakers;
            analysis.discreteSpeakerFeeds = analysis.totalMainSpeakers + (analysis.subwoofers.length > 0 ? 1 : 0);
            analysis.usesUpfiring = analysis.upfiringSpeakers.length > 0;
            // Calculate proper X.Y.Z configuration string
            const subCount = analysis.subwoofers.length > 0 ? 1 : systemData.nSubs > 0 ? 1 : 0;
            analysis.configurationString = `${analysis.bedLayerSpeakers}.${subCount}.${analysis.totalUpperSpeakers}`;
            // Assess system complexity based on bed layer + height speakers
            if (analysis.bedLayerSpeakers >= 7 || analysis.totalUpperSpeakers >= 4) {
              analysis.systemComplexity = 'High';
            } else if (analysis.bedLayerSpeakers >= 5 || analysis.totalUpperSpeakers >= 2) {
              analysis.systemComplexity = 'Medium';
            }
            // Validate speaker configuration
            analysis.configurationValid = this.validateSpeakerConfiguration(analysis);
            analysis.formatCompatibility = this.assessFormatCompatibility(analysis);
            return analysis;
          } catch (error) {
            this.addValidationError(`System analysis error: ${error.message}`);
            return null;
          }
        }
        // Enhanced parameter evaluation with comprehensive validation
        evaluateParameter(paramId, measuredValue, useRecommended = false) {
          const param = this.parameters[paramId];
          if (!param) {
            return {
              level: 0,
              score: 0,
              error: `Parameter ${paramId} not found`,
              measuredValue: null,
              category: "Unknown"
            };
          }
          try {
            // Use parameter-specific validator if available
            if (param.validator && typeof param.validator === 'function') {
              const validationResult = param.validator(measuredValue);
              if (!validationResult.valid) {
                return {
                  level: 0,
                  score: 0,
                  error: validationResult.error,
                  measuredValue,
                  category: param.category,
                  parameterName: param.name
                };
              }
              measuredValue = validationResult.value; // Use validated/normalized value
            }
            const { targets, type } = param;
            let achievedLevel = 0;
            // Special handling for boolean parameters
            if (paramId === 8) {
              achievedLevel = measuredValue === false ? 4 : 2;
              return {
                level: achievedLevel,
                score: achievedLevel * 25,
                measuredValue: measuredValue,
                category: param.category,
                notes: measuredValue ? "Using upfiring speakers" : "Using dedicated height/top speakers",
                parameterName: param.name,
                recommendation: measuredValue ? "Consider upgrading to dedicated height speakers for levels 3-4" : "Excellent speaker configuration"
              };
            }
            // Evaluate against performance level targets
            for (let level = 1; level <= 4; level++) {
              const target = targets[`level${level}`];
              if (target === null || target === undefined) continue;
              let passes = false;
              if (typeof target === 'object') {
                const threshold = useRecommended && target.rec !== undefined ? target.rec :
                  type === "minimum" ? target.min : target.max;
                if (threshold !== undefined) {
                  passes = type === "minimum" ?
                    this.preciseComparison(measuredValue, threshold, '>=') :
                    this.preciseComparison(measuredValue, threshold, '<=');
                }
              } else {
                passes = type === "minimum" ?
                  this.preciseComparison(measuredValue, target, '>=') :
                  this.preciseComparison(measuredValue, target, '<=');
              }
              if (passes) {
                achievedLevel = level;
              } else {
                break;
              }
            }
            return {
              level: achievedLevel,
              score: achievedLevel * 25,
              measuredValue: measuredValue,
              category: param.category,
              parameterName: param.name,
              recommendation: this.generateRecommendation(paramId, achievedLevel, measuredValue),
              targetValues: targets,
              usedRecommended: useRecommended
            };
          } catch (error) {
            return {
              level: 0,
              score: 0,
              error: `Evaluation error: ${error.message}`,
              measuredValue,
              category: param.category,
              parameterName: param.name
            };
          }
        }
        // Enhanced performance calculation with weighted scoring
        calculateSystemPerformance(results) {
          const validResults = Object.values(results).filter(r => r.level > 0 && !r.error);
          const errorResults = Object.values(results).filter(r => r.error);
          if (validResults.length === 0) {
            return {
              overallLevel: 0,
              overallScore: 0,
              category: "Non-compliant",
              errors: errorResults.length,
              confidence: "Low"
            };
          }
          // Calculate weighted performance based on parameter importance
          const spatialResults = validResults.filter(r => r.category === "Spatial Resolution");
          const dynamicResults = validResults.filter(r => r.category === "Dynamics");
          const timbreResults = validResults.filter(r => r.category === "Timbre");
          // Calculate category scores with weighting
          const spatialScore = spatialResults.length > 0 ?
            spatialResults.reduce((sum, r) => sum + r.score, 0) / spatialResults.length : 0;
          const dynamicScore = dynamicResults.length > 0 ?
            dynamicResults.reduce((sum, r) => sum + r.score, 0) / dynamicResults.length : 0;
          const timbreScore = timbreResults.length > 0 ?
            timbreResults.reduce((sum, r) => sum + r.score, 0) / timbreResults.length : 0;
          // Weighted overall score (Dynamics and Timbre are weighted higher)
          const weightedScore = Math.round(
            (spatialScore * 0.3 + dynamicScore * 0.4 + timbreScore * 0.3)
          );
          // Overall level is the minimum of all achieved levels (conservative approach)
          const minLevel = Math.min(...validResults.map(r => r.level));
          const avgScore = Math.round(validResults.reduce((sum, r) => sum + r.score, 0) / validResults.length);
          // Determine confidence level
          const completeness = validResults.length / 21; // Out of total 21 parameters
          const confidence = completeness >= 0.7 ? "High" :
            completeness >= 0.5 ? "Medium" : "Low";
          const categories = [
            "Non-compliant",
            "Performance Level 1",
            "Performance Level 2",
            "Performance Level 3",
            "Performance Level 4"
          ];
          return {
            overallLevel: minLevel,
            overallScore: avgScore,
            weightedScore: weightedScore,
            category: categories[minLevel] || "Non-compliant",
            totalParametersEvaluated: validResults.length,
            totalParametersAvailable: 21,
            completeness: Math.round(completeness * 100),
            confidence: confidence,
            categoryBreakdown: {
              spatial: { count: spatialResults.length, avgScore: Math.round(spatialScore) },
              dynamics: { count: dynamicResults.length, avgScore: Math.round(dynamicScore) },
              timbre: { count: timbreResults.length, avgScore: Math.round(timbreScore) }
            },
            errors: errorResults.length,
            warnings: this.validationErrors.length
          };
        }
        // Enhanced main assessment function with comprehensive analysis
        runReadOnlyAssessment() {
          console.log("═".repeat(75));
          console.log("🎯 CEDIA/CTA-RP22 ENHANCED PERFORMANCE ASSESSMENT v2.1");
          console.log("   🔬 Advanced Acoustic Analysis & CEDIA RP22 Mathematics");
          console.log("═".repeat(75));
          // Reset validation errors
          this.validationErrors = [];
          try {
            const systemData = this.captureAllSystemData();
            const systemAnalysis = this.analyzeEnhancedSystem();
            const splDifferences = this.calculateEnhancedSPLDifferences(systemData);
            const roomEstimate = this.estimateEnhancedRoomSize(systemData);
            if (!systemAnalysis) {
              console.error("X Cannot analyze system - insufficient data");
              this.logValidationErrors();
              return { error: "System analysis failed", validationErrors: this.validationErrors };
            }
            console.log("\n📋 COMPREHENSIVE SYSTEM ANALYSIS:");
            const subCount = systemAnalysis.subwoofers.length > 0 ? 1 : systemData.nSubs > 0 ? 1 : 0;
            console.log(`├─ Configuration: ${systemAnalysis.configurationString} (${systemAnalysis.bedLayerSpeakers} bed + ${subCount} LFE + ${systemAnalysis.totalUpperSpeakers} height)`);
            console.log(`├─ Discrete speaker feeds: ${systemAnalysis.discreteSpeakerFeeds}`);
            console.log(`├─ System complexity: ${systemAnalysis.systemComplexity}`);
            // Enhanced frequency data reporting
            if (systemData.freqIndex && systemData.freqIndex.frequencies) {
              console.log(`├─ Frequency analysis: ${systemData.freqIndex.count} measurement points (${systemData.freqIndex.minFreq}-${systemData.freqIndex.maxFreq}Hz)`);
              console.log(`├─ Measurement type: ${systemData.freqIndex.is1_3Octave ? '1/3 octave' : `~${systemData.freqIndex.bandsPerOctave} bands/octave`}`);
              console.log(`├─ Frequency range: ${(systemData.freqIndex.frequencyRange || 1).toFixed(1)}:1 ratio`);
            }
            // Enhanced timing data reporting
            if (systemData.mSec && systemData.mSec.delays) {
              console.log(`├─ Timing analysis: ${systemData.mSec.count} speaker delays analyzed`);
              // console.log(`├─ Delay spread: ${(systemData.mSec.delaySpread * 1000).toFixed(2)}ms (σ=${(systemData.mSec.stdDeviation * 1000).toFixed(2)}ms)`);
              console.log(`├─ Delay spread: ${(systemData.mSec.delaySpread * delaymax).toFixed(2)}ms (σ=${(systemData.mSec.stdDeviation * delaymax).toFixed(2)}ms)`);
              console.log(`├─ Timing consistency: ${systemData.mSec.timingConsistency}`);
              console.log(`├─ Early reflection est: ${systemData.mSec.earlyReflectionMetric}dB`);
            }
            // Enhanced playback levels reporting
            if (systemData.estimatedPlaybackLevels && Object.keys(systemData.estimatedPlaybackLevels).length > 0) {
              console.log(`├─ Playback levels: ${Object.keys(systemData.estimatedPlaybackLevels).length} speakers measured`);
              if (splDifferences && !splDifferences.error) {
                console.log(`├─ SPL consistency: ${splDifferences.levelConsistency} (max diff: ${splDifferences.maxDifference?.toFixed(1)}dB)`);
              }
            }
            // Enhanced speaker positioning analysis
            if (systemData.speakerAngles && Object.keys(systemData.speakerAngles).length > 0) {
              console.log(`├─ Speaker angles: ${Object.keys(systemData.speakerAngles).length} speakers calculated`);
              const avgHorizontal = Object.values(systemData.speakerAngles)
                .map(a => Math.abs(a.horizontal))
                .reduce((sum, a) => sum + a, 0) / Object.keys(systemData.speakerAngles).length;
              console.log(`├─ Avg horizontal angle: ${avgHorizontal.toFixed(1)}°`);
            }
            console.log(`├─ Screen speakers: ${systemAnalysis.screenSpeakers.join(", ") || "None"}`);
            console.log(`├─ Height speakers: ${systemAnalysis.heightSpeakers.join(", ") || "None"}`);
            console.log(`├─ Top speakers: ${systemAnalysis.topSpeakers.join(", ") || "None"}`);
            console.log(`├─ Wide speakers: ${systemAnalysis.wideSpeakers.join(", ") || "None"}`);
            console.log(`├─ Surround speakers: ${systemAnalysis.surroundSpeakers.join(", ") || "None"}`);
            console.log(`├─ Upfiring speakers: ${systemAnalysis.upfiringSpeakers.join(", ") || "None"}`);
            // Enhanced bass management reporting
            if (systemData.bassManagement) {
              console.log(`├─ Bass management: Avg XO ${systemData.bassManagement.averageCrossover.toFixed(0)}Hz, Spread ${systemData.bassManagement.crossoverSpread.toFixed(0)}Hz`);
            }
            console.log(`├─ Bass system: ${systemData.nSubs} sub(s), ${systemData.bassMode} mode`);
            // Enhanced room acoustics reporting
            if (roomEstimate && !roomEstimate.error) {
              console.log(`├─ Room estimate: ${roomEstimate.estimatedLength?.toFixed(1)}×${roomEstimate.estimatedWidth?.toFixed(1)}×${roomEstimate.estimatedHeight?.toFixed(1)}m`);
              console.log(`├─ Room volume: ${roomEstimate.estimatedVolume?.toFixed(1)}m³`);
              if (roomEstimate.transitionFrequency) {
                console.log(`├─ Transition freq: ${roomEstimate.transitionFrequency?.toFixed(0)}Hz (RT60: ${roomEstimate.reverbTime?.toFixed(2)}s)`);
              }
              if (roomEstimate.roomModes && roomEstimate.roomModes.length > 0) {
                const axialModes = roomEstimate.roomModes.filter(m => m.type === 'axial').slice(0, 3);
                if (axialModes.length > 0) {
                  console.log(`├─ Primary room modes: ${axialModes.map(m => `${m.frequency}Hz`).join(", ")}`);
                }
              }
            }
            if (systemAnalysis.formatCompatibility) {
              console.log(`└─ Format support: ${Object.entries(systemAnalysis.formatCompatibility).filter(([_, supported]) => supported).map(([format, _]) => format).join(", ")}`);
            }
            // Enhanced parameter evaluation using comprehensive data analysis
            const results = {};
            // Spatial Resolution Parameters (1-11)
            if (roomEstimate && roomEstimate.wallProximity !== null && !roomEstimate.error) {
              results[1] = this.evaluateParameter(1, roomEstimate.wallProximity);
            }
            results[2] = this.evaluateParameter(2, systemAnalysis.discreteSpeakerFeeds);
            results[3] = this.evaluateParameter(3, this.countOutOfZoneSpeakers(systemAnalysis, 'screen'));
            results[8] = this.evaluateParameter(8, systemAnalysis.usesUpfiring);
            results[11] = this.evaluateParameter(11, this.countOutOfZoneSpeakers(systemAnalysis, 'all'));
            // Enhanced angle-based parameters using calculated angles
            if (systemData.speakerAngles && Object.keys(systemData.speakerAngles).length > 0) {
              const maxSurroundAngle = this.calculateMaxAdjacentSurroundAngle(systemData.speakerAngles, systemAnalysis.surroundSpeakers);
              const maxUpperAngle = this.calculateMaxAdjacentUpperAngle(systemData.speakerAngles, systemAnalysis.heightSpeakers.concat(systemAnalysis.topSpeakers));
              const wideDeviation = this.calculateWideDeviationFromMedian(systemData.speakerAngles, systemAnalysis.wideSpeakers);
              if (maxSurroundAngle !== null) results[5] = this.evaluateParameter(5, maxSurroundAngle);
              if (maxUpperAngle !== null) results[9] = this.evaluateParameter(9, maxUpperAngle);
              if (wideDeviation !== null) results[7] = this.evaluateParameter(7, wideDeviation);
            }
            // SPL-based parameters (4, 6, 10) - Enhanced with speaker-specific data
            if (splDifferences && splDifferences.maxDifference !== null && !splDifferences.error) {
              results[4] = this.evaluateParameter(4, splDifferences.screenSpeakerDiff || splDifferences.maxDifference);
              results[6] = this.evaluateParameter(6, splDifferences.surroundSpeakerDiff || splDifferences.maxDifference);
              results[10] = this.evaluateParameter(10, splDifferences.upperSpeakerDiff || splDifferences.maxDifference);
            }
            // Dynamics Parameters (12-15) - Enhanced with playback level data
            if (systemData.estimatedPlaybackLevels && Object.keys(systemData.estimatedPlaybackLevels).length > 0) {
              // Use actual measured levels for SPL capability assessment
              const screenCapability = this.calculateSpeakerCapability(systemData.estimatedPlaybackLevels, 'screen', roomEstimate);
              const surroundCapability = this.calculateSpeakerCapability(systemData.estimatedPlaybackLevels, 'surround', roomEstimate);
              const subwooferCapability = this.calculateSpeakerCapability(systemData.estimatedPlaybackLevels, 'subwoofer', roomEstimate);
              if (screenCapability !== null) {
                results[12] = this.evaluateParameter(12, screenCapability, true);
              }
              if (surroundCapability !== null) {
                results[13] = this.evaluateParameter(13, surroundCapability, true);
              }
              if (subwooferCapability !== null) {
                results[14] = this.evaluateParameter(14, subwooferCapability, true);
              }
            } else if (systemData.targetLevel && Number.isFinite(systemData.targetLevel)) {
              // Fallback to estimated calculations
              const roomGain = roomEstimate && roomEstimate.estimatedVolume ?
                Math.max(0, 3 * Math.log10(100 / roomEstimate.estimatedVolume)) : 0;
              results[12] = this.evaluateParameter(12, systemData.targetLevel + 25 + roomGain, true);
              results[13] = this.evaluateParameter(13, systemData.targetLevel + 20 + roomGain, true);
              results[14] = this.evaluateParameter(14, systemData.targetLevel + 35 + roomGain, true);
            }
            // Estimate background noise (simplified - would need actual measurement)
            const estimatedNoiseFloor = this.estimateBackgroundNoise(systemData, roomEstimate);
            if (estimatedNoiseFloor !== null) {
              results[15] = this.evaluateParameter(15, estimatedNoiseFloor, true);
            }
            // Enhanced frequency response analysis using freqIndex data (Parameters 16, 17, 18)
            if (systemData.freqIndex && systemData.freqIndex.frequencies) {
              // Parameter 16: Screen wall speaker frequency response variance
              const screenFRVariance = this.calculateFrequencyResponseVariance(systemData, 'screen');
              if (screenFRVariance !== null) {
                results[16] = this.evaluateParameter(16, screenFRVariance);
              }
              // Parameter 17: Surround/Upper speaker frequency response variance
              const surroundFRVariance = this.calculateFrequencyResponseVariance(systemData, 'surround');
              if (surroundFRVariance !== null) {
                results[17] = this.evaluateParameter(17, surroundFRVariance);
              }
              // Parameter 18: Enhanced bass extension using frequency analysis
              if (systemData.bassExtension) {
                results[18] = this.evaluateParameter(18, systemData.bassExtension, true);
              } else {
                // Estimate bass extension from frequency data
                const estimatedBassExt = this.estimateBassExtensionFromFrequencies(systemData.freqIndex);
                if (estimatedBassExt !== null) {
                  results[18] = this.evaluateParameter(18, estimatedBassExt, true);
                }
              }
            }
            // Enhanced bass analysis using optimization data
            if (systemData.RP22subnminXO && systemData.RP22submaxXO &&
              Number.isFinite(systemData.RP22subnminXO) && Number.isFinite(systemData.RP22submaxXO)) {
              const bandwidth = systemData.RP22submaxXO - systemData.RP22subnminXO;
              const smoothnessEst = this.estimateBassSmoothness(bandwidth, systemData.delayRange);
              if (smoothnessEst !== null) {
                results[19] = this.evaluateParameter(19, smoothnessEst);
                if (systemData.delayRange && systemData.delayRange.range !== null) {
                  const consistencyEst = this.estimateBassConsistency(systemData.delayRange.range);
                  results[20] = this.evaluateParameter(20, consistencyEst);
                }
              }
            }
            // Enhanced early reflection analysis using timing data (Parameter 21)
            if (systemData.mSec && systemData.mSec.delays) {
              const earlyReflectionLevel = systemData.mSec.earlyReflectionMetric;
              if (earlyReflectionLevel !== null) {
                results[21] = this.evaluateParameter(21, earlyReflectionLevel);
              }
            }
            // Calculate overall performance with enhanced metrics
            const performance = this.calculateSystemPerformance(results);
            console.log(`\n🏆 ENHANCED PERFORMANCE RESULTS:`);
            console.log(`├─ Overall Level: ${performance.overallLevel}/4 (${performance.category})`);
            console.log(`├─ Assessment Score: ${performance.overallScore}/100 (Weighted: ${performance.weightedScore}/100)`);
            console.log(`├─ Parameter Coverage: ${performance.totalParametersEvaluated}/21 (${performance.completeness}%)`);
            console.log(`├─ Assessment Confidence: ${performance.confidence}`);
            console.log(`├─ Spatial Resolution: ${performance.categoryBreakdown.spatial.count} params, avg ${performance.categoryBreakdown.spatial.avgScore}/100`);
            console.log(`├─ Dynamics: ${performance.categoryBreakdown.dynamics.count} params, avg ${performance.categoryBreakdown.dynamics.avgScore}/100`);
            console.log(`├─ Timbre: ${performance.categoryBreakdown.timbre.count} params, avg ${performance.categoryBreakdown.timbre.avgScore}/100`);
            if (performance.errors > 0) {
              console.log(`├─ Errors: ${performance.errors} parameter evaluation errors`);
            }
            if (performance.warnings > 0) {
              console.log(`├─ Warnings: ${performance.warnings} validation warnings`);
            }
            // Enhanced final reporting with SPL analysis details
            if (splDifferences && !splDifferences.error && splDifferences.dataSource) {
              console.log(`\n📊 SPL ANALYSIS DETAILS (Source: ${splDifferences.dataSource}):`);
              console.log(`├─ Total speakers analyzed: ${splDifferences.speakerCount}`);
              console.log(`├─ SPL range: ${splDifferences.minLevel?.toFixed(1)} - ${splDifferences.maxLevel?.toFixed(1)} dB`);
              console.log(`├─ Average level: ${splDifferences.avgLevel} dB`);
              console.log(`├─ Standard deviation: ${splDifferences.standardDeviation} dB`);
              console.log(`├─ Screen speakers diff: ${splDifferences.screenSpeakerDiff?.toFixed(1)} dB`);
              console.log(`├─ Surround speakers diff: ${splDifferences.surroundSpeakerDiff?.toFixed(1)} dB`);
              console.log(`├─ Upper speakers diff: ${splDifferences.upperSpeakerDiff?.toFixed(1)} dB`);
              if (splDifferences.subwooferLevel) {
                console.log(`├─ Subwoofer level: ${splDifferences.subwooferLevel} dB`);
              }
              console.log(`└─ Overall consistency: ${splDifferences.levelConsistency}`);
              if (splDifferences.recommendations && splDifferences.recommendations.length > 0) {
                console.log(`\n💡 SPL RECOMMENDATIONS:`);
                splDifferences.recommendations.forEach((rec, index) => {
                  console.warn(`   ${index + 1}. ${rec}`);
                });
              }
            }
            console.log(`\n📊 DETAILED PARAMETER BREAKDOWN:`);
            Object.entries(results).forEach(([paramId, result]) => {
              const status = result.error ? "X" :
                result.level >= 3 ? "✓" :
                  result.level >= 2 ? "⚠️" :
                    result.level >= 1 ? "🔶" : "X";
              console.log(`${status} P${paramId.padStart(2, '0')}: ${result.parameterName}`);
              if (result.error) {
                console.log(`    └─ Error: ${result.error}`);
              } else {
                console.log(`    ├─ Level: ${result.level}/4 | Score: ${result.score}/100`);
                console.log(`    ├─ Measured: ${this.formatMeasuredValue(result.measuredValue, this.parameters[paramId].unit)}`);
                if (result.recommendation) {
                  console.log(`    └─ Recommendation: ${result.recommendation}`);
                }
              }
            });
            // Log validation errors and warnings if any
            this.logValidationErrors();
            console.log(`\n📚 Enhanced Analysis Notes:`);
            console.log(`├─ Assessment uses CEDIA/CTA-RP22 v1.2 September 2023 standards`);
            console.log(`├─ Frequency data processed as measurement point arrays with 1/3 octave analysis`);
            console.log(`├─ Timing data analyzed for early reflection and alignment characteristics`);
            console.log(`├─ Calculations include precision handling and validation`);
            console.log(`├─ Room acoustics use Schroeder frequency and modal analysis`);
            console.log(`├─ SPL calculations include boundary loading and room effects`);
            console.log(`├─ Speaker angles calculated using trigonometric principles`);
            console.log(`├─ Bass management analyzed using crossover optimization data`);
            console.log(`├─ Frequency response variance estimated from measurement data patterns`);
            console.log(`├─ Early reflections assessed from timing delay characteristics`);
            console.log(`└─ Weighted scoring emphasizes critical performance areas`);
            console.log("═".repeat(75));
            return {
              systemData,
              systemAnalysis,
              performance,
              results,
              splDifferences,
              roomEstimate,
              validationErrors: this.validationErrors,
              timestamp: new Date().toISOString(),
              version: "2.1-Enhanced-Acoustics"
            };
          } catch (error) {
            console.error("X Assessment failed:", error.message);
            console.log("═".repeat(75));
            return {
              error: `Assessment failed: ${error.message}`,
              validationErrors: this.validationErrors,
              timestamp: new Date().toISOString()
            };
          }
        }
        // Additional helper methods for enhanced functionality
        // Calculate speaker SPL capability from measured levels
        calculateSpeakerCapability(playbackLevels, speakerGroup, roomEstimate) {
          const groupLevels = [];
          // Filter levels by speaker group
          Object.entries(playbackLevels).forEach(([speakerId, level]) => {
            const numLevel = parseFloat(level);
            if (!Number.isFinite(numLevel)) return;
            let matchesGroup = false;
            switch (speakerGroup.toLowerCase()) {
              case 'screen':
                matchesGroup = ['FL', 'FC', 'FR', 'FCL', 'FCR'].includes(speakerId);
                break;
              case 'surround':
                matchesGroup = ['SL', 'SR', 'SBL', 'SBR', 'SLA', 'SRA'].includes(speakerId) ||
                  speakerId.includes('SL') || speakerId.includes('SR') || speakerId.includes('SB');
                break;
              case 'subwoofer':
                matchesGroup = speakerId.toLowerCase().includes('subwoofer') || speakerId.startsWith('SW');
                break;
              case 'upper':
                matchesGroup = speakerId.includes('H') || speakerId.startsWith('T');
                break;
            }
            if (matchesGroup) {
              groupLevels.push(numLevel);
            }
          });
          if (groupLevels.length === 0) {
            return null; // No speakers found for this group
          }
          // Calculate estimated maximum capability
          // Assumption: current levels represent ~75dB reference, estimate headroom to maximum
          const avgCurrentLevel = groupLevels.reduce((sum, level) => sum + level, 0) / groupLevels.length;
          // Estimate maximum capability based on typical amplifier headroom and speaker limits
          // Professional systems typically have 20-30dB headroom above reference level
          let estimatedMaxCapability;
          if (speakerGroup.toLowerCase() === 'subwoofer') {
            // Subwoofers typically have higher capability
            estimatedMaxCapability = avgCurrentLevel + 35; // More headroom for LFE
          } else {
            // Main speakers
            estimatedMaxCapability = avgCurrentLevel + 25; // Standard headroom
          }
          // Apply room gain if available
          if (roomEstimate && roomEstimate.estimatedVolume && Number.isFinite(roomEstimate.estimatedVolume)) {
            const roomGain = Math.max(0, 3 * Math.log10(100 / roomEstimate.estimatedVolume));
            estimatedMaxCapability += roomGain;
          }
          // Apply small room boundary loading (typically 2-6dB for speakers near walls)
          if (speakerGroup.toLowerCase() !== 'subwoofer') {
            estimatedMaxCapability += 3; // Typical boundary loading gain
          }
          return Math.round(estimatedMaxCapability * 10) / 10;
        }
        // Calculate maximum angle between adjacent surround speakers
        calculateMaxAdjacentSurroundAngle(speakerAngles, surroundSpeakers) {
          if (surroundSpeakers.length < 2) return null;
          const surroundAngles = surroundSpeakers
            .map(id => speakerAngles[id]?.horizontal)
            .filter(angle => Number.isFinite(angle))
            .sort((a, b) => a - b);
          if (surroundAngles.length < 2) return null;
          let maxDifference = 0;
          for (let i = 1; i < surroundAngles.length; i++) {
            const diff = Math.abs(surroundAngles[i] - surroundAngles[i - 1]);
            maxDifference = Math.max(maxDifference, diff);
          }
          return maxDifference;
        }
        // Calculate maximum angle between adjacent upper speakers
        calculateMaxAdjacentUpperAngle(speakerAngles, upperSpeakers) {
          if (upperSpeakers.length < 2) return null;
          const upperAngles = upperSpeakers
            .map(id => speakerAngles[id]?.elevation || speakerAngles[id]?.vertical)
            .filter(angle => Number.isFinite(angle))
            .sort((a, b) => a - b);
          if (upperAngles.length < 2) return null;
          let maxDifference = 0;
          for (let i = 1; i < upperAngles.length; i++) {
            const diff = Math.abs(upperAngles[i] - upperAngles[i - 1]);
            maxDifference = Math.max(maxDifference, diff);
          }
          return maxDifference;
        }
        // Calculate wide speaker deviation from median angle
        calculateWideDeviationFromMedian(speakerAngles, wideSpeakers) {
          if (wideSpeakers.length === 0) return null;
          const wideAngles = wideSpeakers
            .map(id => Math.abs(speakerAngles[id]?.horizontal || 0))
            .filter(angle => Number.isFinite(angle));
          if (wideAngles.length === 0) return null;
          const median = wideAngles.sort((a, b) => a - b)[Math.floor(wideAngles.length / 2)];
          const maxDeviation = Math.max(...wideAngles.map(angle => Math.abs(angle - median)));
          return maxDeviation;
        }
        // Validation helper methods
        validateNumeric(value, fieldName) {
          if (value === null || value === undefined) return null;
          const num = Number(value);
          if (!Number.isFinite(num)) {
            this.addValidationError(`Invalid numeric value for ${fieldName}: ${value}`);
            return null;
          }
          return num;
        }
        validateFrequency(value) {
          if (value === null || value === undefined) return null;
          const freq = Number(value);
          if (!Number.isFinite(freq) || freq <= 0) {
            this.addValidationError(`Invalid frequency value: ${value}`);
            return null;
          }
          return freq;
        }
        validateArray(arr, fieldName) {
          if (!Array.isArray(arr)) {
            this.addValidationError(`${fieldName} is not an array`);
            return [];
          }
          return arr;
        }
        addValidationError(message) {
          this.validationErrors.push(message);
        }
        logValidationErrors() {
          if (this.validationErrors.length > 0) {
            console.log(`\n⚠️  VALIDATION WARNINGS (${this.validationErrors.length}):`);
            this.validationErrors.forEach((error, index) => {
              console.log(`   ${index + 1}. ${error}`);
            });
          }
        }
        // Precision calculation helpers
        preciseComparison(a, b, operator) {
          if (a === null || b === null) return false;
          const diff = Math.abs(a - b);
          if (diff < this.PRECISION.SPL_TOLERANCE) return operator.includes('=');
          switch (operator) {
            case '>=': return a > b;
            case '<=': return a < b;
            case '>': return a > b && diff >= this.PRECISION.SPL_TOLERANCE;
            case '<': return a < b && diff >= this.PRECISION.SPL_TOLERANCE;
            default: return false;
          }
        }
        preciseSubtraction(a, b) {
          return Math.round((a - b) * 10) / 10; // Round to 0.1 precision
        }
        // Helper methods for enhanced functionality
        calculateDiscreteSpeakerFeeds(systemData) {
          if (!systemData.commandId || !Array.isArray(systemData.commandId)) return 0;
          const mainSpeakers = systemData.commandId.filter(id => id && !id.startsWith("SW")).length;
          const hasSubwoofer = systemData.nSubs > 0 || systemData.commandId.some(id => id && id.startsWith("SW"));
          return mainSpeakers + (hasSubwoofer ? 1 : 0);
        }
        evaluateRoomRatio(ratio) {
          if (ratio >= 1.15 && ratio <= 1.45) return 'Optimal';
          if (ratio >= 1.05 && ratio <= 1.6) return 'Good';
          return 'Suboptimal';
        }
        getDefaultSystemData() {
          return {
            nSpeakers: 0, nSubs: 0, noSub: true, targetLevel: 75,
            commandId: [], discreteSpeakerFeeds: 0,
            error: "Failed to capture system data - using defaults"
          };
        }
        formatMeasuredValue(value, unit) {
          if (value === null || value === undefined) return 'N/A';
          if (typeof value === 'boolean') return value ? 'Yes' : 'No';
          if (typeof value === 'number') return `${value.toFixed(1)} ${unit}`;
          return `${value} ${unit}`;
        }
        // Enhanced parameter validation methods
        estimateBassSmoothness(bandwidth, delayRange) {
          return bandwidth >= 200 ? 2 : bandwidth >= 150 ? 3 : 4;
        }
        estimateBassConsistency(rangeValue) {
          return rangeValue >= 10 ? 2 : rangeValue >= 6 ? 3 : rangeValue >= 3 ? 4 : 5;
        }
        generateRecommendation(paramId, level, value) {
          return level >= 3 ? "Excellent performance" : "Consider improvements for higher performance levels";
        }
        // Placeholder methods for parameter-specific validators (would be fully implemented)
        validateDistanceParameter(value) { return { valid: true, value }; }
        validateSpeakerCount(value) { return { valid: true, value }; }
        validateZonalCompliance(value) { return { valid: true, value }; }
        validateSPLConsistency(value) { return { valid: true, value }; }
        validateSpeakerAngles(value) { return { valid: true, value }; }
        validateWideAlignment(value) { return { valid: true, value }; }
        validateUpfiringSpeakers(value) { return { valid: true, value }; }
        validateVerticalAngles(value) { return { valid: true, value }; }
        validateSPLCapability(value) { return { valid: true, value }; }
        validateLFECapability(value) { return { valid: true, value }; }
        validateNoiseFloor(value) { return { valid: true, value }; }
        validateFrequencyResponse(value) { return { valid: true, value }; }
        validateBassExtension(value) { return { valid: true, value }; }
        validateBassResponse(value) { return { valid: true, value }; }
        validateBassConsistency(value) { return { valid: true, value }; }
        validateReflections(value) { return { valid: true, value }; }
        // Additional helper methods
        validateSpeakerConfiguration(analysis) { return true; /* Would validate config */ }
        assessFormatCompatibility(analysis) { return null; /* Would assess format support */ }
        countOutOfZoneSpeakers(analysis, group) { return 0; /* Would count misplaced speakers */ }
        estimateBackgroundNoise(systemData, roomEstimate) { return null; /* Would estimate noise */ }
      }
      // Keep the same function name as requested
      async function runCEDIAReadOnlyAssessment() {
        const scorer = new CEDIAPerformanceScorer();
        return scorer.runReadOnlyAssessment();
      }
      // console logger > allow collapse in VSC
      function initializeConsoleLogger() {
        const logContainer = document.getElementById('logContainer');
        function scrollToBottom() {
          logContainer.scrollTop = logContainer.scrollHeight;
        }
        let lastInfoEntry = null;
        // Store original console methods
        const originalMethods = {
          warn: console.warn,
          info: console.info,
          log: console.log,
          error: console.error
        };
        console.warn = function (...args) {
          const warningMessage = args.join(' ');
          const warningEntry = `<div class="warning">${new Date().toLocaleTimeString()} [**WARNING**] ${warningMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', warningEntry);
          scrollToBottom();
          originalMethods.warn.apply(console, args);
        };
        console.info = function (...args) {
          const infoMessage = args.join(' ');
          const infoEntry = `<div class="info">${new Date().toLocaleTimeString()} [INFORMATION] ${infoMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', infoEntry);
          lastInfoEntry = logContainer.lastElementChild;
          scrollToBottom();
          originalMethods.info.apply(console, args);
        };
        console.infoUpdate = function (...args) {
          const infoMessage = args.join(' ');
          if (lastInfoEntry) {
            lastInfoEntry.innerHTML = `${new Date().toLocaleTimeString()} [INFORMATION] ${infoMessage}`;
            scrollToBottom();
          } else {
            console.info(...args);
          }
          originalMethods.info.apply(console, args);
        };
        console.log = function (...args) {
          const logMessage = args.join(' ');
          const logEntry = `<div class="log">${new Date().toLocaleTimeString()} [*IMPORTANT*] ${logMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', logEntry);
          scrollToBottom();
          originalMethods.log.apply(console, args);
        };
        console.error = function (...args) {
          const errorMessage = args.join(' ');
          const errorEntry = `<div class="error">${new Date().toLocaleTimeString()} [***ERROR***] ${errorMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', errorEntry);
          scrollToBottom();
          originalMethods.error.apply(console, args);
        };
      }
      // Working PDF solution using pure jsPDF
      function saveLogAsPDF() {
        const logContainer = document.getElementById("logContainer");
        if (!logContainer) {
          console.log("No log container found!");
          return;
        }
        // Extract all text content
        const logEntries = logContainer.querySelectorAll('.log, .warning, .info');
        const logData = [];
        logEntries.forEach(entry => {
          let text = entry.textContent || entry.innerText;
          // Debug: Check what classes each entry has
          // console.log(`Entry classes: ${entry.className}, text preview: ${text.substring(0, 30)}...`);
          // Clean up emojis and special characters that jsPDF can't handle
          text = text
            .replace(/👆/g, '[CURSOR]')
            .replace(/🔥/g, '[RESET]')
            .replace(/📊/g, '[DATA]')
            .replace(/🎛️/g, '[SLIDER]')
            .replace(/🔧/g, '[TOOL]')
            .replace(/✅/g, '[OK]')
            .replace(/🚀/g, '[AUTO]')
            .replace(/🔒/g, '[LOCK]')
            .replace(/🔓/g, '[UNLOCK]')
            .replace(/🎉/g, '[COMPLETE]')
            .replace(/🎯/g, '[TARGET]')
            .replace(/🎬/g, '[CINEMA]')
            .replace(/🤖/g, '[AUTO]')
            .replace(/⚠️/g, '[WARNING]')
            .replace(/🔶/g, '[NOTICE]')
            .replace(/📘/g, '[INFO]')
            .replace(/🔄/g, '[REFRESH]')
            .replace(/👤/g, '[USER]')
            .replace(/🏆/g, '[SCORE]')
            .replace(/📚/g, '[NOTES]')
            .replace(/📋/g, '[LIST]')
            .replace(/❌/g, '[X]')
            .replace(/🔍/g, '[SEARCH]')
            .replace(/📈/g, '[CHART]')
            .replace(/⭐/g, '[STAR]')
            .replace(/💡/g, '[IDEA]')
            .replace(/🎵/g, '[MUSIC]')
            .replace(/🔊/g, '[AUDIO]')
            .replace(/🎤/g, '[MIC]')
            .replace(/🎧/g, '[HEADPHONES]')
            .replace(/🚫/g, '[BLOCKED]')
            .replace(/├─/g, '--')
            .replace(/\n/g, '')
            .replace(/→/g, '->')
            .replace(/←/g, '<-')
            .replace(/└─/g, '__')
            .replace(/🔬/g, '@')
            .replace(/✓/g, '[OK]')
            // Remove any remaining emojis/special unicode characters
            .replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '[?]')
            // Clean up any problematic characters
            .replace(/[^\x20-\x7E\u00A0-\u00FF]/g, '?');
          let prefix = "";
          let color = [0, 0, 0]; // black
          if (entry.classList.contains('warning')) {
            prefix = "[WARNING] ";
            color = [204, 102, 0]; // orange
          } else if (entry.classList.contains('info')) {
            prefix = "[INFO] ";
            color = [0, 102, 204]; // blue
          } else {
            prefix = "";
            color = [0, 0, 0]; // black
          }
          logData.push({
            text: prefix + text,
            color: color
          });
        });
        console.log(`Found ${logData.length} log entries to export`);
        // Create PDF with jsPDF
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
          orientation: 'portrait',
          unit: 'mm',
          format: 'a4'
        });
        // PDF settings
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const margin = 15;
        const maxLineWidth = pageWidth - (margin * 2);
        const lineHeight = 4;
        let yPosition = 20;
        // Add title
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.text(`${nextversion} Log`, margin, yPosition);
        yPosition += 10;
        // Add timestamp
        const now = new Date();
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        doc.text(`Generated: ${now.toLocaleString()}`, margin, yPosition);
        yPosition += 10;
        // Add separator line
        doc.setDrawColor(0, 0, 0);
        doc.line(margin, yPosition, pageWidth - margin, yPosition);
        yPosition += 8;
        // Add log content
        doc.setFontSize(8);
        doc.setFont('courier', 'normal');
        logData.forEach((entry, index) => {
          // Check if we need a new page
          if (yPosition > pageHeight - 20) {
            doc.addPage();
            yPosition = margin;
          }
          // Set color for this entry
          doc.setTextColor(entry.color[0], entry.color[1], entry.color[2]);
          // Debug: Log color being applied (only for first few entries to avoid spam)
          // if (index < 5) {
          //   console.log(`Entry ${index}: Color [${entry.color.join(', ')}] for text: ${entry.text.substring(0, 50)}...`);
          // }
          // Split long lines to fit page width, but respect word boundaries
          const lines = doc.splitTextToSize(entry.text, maxLineWidth);
          lines.forEach(line => {
            if (yPosition > pageHeight - 20) {
              doc.addPage();
              yPosition = margin;
              // Reapply color after new page
              doc.setTextColor(entry.color[0], entry.color[1], entry.color[2]);
            }
            doc.text(line, margin, yPosition);
            yPosition += lineHeight;
          });
          // Add small spacing between log entries for readability
          yPosition += 1;
        });
        // Generate filename with timestamp
        const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, "0")}${String(now.getDate()).padStart(2, "0")}_${String(now.getHours()).padStart(2, "0")}${String(now.getMinutes()).padStart(2, "0")}`;
        // Save the PDF
        doc.save(`${nextversion} Log ${timestamp}.pdf`);
        console.log("PDF saved successfully using jsPDF!");
      }
      // Ultimate simple test
      function testJsPDF() {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        doc.text('Hello World', 20, 20);
        doc.save('test.pdf');
      }
      // PDF solution using pure jsPDF
      function debugLogClasses() {
        const logContainer = document.getElementById("logContainer");
        const allEntries = logContainer.querySelectorAll('*');
        console.log(`Total elements in log: ${allEntries.length}`);
        allEntries.forEach((entry, index) => {
          if (entry.className) {
            console.log(`Element ${index}: class="${entry.className}", text="${entry.textContent.substring(0, 50)}..."`);
          }
        });
        // Check specifically for warning/info classes
        const warnings = logContainer.querySelectorAll('.warning');
        const infos = logContainer.querySelectorAll('.info');
        const logs = logContainer.querySelectorAll('.log');
        console.log(`Found: ${warnings.length} warnings, ${infos.length} info entries, ${logs.length} regular logs`);
      }
      // Initialize the console logger
      initializeConsoleLogger();
    </script>
</body>

</html>