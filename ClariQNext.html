<!DOCTYPE html>
<html lang="en-US" class="notranslate" translate="no">

<head>
  <meta charset="UTF-8">
  <title>ClariQ Next - Nvexx 2025</title>
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/css/bootstrap.min.css'>
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css'>
  <link rel='stylesheet'
    href='https://cdnjs.cloudflare.com/ajax/libs/simple-line-icons/2.5.5/css/simple-line-icons.min.css'>
  <link rel="stylesheet" href="./style.css">
  <meta name="googlebot" content="notranslate" />
  <meta name="google" content="notranslate">
</head>

<body data-theme="dark">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    //ALL SETTINGS GO HERE
    const nextversion = "ClariQ Next 0.1.1 - 19-10-2025 @ 20:24";
    // ClearCurve
    let isClearCurve = false;
    const modelsSoS300 = ["-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011", "SR6011", "C-A110", "X3700H", "X4700H", "X6500H", "X6700H",
      "X8500H", "R-A110", "-S730H", "-S740H", "-S750H", "-S760H", "-S930H", "-S940H", "-S950H", "-S960H", "X1400H", "X1500H", "X1600H",
      "X1700H", "X2400H", "X2500H", "X2600H", "X2700H", "X3400H", "X3500H", "X3600H", "X3700H", "X4300H", "X4400H", "X4500H", "X4700H",
      "X6300H", "X6400H", "X6500H", "X6700H", "X8500H", "AV7703", "AV7704", "AV7705", "AV7706", "AV8805", "NR1608", "NR1609", "NR1710",
      "NR1711", "SR5012", "SR5013", "SR5014", "SR5015", "SR6012", "SR6013", "SR6014", "SR6015", "SR7011", "SR7012", "SR7013", "SR7015",
      "SR8012", "SR8015"];
    const micCalProb = ["-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011",
      "-S730H", "-S740H", "-S750H", "-S760H", "-S930H", "-S940H", "-S950H",
      "-S960H", "X1400H", "X1500H", "X1600H", "X1700H", "X2400H", "X2500H",
      "X2600H", "X2700H", "X3400H", "X3500H", "X3600H", "NR1608", "NR1609",
      "NR1710", "NR1711", "SR5012", "SR5013", "SR5014", "SR5015", "SR6013",
      "SR6014", "-S770H", "-S970H", "X1800H", "X2800H", "EMA 60", "MA 70s"];
    const noxo180 = ["-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011", "SR6011", "X6500H", "-S730H", "-S740H", "-S930H", "-S940H",
      "X1400H", "X1500H", "X2400H", "X2500H", "X3400H", "X3500H", "X4300H", "X4400H", "X4500H", "X6300H", "X6400H", "X6500H", "AV7703",
      "AV7704", "AV7705", "NR1608", "NR1609", "SR5012", "SR5013", "SR6012", "SR6013", "SR7011", "SR7012", "SR7013", "SR8012"];
    const models70xo = ["A-900H", "MA 70S", "-S970H", "X2800H", "-S670H", " AV 10", " AV 20", "VR-A1H", "VC-A1H", "X3800H", "X4800H",
      "EMA 30", "EMA 40", "EMA 50", "X6800H", "R-A10H", "C-A10H"];
    // https://www.dirac.com/online-store/ 18m supported  
    const modelsDirac = ["VR-A1H", "VC-A1H", "R-A10H", "C-A10H", "X6800H", "X4800H", "X3800H", " AV 10", " AV 20", "EMA 30", "EMA 40", "EMA 50"];
    let DiracEnabled = false;
    const baseUrl = 'http://localhost:4735/measurements', retryDelay = 500;
    let adyContents, fileName, sOs, isCirrusLogic, flDist, nChannels, nSpeakers, nSubs, noCenter;
    let targetCurvePath, targetCurveName, targetResponse, noInversion = false, swInvMsg = "";
    let bassMode = "Standard", noSub = false, subLoTrim, subHiTrim, subLoDelay, subHiDelay;
    let minXO = 40, maxXO = 250, previousDelay = null, swChannelCount = 0;
    const freqIndex = [40, 60, 80, 90, 100, 110, 120, 150, 200, 250];
    const customLevel = [], customDistance = [], customCrossover = [];
    const mSec = [], invertSub = [], commandId = [];
    const m3dBPoints = {};
    let targetLevel = 75.0; // Audyssey typically calibrates to 75 dB SPL
    let isCirrusLogictargetLevel = 75.0;
    // Advanced sorting check and correction
    let needsSorting = false, expectedOrder = [];
    // MODES
    let isDarkMode = true, isDyslexicMode = false;
    let isDolbymode = false, isTHXmode = false, isIMAXmode = false, supportsIMAX = false;
    let modeSubXOMin = 31.5, modeSubXOMax = 120, modeSpkMin = 20, modeSpkMax = 20000;
    // cedia specific
    let isRP22mode = false;
    let RP22subnminXO, RP22submaxXO, RP22subrequiredDelay, RP22hasAtmos, RP22hasDTSX, RP22hasAURO3D;
    let estimatedPlaybackLevels = [], estimatedDistances = [], RP22BestXO = [];
    // CONDENCED VERSION
    let AdvancedFilters = false, AdvancedFiltersType = "null";
    // SPEED DELAY BASED ON CPU CORES
    var cores = 1;
    const getOptimalDelay = () => {
      cores = navigator.hardwareConcurrency || 1; // Fallback to 1 if undefined
      let delay;
      if (cores <= 1) {
        delay = 256;
      } else if (cores <= 2) {
        delay = 236;
      } else if (cores <= 4) {
        delay = 216;
      } else if (cores <= 8) {
        delay = 196;
      } else if (cores <= 12) {
        delay = 176;
      } else if (cores <= 16) {
        delay = 156;
      } else if (cores <= 24) {
        delay = 136;
      } else if (cores <= 32) {
        delay = 116;
      } else {
        delay = 256;
      }
      console.warn(`⚠ Detected ${cores} logical CPU core(s). Assigned delay: ${delay}ms`);
      return delay;
    };
    let speedDelay = getOptimalDelay();
    // store more AVR default values
    let lfcSupport, enMultEQType, auro, dolbyVersion, dynamicEq, dynamicVolume, lfc, subwooferNum, subwooferLayout;
    let hasHeightChannel = false, isDebugMode = false;
    const heightChannelIds = ["FHL", "RHL", "SHL", "TFL", "TML", "TRL", "BDL", "FDL", "SDL", "TS", "CH"], delaymax = 1000;
    let lowFreq, highFreq;
    let IsCustomMeasurements = false;
    // Trim map to use with Filters.?? 
    let normalizedTrimMap = {};
    let phaseWeight = 0.5; // Default 50%
    // 
    const CenterChannelId = ["C"];
    let hasCenterChannel = false;
    const CenterHeightChannelId = ["CH"];
    let hasCenterHeightChannel = false;
    const SurroundBackSingleChannelId = ["SB"];
    let hasSurroundBackSingleChannel = false;
    const TopSurroundChannelId = ["TS"];
    let hasTopSurroundChannel = false;
    const FrontLeftFrontRightChannelId = ["FL", "FR"];
    let hasFrontLeftFrontRightChannel = false;
    const FrontWideLeftFrontWideRightChannelId = ["FWL", "FWR"];
    let hasFrontWideLeftFrontWideRightChannel = false;
    const SurroundLeftSurroudRightChannelId = ["SLA", "SRA"];
    let hasSurroundLeftSurroudRightChannel = false;
    const SurroundBackLeftSurroundBackRightChannelId = ["SBL", "SBR"];
    let hasSurroundBackLeftSurroundBackRightChannel = false;
    const FrontHeightLeftFrontHeightRightChannelId = ["FHL", "FHR"];
    let hasFrontHeightLeftFrontHeightRightChannel = false;
    const SurroundHeightLeftSurroudHeightRightChannelId = ["SHL", "SHR"];
    let hasSurroundHeightLeftSurroudHeightRightChannel = false;
    const RearHeightLeftRearHeightRightChannelId = ["RHL", "RHR"];
    let hasRearHeightLeftRearHeightRightChannel = false;
    const TopFrontLeftTopFrontRightChannelId = ["TFL", "TFR"];
    let hasTopFrontLeftTopFrontRightChannel = false;
    const TopMiddleLeftTopMiddleRightChannelId = ["TML", "TMR"];
    let hasTopMiddleLeftTopMiddleRightChannel = false;
    const TopRearLeftTopRearRightChannelId = ["TRL", "TRR"];
    let hasTopRearLeftTopRearRightChannel = false;
    const FrontDolbyLeftFrontDolbyRightChannelId = ["FDL", "FDR"];
    let hasFrontDolbyLeftFrontDolbyRightChannel = false;
    const SurroundDolbyLeftSurroundDolbyRightChannelId = ["SDL", "SDL"];
    let hasSurroundDolbyLeftSurroundDolbyRightChannel = false;
    const BackDolbyLeftBackDolbyRightChannelId = ["BDL", "BDL"];
    let hasBackDolbyLeftBackDolbyRightChannel = false;

    // ═══════════════════════════════════════════════════════════════════════════
    // NART SPEAKER GROUPING SYSTEM (Dirac ART-style)
    // ═══════════════════════════════════════════════════════════════════════════
    // BED: 
    // front: ["FL", "FR"],
    // frontWide: ["FWL", "FWR"],
    // surroundBack: ["SBL", "SBR"],
    // surroundBackSingle: ["SB"],
    // surround: ["SLA", "SRA"],
    // center: ["C"]
    // HEIGHT:
    // frontHeight: ["FHL", "FHR"],
    // rearHeight: ["RHL", "RHR"],
    // surroundHeight: ["SHL", "SHR"],
    // topFront: ["TFL", "TFR"],
    // topMiddle: ["TML", "TMR"],
    // topRear: ["TRL", "TRR"],
    // upfiringBack: ["BDL", "BDR"],
    // upfiringFront: ["FDL", "FDR"],
    // upfiringSurround: ["SDL", "SDR"],
    // topSurround: ["TS"],
    // centerHeight: ["CH"]
    const SPEAKER_GROUPS = {
      // MAINS BED 
      CENTER: {
        name: 'CENTER',
        displayName: 'Center',
        patterns: ['C'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'HEIGHT_CH'],
        canSupport: []
      },
      HEIGHT_CH: {
        name: 'HEIGHT_CH',
        displayName: 'Center Height (Auro3D)',
        patterns: ['CH'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR'],
        canSupport: ['CENTER']
      },
      MAIN_FL_FR: {
        name: 'MAIN_FL_FR',
        displayName: 'Main Front Left/Right',
        patterns: ['FL', 'FR'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']  // ← ADD HEIGHT_CH
      },

      MAIN_FWL_FWR: {
        name: 'MAIN_FWL_FWR',
        displayName: 'Main Front Wide Left/Right',
        patterns: ['FWL', 'FWR'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']  // ← ADD HEIGHT_CH
      },
      // MAIN SURROUNDS
      SURROUND_SLA_SRA: {
        name: 'SURROUND_SLA_SRA',
        displayName: 'Surround Left/Right',
        patterns: ['SL', 'SR', 'SLA', 'SRA'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']
      },
      SURROUND_SB_SBL_SBR: {
        name: 'SURROUND_SB_SBL_SBR',
        displayName: 'Surround Rear Single/Left/Right',
        patterns: ['SB', 'SBL', 'SBR'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']
      },
      // HEIGHTS
      HEIGHT_FHL_FHR: {
        name: 'HEIGHT_FHL_FHR',
        displayName: 'Front Height Left/Right',
        patterns: ['FHL', 'FHR'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']
      },
      HEIGHT_SHL_SHR: {
        name: 'HEIGHT_SHL_SHR',
        displayName: 'Surround Height Left/Right',
        patterns: ['SHL', 'SHR'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']
      },
      HEIGHT_RHL_RHR: {
        name: 'HEIGHT_RHL_RHR',
        displayName: 'Surround Rear Height Left/Right',
        patterns: ['RHL', 'RHR'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']
      },
      // TOPS:
      TOP_TFL_TFR: {
        name: 'TOP_TFL_TFR',
        displayName: 'Top Front Left/Right',
        patterns: ['TFL', 'TFR'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']
      },
      TOP_TML_TMR: {
        name: 'TOP_TML_TMR',
        displayName: 'Top Middle Left/Right',
        patterns: ['TML', 'TMR'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']
      },
      TOP_TRL_TRR: {
        name: 'TOP_TRL_TRR',
        displayName: 'Top rear Left/Right',
        patterns: ['TRL', 'TRR'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']
      },
      TOP_TS: {
        name: 'TOP_TS',
        displayName: 'Top Surround (Auro3D)',
        patterns: ['TS'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']
      },
      // DOLBY ENABLED
      DOLBY_FDL_FDR: {
        name: 'DOLBY_FDL_FDR',
        displayName: 'Dolby Enabled Front Left/Right',
        patterns: ['FDL', 'FDR'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']
      },
      DOLBY_SDL_SDR: {
        name: 'DOLBY_SDL_SDR',
        displayName: 'Dolby Enabled Surround Left/Right',
        patterns: ['SDL', 'SDR'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']
      },
      DOLBY_BDL_BDR: {
        name: 'DOLBY_BDL_BDR',
        displayName: 'Dolby Enabled Back Left/Right',
        patterns: ['BDL', 'BDR'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']
      },
      SUBWOOFERS: {
        name: 'SUBWOOFERS',
        displayName: 'Subwoofers',
        patterns: ['SW'],
        canBeSupportedBy: ['SUBWOOFERS', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS'],
        canSupport: ['CENTER', 'HEIGHT_CH', 'MAIN_FL_FR', 'MAIN_FWL_FWR', 'SURROUND_SLA_SRA', 'SURROUND_SB_SBL_SBR', 'HEIGHT_FHL_FHR', 'HEIGHT_SHL_SHR', 'HEIGHT_RHL_RHR', 'TOP_TFL_TFR', 'TOP_TML_TMR', 'TOP_TRL_TRR', 'TOP_TS', 'SUBWOOFERS']
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════
    // NART SUPPORT MATRIX (Dirac ART-style)
    // Defines how much below reference level a supporting speaker must be capable of
    // ═══════════════════════════════════════════════════════════════════════════
    const NART_SUPPORT_MATRIX = {
      // MAINS
      CENTER: {
        supportedBy: {
          //CENTER: -0,
          //HEIGHT_CH: -6,
          MAIN_FL_FR: -6,
          //MAIN_FWL_FWR: -5,
          //// MAIN SURROUNDS
          //SURROUND_SLA_SRA: -9,
          //SURROUND_SB_SBL_SBR: -12,
          //// HEIGHTS
          //HEIGHT_FHL_FHR: -6,
          //HEIGHT_SHL_SHR: -6,
          //HEIGHT_RHL_RHR: -12,
          //// TOPS:
          //TOP_TFL_TFR: -6,
          //TOP_TML_TMR: -6,
          //TOP_TRL_TRR: -12,
          //TOP_TS: -6,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -18
        }
      },
      HEIGHT_CH: {
        supportedBy: {
          //CENTER: -0,
          //HEIGHT_CH: -6,
          //MAIN_FL_FR: -6,
          //MAIN_FWL_FWR: -5,
          //// MAIN SURROUNDS
          //SURROUND_SLA_SRA: -9,
          //SURROUND_SB_SBL_SBR: -12,
          //// HEIGHTS
          //HEIGHT_FHL_FHR: -6,
          //HEIGHT_SHL_SHR: -6,
          //HEIGHT_RHL_RHR: -12,
          //// TOPS:
          //TOP_TFL_TFR: -6,
          //TOP_TML_TMR: -6,
          //TOP_TRL_TRR: -12,
          //TOP_TS: -6,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -18
        }
      },
      MAIN_FL_FR: {
        supportedBy: {
          CENTER: -6,
          //HEIGHT_CH: -6,
          MAIN_FL_FR: -5,
          MAIN_FWL_FWR: -6,
          //// MAIN SURROUNDS
          SURROUND_SLA_SRA: -6,
          SURROUND_SB_SBL_SBR: -6,
          //// HEIGHTS
          HEIGHT_FHL_FHR: -6,
          HEIGHT_SHL_SHR: -6,
          HEIGHT_RHL_RHR: -6,
          //// TOPS:
          TOP_TFL_TFR: -6,
          TOP_TML_TMR: -6,
          TOP_TRL_TRR: -6,
          TOP_TS: -6,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -5
        }
      },
      MAIN_FWL_FWR: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          MAIN_FL_FR: -6,
          MAIN_FWL_FWR: -12,
          //// MAIN SURROUNDS
          SURROUND_SLA_SRA: -12,
          SURROUND_SB_SBL_SBR: -12,
          //// HEIGHTS
          HEIGHT_FHL_FHR: -9,
          HEIGHT_SHL_SHR: -9,
          HEIGHT_RHL_RHR: -9,
          //// TOPS:
          TOP_TFL_TFR: -9,
          TOP_TML_TMR: -9,
          TOP_TRL_TRR: -9,
          TOP_TS: -9,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -5
        }
      },
      // SURROUNDS
      SURROUND_SLA_SRA: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          MAIN_FL_FR: -6,
          MAIN_FWL_FWR: -12,
          //// MAIN SURROUNDS
          SURROUND_SLA_SRA: -12,
          SURROUND_SB_SBL_SBR: -12,
          //// HEIGHTS
          HEIGHT_FHL_FHR: -9,
          HEIGHT_SHL_SHR: -9,
          HEIGHT_RHL_RHR: -9,
          //// TOPS:
          TOP_TFL_TFR: -9,
          TOP_TML_TMR: -9,
          TOP_TRL_TRR: -9,
          TOP_TS: -9,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -5
        }
      },
      SURROUND_SB_SBL_SBR: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          MAIN_FL_FR: -6,
          MAIN_FWL_FWR: -12,
          //// MAIN SURROUNDS
          SURROUND_SLA_SRA: -12,
          SURROUND_SB_SBL_SBR: -12,
          //// HEIGHTS
          HEIGHT_FHL_FHR: -9,
          HEIGHT_SHL_SHR: -9,
          HEIGHT_RHL_RHR: -9,
          //// TOPS:
          TOP_TFL_TFR: -9,
          TOP_TML_TMR: -9,
          TOP_TRL_TRR: -9,
          TOP_TS: -9,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -5
        }
      },
      // HEIGHTS:
      HEIGHT_FHL_FHR: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          MAIN_FL_FR: -5,
          MAIN_FWL_FWR: -9,
          //// MAIN SURROUNDS
          SURROUND_SLA_SRA: -9,
          SURROUND_SB_SBL_SBR: -9,
          //// HEIGHTS
          HEIGHT_FHL_FHR: -12,
          HEIGHT_SHL_SHR: -12,
          HEIGHT_RHL_RHR: -12,
          //// TOPS:
          TOP_TFL_TFR: -12,
          TOP_TML_TMR: -12,
          TOP_TRL_TRR: -12,
          TOP_TS: -12,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -4
        }
      },
      HEIGHT_SHL_SHR: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          MAIN_FL_FR: -5,
          MAIN_FWL_FWR: -9,
          //// MAIN SURROUNDS
          SURROUND_SLA_SRA: -9,
          SURROUND_SB_SBL_SBR: -9,
          //// HEIGHTS
          HEIGHT_FHL_FHR: -12,
          HEIGHT_SHL_SHR: -12,
          HEIGHT_RHL_RHR: -12,
          //// TOPS:
          TOP_TFL_TFR: -12,
          TOP_TML_TMR: -12,
          TOP_TRL_TRR: -12,
          TOP_TS: -12,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -4
        }
      },
      HEIGHT_RHL_RHR: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          MAIN_FL_FR: -5,
          MAIN_FWL_FWR: -9,
          //// MAIN SURROUNDS
          SURROUND_SLA_SRA: -9,
          SURROUND_SB_SBL_SBR: -9,
          //// HEIGHTS
          HEIGHT_FHL_FHR: -12,
          HEIGHT_SHL_SHR: -12,
          HEIGHT_RHL_RHR: -12,
          //// TOPS:
          TOP_TFL_TFR: -12,
          TOP_TML_TMR: -12,
          TOP_TRL_TRR: -12,
          TOP_TS: -12,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -4
        }
      },
      // TOPS:
      TOP_TFL_TFR: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          MAIN_FL_FR: -5,
          MAIN_FWL_FWR: -9,
          //// MAIN SURROUNDS
          SURROUND_SLA_SRA: -9,
          SURROUND_SB_SBL_SBR: -9,
          //// HEIGHTS
          HEIGHT_FHL_FHR: -12,
          HEIGHT_SHL_SHR: -12,
          HEIGHT_RHL_RHR: -12,
          //// TOPS:
          TOP_TFL_TFR: -12,
          TOP_TML_TMR: -12,
          TOP_TRL_TRR: -12,
          TOP_TS: -12,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -4
        }
      },
      TOP_TML_TMR: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          MAIN_FL_FR: -5,
          MAIN_FWL_FWR: -9,
          //// MAIN SURROUNDS
          SURROUND_SLA_SRA: -9,
          SURROUND_SB_SBL_SBR: -9,
          //// HEIGHTS
          HEIGHT_FHL_FHR: -12,
          HEIGHT_SHL_SHR: -12,
          HEIGHT_RHL_RHR: -12,
          //// TOPS:
          TOP_TFL_TFR: -12,
          TOP_TML_TMR: -12,
          TOP_TRL_TRR: -12,
          TOP_TS: -12,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -4
        }
      },
      TOP_TRL_TRR: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          MAIN_FL_FR: -5,
          MAIN_FWL_FWR: -9,
          //// MAIN SURROUNDS
          SURROUND_SLA_SRA: -9,
          SURROUND_SB_SBL_SBR: -9,
          //// HEIGHTS
          HEIGHT_FHL_FHR: -12,
          HEIGHT_SHL_SHR: -12,
          HEIGHT_RHL_RHR: -12,
          //// TOPS:
          TOP_TFL_TFR: -12,
          TOP_TML_TMR: -12,
          TOP_TRL_TRR: -12,
          TOP_TS: -12,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -4
        }
      },
      TOP_TS: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          MAIN_FL_FR: -5,
          MAIN_FWL_FWR: -9,
          //// MAIN SURROUNDS
          SURROUND_SLA_SRA: -9,
          SURROUND_SB_SBL_SBR: -9,
          //// HEIGHTS
          HEIGHT_FHL_FHR: -12,
          HEIGHT_SHL_SHR: -12,
          HEIGHT_RHL_RHR: -12,
          //// TOPS:
          TOP_TFL_TFR: -12,
          TOP_TML_TMR: -12,
          TOP_TRL_TRR: -12,
          TOP_TS: -12,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -4
        }
      },

      // DOLBY enabled
      DOLBY_FDL_FDR: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          //MAIN_FL_FR: -5,
          //MAIN_FWL_FWR: -9,
          //// MAIN SURROUNDS
          //SURROUND_SLA_SRA: -9,
          //SURROUND_SB_SBL_SBR: -9,
          //// HEIGHTS
          //HEIGHT_FHL_FHR: -12,
          //HEIGHT_SHL_SHR: -12,
          //HEIGHT_RHL_RHR: -12,
          //// TOPS:
          //TOP_TFL_TFR: -12,
          //TOP_TML_TMR: -12,
          //TOP_TRL_TRR: -12,
          //TOP_TS: -12,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          // SUBWOOFERS: -18
        }
      },
      DOLBY_SDL_SDR: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          //MAIN_FL_FR: -5,
          //MAIN_FWL_FWR: -9,
          //// MAIN SURROUNDS
          //SURROUND_SLA_SRA: -9,
          //SURROUND_SB_SBL_SBR: -9,
          //// HEIGHTS
          //HEIGHT_FHL_FHR: -12,
          //HEIGHT_SHL_SHR: -12,
          //HEIGHT_RHL_RHR: -12,
          //// TOPS:
          //TOP_TFL_TFR: -12,
          //TOP_TML_TMR: -12,
          //TOP_TRL_TRR: -12,
          //TOP_TS: -12,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          // SUBWOOFERS: -18
        }
      },
      DOLBY_BDL_BDR: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          //MAIN_FL_FR: -5,
          //MAIN_FWL_FWR: -9,
          //// MAIN SURROUNDS
          //SURROUND_SLA_SRA: -9,
          //SURROUND_SB_SBL_SBR: -9,
          //// HEIGHTS
          //HEIGHT_FHL_FHR: -12,
          //HEIGHT_SHL_SHR: -12,
          //HEIGHT_RHL_RHR: -12,
          //// TOPS:
          //TOP_TFL_TFR: -12,
          //TOP_TML_TMR: -12,
          //TOP_TRL_TRR: -12,
          //TOP_TS: -12,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          // SUBWOOFERS: -18
        }
      },

      SUBWOOFERS: {
        supportedBy: {
          //CENTER: -6,
          //HEIGHT_CH: -6,
          //MAIN_FL_FR: -5,
          //MAIN_FWL_FWR: -9,
          //// MAIN SURROUNDS
          //SURROUND_SLA_SRA: -9,
          //SURROUND_SB_SBL_SBR: -9,
          //// HEIGHTS
          //HEIGHT_FHL_FHR: -12,
          //HEIGHT_SHL_SHR: -12,
          //HEIGHT_RHL_RHR: -12,
          //// TOPS:
          //TOP_TFL_TFR: -12,
          //TOP_TML_TMR: -12,
          //TOP_TRL_TRR: -12,
          //TOP_TS: -12,
          //// DOLBY ENABLED
          //DOLBY_FDL_FDR: -6,
          //DOLBY_SDL_SDR: -6,
          //DOLBY_BDL_BDR: -12,
          ////SUBS
          SUBWOOFERS: -18
        }
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════
    // NART SPEAKER PRIORITY HIERARCHY
    // Lower number = Higher priority (never adjusted to help lower priority speakers)
    // ═══════════════════════════════════════════════════════════════════════════
    const NART_SPEAKER_PRIORITY = {
      // HIGHEST PRIORITY - Main stereo pair (never adjust these)
      'FL': 2,
      'FR': 2,

      // HIGH PRIORITY - Front stage
      'C': 3,
      'FWL': 4,
      'FWR': 4,

      // MEDIUM PRIORITY - Surrounds
      'SLA': 4,
      'SRA': 4,
      'SL': 4,
      'SR': 4,

      // LOWER PRIORITY - Rear surrounds
      'SBL': 4,
      'SBR': 4,
      'SB': 4,

      // LOWEST PRIORITY - Heights (most flexible for adjustment)
      'FHL': 5,
      'FHR': 5,
      'SHL': 5,
      'SHR': 5,
      'RHL': 5,
      'RHR': 5,
      'TFL': 5,
      'TFR': 5,
      'TML': 5,
      'TMR': 5,
      'TRL': 5,
      'TRR': 5,
      'TS': 5,
      'CH': 5,
      'FDL': 5,
      'FDR': 5,
      'SDL': 5,
      'SDR': 5,
      'BDL': 5,
      'BDR': 5,

      // SUBWOOFERS - Handled separately, never adjusted by NART
      'SW1': 1,
      'SW': 1,
      'SWMIX': 1
    };

    // Helper function to get speaker priority (default to medium if not found)
    function getNARTPriority(speakerId) {
      return NART_SPEAKER_PRIORITY[speakerId] || 3;
    }


    // Assuming we're optimizing subwoofer (target = SUBWOOFERS group)
    // const targetGroup = 'SUBWOOFERS';
    let targetGroup = 'SUBWOOFERS';

    for (let i = 1; i <= nSpeakers; i++) {
      const supportGroup = getSpeakerGroup(commandId[i]);
      const requiredOffset = getNARTSupportOffset(targetGroup, supportGroup);

      if (requiredOffset === null) {
        console.info(`├─ Skipping ${commandId[i]} (${supportGroup}) - group rules prevent supporting ${targetGroup}`);
        continue;
      }

      // Check bass extension with group-specific threshold
      const bassExtension = findBassExtensionWithOffset(i, requiredOffset);

      if (bassExtension.highExtension >= 150) {
        console.info(`├─ ${commandId[i]} (${supportGroup}): Bass capable with ${requiredOffset}dB threshold`);
        console.info(`   └─ Extension: ${bassExtension.lowExtension.toFixed(0)}Hz - ${bassExtension.highExtension.toFixed(0)}Hz`);
        bassCapableSpeakers.push({
          index: i,
          commandId: commandId[i],
          group: supportGroup,
          threshold: requiredOffset,
          ...bassExtension
        });
      }
    }

    // Helper function to determine speaker group
    function getSpeakerGroup(speakerCommandId) {
      for (const [groupKey, groupConfig] of Object.entries(SPEAKER_GROUPS)) {
        if (groupConfig.patterns.some(pattern => speakerCommandId.startsWith(pattern))) {
          return groupConfig;
        }
      }
      return null;
    }

    function getNARTSupportOffset(targetCommandId, supportCommandId) {
      const targetGroup = getSpeakerGroup(targetCommandId);
      const supportGroup = getSpeakerGroup(supportCommandId);

      if (!targetGroup || !supportGroup) return null;

      // Use .name directly (no transformation needed!)
      const matrix = NART_SUPPORT_MATRIX[targetGroup.name];
      if (!matrix || !matrix.supportedBy) return null;

      // Use .name directly (no transformation needed!)
      return matrix.supportedBy[supportGroup.name] || null;
    }

    // Helper function to check if speaker A can support speaker B
    function canSpeakerSupport(speakerA_Id, speakerB_Id) {
      const groupA = getSpeakerGroup(speakerA_Id);
      const groupB = getSpeakerGroup(speakerB_Id);

      // Check if groupA is in groupB's "canBeSupportedBy" list
      return groupB.config.canBeSupportedBy.includes(groupA.key);
    }

    var nartDelays = {}; // Store NART delays separately from acoustic delays -> Use var to ensure global scope
    var nartXOs = []; // Store the NART CrossOvers for the new sliders.
  </script>

  <!-- CUSTOM FILTERS -->
  <script>
    var customFiltersArray = []; // Use var to ensure global scope

    function toggleCustomFilterBuilder() {
      const selectedType = document.getElementById('script_af_type').value;
      const builder = document.getElementById('customFilterBuilder');

      if (selectedType === 'CUSTOMadvanced') {
        builder.style.display = 'block';
        // Initialize with one empty filter if none exist
        if (customFiltersArray.length === 0) {
          addCustomFilter();
        }
      } else {
        builder.style.display = 'none';
      }
    }

    function addCustomFilter() {
      if (customFiltersArray.length >= 20) {
        alert('Maximum of 20 filters reached!');
        return;
      }

      const filterIndex = customFiltersArray.length;
      const filter = {
        type: 'PK',
        frequency: 1000,
        gaindB: 0,
        q: 1.0
      };

      customFiltersArray.push(filter);
      renderFiltersList();
      updateFilterCount();
    }

    function removeCustomFilter(index) {
      customFiltersArray.splice(index, 1);
      renderFiltersList();
      updateFilterCount();
    }

    function updateFilter(index, field, value) {
      if (field === 'type') {
        customFiltersArray[index][field] = value;
        // Reset Q for non-PK filters
        if (value !== 'PK') {
          customFiltersArray[index].q = 1.0;
        }
      } else if (field === 'frequency') {
        customFiltersArray[index][field] = parseFloat(value) || 1000;
      } else if (field === 'gaindB') {
        customFiltersArray[index][field] = parseFloat(value) || 0;
      } else if (field === 'q') {
        customFiltersArray[index][field] = parseFloat(value) || 1.0;
      }
      renderFiltersList(); // Re-render to show/hide Q field
    }

    function renderFiltersList() {
      const container = document.getElementById('customFiltersList');

      if (customFiltersArray.length === 0) {
        container.innerHTML = '<div class="alert alert-warning">No filters added. Click "Add Filter" to get started.</div>';
        return;
      }

      container.innerHTML = customFiltersArray.map((filter, index) => `
     <div class="filter-row">
      <div class="row align-items-center">
        <div class="col-auto">
          <span class="filter-number">${index + 1}</span>
        </div>
        
        <div class="col-md-2">
          <label class="form-label">Type</label>
          <select class="form-select" onchange="updateFilter(${index}, 'type', this.value)">
            <option value="PK" ${filter.type === 'PK' ? 'selected' : ''}>Peak (PK)</option>
            <option value="LS" ${filter.type === 'LS' ? 'selected' : ''}>Low Shelf (LS)</option>
            <option value="HS" ${filter.type === 'HS' ? 'selected' : ''}>High Shelf (HS)</option>
            <!-- HP and LP commented out - conflicts with bass management
            <option value="HP" ${filter.type === 'HP' ? 'selected' : ''}>High Pass (HP)</option>
            <option value="LP" ${filter.type === 'LP' ? 'selected' : ''}>Low Pass (LP)</option>
            -->
          </select>
        </div>
        
        <div class="col-md-2">
          <label class="form-label">Frequency (Hz)</label>
          <input type="number" class="form-control" value="${filter.frequency}" 
                 min="10" max="20000" step="1"
                 onchange="updateFilter(${index}, 'frequency', this.value)">
        </div>
        
        <div class="col-md-2">
          <label class="form-label">Gain (dB)</label>
          <input type="number" class="form-control" value="${filter.gaindB}" 
                 min="-20" max="20" step="0.1"
                 onchange="updateFilter(${index}, 'gaindB', this.value)">
        </div>
        
        ${filter.type === 'PK' ? `
        <div class="col-md-2">
          <label class="form-label">Q Factor</label>
          <input type="number" class="form-control" value="${filter.q}" 
                 min="0.1" max="10" step="0.1"
                 onchange="updateFilter(${index}, 'q', this.value)">
        </div>
        ` : '<div class="col-md-2"><small class="text-muted">Q N/A</small></div>'}
        
        <div class="col-md-2">
          <label class="form-label d-block">&nbsp;</label>
          <button type="button" class="btn btn-danger btn-sm w-100" 
                  onclick="removeCustomFilter(${index})">
            🗑️ Remove
          </button>
        </div>
      </div>
     </div>
     `).join('');
    }

    function updateFilterCount() {
      const count = customFiltersArray.length;
      document.getElementById('filterCount').textContent = count;
      document.getElementById('filterWarning').style.display = count >= 20 ? 'inline' : 'none';
    }

    function loadFilterTemplate(template) {
      customFiltersArray = [];

      switch (template) {
        case 'bass':
          customFiltersArray = [
            { type: 'PK', frequency: 60, gaindB: 4.0, q: 0.7 },
            { type: 'PK', frequency: 100, gaindB: 3.0, q: 1.0 },
            { type: 'PK', frequency: 200, gaindB: 2.0, q: 1.2 }
          ];
          break;

        case 'treble':
          customFiltersArray = [
            { type: 'PK', frequency: 5000, gaindB: 2.0, q: 1.5 },
            { type: 'PK', frequency: 8000, gaindB: 3.0, q: 1.5 },
            { type: 'HS', frequency: 10000, gaindB: 2.5, q: 1.0 }
          ];
          break;

        case 'vshape':
          customFiltersArray = [
            { type: 'PK', frequency: 60, gaindB: 4.0, q: 0.8 },
            { type: 'PK', frequency: 250, gaindB: -2.0, q: 1.0 },
            { type: 'PK', frequency: 1000, gaindB: -3.0, q: 0.8 },
            { type: 'PK', frequency: 3000, gaindB: 2.0, q: 1.5 },
            { type: 'PK', frequency: 8000, gaindB: 3.0, q: 1.5 },
            { type: 'HS', frequency: 12000, gaindB: 2.0, q: 1.0 }
          ];
          break;

        case 'flat':
          // Removed HP filter - use neutral PK instead
          customFiltersArray = [
            { type: 'PK', frequency: 1000, gaindB: 0, q: 1.0 }
          ];
          break;
      }

      renderFiltersList();
      updateFilterCount();
    }

    function clearAllFilters() {
      if (customFiltersArray.length > 0 && !confirm('Clear all filters?')) {
        return;
      }
      customFiltersArray = [];
      renderFiltersList();
      updateFilterCount();
    }

    // Export function to get custom filters for the main script
    function getCustomFilters() {
      return {
        filters: customFiltersArray,
        description: document.getElementById('customFilterDescription').value || 'Custom User-Defined EQ'
      };
    }

    function debugCustomFilters() {
      console.log("=== CUSTOM FILTERS DEBUG ===");
      console.log("customFiltersArray exists?", typeof customFiltersArray !== 'undefined');
      console.log("customFiltersArray value:", customFiltersArray);
      console.log("customFiltersArray length:", customFiltersArray ? customFiltersArray.length : 'N/A');
      console.log("getCustomFilters function exists?", typeof getCustomFilters !== 'undefined');

      if (typeof getCustomFilters === 'function') {
        const config = getCustomFilters();
        console.log("getCustomFilters() returns:", config);
      }

      alert("Check the console for debug information!");
    }

    // Comprehensive logging helper
    function logState(functionName, stage, includeDistances = false) {
      console.log(`\n${'═'.repeat(60)}`);
      console.log(`📊 ${functionName} - ${stage}`);
      console.log(`${'═'.repeat(60)}`);

      console.log(`nSpeakers: ${nSpeakers}, nSubs: ${nSubs}, nChannels: ${nChannels}`);
      console.log(`flDist: ${flDist}, sOs: ${sOs}`);

      console.log(`\nmSec array (seconds):`);
      for (let i = 1; i <= nSpeakers + nSubs; i++) {
        const msecMs = mSec[i] ? (mSec[i] * 1000).toFixed(4) : 'undefined';
        const nartMs = nartDelays[commandId[i]] ? (nartDelays[commandId[i]] * 1000).toFixed(4) : '0.0000';
        console.log(`  [${i}] ${commandId[i]?.padEnd(4) || '????'}: mSec=${msecMs}ms, NART=${nartMs}ms`);
      }

      if (includeDistances) {
        console.log(`\ncustomDistance array (meters):`);
        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          const dist = customDistance[i] !== undefined ? customDistance[i].toFixed(2) : 'undefined';
          console.log(`  [${i}] ${commandId[i]?.padEnd(4) || '????'}: ${dist}m`);
        }
      }
      console.log(`${'═'.repeat(60)}\n`);
    }
  </script>

  <!-- partial -->
  <script src="./script.js"></script>
  <!-- Include jsPDF library first -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <!-- partial:index.partial.html -->
  <div class="container">
    <div class="form-container">
      <div class="form-header">
        <div class="theme-toggle">
          <div class="toggle-switch active" id="themeToggle">
            <div class="toggle-slider">☀️</div>
          </div>
        </div>

        <div class="font-toggle">
          <div class="toggle-switch active" id="dyslexicToggle">
            <div class="toggle-slider">🔤</div>
          </div>
        </div>

        <h2><img src="https://www.nvexx.nl/audyssey/nvexx_128.png" class="centerimg" alt="Nvexx logo" />ClariQ Next</h2>
        <noscript>
          <div style="color: red; padding: 10px; border: 1px solid red;">
            JavaScript is disabled in your browser. Please enable it for full functionality.
          </div>
        </noscript>
      </div>

      <div class="progress">
        <div class="progress-bar" role="progressbar" style="width: 0%"></div>
      </div>

      <div class="step-indicator">
        <div class="step-line"></div>
        <div class="step-circle active">1</div>
        <div class="step-circle">2</div>
        <div class="step-circle">3</div>
        <div class="step-circle">4</div>
        <div class="step-circle">5</div>
        <div class="step-circle">6</div>
        <div class="step-circle">7</div>
        <div class="step-circle">8</div>
        <div class="step-circle">9</div>
        <div class="step-circle">10</div>
        <div class="step-circle">11</div>
        <div class="step-circle">12</div>
        <div class="step-circle">13</div>
        <div class="step-circle">14</div>
      </div>

      <form id="multiStepForm">
        <!-- Step 1: Basic settings -->
        <div class="form-step active" data-step="1">
          <h3 class="mb-4">Basic settings</h3>
          <div class="mb-4">
            <ul>
              <li>Sub inversion allowed</li>
              <ul>
                <li>Can you or are you willing to physically change subwoofer polarity?</li>
              </ul>
            </ul>
            <ul>
              <li>Script mode</li>
              <ul>
                <li>Full auto - the script goes through each step</li>
                <li>Manual - allows you to go through each step manually. (button clicks)</li>
              </ul>
            </ul>
            <ul>
              <li>Advanced Filters</li>
              <ul>
                <li>ClariQ Next custom filters including:</li>
                <ul>
                  <li>Custom (build your own)</li>
                  <li>Advanced Dialog Enhancement</li>
                  <li>Hearing Loss</li>
                  <li>Gaming</li>
                </ul>
              </ul>
            </ul>
          </div>

          <hr />
          <div class="row g-4">
            <div class="col-md-4">
              <label for="sub_inversion_on">Sub inversion allowed</label><br>
              <input type="radio" id="sub_inversion_on" name="sub_inversion" value="0" required checked="checked">
            </div>
            <div class="col-md-4">
              <label for="sub_inversion_off">Sub inversion NOT! allowed!</label><br>
              <input type="radio" id="sub_inversion_off" name="sub_inversion" value="1">
            </div>
          </div>

          <hr />
          <div class="row g-4">
            <div class="col-md-4">
              <label for="radio_script_mode_auto">Fully automatic</label><br>
              <input type="radio" id="radio_script_mode_auto" name="script_mode" value="0" required checked="checked">
            </div>
            <div class="col-md-4">
              <label for="radio_script_mode_manual">Manual mode (manually select the next step)</label><br>
              <input type="radio" id="radio_script_mode_manual" name="script_mode" value="1">
            </div>
          </div>

          <hr />
          <div class="row g-4">
            <h3 class="mb-4">Advanced Filters</h3>
            <div class="col-md-4">
              <label for="radio_script_af_off">Advanced Filters OFF</label><br>
              <input type="radio" id="radio_script_af_off" name="script_af" value="0" required checked="checked">
            </div>
            <div class="col-md-4">
              <label for="radio_script_af_on">Advanced Filters ON</label><br>
              <input type="radio" id="radio_script_af_on" name="script_af" value="1">
            </div>
          </div>

          <div class="row g-4">
            <div class="col-md-4">
              <label for="script_af_type">Advanced Filters Type</label><br>
              <select name="script_af_type" id="script_af_type" onchange="toggleCustomFilterBuilder()">
                <option value="null" selected>none</option>
                <option value="CUSTOMadvanced">🎛️ Custom Filters (Build Your Own)</option>
                <option value="DIALOGadvanced">Advanced Dialog Enhancement - CEDIA RP22</option>
                <option value="HLOSSresearch">Hearing Loss >> Research-Based Hearing Loss Compensation (presbycusis
                  patterns)</option>
                <option value="HLOSSmoderate">Hearing Loss >> Moderate Hearing Loss Compensation (mild hearing loss)
                </option>
                <option value="HLOSSsevere">Hearing Loss >> Severe Hearing Loss Compensation (⚠️high gains)</option>
                <option value="HLOSSoriginal">Hearing Loss >> original / ClariQ Next 0.0.3 values</option>
                <option value="GAMINGcompetitive">Gaming >> Competitive Gaming EQ (Footsteps & Tactical Audio)</option>
                <option value="GAMINGimmersive">Gaming >> Immersive Gaming EQ (Cinematic Experience)</option>
                <option value="GAMINGvoice">Gaming >> Voice Chat Gaming EQ (Clear Communication)</option>
                <option value="GAMINGbalanced">Gaming >> Balanced Gaming EQ (All-Purpose)</option>
              </select>
            </div>
          </div>

          <!-- Custom Filter Builder (hidden by default) -->
          <div id="customFilterBuilder" style="display: none;" class="mt-4">
            <div class="card">
              <div class="card-header bg-primary text-white">
                <h5 class="mb-0">🎛️ Custom Filter Builder</h5>
                <small>Create up to 20 custom EQ filters (Peak, Low Shelf, High Shelf only)</small>
              </div>
              <div class="card-body">
                <!-- Filter Description -->
                <div class="row mb-3">
                  <div class="col-md-8">
                    <label for="customFilterDescription">Filter Set Name</label>
                    <input type="text" id="customFilterDescription" class="form-control" placeholder="My Custom EQ"
                      value="Custom User-Defined EQ">
                  </div>
                  <div class="col-md-4 d-flex align-items-end">
                    <button type="button" class="btn btn-success w-100" onclick="addCustomFilter()">
                      ➕ Add Filter
                    </button>
                  </div>
                </div>

                <!-- Filters List -->
                <div id="customFiltersList" class="mb-3">
                  <!-- Filters will be added here dynamically -->
                </div>

                <!-- Filter Count Display -->
                <div class="alert alert-info">
                  <strong>Filters: <span id="filterCount">0</span> / 20</strong>
                  <span id="filterWarning" style="display: none; color: #dc3545;"> - Maximum reached!</span>
                  <small class="d-block mt-1">
                    ℹ️ Custom filters override from high to low frequency (indices 20→1)<br>
                    This preserves critical low-frequency room correction
                  </small>
                </div>

                <!-- Preset Templates -->
                <div class="row mt-3">
                  <div class="col-12">
                    <label>Quick Templates:</label>
                    <div class="btn-group w-100" role="group">
                      <button type="button" class="btn btn-outline-secondary btn-sm"
                        onclick="loadFilterTemplate('bass')">Bass Boost</button>
                      <button type="button" class="btn btn-outline-secondary btn-sm"
                        onclick="loadFilterTemplate('treble')">Treble Boost</button>
                      <button type="button" class="btn btn-outline-secondary btn-sm"
                        onclick="loadFilterTemplate('vshape')">V-Shape</button>
                      <button type="button" class="btn btn-outline-secondary btn-sm"
                        onclick="loadFilterTemplate('flat')">Flat/Neutral</button>
                      <button type="button" class="btn btn-outline-danger btn-sm" onclick="clearAllFilters()">Clear
                        All</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <br />
          <div class="mb-4">
            <h3 class="mb-4 warning">Usage</h3>
            <ul>
              <li>Download and install the free room correction software Room EQ Wizard (v5.40
                Beta) on
                your computer
                <ul>
                  <li class="small-bullet">download link for the latest REW Beta version: <a
                      href="https://www.avnirvana.com/threads/rew-api-beta-releases.12981/" target="_blank">here</a>
                  </li>
                </ul>
              </li>
              <li>Choose your preferred basic settings</li>
              <li>When done click the '[.ady]' button below to go to the next step.</li>
            </ul>
          </div>
          <div class="d-flex justify-content-end mt-4">
            <button type="button" class="btn btn-primary btn-nav next-step">.ady file</button>
          </div>
        </div>

        <!-- Step 2: Basic Measurement settings -->
        <div class="form-step" data-step="2">
          <div class="mb-4" id="BMs">
            <h3 class="mb-4">Basic Measurement settings</h3>
          </div>
          <div class="mb-4" id="adyf">
            <h3 class="mb-4">.ady file</h3>
            <ul>
              <li>upload your .ady file here</li>
              <ul>
                <li>browse to the Audyssey calibration file (.ady) generated by the MultEQ Editor (IOS/Android) app
                </li>
                <li>when prompted, download and 'save' the .zip (measurements) on your computer. Make sure the zip
                  file
                  is unblocked: right-click > properties > unblock</li>
                <li>start REW, go to the 'EQ' / 'House Curve', and select a target curve of your choice</li>
                <li>open the zip file and select ALL (keyboard shortcut: "CTRL+A" for Windows / "Command+A" for Mac)
                  the
                  files in that folder</li>
                <li>left click on the selection (inside the .zip file) and drag & drop them onto REW. Wait until all
                  measurements are imported
                  and '[SPL Adjustments →]' button is enabled</li>
              </ul>
              <li>You can also use custom measurements with ClariQ Next!</li>
              <ul>
                <li>naming still needs to follow $0/1/2/3/4/5/6/7/8/9/10/11/12/13/14/15 etc for normal speakers</li>
                <li>naming still needs to follow SW10/11/12/13/14/15/16/17/18/19/110/111/112/113/114/115 etc for
                  subwoofers</li>
                <li>naming still needs to follow SW20/21/22/23/24/25/26/27/28/29/210/211/212/213/214/215 etc for
                  subwoofers</li>
                <li>the order in REW doesn't matter only the naming (custom sorting by ClariQ Next)</li>
              </ul>
              <li>Frequency Range Selector</li>
              <ul>
                <li>once your .ady is uploaded and the measurements are loaded into REW the Frequency Range Selector
                  will be availble</li>
                <ul>
                  <li>Select a "preferred range" from the frequency index values supported by your AVR</li>
                  <ul></ul>
                  <li class="warning">* The final minumum range used will depend on your suboofer(s) capabilities</li>
                </ul>
              </ul>
            </ul>
          </div>
          <label class="form-label" id="resumeUploadlabel" for="resumeUpload">Upload your .ady file here</label>
          <div class="file-upload" id="resumeUpload">
            <input type="file" id="resume" class="d-none" accept=".ady">
            <div class="upload-content">
              <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor"
                class="bi bi-cloud-upload mb-3" viewBox="0 0 16 16">
                <path fill-rule="evenodd"
                  d="M4.406 1.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 2 5.166 4.579C14.758 4.804 16 6.137 16 7.773 16 9.569 14.502 11 12.687 11H10a.5.5 0 0 1 0-1h2.688C13.979 10 15 8.988 15 7.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 2.825 10.328 1 8 1a4.53 4.53 0 0 0-2.941 1.1c-.757.652-1.153 1.438-1.153 2.055v.448l-.445.049C2.064 4.805 1 5.952 1 7.318 1 8.785 2.23 10 3.781 10H6a.5.5 0 0 1 0 1H3.781C1.708 11 0 9.366 0 7.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383z" />
                <path fill-rule="evenodd"
                  d="M7.646 4.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707V14.5a.5.5 0 0 1-1 0V5.707L5.354 7.854a.5.5 0 1 1-.708-.708l3-3z" />
              </svg>
              <p class="mb-1">Drag and drop your .ady here</p>
              <p class="text-muted small">or click to browse (.ady)</p>
            </div>
          </div>
          <hr />
          <div class="row g-4" id="cinemaModes">
            <strong class="error" id="unlock_cinema_modes">Please upload your .ady and import your measurements into
              REW</strong>
            <div class="col-md-4">
              <label for="radio_home_cinema">Home Cinema (75dB) default</label><br>
              <input type="radio" id="radio_home_cinema" name="cinema_type" value="75" required checked="checked"
                disabled>
              <ul>
                <li>Subwoofer -Hz - -Hz / system calculated</li>
                <li>Speakers -Hz - -kHz / system calculated</li>
              </ul>
            </div>
            <div class="col-md-4">
              <label for="radio_professional_cinema">Dolby mode! (82dB -SPL)</label><br>
              <input type="radio" id="radio_dolby_cinema" name="cinema_type" value="85.2" disabled>
              <ul>
                <li>Subwoofer 31.5hz - 120Hz</li>
                <li>Speakers 40hz - 16kHz</li>
              </ul>
            </div>
            <div class="col-md-4">
              <label for="radio_professional_cinema">Cedia RP22 mode! (85dB -SPL)</label><br>
              <input type="radio" id="radio_cedia_cinema" name="cinema_type" value="85.1" disabled>
              <ul>
                <li>Subwoofer -hz - -Hz / performance based</li>
                <li>Speakers -hz - -Hz / performance based</li>
              </ul>
            </div>
            <div class="col-md-4">
              <label for="radio_professional_cinema">THX mode! (85dB -SPL)</label><br>
              <input type="radio" id="radio_thx_cinema" name="cinema_type" value="85.3" disabled>
              <ul>
                <li>Subwoofer 20hz - 120Hz</li>
                <li>Speakers 80hz - 20kHz</li>
              </ul>
            </div>
            <div class="col-md-4">
              <label for="radio_professional_cinema">IMAX mode! (100dB -SPL)</label><br>
              <input type="radio" id="radio_imax_cinema" name="cinema_type" value="85.4" disabled>
              <ul>
                <li>Subwoofer 20hz - 70Hz</li>
                <li>Speakers 70hz - 20kHz</li>
                <li>AVR specific!</li>
              </ul>
            </div>
          </div>

          <hr />
          <li><strong class="warning">Please keep REW on 'SPL & Phase' tab and stay on this web page until
              optimization
              is
              completed!</strong></li>
          </ul>
          <br />

          <!-- Phase Weight Slider Container -->
          <div class="slider-container phase-weight-slider" style="display: none;">
            <div class="slider-header">
              <h4>Phase Alignment Weight</h4>
              <div class="slider-info">
                <span class="slider-value">
                  Current: <strong id="phaseWeightValue">50%</strong>
                </span>
                <span class="slider-value">
                  Normalized: <strong id="phaseWeightNumeric">0.50</strong>
                </span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-phaseWeight"></div>
                <div class="slider-handle" id="handle-phaseWeight"></div>
              </div>
              <div class="slider-ticks" id="sliderTicks-phaseWeight"></div>
            </div>

            <div class="slider-description">
              <ul>
                <li>Adjust the weight between magnitude and phase optimization (0% = magnitude only, 100% = phase
                  only)
                </li>
              </ul>
            </div>
          </div>

          <!-- CENTER Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container center-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - CENTER</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-center"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-center"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-center"></span> |
                Indices: <span id="indicesValue-center"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-center"></div>
              </div>
              <div class="slider-handle min" id="minHandle-center"></div>
              <div class="slider-handle max" id="maxHandle-center"></div>

              <div class="slider-ticks" id="sliderTicks-center"></div>
            </div>
          </div>

          <!-- FRONT LEFT & RIGHT Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container main-fl-fr-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - FRONT LEFT & RIGHT</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-main_fl_fr"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-main_fl_fr"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-main_fl_fr"></span> |
                Indices: <span id="indicesValue-main_fl_fr"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-main_fl_fr"></div>
              </div>
              <div class="slider-handle min" id="minHandle-main_fl_fr"></div>
              <div class="slider-handle max" id="maxHandle-main_fl_fr"></div>

              <div class="slider-ticks" id="sliderTicks-main_fl_fr"></div>
            </div>
          </div>

          <!-- FRONT WIDE LEFT & RIGHT Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container main-fwl-fwr-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - FRONT WIDE LEFT & RIGHT</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-main_fwl_fwr"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-main_fwl_fwr"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-main_fwl_fwr"></span> |
                Indices: <span id="indicesValue-main_fwl_fwr"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-main_fwl_fwr"></div>
              </div>
              <div class="slider-handle min" id="minHandle-main_fwl_fwr"></div>
              <div class="slider-handle max" id="maxHandle-main_fwl_fwr"></div>

              <div class="slider-ticks" id="sliderTicks-main_fwl_fwr"></div>
            </div>
          </div>

          <!-- SURROUND LEFT & RIGHT Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container surround-sla-sra-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - SURROUND LEFT & RIGHT</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-surround_sla_sra"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-surround_sla_sra"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-surround_sla_sra"></span> |
                Indices: <span id="indicesValue-surround_sla_sra"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-surround_sla_sra"></div>
              </div>
              <div class="slider-handle min" id="minHandle-surround_sla_sra"></div>
              <div class="slider-handle max" id="maxHandle-surround_sla_sra"></div>

              <div class="slider-ticks" id="sliderTicks-surround_sla_sra"></div>
            </div>
          </div>

          <!-- SURROUND BACK LEFT & RIGHT Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container surround-sbl-sbr-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - SURROUND BACK LEFT & RIGHT</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-surround_sbl_sbr"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-surround_sbl_sbr"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-surround_sbl_sbr"></span> |
                Indices: <span id="indicesValue-surround_sbl_sbr"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-surround_sbl_sbr"></div>
              </div>
              <div class="slider-handle min" id="minHandle-surround_sbl_sbr"></div>
              <div class="slider-handle max" id="maxHandle-surround_sbl_sbr"></div>

              <div class="slider-ticks" id="sliderTicks-surround_sbl_sbr"></div>
            </div>
          </div>

          <!-- SURROUND BACK SINGLE Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container surround-sb-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - SURROUND BACK SINGLE</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-surround_sb"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-surround_sb"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-surround_sb"></span> |
                Indices: <span id="indicesValue-surround_sb"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-surround_sb"></div>
              </div>
              <div class="slider-handle min" id="minHandle-surround_sb"></div>
              <div class="slider-handle max" id="maxHandle-surround_sb"></div>

              <div class="slider-ticks" id="sliderTicks-surround_sb"></div>
            </div>
          </div>

          <!-- HEIGHT FRONT LEFT & RIGHT Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container height-fhl-fhr-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - HEIGHT FRONT LEFT & RIGHT</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-height_fhl_fhr"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-height_fhl_fhr"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-height_fhl_fhr"></span> |
                Indices: <span id="indicesValue-height_fhl_fhr"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-height_fhl_fhr"></div>
              </div>
              <div class="slider-handle min" id="minHandle-height_fhl_fhr"></div>
              <div class="slider-handle max" id="maxHandle-height_fhl_fhr"></div>

              <div class="slider-ticks" id="sliderTicks-height_fhl_fhr"></div>
            </div>
          </div>

          <!-- HEIGHT SURROUND LEFT & RIGHT Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container height-shl-shr-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - HEIGHT SURROUND LEFT & RIGHT</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-height_shl_shr"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-height_shl_shr"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-height_shl_shr"></span> |
                Indices: <span id="indicesValue-height_shl_shr"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-height_shl_shr"></div>
              </div>
              <div class="slider-handle min" id="minHandle-height_shl_shr"></div>
              <div class="slider-handle max" id="maxHandle-height_shl_shr"></div>

              <div class="slider-ticks" id="sliderTicks-height_shl_shr"></div>
            </div>
          </div>

          <!-- HEIGHT REAR LEFT & RIGHT Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container height-rhl-rhr-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - HEIGHT REAR LEFT & RIGHT</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-height_rhl_rhr"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-height_rhl_rhr"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-height_rhl_rhr"></span> |
                Indices: <span id="indicesValue-height_rhl_rhr"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-height_rhl_rhr"></div>
              </div>
              <div class="slider-handle min" id="minHandle-height_rhl_rhr"></div>
              <div class="slider-handle max" id="maxHandle-height_rhl_rhr"></div>

              <div class="slider-ticks" id="sliderTicks-height_rhl_rhr"></div>
            </div>
          </div>

          <!-- CENTER HEIGHT (AURO3D) Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container height-ch-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - CENTER HEIGHT (AURO3D)</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-height_ch"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-height_ch"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-height_ch"></span> |
                Indices: <span id="indicesValue-height_ch"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-height_ch"></div>
              </div>
              <div class="slider-handle min" id="minHandle-height_ch"></div>
              <div class="slider-handle max" id="maxHandle-height_ch"></div>

              <div class="slider-ticks" id="sliderTicks-height_ch"></div>
            </div>
          </div>

          <!-- TOP FRONT LEFT & RIGHT Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container top-tfl-tfr-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - TOP FRONT LEFT & RIGHT</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-top_tfl_tfr"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-top_tfl_tfr"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-top_tfl_tfr"></span> |
                Indices: <span id="indicesValue-top_tfl_tfr"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-top_tfl_tfr"></div>
              </div>
              <div class="slider-handle min" id="minHandle-top_tfl_tfr"></div>
              <div class="slider-handle max" id="maxHandle-top_tfl_tfr"></div>

              <div class="slider-ticks" id="sliderTicks-top_tfl_tfr"></div>
            </div>
          </div>

          <!-- TOP MIDDLE LEFT & RIGHT Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container top-tml-tmr-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - TOP MIDDLE LEFT & RIGHT</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-top_tml_tmr"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-top_tml_tmr"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-top_tml_tmr"></span> |
                Indices: <span id="indicesValue-top_tml_tmr"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-top_tml_tmr"></div>
              </div>
              <div class="slider-handle min" id="minHandle-top_tml_tmr"></div>
              <div class="slider-handle max" id="maxHandle-top_tml_tmr"></div>

              <div class="slider-ticks" id="sliderTicks-top_tml_tmr"></div>
            </div>
          </div>

          <!-- TOP REAR LEFT & RIGHT Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container top-trl-trr-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - TOP REAR LEFT & RIGHT</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-top_trl_trr"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-top_trl_trr"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-top_trl_trr"></span> |
                Indices: <span id="indicesValue-top_trl_trr"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-top_trl_trr"></div>
              </div>
              <div class="slider-handle min" id="minHandle-top_trl_trr"></div>
              <div class="slider-handle max" id="maxHandle-top_trl_trr"></div>

              <div class="slider-ticks" id="sliderTicks-top_trl_trr"></div>
            </div>
          </div>

          <!-- TOP SURROUND (AURO3D) Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container top-ts-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - TOP SURROUND (AURO3D)</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-top_ts"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-top_ts"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-top_ts"></span> |
                Indices: <span id="indicesValue-top_ts"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-top_ts"></div>
              </div>
              <div class="slider-handle min" id="minHandle-top_ts"></div>
              <div class="slider-handle max" id="maxHandle-top_ts"></div>

              <div class="slider-ticks" id="sliderTicks-top_ts"></div>
            </div>
          </div>

          <!-- DOLBY ENABLED FRONT LEFT & RIGHT Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container dolby-fdl-fdr-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - DOLBY ENABLED FRONT LEFT & RIGHT</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-dolby_fdl_fdr"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-dolby_fdl_fdr"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-dolby_fdl_fdr"></span> |
                Indices: <span id="indicesValue-dolby_fdl_fdr"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-dolby_fdl_fdr"></div>
              </div>
              <div class="slider-handle min" id="minHandle-dolby_fdl_fdr"></div>
              <div class="slider-handle max" id="maxHandle-dolby_fdl_fdr"></div>

              <div class="slider-ticks" id="sliderTicks-dolby_fdl_fdr"></div>
            </div>
          </div>

          <!-- DOLBY ENABLED SURROUND LEFT & RIGHT Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container dolby-sdl-sdr-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - DOLBY ENABLED SURROUND LEFT & RIGHT</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-dolby_sdl_sdr"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-dolby_sdl_sdr"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-dolby_sdl_sdr"></span> |
                Indices: <span id="indicesValue-dolby_sdl_sdr"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-dolby_sdl_sdr"></div>
              </div>
              <div class="slider-handle min" id="minHandle-dolby_sdl_sdr"></div>
              <div class="slider-handle max" id="maxHandle-dolby_sdl_sdr"></div>

              <div class="slider-ticks" id="sliderTicks-dolby_sdl_sdr"></div>
            </div>
          </div>

          <!-- DOLBY ENABLED BACK LEFT & RIGHT Slider container - initially hidden, will be shown after .ady processing -->
          <div class="slider-container dolby-bdl-bdr-channel" style="display: none;">
            <h4 class="mb-4">Frequency Range Selector - DOLBY ENABLED BACK LEFT & RIGHT</h4>
            <ul>
              <li>Select a "preferred range" from the frequency index values</li>
              <ul>
                <li class="warning">The final minimum range used will depend on your subwoofer(s) capabilities.</li>
                <li class="warning">We don't know your subwoofer(s) capabilities at this stage.</li>
              </ul>
            </ul>
            <div class="values-display">
              <div class="value-item">
                Min: <span class="min-value" id="minValue-dolby_bdl_bdr"></span>
              </div>
              <div class="value-item">
                Max: <span class="max-value" id="maxValue-dolby_bdl_bdr"></span>
              </div>
              <div class="range-info">
                Range: <span id="rangeValue-dolby_bdl_bdr"></span> |
                Indices: <span id="indicesValue-dolby_bdl_bdr"></span>
              </div>
            </div>

            <div class="slider-wrapper">
              <div class="slider-track">
                <div class="slider-range" id="sliderRange-dolby_bdl_bdr"></div>
              </div>
              <div class="slider-handle min" id="minHandle-dolby_bdl_bdr"></div>
              <div class="slider-handle max" id="maxHandle-dolby_bdl_bdr"></div>

              <div class="slider-ticks" id="sliderTicks-dolby_bdl_bdr"></div>
            </div>
          </div>

          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">SPL Adjustments →</button>
          </div>
        </div>

        <!-- Step 3: SPL Adjustments not really needed -->
        <div class="form-step" data-step="3">
          <h3 class="mb-4">SPL Adjustments</h3>
          <div class="mb-4">
            <ul>
              <li>
                <span id="target-level-display" class="warning">Select cinema type to see target level</span>
                <ul>
                  <li>Offset according to the chosen cinema mode </li>
                </ul>
              </li>
              <li>Makes it easier to read in REW</li>
              <ul>
                <li>Takes into account specific 120dB spl offsets that are no longer supported!</li>
                <li>Takes into account script 78dB spl offsets</li>
                <li>Takes into account custom measurements</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">BootUP →</button>
          </div>
        </div>

        <!-- Step 4: Bootup -->
        <div class="form-step" data-step="4">
          <h3 class="mb-4">Bootup</h3>
          <div class="mb-4">
            <ul>
              <li>Here we go.. Be patient!</li>
              <li>Applying Audyssey microphone calibration file to measurements if needed</li>
              <li>Resets, IR windows, EQ target shape, room curve settings and equalizer to
                'Generic/Generic' for all measurements..</li>
              <li>Checking measurement names, indices and sorting</li>
              <ul>
                <li>Custom sorting if custom measurements are not sorted correctly</li>
                <li>ClariQ Next sorting, the standard REW A-Z sorting doesn't suffice!</li>
              </ul>
              <li>Sets default target level according to the chosen cinema mode</li>
              <li>Logs current set optimization parameters</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">GroundWorks →</button>
          </div>
        </div>

        <!-- Step 5: Groundworks -->
        <div class="form-step" data-step="5">
          <h3 class="mb-4">Groundworks</h3>
          <div class="mb-4">
            <ul>
              <li>Sets initial trims using mlp measurements</li>
              <li>Time align speakers according to mlp measurements</li>
              <ul>
                <li>based on #measurement count per speaker (microphone positions)</li>
              </ul>
              <li>Spatial averaging of speakers and subwoofers</li>
              <li>normalizes trim levels (ClariQ Next !)</li>
              <ul>
                <li>based on cinema mode chosen</li>
                <li>makes sure trim levels are correct for modes that have a SPL of 75+dB</li>
                <ul>
                  <li>Dolby mode (82dB)</li>
                  <li>Cedia RP22 mode (85dB)</li>
                  <li>THX mode (85dB)</li>
                  <li>IMAX mode (100dB)</li>
                </ul>
              </ul>
              <ul>
                <li>Initial Subwoofer bass fil for dip compensation</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Speaker Calibration →</button>
          </div>
        </div>

        <!-- Step 6: Speaker Calibration -->
        <div class="form-step" data-step="6">
          <h3 class="mb-4">Speaker Calibration</h3>
          <div class="mb-4">
            <ul>
              <li>Calculates speaker(s) -3dB points</li>
              <li>Calculates High Frequency rolloffs</li>
              <ul>
                <li>Depending on the cinema mode chosen</li>
                <ul>
                  <li>Dolby mode - 16000Hz rolloff</li>
                  <li>Cedia RP22 mode - 15000Hz rolloff</li>
                  <li>THX mode - 20000Hz rolloff</li>
                  <li>IMAX mode - 20000Hz rolloff</li>
                  <li>default - calculates rolloff</li>
                </ul>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Subwoofer Calibration →</button>
          </div>
        </div>

        <!-- Step 7: Subwoofer Calibration -->
        <div class="form-step" data-step="7">
          <h3 class="mb-4">Subwoofer Calibration</h3>
          <div class="mb-4">
            <ul>
              <li>Calculates subwoofer(s) -3dB points</li>
              <li>Calculates low frequency rolloffs</li>
              <ul>
                <li>Depending on the cinema mode chosen</li>
                <ul>
                  <li>Dolby mode - 16000Hz rolloff</li>
                  <li>Cedia RP22 mode - 15000Hz rolloff</li>
                  <li>THX mode - 20000Hz rolloff</li>
                  <li>IMAX mode - 20000Hz rolloff</li>
                  <li>default - calculates rolloff</li>
                </ul>
              </ul>
              <li>calculates availble bandwidth</li>
              <li>sets "estimated" XO range based on available bandwidth</li>
              <ul>
                <li>can be adjusted by using the slider range</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Optimize subwoofer delay →</button>
          </div>
        </div>

        <!-- Step 8: was >> Step 10: Optimize subwoofer delay -->
        <div class="form-step" data-step="8">
          <h3 class="mb-4">Optimize subwoofer delay</h3>
          <div class="mb-4">
            <ul>
              <li>Optimize subwoofer(s) delay(s)</li>
              <ul>
                <li>Skipping! - NART handles all sub alignment in step 10</li>
                <!--<li>Calculates the optimal subwoofer delay for ALL speakers using average initial calculated XO</li>
                <li>Calculates the optimal subwoofer delay within the available delay range</li>
                <li>takes into account the "Sub inversion allowed" option</li>-->
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Finalize crossovers →</button>
          </div>
        </div>

        <!-- Step 9: was >> Step 12: Finalize crossovers -->
        <div class="form-step" data-step="9">
          <h3 class="mb-4">Finalize crossovers</h3>
          <div class="mb-4">
            <ul>
              <li>Finalize crossovers based on usable XO range</li>
              <ul>
                <li>based on (combined subwoofer lowest safe bandwidth + slider range)</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Generate filters →</button>
          </div>
        </div>

        <!-- Step 10: was >> Step 8: Generate Filters -->
        <div class="form-step" data-step="10">
          <h3 class="mb-4">Generate filters</h3>
          <div class="mb-4">
            <ul>
              <li class="warning">ClariQ Next PROPRIETARY NART!</li>
              <li>Analyzes Room modes (Standing Waves)</li>
              <li>Calculates what speakers can contribute to modal cancellation</li>
              <li>Frequency-dependent alignment strategies</li>
              <ul>
                <li>Band-by-band optimization (20-60Hz, 60-100Hz, 100-150Hz) with different strategies per band</li>
              </ul>
              <li>Multi-band phase optimization</li>
              <li>Support Speaker Architecture</li>
              <ul>
                <li>Between speaker groups</li>
                <li>Depends on calculated bandwidth of speakers</li>
                <li>Advanced speaker support Matrix</li>
                <ul>
                  <li>UI/UX implementation pending</li>
                </ul>
              </ul>
              <li>Advanced subwoofer and Multi Subwoofer alignment</li>
            </ul>
            <ul>
              <li class="warning">ClariQ Next PROPRIETARY FILTER GENERATION AND CHECKING !</li>
            </ul>
            <ul>
              <li class="warning">ClariQ Next SBIR detection</li>
              <ul>
                <li>good indication of expected SBIR</li>
                <li>logs and gives an overview of expected nulls</li>
              </ul>
            </ul>
            <ul>
              <li class="warning">ClariQ Next SBIR filter optimizations</li>
              <ul>
                <li>Checks REW generated filters</li>
                <li>we don't want to boost above +3dB as we can't fix nulls with EQ!</li>
                <li>we don't want to cut more than -10dB as we can't fix nulls with EQ!</li>
                <li>logs and gives an overview of active REW generated filters</li>
                <li>logs and gives an overview of any BOOST VIOLATION FOUND</li>
                <li>logs and gives an overview of any CUT VIOLATION FOUND</li>
                <li>automatically corrects the filters to stay within +3dB and -10dB</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Finalize trims →</button>
          </div>
        </div>

        <!-- Step 11: was >> Step 9: Finalize trimming -->
        <div class="form-step" data-step="11">
          <h3 class="mb-4">Finalize trims</h3>
          <div class="mb-4">
            <ul>
              <li>Final speaker & subwoofer trims:</li>
              <ul>
                <li>checks if they are within range</li>
                <li>Sets final trims (that will be send to the *.ady)</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Finalize distances →</button>
          </div>
        </div>

        <!-- Step 12: was >> Step 11: Finalize distances -->
        <div class="form-step" data-step="12">
          <h3 class="mb-4">Finalize distances</h3>
          <div class="mb-4">
            <ul>
              <li>Finalize calculated distances</li>
              <ul>
                <li>speaker & subwoofer distances</li>
                <li>Includes NART modal cancellation</li>
              </ul>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Draw expected results →</button>
          </div>
        </div>

        <!-- Step 13: Draw expected results -->
        <div class="form-step" data-step="13">
          <h3 class="mb-4">Draw expected results</h3>
          <div class="mb-4">
            <ul>
              <li>Logs SBIR (BOUNDARY INTERFERENCE) ANALYSIS</li>
              <li>Generating expected final outputs for each channel.</li>
              <li>Updating REW results to reflect the expected final outputs for each channel.</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <button type="button" class="btn btn-primary btn-nav next-step">Finalize .ady →</button>
          </div>
        </div>

        <!-- Step 14: Finalize .ady -->
        <div class="form-step" data-step="14">
          <h3 class="mb-4">Finalize .ady</h3>
          <div class="mb-4">
            <ul>
              <li>Constructing .ady file</li>
              <li>Generating CEDIA RP22 report</li>
            </ul>
          </div>
          <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary btn-nav prev-step">← Back</button>
            <!--<button type="button" class="btn btn-primary btn-nav next-step">Continue →</button>-->
          </div>
        </div>

      </form>
      <pre id="logContainer"></pre>
      <br />
      <br />
      <div class="row g-4">
        <div class="col-md-4" style="text-align: center;">
          <p>Socials:</p>
          <a href="https://ko-fi.com/nvexx" target="_blank" style="text-decoration: none;">Ko-fi <span
              class="icon-cup"></span></a>
          &nbsp;
          <a href="https://discord.com/invite/fyVzznE" target="_blank" style="text-decoration: none;">Discord
            <svg class="w-[48px] h-[48px] text-gray-800 dark:text-white" aria-hidden="true"
              xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
              <path
                d="M18.942 5.556a16.3 16.3 0 0 0-4.126-1.3 12.04 12.04 0 0 0-.529 1.1 15.175 15.175 0 0 0-4.573 0 11.586 11.586 0 0 0-.535-1.1 16.274 16.274 0 0 0-4.129 1.3 17.392 17.392 0 0 0-2.868 11.662 15.785 15.785 0 0 0 4.963 2.521c.41-.564.773-1.16 1.084-1.785a10.638 10.638 0 0 1-1.706-.83c.143-.106.283-.217.418-.331a11.664 11.664 0 0 0 10.118 0c.137.114.277.225.418.331-.544.328-1.116.606-1.71.832a12.58 12.58 0 0 0 1.084 1.785 16.46 16.46 0 0 0 5.064-2.595 17.286 17.286 0 0 0-2.973-11.59ZM8.678 14.813a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.918 1.918 0 0 1 1.8 2.047 1.929 1.929 0 0 1-1.8 2.045Zm6.644 0a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.919 1.919 0 0 1 1.8 2.047 1.93 1.93 0 0 1-1.8 2.045Z" />
            </svg>
          </a>
          &nbsp;
          <a href="https://github.com/NvexxNL/ClariQNext" target="_blank" style="text-decoration: none;">GitHub <span
              class="icon-social-github"></span></a>
        </div>

        <div class="col-md-4" style="text-align: center;">
          <a href="https://ko-fi.com/nvexx/tip" target="_blank"><img height="74" style="border: 0px; height: 74px"
              src="https://storage.ko-fi.com/cdn/brandasset/v2/support_me_on_kofi_badge_red.png"
              alt="Support me on ko-fi.com" /></a>
        </div>

        <div class="col-md-4" style="text-align: center;">
          <a href="https://open.spotify.com/playlist/0ADi7e8brgnKkzri4qfpHS"
            style="size: 48px; font-size: 48pt; color: #1db954; text-decoration: none;" target="_blank"><span
              class="icon-social-spotify"></span></a>
          <p style="color: #1db954;">skull's Audio System Test Tracks</p>
        </div>
      </div>
    </div>

    <script>
      function extractAdy(event) {
        console.info(`Initializing ${nextversion}`);
        const file = event.target.files[0];
        fileName = file.name;
        console.info(`Audyssey calibration '${fileName}' has been uploaded!`)
        const reader = new FileReader();
        reader.onload = async function (e) {
          adyContents = e.target.result;
          const jsonData = JSON.parse(adyContents);
          let modelName = jsonData.targetModelName;
          const model = modelName.slice(-6);
          sOs = modelsSoS300.includes(model) ? 300.00 : 343.00;
          Object.freeze(sOs);
          isCirrusLogic = micCalProb.includes(model) ? true : false;
          Object.freeze(isCirrusLogic);
          if (!noxo180.includes(model)) {
            freqIndex.push(180);
          }
          if (models70xo.includes(model)) {
            freqIndex.push(70);
            supportsIMAX = true;
          }
          if (modelsDirac.includes(model)) {
            DiracEnabled = true;
          }
          freqIndex.sort(function (a, b) { return a - b; });
          Object.freeze(freqIndex);
          console.log(`Speed of sound setting has been automatically adjusted for your ${modelName} at ${sOs} m/s.`);
          const hasSWChannels = jsonData.detectedChannels.some(channel => channel.commandId && channel.commandId.startsWith("SW"));
          if (!hasSWChannels) {
            console.warn("⚠ No subwoofer detected in your calibration file. Mains will be set to Large/Full Range!");
            noSub = true;
          }
          Object.freeze(noSub);
          bassMode = jsonData.subwooferMode;
          Object.freeze(bassMode);
          lfcSupport = jsonData.lfcSupport;
          Object.freeze(lfcSupport);
          enMultEQType = jsonData.enMultEQType;
          Object.freeze(enMultEQType);
          auro = jsonData.auro;
          Object.freeze(auro);
          dolbyVersion = jsonData.dolbyVersion;
          Object.freeze(dolbyVersion);
          dynamicEq = jsonData.dynamicEq;
          Object.freeze(dynamicEq);
          dynamicVolume = jsonData.dynamicVolume;
          Object.freeze(dynamicVolume);
          lfc = jsonData.lfc;
          Object.freeze(lfc);
          subwooferMode = jsonData.subwooferMode;
          Object.freeze(subwooferMode);
          subwooferNum = jsonData.subwooferNum;
          Object.freeze(subwooferNum);
          subwooferLayout = jsonData.subwooferLayout;
          Object.freeze(subwooferLayout);
          noCenter = true;
          subLoTrim = Infinity;
          subHiTrim = -Infinity;
          subLoDelay = Infinity;
          subHiDelay = -Infinity;
          console.info("");
          console.info("title:", jsonData.title);
          console.info("enAmpAssignType:", jsonData.enAmpAssignType);
          console.info("dynamicVolume:", jsonData.dynamicVolume);
          console.info("enTargetCurveType:", jsonData.enTargetCurveType);
          console.info("lfcSupport:", jsonData.lfcSupport);
          console.info("targetModelName:", jsonData.targetModelName);
          console.info("interfaceVersion:", jsonData.interfaceVersion);
          console.info("dynamicEq:", jsonData.dynamicEq);
          console.info("ampAssignInfo:", jsonData.ampAssignInfo);
          console.info("lfc:", jsonData.lfc);
          console.info("systemDelay:", jsonData.systemDelay);
          console.info("auro:", jsonData.auro);
          console.info("dolbyVersion:", jsonData.dolbyVersion);
          console.info("upgradeInfo:", jsonData.upgradeInfo);
          console.info("enMultEQType:", jsonData.enMultEQType);
          console.info("adcLineup:", jsonData.adcLineup);
          console.info("subwooferNum:", jsonData.subwooferNum);
          console.info("subwooferMode:", jsonData.subwooferMode);
          console.info("subwooferLayout:", jsonData.subwooferLayout);
          console.info("measurementsPerPosition:", jsonData.measurementsPerPosition);
          // console.info("detectedChannels ")
          // log the full detected channels list in one line
          console.info("detectedChannels", jsonData.detectedChannels.map(ch => ch.commandId).join(","));
          // Populate commandId array with 1-based indexing
          jsonData.detectedChannels.forEach((channel, index) => {
            if (channel.commandId) {
              commandId[index + 1] = channel.commandId; // 1-based indexing
              console.info(`commandId[${index + 1}]: ${channel.commandId}`);
            }
          });
          console.info("");
          jsonData.detectedChannels.forEach(channel => {
            if (channel.commandId && channel.commandId === "C") {
              noCenter = false;
            }
            if (channel.commandId && channel.commandId.startsWith("SW")) {
              swChannelCount++;
              subLoTrim = Math.min(subLoTrim, parseFloat(channel.trimAdjustment));
              subHiTrim = Math.max(subHiTrim, parseFloat(channel.trimAdjustment));
              subLoDelay = Math.min(subLoDelay, parseFloat(channel.delayAdjustment));
              subHiDelay = Math.max(subHiDelay, parseFloat(channel.delayAdjustment));
              //
              channel.midrangeCompensation = true;
              channel.frequencyRangeRolloff = 250;
              if ("customCrossover" in channel) {
                delete channel.customCrossover;
              }
              if ("customSpeakerType" in channel) {
                delete channel.customSpeakerType;
              }
              if (swChannelCount === 1) {
                channel.customTargetCurvePoints = [];
              } else {
                if ("customTargetCurvePoints" in channel) {
                  delete channel.customTargetCurvePoints;
                }
              }
            } else {
              channel.customTargetCurvePoints = [];
              channel.midrangeCompensation = false;
              channel.frequencyRangeRolloff = 20000;
            }

            if (channel.commandId && heightChannelIds.includes(channel.commandId)) {
              hasHeightChannel = true;
            }
            if (channel.commandId && CenterChannelId.includes(channel.commandId)) {
              hasCenterChannel = true;
            }
            if (channel.commandId && CenterHeightChannelId.includes(channel.commandId)) {
              hasCenterHeightChannel = true;
            }
            if (channel.commandId && SurroundBackSingleChannelId.includes(channel.commandId)) {
              hasSurroundBackSingleChannel = true;
            }
            if (channel.commandId && TopSurroundChannelId.includes(channel.commandId)) {
              hasTopSurroundChannel = true;
            }
            if (channel.commandId && FrontLeftFrontRightChannelId.includes(channel.commandId)) {
              hasFrontLeftFrontRightChannel = true;
            }
            if (channel.commandId && FrontWideLeftFrontWideRightChannelId.includes(channel.commandId)) {
              hasFrontWideLeftFrontWideRightChannel = true;
            }
            if (channel.commandId && SurroundLeftSurroudRightChannelId.includes(channel.commandId)) {
              hasSurroundLeftSurroudRightChannel = true;
            }
            if (channel.commandId && SurroundBackLeftSurroundBackRightChannelId.includes(channel.commandId)) {
              hasSurroundBackLeftSurroundBackRightChannel = true;
            }
            if (channel.commandId && FrontHeightLeftFrontHeightRightChannelId.includes(channel.commandId)) {
              hasFrontHeightLeftFrontHeightRightChannel = true;
            }
            if (channel.commandId && SurroundHeightLeftSurroudHeightRightChannelId.includes(channel.commandId)) {
              hasSurroundHeightLeftSurroudHeightRightChannel = true;
            }
            if (channel.commandId && RearHeightLeftRearHeightRightChannelId.includes(channel.commandId)) {
              hasRearHeightLeftRearHeightRightChannel = true;
            }
            if (channel.commandId && TopFrontLeftTopFrontRightChannelId.includes(channel.commandId)) {
              hasTopFrontLeftTopFrontRightChannel = true;
            }
            if (channel.commandId && TopMiddleLeftTopMiddleRightChannelId.includes(channel.commandId)) {
              hasTopMiddleLeftTopMiddleRightChannel = true;
            }
            if (channel.commandId && TopRearLeftTopRearRightChannelId.includes(channel.commandId)) {
              hasTopRearLeftTopRearRightChannel = true;
            }
            if (channel.commandId && FrontDolbyLeftFrontDolbyRightChannelId.includes(channel.commandId)) {
              hasFrontDolbyLeftFrontDolbyRightChannel = true;
            }
            if (channel.commandId && SurroundDolbyLeftSurroundDolbyRightChannelId.includes(channel.commandId)) {
              hasSurroundDolbyLeftSurroundDolbyRightChannel = true;
            }
            if (channel.commandId && BackDolbyLeftBackDolbyRightChannelId.includes(channel.commandId)) {
              hasBackDolbyLeftBackDolbyRightChannel = true;
            }
            /*
            console.info(channel.commandId);
            console.info("customEnSpeakerConnect", channel.channelReport.customEnSpeakerConnect);
            console.info("distance", channel.channelReport.distance);
            console.info("enSpeakerConnect", channel.channelReport.enSpeakerConnect);
            console.info("isReversePolarity", channel.channelReport.isReversePolarity);
            console.info("customCrossover", channel.customCrossover);
            console.info("customDistance", channel.customDistance);
            console.info("customLevel", channel.customLevel);
            console.info("customSpeakerType", channel.customSpeakerType);
            console.info("delayAdjustment", channel.delayAdjustment);
            console.info("enChannelType", channel.enChannelType);
            console.info("frequencyRangeRolloff", channel.frequencyRangeRolloff);
            console.info("isSkipMeasurement", channel.isSkipMeasurement);
            console.info("midrangeCompensation", channel.midrangeCompensation);
            console.info("trimAdjustment", channel.trimAdjustment);
            console.info("");
            */
          });
          Object.freeze(noCenter);
          Object.freeze(swChannelCount);
          subLoTrim = -12 + Math.abs(subLoTrim);
          subHiTrim = 12 - Math.abs(subHiTrim);
          Object.freeze(subLoTrim);
          Object.freeze(subHiTrim);
          subLoDelay /= sOs;
          subHiDelay /= sOs;
          Object.freeze(subLoDelay);
          Object.freeze(subHiDelay);
          flDist = getFLDistance(jsonData.detectedChannels);
          Object.freeze(flDist);
          console.info("Speaker measurements have been extracted from the uploaded calibration file.");
          let totalMeasurements = 0;
          const zip = new JSZip();
          const { detectedChannels } = jsonData;
          const filePromises = Object.entries(detectedChannels).map(([key, detectedChannel]) => {
            const { responseData, commandId } = detectedChannel;
            return Promise.all(Object.entries(responseData).map(([arrayKey, arrayData]) => {
              const dataString = arrayData.join('\n');
              const rewHeader = `* Impulse Response data saved by REW\n0 // Peak value before normalisation\n0 // Peak index\n16384 // Response length\n2.0833333333333333E-5 // Sample interval (seconds)\n0.0 // Start time (seconds)\n78.0 // Data offset (dB)\n* Data start\n${dataString}`;
              const measurementName = `${commandId}${arrayKey}.txt`;
              zip.file(measurementName, rewHeader);
              totalMeasurements++;
            }));
          });
          Object.freeze(totalMeasurements);
          if (isCirrusLogic) {
            zip.file("_micCal.txt", micCal);
          }
          console.log(`Please save ${fileName.substring(0, fileName.lastIndexOf('.'))}_extractedMeasurements.zip file when prompted.`);
          console.info("Checking for measurements...");
          await Promise.all(filePromises.flat());
          try {
            const content = await zip.generateAsync({ type: 'blob' });
            const urlZip = URL.createObjectURL(content);
            try {
              const downloadLink = document.createElement('a');
              downloadLink.href = urlZip;
              downloadLink.download = `${fileName.substring(0, fileName.lastIndexOf('.'))}_extractedMeasurements.zip`;
              downloadLink.style.display = 'none';
              document.body.appendChild(downloadLink);
              downloadLink.click();
              document.body.removeChild(downloadLink);
            } finally {
              URL.revokeObjectURL(urlZip); // Always cleanup the URL object
            }
          } catch (error) {
            console.error('🞮 Error generating or downloading zip file:', error);
          }
          let lastValidationState = null; // Track previous validation state
          let isFirstValidation = true; // Track if this is the first validation run

          const checkMeasurementCount = async () => {
            const measurements = await fetch_mREW();
            let mCount = Object.keys(measurements).length;
            if (isCirrusLogic) (mCount--);

            // ═══════════════════════════════════════════════════════════════════════
            // CRITICAL: Validate actual subwoofer count from measurements
            // ═══════════════════════════════════════════════════════════════════════
            const actualSubCounts = {};
            const actualMeasurements = new Set();

            for (let i = 1; i <= mCount; i++) {
              const title = measurements[i].title;
              actualMeasurements.add(title);

              // Count actual subwoofers by detecting SW{N}0 patterns
              const swMatch = title.match(/^SW(\d)0$/);
              if (swMatch) {
                const subNum = parseInt(swMatch[1]);
                if (!actualSubCounts[subNum]) {
                  actualSubCounts[subNum] = 0;
                }
                actualSubCounts[subNum]++;
              }
            }
            const actualSubCount = Object.keys(actualSubCounts).length;

            // ═══════════════════════════════════════════════════════════════════════
            // COMPARE: .ady file vs actual measurements
            // ═══════════════════════════════════════════════════════════════════════
            if (actualSubCount !== swChannelCount) {
              console.warn("═".repeat(60));
              console.warn("⚠ SUBWOOFER COUNT MISMATCH DETECTED!");
              console.warn("═".repeat(60));
              console.warn(`.ady file claims: ${swChannelCount} subwoofer(s)`);
              console.warn(`Actual measurements: ${actualSubCount} subwoofer(s)`);
              console.warn("");

              // Show what we found
              for (const [subNum, count] of Object.entries(actualSubCounts)) {
                console.warn(`  Found: SW${subNum} with ${count} MLP measurement`);
              }

              // Show what .ady expected
              const expectedSubs = [];
              jsonData.detectedChannels.forEach(channel => {
                if (channel.commandId && channel.commandId.startsWith("SW")) {
                  expectedSubs.push(channel.commandId);
                }
              });
              console.warn(`  .ady expected: ${expectedSubs.join(', ')}`);
              console.warn("");
              console.warn("Possible causes:");
              console.warn("  1. .ady was modified/edited after measurement");
              console.warn("  2. ZIP doesn't contain all measured subwoofers");
              console.warn("  3. Measurement naming doesn't follow SW{N}{P} convention");
              console.warn("");
              console.warn(`✓ Using actual count: ${actualSubCount} subwoofer(s)`);
              console.warn("═".repeat(60));
              // CORRECT the global variable
              swChannelCount = actualSubCount;
              Object.freeze(swChannelCount);
            }

            // ═══════════════════════════════════════════════════════════════════════
            // Validate measurement names against ADY file
            // ═══════════════════════════════════════════════════════════════════════
            try {
              const expectedMeasurements = new Set();

              // Extract expected measurement names from ADY
              jsonData.detectedChannels.forEach(channel => {
                const commandId = channel.commandId;

                // For subwoofers, only count the ones that actually exist
                if (commandId.startsWith("SW")) {
                  const subNum = commandId.slice(-1); // Extract "1" from "SW1"
                  const channelIndices = Object.keys(channel.responseData);

                  // Only add to expected if this sub actually exists in measurements
                  if (actualSubCounts[subNum]) {
                    channelIndices.forEach(index => {
                      expectedMeasurements.add(`${commandId}${index}`);
                    });
                  }
                } else {
                  // Non-subwoofer channels
                  const channelIndices = Object.keys(channel.responseData);
                  channelIndices.forEach(index => {
                    expectedMeasurements.add(`${commandId}${index}`);
                  });
                }
              });

              // Find discrepancies
              const missing = [...expectedMeasurements].filter(name => !actualMeasurements.has(name));
              const extra = [...actualMeasurements].filter(name => !expectedMeasurements.has(name));

              // Create current validation state for comparison
              const currentValidationState = JSON.stringify({ missing, extra, mCount });

              // Show validation messages on first run OR if state changed
              if (isFirstValidation || currentValidationState !== lastValidationState) {
                console.infoUpdate("Validating REW measurements against ADY file...");

                if (missing.length === 0 && extra.length === 0) {
                  console.infoUpdate("✓ All REW measurements match ADY file expectations");
                } else {
                  if (missing.length > 0) {
                    console.warn(`⚠ Missing measurements: ${missing.join(', ')}`);
                  }
                  if (extra.length > 0) {
                    console.warn(`⚠ Extra measurements: ${extra.join(', ')}`);
                  }
                }

                lastValidationState = currentValidationState;
                isFirstValidation = false;
              }
            } catch (error) {
              console.error("🞮 Could not validate measurement names:", error.message);
            }

            // Check if count matches for success logic
            if (mCount === totalMeasurements) {
              const importedMeasurements = [];
              for (let i = 1; i <= mCount; i++) {
                importedMeasurements.push(measurements[i].title);
              }

              console.infoUpdate(`All ${isCirrusLogic ? mCount + 1 : mCount} measurements successfully imported!`);
              console.infoUpdate(`Measurements: ${importedMeasurements.join(', ')}`);

              window.measurementsImported = true;
              window.updateContinueButtonState();
              clearInterval(intervalId);

              if (window.onMeasurementsImported) {
                window.onMeasurementsImported();
                document.getElementById("resumeUpload").disabled = true;
                document.getElementById("resumeUpload").style.display = "none";
                document.getElementById("resumeUploadlabel").style.display = "none";
              }
            } else {
              console.infoUpdate(`Expecting ${totalMeasurements} measurements to be imported into REW...`);
            }
          }

          const intervalId = setInterval(checkMeasurementCount, 1000);
        }
        reader.readAsText(file);
      }

      // Delay utility functions - place after global variables
      const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
      const platformDelay = async () => {
        if (!isWindowsPlatform()) {
          await delay(speedDelay);
        }
      };

      const customDelay = async (ms) => {
        if (!isWindowsPlatform()) {
          await delay(ms);
        }
      };

      // global mode variables
      function getCurrentMode() {
        if (isRP22mode) return 'RP22';
        if (isDolbymode) return 'DOLBY';
        if (isTHXmode) return 'THX';
        if (isIMAXmode) return 'IMAX';
        return 'DEFAULT';
      }

      // global mode config
      const MODE_CONFIG = {
        RP22: {
          speaker: { min: 20, max: 20000 },
          subwoofer: { min: 20, max: 120 },
          rolloffHF: 15000,
          smoothing: '1/3'
        },
        DOLBY: {
          speaker: { min: 31.5, max: 16000 },
          subwoofer: { min: 31.5, max: 120 },
          rolloffHF: 16000,
          smoothing: '1/1'
        },
        THX: {
          speaker: { min: 20, max: 20000 },
          subwoofer: { min: 20, max: 120 },
          rolloffHF: 20000,
          smoothing: '1/1'
        },
        IMAX: {
          speaker: { min: 20, max: 20000 },
          subwoofer: { min: 20, max: 70 },
          rolloffHF: 20000,
          smoothing: '1/1'
        },
        DEFAULT: {
          speaker: { min: 20, max: 20000 },
          subwoofer: { min: 30, max: 80 },
          rolloffHF: null, // calculated dynamically
          smoothing: '1/1'
        }
      };

      // global SPL Constants
      const SPL_OFFSETS = {
        SPL_78DB: 78,
        SPL_88DB: 88,
        SPL_120DB: 120
      };

      const VALID_TARGET_LEVELS = [75, 82, 85, 100];
      const DEFAULT_TARGET_LEVEL = 75;

      // Helper function to set target level based on configuration
      function setTargetLevel(targetLevel, isCirrusLogic) {
        const validLevel = VALID_TARGET_LEVELS.includes(targetLevel) ? targetLevel : DEFAULT_TARGET_LEVEL;
        return parseFloat(validLevel);
      }

      // Helper function to handle different SPL offset types
      function handleSplOffset(splOffsetdB, measurements, targetLevel, isCirrusLogic) {
        const offset = parseFloat(splOffsetdB);
        switch (offset) {
          case SPL_OFFSETS.SPL_78DB:
            console.warn("⚠ Measurements at 78.0dB");
            return setTargetLevel(targetLevel, isCirrusLogic);
          case SPL_OFFSETS.SPL_88DB:
            console.warn("⚠ Measurements at 88.0dB");
            return setTargetLevel(targetLevel, isCirrusLogic);
          case SPL_OFFSETS.SPL_120DB:
            // Check if this is the deprecated old MJ format
            const requiredProperties = ['timingReference', 'delay', 'timingOffset', 'signalToNoisedB'];
            const hasRequiredProperties = requiredProperties.every(prop =>
              measurements[1].hasOwnProperty(prop)
            );
            if (!hasRequiredProperties) {
              console.error("🞮 These specific 120dB measurements are no longer supported!");
              console.error("🞮 Please use the ZIP that came with ClariQ Next");
              console.error("🞮 Or use custom measurements inside REW");
              throw new Error("🞮 Unsupported measurement type: 120dB old format is deprecated");
            }
            return setTargetLevel(targetLevel, isCirrusLogic);
          default:
            console.warn(`⚠ Custom measurements detected. SPL offset: ${offset}dB`);
            IsCustomMeasurements = true;
            return setTargetLevel(targetLevel, isCirrusLogic);
        }
      }

      // Helper function for setup operations
      async function performSetupOperations(speedDelay) {
        const operations = [
          { fn: clearCommands, name: "clearCommands" },
          { fn: disableBlock, name: "disableBlock" },
          { fn: enableGraph, name: "enableGraph" },
          { fn: enableBlock, name: "enableBlock" },
          { fn: disableGraph, name: "disableGraph" },
          { fn: enableGraph, name: "enableGraph" }
        ];

        for (const operation of operations) {
          await operation.fn();
          await platformDelay();
        }
      }

      // Main function - now much cleaner and focused
      async function CorrectSPL() {
        try {
          // Setup operations
          await performSetupOperations(speedDelay);
          // Fetch measurements
          const measurements = await fetch_mREW();
          // Validate measurements
          if (!measurements || !measurements[1]) {
            throw new Error("Invalid measurements data");
          }
          // Get measurement count
          const measurementIds = Object.keys(measurements).filter(key => !isNaN(key));
          console.log(`Found ${measurementIds.length} measurements to check`);
          // Process SPL offset and set target level
          const splOffsetdB = measurements[1].splOffsetdB;
          if (splOffsetdB === undefined) {
            throw new Error("SPL offset not found in measurements");
          }
          isCirrusLogictargetLevel = handleSplOffset(
            splOffsetdB,
            measurements,
            targetLevel,
            isCirrusLogic
          );
          console.log(`Target level set to: ${isCirrusLogictargetLevel}dB`);
        } catch (error) {
          console.error("🞮 Error in CorrectSPL:", error.message);
          // Handle specific error types
          if (error.message.includes("Unsupported measurement type")) {
            isAutoMode = false;
            isScriptRunning = false;
            process.exit(1);
          }
          // Re-throw other errors for higher-level handling
          throw error;
        }
      }

      function getadyName(fileName, suffix) {
        const dotIndex = fileName.lastIndexOf(".");
        const modifiedName = fileName.substring(0, dotIndex) + suffix;
        return modifiedName;
      }

      function getFLDistance(channels) {
        let flIndex = 0;
        for (let i = 0; i < channels.length; i++) {
          if (channels[i].commandId === "FL") {
            flIndex = i;
            break;
          }
        }
        let dist = parseFloat(channels[flIndex].channelReport.distance);
        if (isNaN(dist) || dist === 0) {
          dist = parseFloat(channels[flIndex].customDistance);
          if (isNaN(dist) || dist === 0 || dist === null) {
            // Try the distance property as a fallback
            dist = parseFloat(channels[flIndex].distance);
            if (isNaN(dist) || dist === 0 || dist === null) {
              console.warn(`⚠ No distance found for ${channels[flIndex].commandId}! Defaulting to 6m.`)
              console.warn(`⚠ To fix: Open ady in MultEQ phone app then > Speaker Detection Results > Change any crossover > Save and then retry.`);
              dist = 6.00;
            }
          }
        }
        return dist;
      }

      async function addmicCal() {
        console.info("Applying Audyssey microphone calibration file to measurements...");
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i < mCount; i++) {
          const name = measurements[i].title;
          console.infoUpdate(`Applying Audyssey microphone calibration file to ${name}...`);
          const irWindows = await fetchSafe('ir-windows', i);
          const leftW = parseFloat(irWindows.leftWindowWidthms);
          const rightW = parseFloat(irWindows.rightWindowWidthms);
          const refTime = parseFloat(irWindows.refTimems);
          await postNext('Arithmetic', [i, mCount], { function: "A * B" });
          await postSafe(`${baseUrl}/${mCount + i}/ir-windows`, { leftWindowWidthms: leftW, rightWindowWidthms: rightW, refTimems: refTime }, "Update processed");
          await fetch_mREW(mCount + i, 'PUT', { title: name });
        }
        console.infoUpdate("Deleting processed measurements...");
        for (let i = mCount; i >= 1; i--) {
          await postDelete(i);
        }
        console.infoUpdate("Completed applying Audyssey microphone calibration file to measurements.");
      }

      // Debugging function to help troubleshoot the user's specific environment
      async function debugUserEnvironment() {
        console.log("=== USER ENVIRONMENT DEBUG ===");
        // Check REW API connectivity and version
        try {
          const rewVersion = await fetch(`http://localhost:4735/version`);
          if (rewVersion.ok) {
            const rew = await rewVersion.json();
            console.log(`REW Version: ${rew.message}`);
          } else {
            console.error(`🞮 REW Version check failed: ${rewVersion.status}`);
          }
        } catch (error) {
          console.error("🞮 REW API connection failed:", error);
        }
        // Check what postNext function actually looks like
        console.log("postNext function type:", typeof postNext);
        if (typeof postNext === 'function') {
          console.log("postNext function source (first 200 chars):", postNext.toString().substring(0, 200));
        }
        // Check baseUrl
        console.log("baseUrl:", baseUrl);
        // Test simple REW API call
        try {
          const measurements = await fetch_mREW();
          console.log("fetch_mREW successful, measurement count:", Object.keys(measurements).length);
          // Test a simple command on measurement 1 if it exists
          if (measurements[1]) {
            console.log("Testing simple command on measurement 1...");
            const testResult = await postNext('Smooth', 1, { smoothing: "1/48" });
            console.log("Simple command test successful");
          }
        } catch (error) {
          console.error("🞮 Basic REW API test failed:", error);
        }
        console.log("=== END ENVIRONMENT DEBUG ===");
      }

      async function enableRoomCurve() {
        await postSafe(`http://localhost:4735/eq/default-room-curve-settings`, {
          addRoomCurve: true, lowFreqRiseStartHz: 630, lowFreqRiseEndHz: 100, lowFreqRiseSlopedBPerOctave: 0.8,
          highFreqFallStartHz: 630, highFreqFallSlopedBPerOctave: 0.8
        }, "Update processed");
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i <= mCount; i++) {
          await postSafe(`${baseUrl}/${i}/room-curve-settings`, {
            addRoomCurve: true, lowFreqRiseStartHz: 630, lowFreqRiseEndHz: 100, lowFreqRiseSlopedBPerOctave: 0.8,
            highFreqFallStartHz: 630, highFreqFallSlopedBPerOctave: 0.8
          }, "Update processed");
        }
      }

      async function disableRoomCurve() {
        await postSafe(`http://localhost:4735/eq/default-room-curve-settings`, { addRoomCurve: false }, "Update processed");
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i <= mCount; i++) {
          await postSafe(`${baseUrl}/${i}/room-curve-settings`, { addRoomCurve: false }, "Update processed");
        }
      }

      function logCustomizations() {
        console.info(`****************************************************************************************************`);
        console.log("Optimization parameters:")
        const mode = getCurrentMode();
        if (targetCurveName === "") {
          console.info("  No target curve - 'ClariQ Next' - will EQ to a gentle downward slope & enable Dynamic EQ.");
        } else {
          console.info(`  Active target curve: ${targetCurveName}.`);
        }
        if (targetLevel == 75) {
          console.info(`  Target level set to ${targetLevel}dB`);
        } else {
          console.warn(`  ⚠ Target level set to ${targetLevel}dB`);
        }
        if (mode !== 'DEFAULT') {
          console.warn(`  ⚠ ${mode} mode active`);
          const config = MODE_CONFIG[mode];
          console.info(`    - Speaker range: ${config.speaker.min}-${config.speaker.max}Hz`);
          console.info(`    - Subwoofer range: ${config.subwoofer.min}-${config.subwoofer.max}Hz`);
          if (config.rolloffHF) {
            console.info(`    - HF rolloff: ${config.rolloffHF}Hz`);
          }
        } else {
          console.info(`  Standard mode active (DEFAULT)`);
        }

        // If none of the sliders are touched
        if (!isClearCurve) {
          if (hasCenterChannel === true && window.selectedMinFreq_center !== undefined) {
            console.info(`  CENTER range: ${window.selectedMinFreq_center}-${window.selectedMaxFreq_center}Hz`);
          }
          if (hasFrontLeftFrontRightChannel === true && window.selectedMinFreq_main_fl_fr !== undefined) {
            console.info(`  FRONT LEFT & RIGHT range: ${window.selectedMinFreq_main_fl_fr}-${window.selectedMaxFreq_main_fl_fr}Hz`);
          }
          if (hasSurroundLeftSurroudRightChannel === true && window.selectedMinFreq_surround_sla_sra !== undefined) {
            console.info(`  SURROUND LEFT & RIGHT range: ${window.selectedMinFreq_surround_sla_sra}-${window.selectedMaxFreq_surround_sla_sra}Hz`);
          }
          if (hasSurroundBackLeftSurroundBackRightChannel === true && window.selectedMinFreq_surround_sbl_sbr !== undefined) {
            console.info(`  SURROUND BACK LEFT & RIGHT range: ${window.selectedMinFreq_surround_sbl_sbr}-${window.selectedMaxFreq_surround_sbl_sbr}Hz`);
          }
          if (hasSurroundBackSingleChannel === true && window.selectedMinFreq_surround_sb !== undefined) {
            console.info(`  SURROUND BACK SINGLE range: ${window.selectedMinFreq_surround_sb}-${window.selectedMaxFreq_surround_sb}Hz`);
          }
          if (hasFrontWideLeftFrontWideRightChannel === true && window.selectedMinFreq_main_fwl_fwr !== undefined) {
            console.info(`  FRONT WIDE LEFT & RIGHT range: ${window.selectedMinFreq_main_fwl_fwr}-${window.selectedMaxFreq_main_fwl_fwr}Hz`);
          }
          if (hasFrontHeightLeftFrontHeightRightChannel === true && window.selectedMinFreq_height_fhl_fhr !== undefined) {
            console.info(`  FRONT HEIGHT LEFT & RIGHT range: ${window.selectedMinFreq_height_fhl_fhr}-${window.selectedMaxFreq_height_fhl_fhr}Hz`);
          }
          if (hasSurroundHeightLeftSurroudHeightRightChannel === true && window.selectedMinFreq_height_shl_shr !== undefined) {
            console.info(`  SURROUND HEIGHT LEFT & RIGHT range: ${window.selectedMinFreq_height_shl_shr}-${window.selectedMaxFreq_height_shl_shr}Hz`);
          }
          if (hasRearHeightLeftRearHeightRightChannel === true && window.selectedMinFreq_height_rhl_rhr !== undefined) {
            console.info(`  REAR HEIGHT LEFT & RIGHT range: ${window.selectedMinFreq_height_rhl_rhr}-${window.selectedMaxFreq_height_rhl_rhr}Hz`);
          }
          if (hasCenterHeightChannel === true && window.selectedMinFreq_height_ch !== undefined) {
            console.info(`  CENTER HEIGHT (AURO3D) range: ${window.selectedMinFreq_height_ch}-${window.selectedMaxFreq_height_ch}Hz`);
          }
          if (hasTopFrontLeftTopFrontRightChannel === true && window.selectedMinFreq_top_tfl_tfr !== undefined) {
            console.info(`  TOP FRONT LEFT & RIGHT range: ${window.selectedMinFreq_top_tfl_tfr}-${window.selectedMaxFreq_top_tfl_tfr}Hz`);
          }
          if (hasTopMiddleLeftTopMiddleRightChannel === true && window.selectedMinFreq_top_tml_tmr !== undefined) {
            console.info(`  TOP MIDDLE LEFT & RIGHT range: ${window.selectedMinFreq_top_tml_tmr}-${window.selectedMaxFreq_top_tml_tmr}Hz`);
          }
          if (hasTopRearLeftTopRearRightChannel === true && window.selectedMinFreq_top_trl_trr !== undefined) {
            console.info(`  TOP REAR LEFT & RIGHT range: ${window.selectedMinFreq_top_trl_trr}-${window.selectedMaxFreq_top_trl_trr}Hz`);
          }
          if (hasTopSurroundChannel === true && window.selectedMinFreq_top_ts !== undefined) {
            console.info(`  TOP SURROUND (AURO3D) range: ${window.selectedMinFreq_top_ts}-${window.selectedMaxFreq_top_ts}Hz`);
          }
          if (hasFrontDolbyLeftFrontDolbyRightChannel === true && window.selectedMinFreq_dolby_fdl_fdr !== undefined) {
            console.info(`  FRONT DOLBY LEFT & RIGHT range: ${window.selectedMinFreq_dolby_fdl_fdr}-${window.selectedMaxFreq_dolby_fdl_fdr}Hz`);
          }
          if (hasSurroundDolbyLeftSurroundDolbyRightChannel === true && window.selectedMinFreq_dolby_sdl_sdr !== undefined) {
            console.info(`  SURROUND DOLBY LEFT & RIGHT range: ${window.selectedMinFreq_dolby_sdl_sdr}-${window.selectedMaxFreq_dolby_sdl_sdr}Hz`);
          }
          if (hasBackDolbyLeftBackDolbyRightChannel === true && window.selectedMinFreq_dolby_bdl_bdr !== undefined) {
            console.info(`  BACK DOLBY LEFT & RIGHT range: ${window.selectedMinFreq_dolby_bdl_bdr}-${window.selectedMaxFreq_dolby_bdl_bdr}Hz`);
          }
          console.info(`  Phase Weight: ${window.phaseWeight}`);
        }

        if (freqIndex.includes(180)) {
          console.warn("  ⚠ AVR supports 180Hz");
        }
        if (freqIndex.includes(70)) {
          console.warn("  ⚠ AVR supports IMAX 70Hz");
        }
        if (DiracEnabled == true) {
          console.warn("  ⚠ AVR supports Dirac");
          console.warn("  ⚠ AVR max distance set to 18m");
        } else {
          console.info("  AVR does not! supports Dirac");
          console.info("  AVR max distance set to 6m");
        }
        if (noInversion) {
          console.warn(`  ⚠ Subwoofer polarity inversion allowed: No.`);
        } else {
          console.info(`  Subwoofer polarity inversion allowed: Yes.`);
        }
        if (AdvancedFilters === true || AdvancedFilters === 1) {
          console.warn(`  ⚠ Advanced Filters: ${AdvancedFilters}`);
        } else {
          console.info(`  Advanced Filters: ${AdvancedFilters}`);
        }

        if (AdvancedFilters == true && AdvancedFiltersType == "null") {
          console.info(`  Advanced Filters Type: none`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "CUSTOMadvanced") {
          console.warn(`  ⚠ Advanced Filters Type: custom filters active`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "DIALOGadvanced") {
          console.warn(`  ⚠ Advanced Filters Type: Advanced Dialog Enhancement CEDIA RP22`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSresearch") {
          console.warn(`  ⚠ Advanced Filters Type: Research-Based Hearing Loss Compensation`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSmoderate") {
          console.warn(`  ⚠ Advanced Filters Type: Moderate Hearing Loss Compensation`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSsevere") {
          console.warn(`  ⚠ Advanced Filters Type: Severe Hearing Loss Compensation`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "HLOSSoriginal") {
          console.warn(`  ⚠ Advanced Filters Type: Original 0.0.3 Hearing Loss Compensation`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGcompetitive") {
          console.warn(`  ⚠ Advanced Filters Type: Competitive Gaming EQ (Footsteps & Tactical Audio)`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGimmersive") {
          console.warn(`  ⚠ Advanced Filters Type: Immersive Gaming EQ (Cinematic Experience)`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGvoice") {
          console.warn(`  ⚠ Advanced Filters Type: Voice Chat Gaming EQ (Clear Communication)`);
        } else if (AdvancedFilters == true && AdvancedFiltersType == "GAMINGbalanced") {
          console.infwarno(`  Advanced Filters Type: Balanced Gaming EQ (All-Purpose)`);
        }
        if (needsSorting) {
          console.warn(`  ⚠ Measurements are custom sorted`);
        } else {
          console.info(`  Measurements are default sorted`);
        }
        console.info(`  Version: ${nextversion}`)
        console.info(`****************************************************************************************************`);
      }

      async function bootUp() {
        console.info("Resetting IR windows, equalizer & target settings for all measurements");
        const measurements = await fetch_mREW();
        const titles = {}; let titleIndices = {};
        let mCount = Object.keys(measurements).length;
        console.info(`Starting processing of ${mCount} measurements...`);
        for (let q = 1; q <= mCount; q++) {
          console.infoUpdate(`Counting measurement ${q} of ${mCount}`);
        }
        if (mCount > 100) {
          console.warn(`⚠ large amount of measurements found ${mCount} REW may seem unresponsive for some time`)
          console.warn(`⚠ Please be patient`)
        }
        if (!mCount) { console.error(`🞮 There are no measurements in REW!`); throw new Error; }
        // Identify and store mic calibration measurements before processing
        let micCalMeasurements = [];
        let actualMCount = mCount;
        for (let i = 1; i <= mCount; i++) {
          if (measurements[i].title.startsWith('_micCal')) {
            micCalMeasurements.push({
              index: i,
              title: measurements[i].title,
              data: measurements[i]
            });
            actualMCount--;
          }
        }
        // Use actualMCount for processing (excluding mic cal)
        if (isCirrusLogic) { actualMCount--; };
        let baseMessage = "Resetting IR windows, EQ type, target shape and smoothing for all measurements..."
        // Reset settings for ALL measurements (including mic cal)
        for (let q = 1; q <= mCount; q++) {
          await postSafe(`${baseUrl}/${q}/ir-windows`, { leftWindowType: "Rectangular", rightWindowType: "Rectangular" }, "Update processed");
          await customDelay(speedDelay / 3);
          await postSafe(`${baseUrl}/${q}/equaliser`, { manufacturer: "Generic", model: "Generic" }, "Equaliser selected");
          await customDelay(speedDelay / 3);
          await postSafe(`${baseUrl}/${q}/target-settings`, { shape: "None" }, "Update processed");
          await customDelay(speedDelay / 3);
          // await postNext('Smooth', q, { smoothing: "1/48" });
          await postNext('Smooth', q, { smoothing: "none" });
          await customDelay(speedDelay / 3);
          console.infoUpdate(`${baseMessage} (${q}/${mCount})`);
        }
        await console.infoUpdate("Resetting default equalizer to 'Generic/Generic'...");
        await postSafe(`http://localhost:4735/eq/default-equaliser`, { manufacturer: "Generic", model: "Generic" }, "Default equaliser changed");
        await customDelay(speedDelay / 3);
        await console.infoUpdate(`Resetting default target level to ${targetLevel}dB...`);
        await fetch("http://localhost:4735/eq/default-target-level", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: Number(targetLevel).toFixed(1),
        });
        await customDelay(speedDelay / 3);
        const firstTitle = measurements[1].title;
        console.infoUpdate(`Checking measurement names, indices and sorting...`);
        // Build titleIndices excluding mic calibration measurements
        for (let i = 1; i <= mCount; i++) {
          const title = measurements[i].title;
          // Skip mic calibration measurements for sorting logic
          if (title.startsWith('_micCal')) {
            continue;
          }
          const titleKey = title.replace(/\d+/g, '');
          if (!/^\D+(\d+)?$/.test(titleKey)) {
            console.error(`🞮 Speaker name ${titleKey} does not end with a numeric index.`);
            throw new Error;
          }
          if (!titles[titleKey]) {
            titles[titleKey] = true;
            titleIndices[titleKey] = [];
          }
          const matchResult = title.match(/\d+/);
          if (matchResult && matchResult.length > 0) {
            titleIndices[titleKey].push(parseInt(matchResult[0]));
          } else {
            console.error(`🞮 No indices found in speaker name: ${title}`);
            throw new Error;
          }
        }
        // Build expected order: regular speakers first, then subwoofers (mic cal will be handled separately)
        const regularGroups = Object.keys(titleIndices).filter(key => !key.startsWith('SW')).sort();
        const swGroups = Object.keys(titleIndices).filter(key => key.startsWith('SW')).sort();
        for (const groupKey of [...regularGroups, ...swGroups]) {
          for (const index of titleIndices[groupKey].sort((a, b) => a - b)) {
            expectedOrder.push(groupKey + index);
          }
        }
        // Check if current REW order matches expected order (excluding mic cal)
        let currentOrderWithoutMicCal = [];
        for (let i = 1; i <= mCount; i++) {
          if (!measurements[i].title.startsWith('_micCal')) {
            currentOrderWithoutMicCal.push(measurements[i].title);
          }
        }
        for (let i = 0; i < expectedOrder.length; i++) {
          if (currentOrderWithoutMicCal[i] !== expectedOrder[i]) {
            needsSorting = true;
            console.info(`Order mismatch at position ${i + 1}: found "${currentOrderWithoutMicCal[i]}", expected "${expectedOrder[i]}"`);
            break;
          }
        }
        if (needsSorting) {
          console.infoUpdate("Measurements need reordering. Performing manual sort for proper numeric ordering...");
          try {
            // Get current measurements
            const currentMeasurements = await fetch_mREW();
            const currentMCount = Object.keys(currentMeasurements).length;
            // Separate mic cal measurements from regular measurements
            const regularMeasurements = [];
            const micCalMeasurementsForSorting = [];
            for (let i = 1; i <= currentMCount; i++) {
              const name = currentMeasurements[i].title;
              if (name.startsWith('_micCal')) {
                micCalMeasurementsForSorting.push({
                  originalIndex: i,
                  name: name,
                  index: 999999 // Ensure mic cal sorts last
                });
              } else {
                regularMeasurements.push({
                  originalIndex: i,
                  name: name
                });
              }
            }
            // Parse regular measurements and group them
            const measurementGroups = {};
            for (const measurement of regularMeasurements) {
              const name = measurement.name;
              const titleKey = name.replace(/\d+/g, '');
              const matchResult = name.match(/\d+/);
              if (matchResult && matchResult.length > 0) {
                const groupKey = titleKey;
                const index = parseInt(matchResult[0]);
                if (!measurementGroups[groupKey]) {
                  measurementGroups[groupKey] = [];
                }
                measurementGroups[groupKey].push({
                  originalIndex: measurement.originalIndex,
                  name: name,
                  index: index
                });
              } else {
                console.error(`🞮 No indices found in speaker name: ${name}`);
                throw new Error;
              }
            }
            // Sort each group numerically by index
            const sortedGroups = {};
            for (const groupKey in measurementGroups) {
              sortedGroups[groupKey] = measurementGroups[groupKey].sort((a, b) => a.index - b.index);
            }
            // Determine copy order: regular speakers first, then SW groups, then mic cal
            const copyOrder = [];
            const regularGroups = Object.keys(sortedGroups).filter(key => !key.startsWith('SW')).sort();
            const swGroups = Object.keys(sortedGroups).filter(key => key.startsWith('SW')).sort();
            // Add regular and SW measurements
            for (const groupKey of [...regularGroups, ...swGroups]) {
              copyOrder.push(...sortedGroups[groupKey]);
            }
            // Add mic cal measurements at the end
            copyOrder.push(...micCalMeasurementsForSorting);
            console.infoUpdate(`Copying ${copyOrder.length} measurements in correct numeric order...`);
            // Copy all measurements in the correct order
            for (let i = 0; i < copyOrder.length; i++) {
              const measurement = copyOrder[i];
              await postSafe(`http://localhost:4735/measurements/${measurement.originalIndex}/command`, { command: "Response copy" }, "Completed");
              await customDelay(speedDelay);
              console.infoUpdate(`Copying measurements... (${i + 1}/${copyOrder.length})`);
            }
            console.infoUpdate("Removing original measurements...");
            // Delete all original measurements (backwards to avoid index shifting)
            for (let i = currentMCount; i >= 1; i--) {
              await postDelete(i);
              console.infoUpdate(`Removing original measurements... (${currentMCount - i + 1}/${currentMCount})`);
            }
            console.infoUpdate("Renaming copied measurements to remove '-copy' suffixes...");
            // Re-fetch to get the remaining measurements (all should be -copy versions now)
            const copiedMeasurements = await fetch_mREW();
            const newMCount = Object.keys(copiedMeasurements).length;
            // Rename all measurements that have "-copy" suffix
            for (let q = 1; q <= newMCount; q++) {
              const name = copiedMeasurements[q].title;
              if (name.endsWith("-copy")) {
                const newname = name.replace(/-copy/gim, "");
                const requestOptions = {
                  method: "PUT",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ title: newname }),
                };
                await fetch(`http://localhost:4735/measurements/${q}`, requestOptions);
                await customDelay(speedDelay);
                console.infoUpdate(`Renaming measurements... (${q}/${newMCount})`);
              }
            }
            console.infoUpdate("ClariQ Next sorting completed. Mic calibration preserved at end.");
            // Re-fetch and rebuild measurement data
            const sortedMeasurements = await fetch_mREW();
            mCount = Object.keys(sortedMeasurements).length;
            // Recalculate actualMCount after sorting
            actualMCount = mCount;
            for (let i = 1; i <= mCount; i++) {
              if (sortedMeasurements[i].title.startsWith('_micCal')) {
                actualMCount--;
              }
            }
            if (isCirrusLogic) { actualMCount--; };
            // Clear and rebuild the titles and indices with sorted data (excluding mic cal)
            Object.keys(titles).forEach(key => delete titles[key]);
            Object.keys(titleIndices).forEach(key => delete titleIndices[key]);
            for (let i = 1; i <= mCount; i++) {
              const title = sortedMeasurements[i].title;
              // Skip mic calibration measurements
              if (title.startsWith('_micCal')) {
                continue;
              }
              const titleKey = title.replace(/\d+/g, '');
              if (!titles[titleKey]) {
                titles[titleKey] = true;
                titleIndices[titleKey] = [];
              }
              const matchResult = title.match(/\d+/);
              if (matchResult && matchResult.length > 0) {
                titleIndices[titleKey].push(parseInt(matchResult[0]));
              }
            };
            console.info("ClariQ Next sorting and re-indexing completed successfully.");
          } catch (error) {
            console.error("🞮 Failed to perform ClariQ Next sorting:", error);
            console.error("🞮 Please report your issue on discord!");
            throw new Error;
          }
        }
        // Continue with rest of original logic using actualMCount
        nSpeakers = 0;
        nSubs = 0;
        for (const titleKey in titleIndices) {
          const indices = titleIndices[titleKey];
          if (indices[0] != Math.min(...indices)) {
            console.error(`🞮 MLP measurement needs to be the first measurement for ${titleKey} channel!`);
            throw new Error;
          }
          if (titleKey === "SWMIX") {
            nSubs = 1;
          }
          else if (titleKey.startsWith("SW")) {
            for (let i = 0; i < titleIndices[titleKey].length; i++) {
              swIdx = String(titleIndices[titleKey][i]);
              if (swIdx.length === 2 && swIdx.endsWith("0")) {
                nSubs++;
              }
            }
          }
          else {
            nSpeakers++;
          }
        }
        Object.freeze(nSpeakers);
        Object.freeze(nSubs);
        nChannels = Object.keys(titles).length;
        Object.freeze(nChannels);
        const rewVersion = await fetch(`http://localhost:4735/version`);
        if (rewVersion.ok) {
          const rew = await rewVersion.json();
          console.infoUpdate(`Integrity checks completed successfully. Running Room EQ Wizard version ${rew.message}`);
        }
        else {
          console.error('🞮 There seems to be a problem with REW installation!');
          throw new Error;
        }
        // only apply if all sanity checks pass
        if (isCirrusLogic) {
          try {
            await addmicCal();
          } catch (error) {
            console.error("🞮 Microphone calibration failed:", error);
            const skipMicCal = confirm("Microphone calibration failed. Continue without it?");
            if (skipMicCal) {
              // Remove MicCal measurement and continue
              const measurements = await fetch_mREW();
              const mCount = Object.keys(measurements).length;
              await postDelete(mCount);
              console.warn("⚠ Continuing without microphone calibration");
            } else {
              throw error;
            }
          }
        }
        const tcResponse = await fetch('http://localhost:4735/eq/house-curve');
        if (tcResponse.ok) {
          const target = await tcResponse.json();
          targetCurvePath = String(target);
          if (target && targetCurvePath) {
            targetCurveName = targetCurvePath.replace(/^.*[\\/]/, '').split(".")[0];
            Object.freeze(targetCurveName);
            Object.freeze(targetCurvePath);
            await disableRoomCurve();
            await customDelay(speedDelay);
            await postSafe(`http://localhost:4735/eq/house-curve`, targetCurvePath, "House curve set");
            await customDelay(speedDelay);
          }
          else {
            targetCurveName = "";
            await enableRoomCurve();
            await customDelay(speedDelay);
          }

          await fetchSafe('target-level', 1, targetLevel, "Target level set")
          const targetCurve = await postNext('Generate target measurement', 1);
          await customDelay(speedDelay);
          const targetCurveIdx = Object.keys(targetCurve.results)[0];
          // targetResponse = await fetchSafe(`frequency-response?smoothing=1%2F48&ppo=96`, targetCurveIdx);
          targetResponse = await fetchSafe("frequency-response?smoothing=1/48&ppo=96", targetCurveIdx);
          await customDelay(speedDelay);

          if (isDebugMode) {
            console.log("=== TARGET CURVE SPL DEBUG ===");
            const targetArray200to2000 = response2array(targetResponse, 200, 2000);
            const targetSPL200to2000 = targetArray200to2000.reduce((acc, val) => acc + val, 0) / targetArray200to2000.length;
            console.log(`Target curve average SPL (200-2000Hz): ${targetSPL200to2000.toFixed(1)}dB`);
            const targetArray30to80 = response2array(targetResponse, 30, 80);
            const targetSPL30to80 = targetArray30to80.reduce((acc, val) => acc + val, 0) / targetArray30to80.length;
            console.log(`Target curve average SPL (30-80Hz): ${targetSPL30to80.toFixed(1)}dB`);
            console.log(`Target level setting: ${targetLevel}dB`);
            console.log("=== END TARGET CURVE DEBUG ===");
          }
          Object.freeze(targetResponse);
          await postDelete(targetCurveIdx);
        }
        else {
          console.error(`🞮 Failed to fetch target curve, please make sure to have started REW API server! HTTP status code: ${tcResponse.status}.`);
          throw new Error;
        }
        const indicesCounts = Object.values(titleIndices).map(indices => indices.length);
        const isIndicesEqual = indicesCounts.every(count => count === indicesCounts[0]);
        if (!isIndicesEqual) {
          const problemG = [];
          for (const [titleKey, indices] of Object.entries(titleIndices)) {
            if (indices.length !== indicesCounts[0]) {
              problemG.push(titleKey);
            }
          }
          if (problemG.some(group => group.startsWith('SW')) && bassMode === "Directional") {
            console.info(`'Directional bass' mode with '${nSubs}' subwoofers detected!`);
          } else {
            console.error('🞮 Speaker names have different numbers of indices.');
            throw new Error();
          }
        }
        logCustomizations();
        return;
      }

      function getDelayHeadroom(startIdx, endIdx) {
        const minM = Math.min(...mSec.slice(startIdx, endIdx + 1));
        const maxM = Math.max(...mSec.slice(startIdx, endIdx + 1));
        const maxDist = DiracEnabled === true ? 18 : 6;
        const limInsec = maxDist / sOs;
        const msecMin = maxM - limInsec;
        const msecMax = minM + limInsec;
        const maxNegative = msecMin * delaymax;
        const maxPositive = msecMax * delaymax;
        if (maxNegative > maxPositive) {
          console.error("🞮 Ran out of delay range!");
          throw new Error;
        }
        return [maxNegative, maxPositive];
      }

      // returns range that "thisDelay" can be shifted by
      function getDelayRangeOf(thisDelay, startIdx, endIdx) {
        const [maxNegative, maxPositive] = getDelayHeadroom(startIdx, endIdx);
        const delayms = thisDelay * delaymax;
        const loDelay = maxNegative - delayms;
        const hiDelay = maxPositive - delayms;
        if (loDelay > hiDelay) {
          console.error("🞮 Ran out of delay range!");
          throw new Error;
        }
        return [loDelay, hiDelay];
      }

      function getDelayRangeOfFinalSub() {
        let [loDelay, hiDelay] = getDelayRangeOf(mSec[nChannels], 1, nSpeakers);
        // directional subwoofer delay(s)
        if (bassMode === "Directional") {
          const loDelaySub = Math.min(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          const hiDelaySub = Math.max(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          [loDelay,] = getDelayRangeOf(loDelaySub, 1, nSpeakers);
          [, hiDelay] = getDelayRangeOf(hiDelaySub, 1, nSpeakers);
        }
        // standard bass relative delay(s)
        else if (subLoDelay != 0 || subHiDelay != 0) {
          [loDelay,] = getDelayRangeOf(mSec[nChannels] + subLoDelay, 1, nSpeakers);
          [, hiDelay] = getDelayRangeOf(mSec[nChannels] + subHiDelay, 1, nSpeakers);
        }
        if (loDelay > hiDelay) {
          console.error("🞮 Ran out of delay range!");
          throw new Error;
        }
        return [loDelay, hiDelay];
      }

      // ORG > updated new should run better later on
      async function groundWorks() {
        let measurements = await fetch_mREW();
        let mCount = Object.keys(measurements).length;
        const micPositions = mCount / (nSpeakers + nSubs);
        if (bassMode === "Directional") {
          console.info(`'Directional bass' mode with '${swChannelCount}' subwoofers detected.`);
        }
        if (bassMode != "Directional" && swChannelCount > 1) {
          bassMode = "Standard";
          console.info(`'Standard bass' mode with '${swChannelCount}' subwoofers detected.`);
        }
        if (bassMode != "Directional" && swChannelCount === 1) {
          bassMode = "Standard";
          console.info(`'Standard bass' mode with '${swChannelCount}' subwoofer detected.`);
        }
        console.log("Optimizing spatial averaging, volume & time alignment...");
        // STEP 1: Initialize Trims using MLP measurements only
        console.info("Initializing trims...");
        let count = 1;
        let title = {};
        for (let i = 1; i <= mCount; i += micPositions) {
          const indices = Array.from({ length: micPositions }, (_, j) => i + j);
          title[count] = measurements[i].title.slice(0, -1) + "o";
          // trim determination using the MLP measurement ONLY (indices[0])
          const mlpIndex = indices[0]; // This is the MLP measurement (C0, FHL0, etc.)
          console.info(`├─ Calculating MLP trim for channel ${count}: ${title[count]} (using MLP measurement index ${mlpIndex} - ${measurements[mlpIndex].title})`);
          if (title[count].startsWith("SW")) {
            customLevel[count] = await getSubTrim(mlpIndex);
          } else {
            customLevel[count] = await getSpeakerTrim(mlpIndex);
          }
          console.log(`├─ MLP trim result for ${title[count]}: ${customLevel[count]}dB`);
          // shift all measurements for this channel based on MLP trim
          for (let j = 0; j < indices.length; j++) {
            await postNext('Add SPL offset', indices[j], { offset: customLevel[count] });
          }
          // attempt to fix android volume bug where measurements are off by multiples of +/-6dB
          if (isCirrusLogic && IsCustomMeasurements == false) {
            await fixVolBug(indices);
          }
          count++;
        }
        console.info("Initialized trims.");
        // STEP 2: Time align speakers
        console.info("Time aligning speakers...");
        const mlpSPIndices = [];
        const mlpSWIndices = [];
        // Build MLP indices arrays based on current data structure

        // RESET SMOOTHNING TO NONE HERE
        // RESET SMOOTHNING TO NONE HERE
        count = 1;
        for (let i = 1; i <= mCount; i += micPositions) {
          await postNext('Smooth', i, { smoothing: "none" });
          await customDelay(speedDelay / 3);
          if (title[count].startsWith("SW")) {
            mlpSWIndices.push(i); // MLP subwoofer measurement
          } else {
            mlpSPIndices.push(i); // MLP speaker measurement  
          }
          mSec[count] = 0; // initialize
          count++;
        }
        console.info(`├─ MLP Speaker indices: [${mlpSPIndices.join(', ')}]`);
        console.info(`├─ MLP Subwoofer indices: [${mlpSWIndices.join(', ')}]`);
        // calculate the average IR start delay for normalization
        measurements = await fetch_mREW();
        let IRStartDelay = 0;
        for (let i = 0; i < mlpSPIndices.length; i++) {
          IRStartDelay += measurements[mlpSPIndices[i]].timeOfIRStartSeconds;
        }
        IRStartDelay /= nSpeakers;
        console.info(`├─ Average IR start delay: ${IRStartDelay.toFixed(6)}s`);
        // time align & normalize speaker delays
        await postNext('Time align', mlpSPIndices);
        measurements = await fetch_mREW();
        for (let i = 0; i < mlpSPIndices.length; i++) {
          mSec[i + 1] = IRStartDelay - measurements[mlpSPIndices[i]].cumulativeIRShiftSeconds;
          console.info(`├─ Speaker ${i + 1} delay: ${mSec[i + 1].toFixed(6)}s`);
        }
        // shift subwoofer IRs by the same offset used to normalize speaker delays
        // note: this ensures relative delay of SW compared to speakers stay intact
        for (let i = 0; i < mlpSWIndices.length; i++) {
          await postNext('Offset t=0', mlpSWIndices[i], { offset: IRStartDelay, unit: "seconds" });
          console.info(`├─ Applied ${IRStartDelay.toFixed(6)}s offset to subwoofer MLP measurement ${mlpSWIndices[i]}`);
        }
        console.info("Time aligned speakers.");
        // STEP 3: Initialize Subwoofers
        if (noSub) { return; }
        if (bassMode === "Directional") {
          console.warn("⚠ Directional bass detected - deferring conversion until after ART optimization... ⚠");
          console.info("This allows ART to optimize each subwoofer independently before combining.");
          // DON'T convert yet - let ART optimize individual subs first
          // Conversion will happen in convertDirectionalIfNeeded() after ART runs
          // But still need to do the median alignment that was in directional2standard
          const loSWDelay = Math.min(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          const hiSWDelay = Math.max(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
          const medianSWDelay = (loSWDelay + hiSWDelay) / 2;

          // Apply median offset to all subs for initial alignment
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            const firstMeasurement = (i - nSpeakers - 1) * micPositions + (nSpeakers * micPositions) + 1;
            for (let j = 0; j < micPositions; j++) {
              await postNext('Offset t=0', firstMeasurement + j, { offset: -medianSWDelay, unit: "seconds" });
            }
            mSec[i] -= medianSWDelay;
          }
          console.info(`Applied median delay offset of ${medianSWDelay.toFixed(6)}s to ${nSubs} subs for preliminary alignment`);

        } else if (subLoDelay != 0 || subHiDelay != 0) {
          // normalize standard bass subwoofer median IR to t=0
          const IROffset = (subLoDelay + subHiDelay) / 2;
          // Find the subwoofer MLP index (equivalent to cmdIdMeasurements[commandId[nChannels]][0])
          let stdSubMLPIdx = null;
          count = 1;
          for (let i = 1; i <= mCount; i += micPositions) {
            if (title[count].startsWith("SW")) {
              stdSubMLPIdx = i; // This is the MLP measurement for the subwoofer
              break;
            }
            count++;
          }
          if (stdSubMLPIdx) {
            await postNext('Offset t=0', stdSubMLPIdx, { offset: IROffset, unit: "seconds" });
            mSec[nChannels] -= IROffset;
            console.info(`├─ Applied ${IROffset.toFixed(6)}s IROffset to subwoofer MLP measurement ${stdSubMLPIdx}`);
          }
        }
        // align combined subwoofer median IR to median IR of speakers
        // note: this ensures min/max delays are negative/positive, otherwise REW crashes
        const loSPDelay = Math.min(...mSec.slice(1, nSpeakers + 1));
        const hiSPDelay = Math.max(...mSec.slice(1, nSpeakers + 1));
        const medianSPDelay = (loSPDelay + hiSPDelay) / 2;
        console.info(`├─ Speaker delay range: ${loSPDelay.toFixed(6)}s to ${hiSPDelay.toFixed(6)}s (median: ${medianSPDelay.toFixed(6)}s)`);
        // Find subwoofer MLP index and apply median speaker delay offset (equivalent to SWIndices[0])
        count = 1;
        for (let i = 1; i <= mCount; i += micPositions) {
          if (title[count].startsWith("SW")) {
            await postNext('Offset t=0', i, { offset: -medianSPDelay, unit: "seconds" });
            console.info(`├─ Applied ${(-medianSPDelay).toFixed(6)}s offset to subwoofer MLP measurement ${i}`);
            // Check response variation if multiple microphone positions (equivalent to SWIndices.length > 1)
            if (micPositions > 1 && typeof calculateMaxDeltaOfResponses !== 'undefined') {
              const SWIndices = Array.from({ length: micPositions }, (_, j) => i + j);
              const SWMaxDelta = await calculateMaxDeltaOfResponses(SWIndices, 30, 80);
              console.log(`├─ ${title[count]} response variation between ${SWIndices.length} microphone positions: ±${(SWMaxDelta / 2).toFixed(2)}dB`);
            }
            break;
          }
          count++;
        }
        // Update subwoofer delays
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          mSec[i] += medianSPDelay;
        }
        // STEP 4: Spatial Average
        console.info("Starting spatial averaging...");
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        const originalMCount = mCount; // Store original count
        // Use the original micPositions calculation - it should still be correct
        const currentChannels = nSpeakers + nSubs;
        console.info(`├─ Total measurements: ${mCount}, Current channels: ${currentChannels}`);
        console.info(`├─ Using original mic positions: ${micPositions}`);
        console.info(`├─ Title array contents: [${Object.keys(title).map(k => `${k}:"${title[k]}"`).join(', ')}]`);
        count = 1;
        for (let i = 1; i <= originalMCount; i += micPositions) {
          // No smoothing
          await postNext('Smooth', i, { smoothing: "none" });
          await customDelay(speedDelay / 3);
          // Safety check: don't process beyond available titles
          if (count > currentChannels || !title[count]) {
            console.warn(`├─ Stopping spatial averaging - no more channels to process (count: ${count}, max: ${currentChannels}) ⚠`);
            break;
          }
          console.infoUpdate(`🔊 Computing optimal spatial averaging configuration for channel ${count}/${currentChannels} (${title[count]})`);
          const indices = Array.from({ length: micPositions }, (_, j) => i + j);
          console.info(`├─ Processing microphone positions: indices [${indices.join(', ')}]`)
          if (micPositions > 1) {
            console.info(`├─ Cross-correlating ${micPositions} microphone positions...`);
            await postNext('Cross corr align', indices);
            console.log(`├─ Cross-correlation alignment completed`);
          }
          let newMeasurementResult;
          if (micPositions === 1) {
            console.info(`├─ Single microphone position - copying measurement`);
            newMeasurementResult = await postSafe(`${baseUrl}/${i}/command`, { command: "Response copy" }, "Completed");
          } else {
            console.info(`├─ Averaging ${micPositions} microphone positions...`);
            newMeasurementResult = await postNext('Magn plus phase average', indices);
            console.log(`├─ Spatial averaging completed for ${micPositions} positions`);
          }
          // Get the actual index of the newly created measurement
          let newMeasurementIdx;
          if (newMeasurementResult && newMeasurementResult.results) {
            // Extract the new measurement index from the result
            const resultKeys = Object.keys(newMeasurementResult.results);
            newMeasurementIdx = parseInt(resultKeys[0]);
            console.info(`├─ Got measurement index ${newMeasurementIdx} from operation result`);
          } else {
            // Fallback: refresh measurements and find the newest one
            const freshMeasurements = await fetch_mREW();
            const freshMCount = Object.keys(freshMeasurements).length;
            newMeasurementIdx = freshMCount; // Newest measurement should be the last index
            console.info(`├─ Using fallback measurement index ${newMeasurementIdx} (latest measurement)`);
          }
          console.info(`├─ Created averaged measurement: Index ${newMeasurementIdx} - target title: "${title[count]}"`);
          // Update the measurement title
          await fetch_mREW(newMeasurementIdx, 'PUT', { title: title[count] });
          console.info(`├─ Calculating trim for averaged result - Index ${newMeasurementIdx}`);
          // o vs target curve
          const volAdjust = title[count].startsWith("SW") ? await getSubTrim(newMeasurementIdx) : await getSpeakerTrim(newMeasurementIdx);
          console.log(`├─ Averaged trim result: ${volAdjust}dB`);
          await postNext('Add SPL offset', newMeasurementIdx, { offset: volAdjust });
          console.info(`└─ Applied ${volAdjust}dB SPL offset to averaged measurement`);
          console.info(`─────────────────────────────────────────────────────────`);
          // go to next channel
          count++;
        }
        console.infoUpdate("Deleting processed measurements...");
        // Get current measurement count for cleanup
        measurements = await fetch_mREW();
        const finalMCount = Object.keys(measurements).length;
        const numAveragedMeasurements = nSpeakers + nSubs;
        // Delete original measurements (keep the averaged ones)
        for (let i = originalMCount; i >= 1; i--) {
          await postDelete(i);
        }
        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          commandId[i] = title[i].slice(0, -1);
        }
        // Normalize Trim levels targetLevel vs 75dB
        normalizeTrimLevels();
        console.info("Completed averaging, volume & time alignment!");
        // Final subwoofer processing
        if (noSub) { return; }
        const [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        console.info(`Available bass system volume adjustment range → { ${subLoTrim}dB : ${subHiTrim}dB }`);
        console.info(`Total subwoofer 'delay headroom' available → ${(hiDelay - loDelay).toFixed(2)}ms`);
        const dynamicBassFilldB = await getDynamicBassFill(nChannels);
        if (dynamicBassFilldB != 0) {
          console.warn(`⚠ Adding ${dynamicBassFilldB}dB dynamic bass fill to compensate for dips! ⚠`);
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += dynamicBassFilldB;
            console.info(`${commandId[i].padStart(3, ".")} - shifted: ${customLevel[i] - dynamicBassFilldB}dB → ${customLevel[i]}dB`);
          }
          await postNext('Add SPL offset', nChannels, { offset: dynamicBassFilldB });
        }
        // Store directional bass state for ART optimization
        window.hasDirectionalBass = (bassMode === "Directional" && nSubs > 1);
        window.preCombinedSubCount = nSubs;
        // extra mSec logging [Debug]
        //// logState('groundWorks()', 'AFTER - Pure Acoustic Delays Set', false);
      }

      async function calculateMaxDeltaOfResponses(indices, start, end) {
        if (indices.length <= 1) { return 0; }
        const responseArrays = [];
        for (let i = 0; i < indices.length; i++) {
          const freqResponse = await fetchSafe("frequency-response?smoothing=1/48&ppo=96", indices[i]);
          const freqArray = response2array(freqResponse, start, end);
          responseArrays.push(freqArray);
        }
        // find the max difference in SPL across the responses
        let maxDelta = 0;
        for (let i = 0; i < responseArrays[0].length; i++) {
          const points = responseArrays.map(row => row[i]);
          const minVal = Math.min(...points);
          const maxVal = Math.max(...points);
          maxDelta = Math.max(maxVal - minVal, maxDelta);
        }
        return maxDelta;
      }

      async function getALOffset(idx, isSub) {
        const fltResponse = await fetchSafe("frequency-response?smoothing=1/3&ppo=96", idx);
        // let lowFreq, highFreq;
        if (isRP22mode) {
          lowFreq = 20; highFreq = 120;
        } else if (isDolbymode) {
          lowFreq = 31.5; highFreq = 120;
        } else if (isTHXmode) {
          lowFreq = 20; highFreq = 120;
        } else if (isIMAXmode) {
          lowFreq = 20; highFreq = 70;
        } else {
          lowFreq = 30; highFreq = 80;
        }
        const fltArray = isSub ? await response2array(fltResponse, lowFreq, highFreq) : await response2array(fltResponse, 500, 2000);
        const offset = fltArray.reduce((acc, val) => acc + val, 0) / fltArray.length;
        return offset;
      }

      // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
      // PROPRIETARY FILTER GENERATION AND CHECKING ! 
      // CAN NOT BE USED WITHOUT EXPLICIT PERMISSION OF NVEXX !
      // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
      /* ============== */
      /* SBIR DETECTION */
      // Before calling generateFilters(), get the custom config
      AdvancedFiltersType = document.getElementById('script_af_type').value;
      let customFiltersConfig = null;

      if (AdvancedFiltersType === 'CUSTOMadvanced') {
        customFiltersConfig = getCustomFilters();
        console.log("Custom filters config:", customFiltersConfig); // Debug log
      }

      async function generateFilters(customFiltersConfig = null) {
        console.log(`Generating min. phase EQ filters...`);
        // ===== FILTER CONFIGURATION =====
        // Set these variables to enable different filter types:
        // Hearing loss compensation: "research", "moderate", "severe", "original", or null
        // const hearingLossType = "research";
        // Gaming EQ optimization: "competitive", "immersive", "voice", "balanced", or null  
        // - "competitive": Optimized for footsteps, gunshots, tactical audio (FPS games)
        // - "immersive": Cinematic experience with enhanced atmosphere (RPG/Adventure) 
        // - "voice": Clear voice chat communication with game audio
        // - "balanced": All-purpose gaming enhancement
        // const gamingEQType = "competitive";
        // Dialog enhancement: controlled by existing RP22DialogEnhancementFilter boolean
        // Disabled all HP as the filters get messed up!
        // Smart filter creation helper - handles REW API parameter requirements
        const createREWFilter = (index, type, frequency, gaindB = 0, q = 1.0, isAuto = false) => ({
          index,
          type,
          enabled: true,
          frequency,
          ...(["PK", "HS", "LS", "HS Q", "LS Q"].includes(type) && { gaindB }), // Only PK, HS, LS, HS Q, LS Q - have gaindB
          ...(["PK", "HS Q", "LS Q"].includes(type) && { q }), // Include q (but not isAuto) for PK ,HS Q, LS Q versions
          ...(type === "PK" && { isAuto }) // Only PK has q and isAuto
        });

        const getAdvancedFilters = (type) => {
          switch (type) {
            case "CUSTOMadvanced":
              // Read custom filters directly from the global array
              let customFilters = [];
              let customDescription = "Custom User-Defined EQ";

              if (typeof customFiltersArray !== 'undefined' && customFiltersArray.length > 0) {
                customFilters = customFiltersArray;
                const descInput = document.getElementById('customFilterDescription');
                if (descInput) {
                  customDescription = descInput.value || customDescription;
                }
              } else if (typeof getCustomFilters === 'function') {
                const config = getCustomFilters();
                customFilters = config.filters || [];
                customDescription = config.description || customDescription;
              }

              // Validate
              if (!customFilters || customFilters.length === 0) {
                console.warn("⚠ Custom filter type selected but no custom filters defined!");
                return null;
              }

              if (customFilters.length > 20) {
                console.error(`🞮 Custom filters exceed maximum of 20 filters (found ${customFilters.length})`);
                return null;
              }
              console.log("✓ Loading custom filters:", customFilters);
              // CRITICAL: Start from index 20 and count DOWN (reverse order)
              const startIndex = 20;
              const rewFilters = customFilters.map((filter, idx) => {
                const filterIndex = startIndex - idx; // 20, 19, 18, 17, 16...
                console.log(`Creating custom filter at index ${filterIndex}:`, filter);
                return createREWFilter(
                  filterIndex,
                  filter.type,
                  filter.frequency,
                  filter.gaindB || 0,
                  filter.q || 1.0
                );
              });
              // Sort filters by index (descending) to apply from high to low
              rewFilters.sort((a, b) => b.index - a.index);
              // Generate target descriptions
              const targets = customFilters.map((filter) => {
                let desc = `- ${filter.frequency}Hz: `;
                if (filter.type === "PK") {
                  desc += `${filter.gaindB >= 0 ? '+' : ''}${filter.gaindB}dB (Q=${filter.q})`;
                } else if (filter.type === "HS" || filter.type === "LS") {
                  desc += `${filter.gaindB >= 0 ? '+' : ''}${filter.gaindB}dB ${filter.type} shelf`;
                }
                return desc;
              });
              return {
                filters: rewFilters,
                description: customDescription,
                targets: targets
              };

            case "DIALOGadvanced":
              return {
                filters: [
                  createREWFilter(16, "PK", 1600, 2.5, 1.2),   // Peak speech intelligibility
                  createREWFilter(17, "PK", 3000, 3.0, 1.5),   // Critical consonant clarity
                  createREWFilter(18, "PK", 800, 1.5, 0.8),    // Speech warmth and body
                  createREWFilter(19, "PK", 4500, 2.0, 1.8),   // Upper consonant definition
                  createREWFilter(20, "HS", 5000, -1.0)        // Sibilance control
                ],
                description: "Advanced Dialog Enhancement CEDIA RP22",
                targets: [
                  "- 800Hz: +1.5dB (Speech warmth and body)",
                  "- 1.6kHz: +2.5dB (Peak speech intelligibility",
                  "- 3kHz: +3.0dB (Critical consonant clarity)",
                  "- 4.5kHz: +2.0dB (Upper consonant definition)",
                  "- 5kHz+: -1.0dB (Sibilance control)"
                ]
              };
            case "HLOSSresearch":
              return {
                filters: [
                  createREWFilter(11, "PK", 2000, 2.0, 1.0),   // Presbycusis difficulty onset
                  createREWFilter(12, "PK", 4000, 4.0, 1.2),   // Critical consonant clarity
                  createREWFilter(13, "PK", 6000, 6.0, 1.5),   // Major presbycusis loss frequency  
                  createREWFilter(14, "HS", 8000, 4.0)         // High-frequency presbycusis
                ],
                description: "Research-Based Hearing Loss Compensation",
                targets: [
                  "- 2kHz: +2.0dB (Presbycusis difficulty onset)",
                  "- 4kHz: +4.0dB (Critical consonant clarity)",
                  "- 6kHz: +6.0dB (Major presbycusis loss frequency)",
                  "- 8kHz+: +4.0dB (High-frequency compensation)"
                ]
              };
            case "HLOSSmoderate":
              return {
                filters: [
                  // createREWFilter(11, "HP", 80),            // Remove low-frequency masking
                  createREWFilter(12, "PK", 2500, 3.0, 1.0),   // Speech intelligibility range
                  createREWFilter(13, "PK", 4000, 5.0, 1.3),   // 4kHz notch compensation
                  createREWFilter(14, "HS", 6000, 3.0)         // General high-frequency lift
                ],
                description: "Moderate Hearing Loss Compensation",
                targets: [
                  // "- 80Hz: High-pass filter (remove masking)",
                  "- 2.5kHz: +3.0dB (Speech intelligibility)",
                  "- 4kHz: +5.0dB (Notch compensation)",
                  "- 6kHz+: +3.0dB (High-frequency lift)"
                ]
              };
            case "HLOSSsevere":
              return {
                filters: [
                  // createREWFilter(11, "HP", 100),           // Aggressive low-cut
                  createREWFilter(12, "PK", 2000, 6.0, 1.0),   // Strong speech boost
                  createREWFilter(13, "PK", 4000, 10.0, 1.5),  // Maximum 4kHz compensation
                  createREWFilter(14, "PK", 6000, 12.0, 1.5),  // Strong 6kHz boost
                  createREWFilter(15, "HS", 8000, 8.0)         // Aggressive high-frequency
                ],
                description: "Severe Hearing Loss Compensation",
                targets: [
                  // "- 100Hz: High-pass filter (aggressive low-cut)",
                  "- 2kHz: +6.0dB (Strong speech boost)",
                  "- 4kHz: +10.0dB (Maximum compensation)",
                  "- 6kHz: +12.0dB (Strong high-frequency boost)",
                  "- 8kHz+: +8.0dB (Aggressive compensation)"
                ]
              };
            case "HLOSSoriginal":
              return {
                filters: [
                  createREWFilter(11, "PK", 1000, 1.5, 0.9),   // Speech body and presence
                  createREWFilter(12, "PK", 2500, 3.0, 1.2),   // Consonant intelligibility
                  createREWFilter(13, "PK", 4000, 4.0, 1.5),   // High consonant clarity boost
                  createREWFilter(14, "PK", 6000, 3.0, 1.8),   // Upper speech and sibilant detail
                  createREWFilter(15, "HS", 8000, 2.0)         // High frequency audibility
                ],
                description: "Original 0.0.3 Hearing Loss Compensation",
                targets: [
                  "- 1kHz: +1.5dB (Speech body and presence)",
                  "- 2.5kHz: +3.0dB (Consonant intelligibility)",
                  "- 4kHz: +4.0dB (High consonant clarity boost)",
                  "- 6kHz: +3.0dB (Upper speech and sibilant detail)",
                  "- 8kHz+: +2.0dB (High frequency audibility)"
                ]
              };
            case "GAMINGcompetitive":
              return {
                filters: [
                  // createREWFilter(5, "HP", 60),            // Remove low-frequency rumble
                  createREWFilter(6, "PK", 400, -2.0, 1.0),   // Reduce muddiness that masks footsteps
                  createREWFilter(7, "PK", 2000, 3.0, 1.2),   // Boost footstep frequency range
                  createREWFilter(8, "PK", 4000, 4.0, 1.5),   // Critical footstep/gunshot clarity
                  createREWFilter(9, "PK", 8000, 3.0, 1.8),   // High-frequency tactical sounds
                  createREWFilter(10, "HS", 10000, 2.0)       // Enhance detail/positioning cues
                ],
                description: "Competitive Gaming EQ (Footsteps & Tactical Audio)",
                targets: [
                  // "- 60Hz: High-pass (remove rumble that masks footsteps)",
                  "- 400Hz: -2.0dB (reduce muddiness)",
                  "- 2kHz: +3.0dB (footstep detection range)",
                  "- 4kHz: +4.0dB (critical footsteps & gunshots)",
                  "- 8kHz: +3.0dB (tactical audio positioning)",
                  "- 10kHz+: +2.0dB (detail & directional cues)"
                ]
              };
            case "GAMINGimmersive":
              return {
                filters: [
                  createREWFilter(5, "PK", 80, 2.0, 0.8),     // Enhanced bass for explosions/atmosphere
                  createREWFilter(6, "PK", 200, 3.0, 1.0),    // Low-mid warmth and impact
                  createREWFilter(7, "PK", 1000, 1.0, 0.9),   // Balanced mid-range
                  createREWFilter(8, "PK", 3000, 2.0, 1.2),   // Speech and effects clarity
                  createREWFilter(9, "PK", 6000, 1.5, 1.5),   // Detail without harshness
                  createREWFilter(10, "HS", 8000, 1.0)        // Subtle air and openness
                ],
                description: "Immersive Gaming EQ (Cinematic Experience)",
                targets: [
                  "- 80Hz: +2.0dB (bass impact for explosions)",
                  "- 200Hz: +3.0dB (warmth and atmosphere)",
                  "- 1kHz: +1.0dB (balanced mid-range)",
                  "- 3kHz: +2.0dB (speech and effects clarity)",
                  "- 6kHz: +1.5dB (detail without fatigue)",
                  "- 8kHz+: +1.0dB (subtle air and space)"
                ]
              };
            case "GAMINGvoice":
              return {
                filters: [
                  // createREWFilter(5, "HP", 100),           // Remove low-frequency noise
                  createREWFilter(6, "PK", 300, -1.0, 1.0),   // Reduce boom in voice
                  createREWFilter(7, "PK", 1500, 3.0, 1.0),   // Core voice intelligibility
                  createREWFilter(8, "PK", 3000, 4.0, 1.5),   // Voice clarity and consonants
                  createREWFilter(9, "PK", 5000, 2.0, 2.0),   // Voice presence without sibilance
                  createREWFilter(10, "HS", 8000, -1.0)       // Reduce harshness
                ],
                description: "Voice Chat Gaming EQ (Clear Communication)",
                targets: [
                  // "- 100Hz: High-pass (remove voice noise)",
                  "- 300Hz: -1.0dB (reduce voice boom)",
                  "- 1.5kHz: +3.0dB (core voice intelligibility)",
                  "- 3kHz: +4.0dB (voice clarity & consonants)",
                  "- 5kHz: +2.0dB (presence without sibilance)",
                  "- 8kHz+: -1.0dB (reduce harshness)"
                ]
              };
            case "GAMINGbalanced":
              return {
                filters: [
                  // createREWFilter(5, "HP", 40),            // Gentle low-cut
                  createREWFilter(6, "PK", 150, 1.0, 0.8),    // Subtle bass enhancement
                  createREWFilter(7, "PK", 1000, 1.5, 1.0),   // Mid-range presence
                  createREWFilter(8, "PK", 3000, 2.0, 1.3),   // Speech/effects balance
                  createREWFilter(9, "PK", 6000, 1.5, 1.5),   // Detail and clarity
                  createREWFilter(10, "HS", 10000, 1.0)       // Subtle high-end extension
                ],
                description: "Balanced Gaming EQ (All-Purpose)",
                targets: [
                  // "- 40Hz: High-pass (gentle low-cut)",
                  "- 150Hz: +1.0dB (subtle bass enhancement)",
                  "- 1kHz: +1.5dB (mid-range presence)",
                  "- 3kHz: +2.0dB (speech & effects balance)",
                  "- 6kHz: +1.5dB (detail and clarity)",
                  "- 10kHz+: +1.0dB (subtle high-end)"
                ]
              };
            default:
              return null;
          }
        };

        for (let i = 1; i <= nChannels; i++) {
          console.info(`${commandId[i].padStart(3, ".")} - equalizing channel...`);
          const isSub = commandId[i].startsWith("SW");
          let rawOffset = isSub ? await getTCTrim(i, m3dBPoints[i][0], m3dBPoints[i][1]) : await getTCTrim(i, m3dBPoints[i][0], 2000);
          // clamp boost/cut to ±3 dB (adjust if you want tighter)
          const tcLevelOffset = Math.max(-10, Math.min(3, rawOffset));
          await fetchSafe('target-level', i, targetLevel - tcLevelOffset);
          await postNext('Smooth', i, { smoothing: "Var" });
          await postSafe(`${baseUrl}/${i}/target-settings`, {
            shape: isSub ? "Subwoofer" : "Full range",
            lowFreqCutoffHz: (isSub && m3dBPoints[i][0] === 10) ? 0 : m3dBPoints[i][0],
            lowFreqSlopedBPerOctave: 48,
            bassManagementCutoffHz: (isSub && m3dBPoints[i][1] === 320) ? 20000 : m3dBPoints[i][1],
            bassManagementSlopedBPerOctave: 48
          }, "Update processed");

          await postSafe(`http://localhost:4735/eq/match-target-settings`, {
            startFrequency: m3dBPoints[i][0],
            endFrequency: m3dBPoints[i][1],
            individualMaxBoostdB: isSub ? 3 : 3,
            overallMaxBoostdB: isSub ? 0 : 0,
            flatnessTargetdB: 1,
            allowNarrowFiltersBelow200Hz: true,
            varyQAbove200Hz: false,
            allowLowShelf: isSub,
            lowShelfMin: -6,
            lowShelfMax: 6,
            allowHighShelf: !isSub,
            highShelfMin: -6,
            highShelfMax: 6
          }, "Update processed");

          try {
            await postNext('Match target', i);
          }
          catch (error) {
            console.debug(`${commandId[i]} could not be equalized!`);
          }
          // SANITY CHECK: Ensure no filters exceed limits AND clear reserved filter slots
          try {
            let filters = await getFilters(i);
            // Check for reserved filter slot usage (21=HP, 22=LP)
            const reservedFilters = filters.filter(f =>
              (f.index === 21 || f.index === 22) && f.type !== "None"
            );
            if (reservedFilters.length > 0) {
              console.warn(`${commandId[i]} - Found ${reservedFilters.length} reserved filter slot(s) in use: ⚠`);
              const filtersToApply = [];
              let usedSlot20 = false;
              let usedSlot19 = false;
              // Changed from forEach to for...of
              for (const f of reservedFilters) {
                console.warn(`├─ Filter ${f.index}: ${f.type} at ${f.frequency?.toFixed(2) || 'N/A'}Hz - CLEARING (reserved slot) ⚠`);
                // Convert High Pass (Filter 21) to TWO Parametric filters
                if (f.type === "High pass" && f.frequency) {
                  const targetSlot1 = 20;
                  const targetSlot2 = 19;
                  usedSlot20 = true;
                  usedSlot19 = true;
                  const hpFreq = f.frequency;
                  // Problem is BELOW the HP frequency
                  const checkRangeStart = Math.max(20, hpFreq * 0.3);
                  const checkRangeEnd = hpFreq * 0.9;
                  console.warn(`├─ HP at ${hpFreq.toFixed(0)}Hz detected - analyzing bass region BELOW cutoff`);
                  const currentResponse = await fetchSafe("frequency-response?smoothing=Var&ppo=96", i);
                  const rpArray = response2array(currentResponse, checkRangeStart, checkRangeEnd);
                  const tcArray = response2array(targetResponse, checkRangeStart, checkRangeEnd);
                  if (!rpArray || !tcArray || rpArray.length === 0 || tcArray.length === 0) {
                    console.warn(`├─ Could not analyze deviation - using default PK filters`);
                    filtersToApply.push(createREWFilter(targetSlot1, "PK", hpFreq / 1.5, -6, 2.5));
                    filtersToApply.push(createREWFilter(targetSlot2, "PK", hpFreq / 2.5, -6, 2.5));
                  } else {
                    // Find the TWO worst frequencies
                    const topDeviations = findTopDeviations(rpArray, tcArray, checkRangeStart, checkRangeEnd, 2);
                    const { rms, mean } = getDeviationStats(rpArray, tcArray);
                    console.log(`📊 Analysis of ${checkRangeStart.toFixed(0)}Hz-${checkRangeEnd.toFixed(0)}Hz region:`);
                    console.log(`   ├─ Average deviation: ${mean.toFixed(2)}dB (RMS: ${rms.toFixed(2)}dB)`);
                    if (topDeviations.length >= 2) {
                      console.log(`   ├─ Worst peak: ${topDeviations[0].deviation.toFixed(2)}dB at ${topDeviations[0].frequency.toFixed(0)}Hz`);
                      console.log(`   └─ 2nd worst peak: ${topDeviations[1].deviation.toFixed(2)}dB at ${topDeviations[1].frequency.toFixed(0)}Hz`);
                      const pkGain1 = Math.max(-10, Math.min(-3, -topDeviations[0].deviation));
                      const pkGain2 = Math.max(-10, Math.min(-3, -topDeviations[1].deviation));
                      const pkQ = 2.5;
                      console.warn(`├─ Converting HP at ${hpFreq.toFixed(0)}Hz to TWO Parametric filters:`);
                      console.warn(`   ├─ Slot ${targetSlot1}: ${topDeviations[0].frequency.toFixed(0)}Hz, ${pkGain1.toFixed(1)}dB, Q=${pkQ}`);
                      console.warn(`   └─ Slot ${targetSlot2}: ${topDeviations[1].frequency.toFixed(0)}Hz, ${pkGain2.toFixed(1)}dB, Q=${pkQ}`);
                      filtersToApply.push(createREWFilter(targetSlot1, "PK", topDeviations[0].frequency, pkGain1, pkQ));
                      filtersToApply.push(createREWFilter(targetSlot2, "PK", topDeviations[1].frequency, pkGain2, pkQ));
                    } else if (topDeviations.length === 1) {
                      // Only one significant peak found
                      console.log(`   └─ Peak deviation: ${topDeviations[0].deviation.toFixed(2)}dB at ${topDeviations[0].frequency.toFixed(0)}Hz`);
                      const pkGain = Math.max(-10, Math.min(-3, -topDeviations[0].deviation));
                      const pkQ = 2.5;
                      console.warn(`├─ Converting HP at ${hpFreq.toFixed(0)}Hz to Parametric at slot ${targetSlot1}`);
                      console.warn(`   └─ Targeting ${topDeviations[0].frequency.toFixed(0)}Hz: ${pkGain.toFixed(1)}dB, Q=${pkQ}`);
                      filtersToApply.push(createREWFilter(targetSlot1, "PK", topDeviations[0].frequency, pkGain, pkQ));
                    }
                  }
                }

                // Convert Low Pass (Filter 22) to TWO Parametric filters
                if (f.type === "Low pass" && f.frequency) {
                  const targetSlot1 = 19;
                  const targetSlot2 = 18;
                  usedSlot19 = true;
                  const lpFreq = f.frequency;
                  // Problem is ABOVE the LP frequency
                  const checkRangeStart = lpFreq * 1.1;
                  const checkRangeEnd = Math.min(20000, lpFreq * 3);
                  console.warn(`├─ LP at ${lpFreq.toFixed(0)}Hz detected - analyzing treble region ABOVE cutoff`);
                  const currentResponse = await fetchSafe("frequency-response?smoothing=Var&ppo=96", i);
                  const rpArray = response2array(currentResponse, checkRangeStart, checkRangeEnd);
                  const tcArray = response2array(targetResponse, checkRangeStart, checkRangeEnd);
                  if (!rpArray || !tcArray || rpArray.length === 0 || tcArray.length === 0) {
                    console.warn(`├─ Could not analyze deviation - using default PK filters`);
                    filtersToApply.push(createREWFilter(targetSlot1, "PK", lpFreq * 1.5, -6, 2.5));
                    filtersToApply.push(createREWFilter(targetSlot2, "PK", lpFreq * 2.0, -6, 2.5));
                  } else {
                    // Find the TWO worst frequencies
                    const topDeviations = findTopDeviations(rpArray, tcArray, checkRangeStart, checkRangeEnd, 2);
                    const { rms, mean } = getDeviationStats(rpArray, tcArray);
                    console.log(`📊 Analysis of ${checkRangeStart.toFixed(0)}Hz-${checkRangeEnd.toFixed(0)}Hz region:`);
                    console.log(`   ├─ Average deviation: ${mean.toFixed(2)}dB (RMS: ${rms.toFixed(2)}dB)`);
                    if (topDeviations.length >= 2) {
                      console.log(`   ├─ Worst peak: ${topDeviations[0].deviation.toFixed(2)}dB at ${topDeviations[0].frequency.toFixed(0)}Hz`);
                      console.log(`   └─ 2nd worst peak: ${topDeviations[1].deviation.toFixed(2)}dB at ${topDeviations[1].frequency.toFixed(0)}Hz`);
                      const pkGain1 = Math.max(-10, Math.min(-3, -topDeviations[0].deviation));
                      const pkGain2 = Math.max(-10, Math.min(-3, -topDeviations[1].deviation));
                      const pkQ = 2.5;
                      console.warn(`├─ Converting LP at ${lpFreq.toFixed(0)}Hz to TWO Parametric filters:`);
                      console.warn(`   ├─ Slot ${targetSlot1}: ${topDeviations[0].frequency.toFixed(0)}Hz, ${pkGain1.toFixed(1)}dB, Q=${pkQ}`);
                      console.warn(`   └─ Slot ${targetSlot2}: ${topDeviations[1].frequency.toFixed(0)}Hz, ${pkGain2.toFixed(1)}dB, Q=${pkQ}`);
                      filtersToApply.push(createREWFilter(targetSlot1, "PK", topDeviations[0].frequency, pkGain1, pkQ));
                      filtersToApply.push(createREWFilter(targetSlot2, "PK", topDeviations[1].frequency, pkGain2, pkQ));
                    } else if (topDeviations.length === 1) {
                      // Only one significant peak found
                      console.log(`   └─ Peak deviation: ${topDeviations[0].deviation.toFixed(2)}dB at ${topDeviations[0].frequency.toFixed(0)}Hz`);
                      const pkGain = Math.max(-10, Math.min(-3, -topDeviations[0].deviation));
                      const pkQ = 2.5;
                      console.warn(`├─ Converting LP at ${lpFreq.toFixed(0)}Hz to Parametric at slot ${targetSlot1}`);
                      console.warn(`   └─ Targeting ${topDeviations[0].frequency.toFixed(0)}Hz: ${pkGain.toFixed(1)}dB, Q=${pkQ}`);
                      filtersToApply.push(createREWFilter(targetSlot1, "PK", topDeviations[0].frequency, pkGain, pkQ));
                    }
                  }
                }
                // Clear the reserved slot
                filtersToApply.push({
                  index: f.index,
                  type: "None",
                  enabled: false
                });
              }
              // Apply all filter changes at once
              await postSafe(
                `${baseUrl}/${i}/filters`,
                { filters: filtersToApply },
                "Filters set"
              );
              await customDelay(speedDelay / 2);
              // Re-fetch filters after conversion
              filters = await getFilters(i);
              console.info(`✓ Re-fetched filters after conversion`);
            }
            // Run standard violation checks
            const violations = sanityCheck(filters);
            if (violations) {
              const boostViolations = violations.filter(v => v.currentGain > 3).length;
              const cutViolations = violations.filter(v => v.currentGain < -10).length;
              if (boostViolations && cutViolations) {
                console.warn(`⚠ ${commandId[i]} - Fixed ${boostViolations} boost and ${cutViolations} cut filter violations`);
              } else if (boostViolations) {
                console.warn(`⚠ ${commandId[i]} - Fixed ${boostViolations} filter(s) exceeding +3dB boost limit`);
              } else {
                console.warn(`⚠ ${commandId[i]} - Fixed ${cutViolations} filter(s) exceeding -10dB cut limit`);
              }
              await updateFilters(i, violations);
            }
            // SBIR check
            await checkAndDisableSBIRFilters(i, filters);
          }
          catch (error) {
            console.debug(`${commandId[i]} - Sanity check failed:`, error);
          }

          // Apply Advanced Filters (if enabled, has a type other than null and is not subwoofer) 
          if (AdvancedFilters && AdvancedFiltersType !== "null" && commandId[i] !== "SW" && commandId[i] !== "SW1" && commandId[i] !== "SWMIX") {
            // For DIALOGadvanced, ONLY apply to center channel
            if (AdvancedFiltersType === "DIALOGadvanced") {
              if (commandId[i] === "C") {
                // Apply DIALOGadvanced filter to center channel
                const AdvanedFiltersConfig = getAdvancedFilters(AdvancedFiltersType, customFiltersConfig);
                if (AdvanedFiltersConfig) {
                  console.log(`APPLYING ${AdvanedFiltersConfig.description} to:`, commandId[i]);
                  console.info("Advanced Filter Optimization Targets:");
                  // Apply filters sequentially with delays
                  for (let j = 0; j < AdvanedFiltersConfig.filters.length; j++) {
                    await postSafe(`${baseUrl}/${i}/filters`, {
                      filters: [AdvanedFiltersConfig.filters[j]]
                    }, "Filters set");
                    await customDelay(speedDelay / 2);
                  }
                  // Log all targets
                  AdvanedFiltersConfig.targets.forEach(target => console.info(target));
                  console.log(`${AdvanedFiltersConfig.description} applied successfully to:`, commandId[i]);
                }
              }
              // If not center channel, do nothing (skip)
            } else {
              // For all other filter types, apply to all non-subwoofer channels
              const AdvanedFiltersConfig = getAdvancedFilters(AdvancedFiltersType, customFiltersConfig);
              if (AdvanedFiltersConfig) {
                console.log(`APPLYING ${AdvanedFiltersConfig.description} to:`, commandId[i]);
                console.info("Advanced Filter Optimization Targets:");
                // Apply filters sequentially with delays
                for (let j = 0; j < AdvanedFiltersConfig.filters.length; j++) {
                  await postSafe(`${baseUrl}/${i}/filters`, {
                    filters: [AdvanedFiltersConfig.filters[j]]
                  }, "Filters set");
                  await customDelay(speedDelay / 2);
                }
                // Log all targets
                AdvanedFiltersConfig.targets.forEach(target => console.info(target));
                console.log(`${AdvanedFiltersConfig.description} applied successfully to:`, commandId[i]);
              }
            }
          }
          // generate filters & auto level it
          const filter = await postNext('Generate filters measurement', i);
          const filterIdx = Object.keys(filter.results)[0];
          const filterName = `${commandId[i]}-filters`;
          await fetch_mREW(filterIdx, 'PUT', { title: filterName });
          // Only calculate and apply auto-level offset (no tcLevelOffset)
          const ALOffset = await getALOffset(filterIdx, isSub);
          if (isDebugMode) {
            console.log(`=== AUTO-LEVEL DEBUG for ${commandId[i]} ===`);
            console.log(`Auto-level offset calculated: ${ALOffset.toFixed(2)}dB`);
            console.log(`This will be SUBTRACTED from the filter response`);
          }
          // Apply auto-level compensation to filter
          await postNext('Add SPL offset', filterIdx, { offset: -ALOffset });
          // generate predicted equalized response using the auto leveled filter
          const eqResponse = await postNext('Arithmetic', [i, filterIdx], { function: "A * B" });
          const eqResponseIdx = Object.keys(eqResponse.results)[0];
          const eqResponseName = `${commandId[i]}-equalized`;
          await fetch_mREW(eqResponseIdx, 'PUT', { title: eqResponseName });
          // Only apply auto-level offset (rounded to nearest 0.5dB)
          let logUpdate = `${commandId[i].padStart(3, ".")} - equalized`;
          const trimOffset = tcLevelOffset + Math.round(ALOffset * 2) / 2; //round to nearest 0.5
          if (trimOffset != 0) {
            // Apply offset to equalized response for consistency
            await postNext('Add SPL offset', eqResponseIdx, { offset: trimOffset });
            // Update custom levels to reflect the change
            const customLevelOriginal = customLevel[i];
            if (isSub) {
              for (let j = nSpeakers + 1; j <= nSpeakers + nSubs; j++) {
                customLevel[j] += trimOffset;
              }
            } else {
              customLevel[i] += trimOffset;
            }
            logUpdate += ` | auto-level offset: ${customLevelOriginal}dB → ${customLevel[i]}dB (${trimOffset}dB)`;
            if (isDebugMode) {
              console.log(`=== TRIM OFFSET DEBUG for ${commandId[i]} ===`);
              console.log(`Auto-level offset: ${ALOffset.toFixed(2)}dB`);
              console.log(`Rounded trim offset applied: ${trimOffset.toFixed(2)}dB`);
              console.log(`customLevel change: ${customLevelOriginal.toFixed(1)}dB → ${customLevel[i].toFixed(1)}dB`);
            }
          }
          console.infoUpdate(logUpdate);
        }
        // clean up EQ params
        for (let i = nChannels + 1; i <= nChannels * 3; i++) {
          await postSafe(`${baseUrl}/${i}/target-settings`, { shape: "None" }, "Update processed");
        }
      }

      async function getFilters(measurementId) {
        const response = await fetch(`http://localhost:4735/measurements/${measurementId}/filters`, {
          method: 'GET',
          headers: { 'accept': 'application/json' }
        });
        return await response.json();
      }

      function sanityCheck(filters) {
        const violations = [];
        // Filter out inactive filters (type = "None")
        const activeFilters = filters.filter(filter => filter.type !== "None");
        // Header logging
        console.log(`🔍 VALIDATING REW-GENERATED FILTERS...`);
        console.log(`├─ Found ${activeFilters.length} active filters (of ${filters.length} slots):`);
        activeFilters.forEach(filter => {
          if (filter.hasOwnProperty('gaindB')) {
            // Build detailed filter description
            let filterDesc = `Filter ${filter.index}: ${filter.type}`;
            if (filter.frequency) {
              filterDesc += ` at ${filter.frequency.toFixed(2)}Hz`;
            }
            filterDesc += `, Gain: ${filter.gaindB.toFixed(1)}dB`;
            if (filter.q && filter.type === "PK") {
              filterDesc += `, Q: ${filter.q.toFixed(1)}`;
            }
            // Log the detailed filter info
            console.info(`├─ ${filterDesc}`);
            let violation = null;
            const originalGain = filter.gaindB;
            if (filter.gaindB > 3) {
              violation = 'BOOST';
              filter.gaindB = 3;
            } else if (filter.gaindB < -10) {
              violation = 'CUT';
              filter.gaindB = -10;
            }
            if (violation) {
              // REW API constraint: HS filters cannot be set to auto
              if (filter.type === "HS") {
                filter.isAuto = false;
              }
              console.warn(`⚠ ${violation} VIOLATION FOUND: Filter ${filter.index} corrected to ${filter.gaindB}dB`);
              violations.push({
                index: filter.index,
                currentGain: originalGain,
                filter: filter
              });
            }
          }
        });
        console.log(`└─ Total violations found: ${violations.length}`);
        return violations.length > 0 ? violations : null;
      }

      async function updateFilters(measurementId, violations) {
        // Update only the filters that had violations
        for (const violation of violations) {
          const response = await fetch(`http://localhost:4735/measurements/${measurementId}/filters`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'accept': 'application/json'
            },
            body: JSON.stringify(violation.filter)  // Send single filter object directly
          });
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`PUT failed: ${response.status} - ${errorText}`);
          }
          const result = await response.json();
          console.log(`Filter ${violation.filter.index} updated:`, result.message);
        }
      }

      // Main SBIR detection
      async function detectSBIRFromMeasurements() {
        console.log("Analyzing for Speaker Boundary Interference Response (SBIR)...");
        const c = sOs;
        const sbirPatterns = [];
        for (let i = 1; i <= nSpeakers; i++) {
          const title = commandId[i];
          console.info(`Analyzing ${title} for SBIR patterns...`);
          // const response = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', i);
          const response = await fetchSafe("frequency-response?smoothing=Var&ppo=96", i);
          const nulls = await findNulls(response, i);
          if (nulls.length >= 2) {
            const sbirInfo = analyzeSBIRPattern(nulls, c);
            if (sbirInfo.isSBIR) {
              sbirPatterns.push({
                speaker: title,
                speakerIndex: i,
                estimatedBoundaryDistance: sbirInfo.distance,
                nullFrequencies: sbirInfo.frequencies,
                severity: sbirInfo.severity
              });
              console.warn(`⚠ ${title}: SBIR detected! Boundary at ~${sbirInfo.distance.toFixed(2)}m`);
              console.warn(`  ⚠ Nulls at: ${sbirInfo.frequencies.map(f => f.toFixed(0) + 'Hz').join(', ')}`);
              console.warn(`  ⚠ Severity: ${sbirInfo.severity.toUpperCase()}`);
            }
          }
        }
        window.detectedSBIR = sbirPatterns;
        return sbirPatterns;
      }

      // Find nulls helper
      async function findNulls(response, measurementIdx, threshold = -6) {
        const fullResponse = response2array(response, 20, 500);
        const nulls = [];
        let freq = 20;
        const octave = Math.pow(2, 1 / 96);
        const avgLevel = fullResponse.reduce((sum, val) => sum + val, 0) / fullResponse.length;
        for (let i = 1; i < fullResponse.length - 1; i++) {
          freq *= octave;
          if (fullResponse[i] < fullResponse[i - 1] &&
            fullResponse[i] < fullResponse[i + 1] &&
            fullResponse[i] < avgLevel + threshold) {
            const depth = avgLevel - fullResponse[i];
            const q = (freq / 10); // Simplified Q calculation
            nulls.push({
              frequency: freq,
              depth: depth,
              q: q
            });
          }
        }
        return nulls.sort((a, b) => a.frequency - b.frequency);
      }

      // Analyze SBIR pattern
      function analyzeSBIRPattern(nulls, speedOfSound) {
        if (nulls.length < 2) return { isSBIR: false };
        const firstNull = nulls[0].frequency;
        const expectedDistance = speedOfSound / (4 * firstNull);
        let matchCount = 0;
        const detectedFrequencies = [firstNull];
        for (let n = 2; n <= 4; n++) {
          const expectedFreq = firstNull * (2 * n - 1);
          const tolerance = expectedFreq * 0.15;
          const foundNull = nulls.find(nullPoint =>
            Math.abs(nullPoint.frequency - expectedFreq) < tolerance
          );
          if (foundNull) {
            matchCount++;
            detectedFrequencies.push(foundNull.frequency);
          }
        }
        const isSBIR = matchCount >= 1;
        let severity = 'low';
        if (nulls[0].depth > 10 && nulls[0].q > 3) {
          severity = 'severe';
        } else if (nulls[0].depth > 6) {
          severity = 'moderate';
        }
        return {
          isSBIR: isSBIR,
          distance: expectedDistance,
          frequencies: detectedFrequencies,
          severity: severity
        };
      }

      // Display SBIR results
      function displaySBIRResults() {
        if (!window.detectedSBIR || window.detectedSBIR.length === 0) return;
        console.log("");
        console.log("🔊 SBIR (BOUNDARY INTERFERENCE) ANALYSIS:");
        console.log("═".repeat(50));
        for (const sbir of window.detectedSBIR) {
          console.warn(`⚠ ${sbir.speaker}:`);
          console.log(`├─ Estimated boundary distance: ${sbir.estimatedBoundaryDistance.toFixed(2)}m`);
          console.log(`├─ Severity: ${sbir.severity.toUpperCase()}`);
          console.log(`└─ Null frequencies: ${sbir.nullFrequencies.map(f => f.toFixed(0) + 'Hz').join(', ')}`);
          if (sbir.estimatedBoundaryDistance < 0.6) {
            console.log(`└─ ⚠ RECOMMENDATION: Move speaker at least ${(0.6 - sbir.estimatedBoundaryDistance).toFixed(1)}m away from wall`);
            console.log(`--`);
          } else if (sbir.severity === 'severe') {
            console.log(`   🞮 Severe SBIR detected - EQ cannot fix this, repositioning required!`);
            console.log(`--`);
          } else {
            console.log(`--`);
          }
        }
      }

      async function checkAndDisableSBIRFilters(speakerIdx, filters) {
        if (!window.detectedSBIR) return;
        const speakerSBIR = window.detectedSBIR.find(s => s.speakerIndex === speakerIdx);
        if (!speakerSBIR) return;
        let modified = false;
        // Only check active filters
        filters.forEach(filter => {
          // Skip inactive filter slots
          if (filter.type === "None") return;
          for (const nullFreq of speakerSBIR.nullFrequencies) {
            const ratio = filter.frequency / nullFreq;
            // If filter is within 10% of SBIR null frequency
            if (ratio > 0.9 && ratio < 1.1) {
              if (speakerSBIR.severity === 'severe' && filter.gaindB > 0) {
                filter.enabled = false;
                console.warn(`    ⚠ SBIR: Disabled boost at ${filter.frequency.toFixed(0)}Hz (severe null at ${nullFreq.toFixed(0)}Hz)`);
                modified = true;
              } else if (speakerSBIR.severity === 'moderate' && filter.gaindB > 2) {
                filter.gaindB = 2;
                console.warn(`    ⚠ SBIR: Limited boost at ${filter.frequency.toFixed(0)}Hz to 2dB (moderate null at ${nullFreq.toFixed(0)}Hz)`);
                modified = true;
              }
            }
          }
        });
        if (modified) {
          await postSafe(`${baseUrl}/${speakerIdx}/filters`, { filters }, "Filters set");
        }
      }
      /* ============== */
      /* SBIR DETECTION */
      // ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
      // PROPRIETARY FILTER GENERATION AND CHECKING ! 
      // CAN NOT BE USED WITHOUT EXPLICIT PERMISSION OF NVEXX !
      // ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

      function finalizeTrims() {
        if (isDebugMode) {
          console.log("=== FINAL TRIMS DEBUG ===");
          console.log("Raw customLevel values BEFORE sanity check:");
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            console.log(`  ${commandId[i]}: ${customLevel[i].toFixed(1)}dB`);
          }
        }
        sanityCheckSpeakerTrims();
        console.log("Final speaker" + (noSub ? "" : " & subwoofer") + " trims:")
        for (let i = 1; i <= nSpeakers; i++) {
          const customLevelOriginal = customLevel[i];
          customLevel[i] = Math.max(-12, customLevel[i]);
          customLevel[i] = Math.min(customLevel[i], 12);
          if (customLevelOriginal != customLevel[i]) {
            console.warn(`⚠ ${commandId[i].padStart(3, ".")} required volume adjustment beyond hardware limits - shifted: ${customLevelOriginal}dB → ${customLevel[i]}dB`);
          }
          else {
            console.info(`⚠ ${commandId[i].padStart(3, ".")} - applied adjustment: ${customLevel[i]}dB`);
          }
        }
        if (noSub) { return; } // no need to go further without subwoofer
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          const customLevelOriginal = customLevel[i];
          customLevel[i] = Math.max(subLoTrim, customLevel[i]);
          customLevel[i] = Math.min(customLevel[i], subHiTrim);
          if (customLevelOriginal != customLevel[i]) {
            console.warn(`⚠ ${commandId[i].padStart(3, ".")} required volume adjustment beyond hardware limits - shifted: ${customLevelOriginal}dB → ${customLevel[i]}dB`);
          }
          else {
            console.info(`${commandId[i].padStart(3, ".")} - applied adjustment: ${customLevel[i]}dB`);
          }
        }
      }

      function sanityCheckSpeakerTrims() {
        // if a speaker is too sensitive or not sensitive enough, it may end up outside +/-12dB
        const minSpeakerTrim = Math.min(...customLevel.slice(1, nSpeakers + 1));
        const maxSpeakerTrim = Math.max(...customLevel.slice(1, nSpeakers + 1));
        let offset = 0;
        if (minSpeakerTrim < -12 && maxSpeakerTrim < 12) {
          const requiredOffset = -12 - minSpeakerTrim;
          offset = Math.min(requiredOffset, 12 - maxSpeakerTrim); // limited by maxSpeakerTrim
        }
        else if (maxSpeakerTrim > 12 && minSpeakerTrim > -12) {
          const requiredOffset = 12 - maxSpeakerTrim;
          offset = Math.max(requiredOffset, -12 - minSpeakerTrim); // limited by minSpeakerTrim
        }
        if (offset != 0) {
          console.warn(`⚠ Trims are being shifted by ${offset}dB to best stay within hardware limits!`)
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += offset;
          }
        }
      }

      function isSingleChannel(channelCmdId) {
        if (channelCmdId.endsWith("L") && commandId.includes(channelCmdId.slice(0, -1) + "R")) { return false; } // L and R
        if (channelCmdId.endsWith("R") && commandId.includes(channelCmdId.slice(0, -1) + "L")) { return false; } // R and L
        if (channelCmdId.includes("L") && commandId.includes(channelCmdId.replace("L", "R"))) { return false; } // edge case for SLA/SRA type cmdIds
        if (channelCmdId.includes("R") && commandId.includes(channelCmdId.replace("R", "L"))) { return false; } // where L/R is in the middle
        return true;
      }

      function findNearestXO(freq) {
        let xo = Infinity;
        let minDelta = Infinity;
        for (let i = 0; i < freqIndex.length; i++) {
          const delta = Math.abs(freqIndex[i] - freq);
          if (delta < minDelta) {
            minDelta = delta;
            xo = freqIndex[i];
          }
        }
        return xo;
      }

      // === COMMON HELPER ===
      // Compute RMS and average deviation between measurement and target
      function getDeviationStats(rpArray, tcArray) {
        const len = Math.min(rpArray.length, tcArray.length);
        let sumSq = 0;
        let sumAbs = 0;
        for (let i = 0; i < len; i++) {
          const diff = rpArray[i] - tcArray[i];
          sumSq += diff * diff;
          sumAbs += Math.abs(diff);
        }
        const rms = Math.sqrt(sumSq / len);
        const mean = sumAbs / len;
        return { rms, mean };
      }

      // Find the frequency with maximum deviation from target
      function findMaxDeviation(rpArray, tcArray, startFreq, endFreq) {
        const len = Math.min(rpArray.length, tcArray.length);
        if (len === 0) return { frequency: startFreq, deviation: 0 };

        let maxDeviation = -Infinity;
        let maxDeviationIndex = 0;

        for (let i = 0; i < len; i++) {
          const deviation = rpArray[i] - tcArray[i];
          if (deviation > maxDeviation) {
            maxDeviation = deviation;
            maxDeviationIndex = i;
          }
        }

        // Calculate the actual frequency at this index
        // REW uses 96 points per octave
        const octave = Math.pow(2, 1 / 96);
        const frequency = startFreq * Math.pow(octave, maxDeviationIndex);

        return { frequency, deviation: maxDeviation };
      }

      // Find the top N frequencies with maximum deviation from target
      function findTopDeviations(rpArray, tcArray, startFreq, endFreq, count = 2) {
        const len = Math.min(rpArray.length, tcArray.length);
        if (len === 0) return [];

        const deviations = [];
        const octave = Math.pow(2, 1 / 96); // REW uses 96 points per octave

        // Calculate deviation at each frequency
        for (let i = 0; i < len; i++) {
          const deviation = rpArray[i] - tcArray[i];
          const frequency = startFreq * Math.pow(octave, i);
          deviations.push({ index: i, frequency, deviation });
        }

        const results = [];

        for (let n = 0; n < count; n++) {
          // Find max deviation not too close to already selected frequencies
          let maxDeviation = -Infinity;
          let maxIndex = -1;

          for (let i = 0; i < deviations.length; i++) {
            const dev = deviations[i];

            // Skip if too close to already selected frequencies (within 1/3 octave)
            let tooClose = false;
            for (const result of results) {
              const ratio = dev.frequency / result.frequency;
              if (ratio > 0.8 && ratio < 1.25) { // Within ~1/3 octave
                tooClose = true;
                break;
              }
            }

            if (!tooClose && dev.deviation > maxDeviation) {
              maxDeviation = dev.deviation;
              maxIndex = i;
            }
          }

          if (maxIndex >= 0) {
            results.push(deviations[maxIndex]);
          }
        }

        return results;
      }

      async function get3dBPoint(idx, start = 10, end = 320, options = {}) {
        const {
          direction = 'low',      // 'low' or 'high'
          reference = 'target',   // 'target', 'absolute'
          deviceType = 'speaker', // 'speaker' or 'sub'
          threshold = -3,         // find -3 points
          smoothing = null        // null = use mode config
        } = options;

        // Fetch with appropriate smoothing
        const actualSmoothing = smoothing || MODE_CONFIG[getCurrentMode()].smoothing;
        const response = await fetchSafe(`frequency-response?smoothing=${actualSmoothing}&ppo=96`, idx);
        const rpArray = response2array(response, start, end);

        // Get reference level
        let referenceArray;
        if (reference === 'target') {
          referenceArray = response2array(targetResponse, start, end);
        } else {
          // Absolute reference - use appropriate frequency band
          const refBand = deviceType === 'sub'
            ? [modeSubXOMin - 10, modeSubXOMax + 10]   // Bass for subs
            : [500, 2000];                             // Midrange for speakers
          const refArray = response2array(response, ...refBand);
          const refLevel = refArray.reduce((a, v) => a + v, 0) / refArray.length;
          referenceArray = new Array(rpArray.length).fill(refLevel);
        }

        // Find rolloff point
        const octave = Math.pow(2, 1 / 96);
        let rolloff = direction === 'low' ? start : end;

        if (direction === 'low') {
          for (let i = 0; i < rpArray.length; i++) {
            if ((rpArray[i] - referenceArray[i]) >= threshold) break;
            rolloff *= octave;
          }
          return Math.min(rolloff, end);
        } else {
          for (let i = rpArray.length - 1; i >= 0; i--) {
            if ((rpArray[i] - referenceArray[i]) >= threshold) break;
            rolloff /= octave;
          }
          return Math.max(rolloff, start);
        }
      }

      // get high frequency rolloff > vs target
      async function getSpeakerHFRolloff(idx, start = 10000, end = 20000) {
        // goal of this function is to find the roll-off past 10k before any HF peaks that can mess with the high shelf
        const response = await fetchSafe('frequency-response?smoothing=Var&ppo=96', idx);
        const rpArray = response2array(response, start, end);
        const tcArray = response2array(targetResponse, start, end);
        const arrLength = Math.min(rpArray.length, tcArray.length);
        const octave = Math.pow(2, 1 / 96);
        let checkFreq = start;
        let rolloff = checkFreq;
        let lowestSPL = rpArray[0];
        for (let i = 0; i < arrLength; i++) {
          if (rpArray[i] < lowestSPL) {
            lowestSPL = rpArray[i];
            rolloff = checkFreq;
          }
          // if HF peak exceeds lowest point by 3dB, set roll-off before that peak
          // also if HF drops below target by 3dB, stop there otherwise high shelf will fail
          if ((rpArray[i] - lowestSPL >= 3) || (rpArray[i] - tcArray[i] <= -3)) {
            break;
          }
          checkFreq *= octave;
        }
        return Math.min(rolloff, end);
      }

      async function calculateRolloffs() {
        // console.log("Calculating speaker -3dB points from target curve...");
        console.log("Calculating speaker -3dB points...");
        // [DEBUG] DEBUG CODE HERE ↓
        if (isDebugMode) {
          console.log("=== TARGET CURVE DEBUG ===");
          console.log("Target curve in bass region:");
          const debugTcArray = response2array(targetResponse, 20, 120);
          for (let i = 0; i < debugTcArray.length; i += 8) { // Every 8th point to avoid spam
            const freq = 20 * Math.pow(2, i / 96);
            if (freq <= 100) {
              console.log(`${freq.toFixed(1)}Hz: ${debugTcArray[i].toFixed(1)}dB`);
            }
          }
          console.log("=== END TARGET CURVE DEBUG ===");
        }
        // [DEBUG] END DEBUG CODE ↑
        const measurements = await fetch_mREW();
        for (let i = 1; i <= nSpeakers; i++) {
          const title = measurements[i].title;
          // check if single channel or speaker pair
          const singleChannel = isSingleChannel(commandId[i]);
          const cmdIds = (singleChannel ? commandId[i] : `${commandId[i]} & ${commandId[i + 1]}`).padStart(9, ".");
          // rolloff determination logic
          let idx = i;
          if (!singleChannel) {
            const pairAvg = await postNext('Magn plus phase average', [i, i + 1]); // do not use VA. it unfairly benefits single channel speakers
            idx = Object.keys(pairAvg.results)[0];
          }
          // absolute > speaker 
          const rolloff = await get3dBPoint(idx, 20, 320, { direction: 'low', reference: 'absolute', deviceType: 'speaker' }); // NEW single 3dpoint function. Waiting for copy&paste
          let initialXO = findNearestXO(rolloff);
          // edge case for no subwoofer
          if (noSub && cmdIds.endsWith("FL & FR")) {
            initialXO = "L";
          }
          customCrossover[i] = initialXO;
          // used for EQ limits
          const mode = getCurrentMode();
          const config = MODE_CONFIG[mode];
          const rolloffLF = await get3dBPoint(i, 20, 320, { direction: 'low', reference: 'absolute', deviceType: 'speaker' }); // NEW single 3dpoint function. Waiting for copy&paste
          // target > vs curve
          const rolloffHF = await getSpeakerHFRolloff(i);
          if (mode === 'DEFAULT') {
            m3dBPoints[i] = [Math.round(rolloffLF), Math.round(rolloffHF)];
            console.info(`calculateRolloffs: applying Default - ${Math.round(rolloffHF)} rolloff`);
          } else {
            m3dBPoints[i] = [Math.round(rolloffLF), config.rolloffHF];
            console.info(`calculateRolloffs: applying ${mode} - ${config.rolloffHF} rolloff`);
          }
          if (!singleChannel) {
            customCrossover[i + 1] = initialXO;
            await postDelete(idx); // cleanup
            // absolute > speaker 
            const rolloffLFR = await get3dBPoint(i + 1, 20, 320, { direction: 'low', reference: 'absolute', deviceType: 'speaker' }); // NEW single 3dpoint function. Waiting for copy&paste
            // target > vs curve
            const rolloffHFR = await getSpeakerHFRolloff(i + 1);
            if (mode === 'DEFAULT') {
              m3dBPoints[i + 1] = [Math.round(rolloffLFR), Math.round(rolloffHFR)];
              console.info(`calculateRolloffs: applying Default - ${Math.round(rolloffHFR)} rolloff`);
            } else {
              m3dBPoints[i + 1] = [Math.round(rolloffLFR), config.rolloffHF];
              console.info(`calculateRolloffs: applying ${mode} - ${config.rolloffHF} rolloff`);
            }
            i++;
          }
          const logMessage = initialXO === "L" ? "Large/Full Range" : `Initial XO: ${initialXO}hz`;
          console.info(`${cmdIds} - roll-off: ${rolloff.toFixed(2)}Hz → ${logMessage}`);
          console.info("═".repeat(60));
        }
      }

      async function calculateSubBandwidth() {
        if (noSub) { return; }
        const tempFreqIndex = [...freqIndex.filter(freq => freq !== 180 && freq !== 200 && freq !== 250), 20].sort((a, b) => a - b);
        const findNearestXOWithSub = (freq) => {
          let xo = Infinity;
          let minDelta = Infinity;
          for (let i = 0; i < tempFreqIndex.length; i++) {
            const delta = Math.abs(tempFreqIndex[i] - freq);
            if (delta < minDelta) {
              minDelta = delta;
              xo = tempFreqIndex[i];
            }
          }
          return xo;
        };
        // console.log("Calculating subwoofer -3dB points from target curve...")
        console.log("Calculating subwoofer -3dB points...")
        // Get current measurements to find actual indices
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        // Find all subwoofer channels dynamically BY SEARCHING MEASUREMENTS
        const subChannels = [];
        for (let i = 1; i < commandId.length; i++) {
          if (commandId[i] && commandId[i].startsWith('SW')) {
            // Find the actual measurement index for this subwoofer
            let measurementIdx = null;
            for (let j = 1; j <= mCount; j++) {
              // Look for the averaged measurement (ends with 'o')
              if (measurements[j] && measurements[j].title === commandId[i] + 'o') {
                measurementIdx = j;
                break;
              }
            }
            if (measurementIdx) {
              subChannels.push({
                commandIdIndex: i,
                commandId: commandId[i],
                measurementIndex: measurementIdx
              });
            } else {
              console.warn(`⚠ Could not find measurement for ${commandId[i]}`);
            }
          }
        }

        if (subChannels.length === 0) {
          console.warn("⚠ No subwoofer channels found!");
          return;
        }
        // Find the most restrictive bandwidth across all subs
        let highestMinXO = -Infinity;
        let lowestMaxXO = Infinity;
        let worstSubMin = '';
        let worstSubMax = '';
        for (const sub of subChannels) {
          // Use the actual measurement index, not commandId index
          // absolute > subwoofer 
          const subLowFreq = await get3dBPoint(sub.measurementIndex, 10, 280, { direction: 'low', reference: 'absolute', deviceType: 'sub' }); // NEW single 3dpoint function. Waiting for copy&paste
          // absolute > subwoofer 
          const subHighFreq = await get3dBPoint(sub.measurementIndex, 10, 280, { direction: 'high', reference: 'absolute', deviceType: 'sub' }); // NEW single 3dpoint function. Waiting for copy&paste
          const channelMinXO = findNearestXOWithSub(2 * subLowFreq);
          const channelMaxXO = findNearestXOWithSub(subHighFreq);
          // Track which sub is most restrictive
          if (channelMinXO > highestMinXO) {
            highestMinXO = channelMinXO;
            worstSubMin = sub.commandId;
          }
          if (channelMaxXO < lowestMaxXO) {
            lowestMaxXO = channelMaxXO;
            worstSubMax = sub.commandId;
          }
          console.log(`${sub.commandId.padStart(3, ".")} bandwidth: ${subLowFreq.toFixed(2)}hz - ${subHighFreq.toFixed(2)}hz → XO: ${channelMinXO}hz - ${channelMaxXO}hz`);
          // Store using commandId index for compatibility with rest of script
          m3dBPoints[sub.commandIdIndex] = [Math.round(subLowFreq), Math.round(subHighFreq)];
        }
        minXO = highestMinXO;
        maxXO = lowestMaxXO;
        if (minXO >= maxXO) {
          minXO = maxXO;
          console.warn(`⚠ Subwoofer(s) have very little overlapping bandwidth - only ${minXO}hz crossover supported!`);
        } else {
          console.log(`📊 Combined safe usable XO range: ${minXO}hz - ${maxXO}hz (limited by ${worstSubMin} low / ${worstSubMax} high)`);
          console.log(`📊 safe range for optimal subwoofer integration ${minXO}hz will be the lowest possible CrossOver!`);
        }
        Object.freeze(minXO);
        Object.freeze(maxXO);
        // Use the most restrictive sub's values for NART reporting
        RP22subnminXO = (highestMinXO / 2).toFixed(2);
        RP22submaxXO = lowestMaxXO.toFixed(2);
        function roundToNearest(value, array) {
          const num = parseFloat(value);
          return array.reduce((prev, curr) =>
            Math.abs(curr - num) < Math.abs(prev - num) ? curr : prev
          );
        }
        // NART Subwoofer value(s)
        const roundedMin = roundToNearest(RP22subnminXO, freqIndex);
        const roundedMax = roundToNearest(RP22submaxXO, freqIndex);
        nartXOs.push(["SW1".padStart(3, "."), RP22subnminXO.toString(), RP22submaxXO.toString(), "Subwoofer"]);
        sanityCheckInitialXO();
      }

      function sanityCheckInitialXO() {
        if (noSub) { return; } // no need to go further without subwoofer
        for (let i = 1; i <= nSpeakers; i++) {
          const singleChannel = isSingleChannel(commandId[i]);
          const cmdIds = (singleChannel ? commandId[i] : `${commandId[i]} & ${commandId[1 + i]}`).padStart(9, ".");
          const initialXO = customCrossover[i];
          customCrossover[i] = Math.max(minXO, customCrossover[i]);
          if (!singleChannel) {
            customCrossover[i + 1] = customCrossover[i];
            i++;
          }
          if (initialXO != customCrossover[i]) {
            console.warn(`⚠ ${cmdIds} initial XO below usable XO range - shifted: ${initialXO}hz → ${customCrossover[i]}hz`);
          }
        }
      }

      async function optimizeSubDelay() {
        if (noSub) { return; }
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        const measurementIndices = Object.keys(measurements).map(k => parseInt(k)).sort((a, b) => a - b);
        let speakerIndices = [], initialXOs = 0, avgInitialXO = 80;
        let count = 1;
        console.log('=== Available measurements ===');
        for (const i of measurementIndices) {
          const title = measurements[i].title;
          console.log(`${i}: ${title}`);
          // Skip if this is a subwoofer measurement
          if (commandId[count]?.startsWith("SW")) {
            console.log(`  Skipped: SW measurement`);
            count++;
            continue;
          }
          // Add all speaker measurements (raw or equalized)
          speakerIndices.push(i);
          initialXOs += parseFloat(customCrossover[count++]);
          console.log(`  Added to average`);
        }
        if (initialXOs > 0) { avgInitialXO = initialXOs / speakerIndices.length; }
        Object.freeze(avgInitialXO);
        console.log(`Calculating optimal subwoofer delay using ${speakerIndices.length} speakers, average XO ${avgInitialXO.toFixed(2)}hz...`);
        const avgSpeaker = await postNext('Magn plus phase average', Array.from(speakerIndices));
        const avgSpeakerIdx = Object.keys(avgSpeaker.results)[0]
        const avgSpeakerWithHPF = await genSpeaker(avgSpeakerIdx, avgInitialXO);
        const avgSpeakerWithHPFIdx = Object.keys(avgSpeakerWithHPF.results)[0];
        const subwooferWithLPF = await genSub(mCount, avgInitialXO);
        const subwooferWithLPFIdx = Object.keys(subwooferWithLPF.results)[0];
        let [isPossible, requiredDelay, isInverted] = await align4system(avgSpeakerWithHPFIdx, subwooferWithLPFIdx);
        // cleanup
        await postDelete(subwooferWithLPFIdx);
        await postDelete(avgSpeakerWithHPFIdx);
        await postDelete(avgSpeakerIdx);
        // apply optimal delay
        let subMoves = 0;
        if (isPossible) {
          subMoves = requiredDelay;
        } else {
          console.warn(`⚠ Required delay for alignment is too large! Subwoofer(s) set to max possible distance but results will not be optimal.`);
          const [loDelay,] = getDelayRangeOfFinalSub();
          subMoves = loDelay;
          isInverted = false;
        }
        // Find the subwoofer measurement index
        let subwooferIdx = null;
        for (const i of measurementIndices) {
          const title = measurements[i].title;
          if (title.startsWith("SW")) {
            subwooferIdx = i;
            break;
          }
        }
        if (!subwooferIdx) {
          throw new Error("Could not find subwoofer measurement");
        }
        // Also update the invert command if needed
        if (isInverted) {
          await postSafe(`${baseUrl}/${subwooferIdx}/command`, { command: "Invert" }, "Invert completed");
        }
        subMoves /= delaymax;
        // Apply offset to the actual subwoofer index
        await postNext('Offset t=0', subwooferIdx, { offset: -subMoves, unit: "seconds" });
        if (bassMode === "Directional") {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            mSec[i] += subMoves;
            invertSub[i] = isInverted ? !invertSub[i] : invertSub[i];
          }
        } else {
          mSec[nChannels] += subMoves;
          invertSub[nChannels] = isInverted;
        }
      }

      function getFLIndex() {
        let flIndex = 1;
        for (let i = 1; i <= nChannels; i++) {
          if (commandId[i].startsWith("FL")) {
            flIndex = i;
            break;
          }
        }
        return flIndex;
      }

      function initializeDistances() {
        // initialize to 0
        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          customDistance[i] = 0;
        }
        if (noSub) { return; }
        const flIndex = getFLIndex();
        let distMinSub = Infinity;
        let distMaxSub = -Infinity;
        // check if any directional subwoofer needs negative distance
        if (bassMode === "Directional") {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            const distSub = flDist + (mSec[flIndex] - mSec[i]) * sOs;
            distMinSub = Math.min(distMinSub, distSub);
            distMaxSub = Math.max(distMaxSub, distSub);
          }
          // check if any SWMIX subwoofer needs negative distance  
        } else {
          const distMainSub = flDist + (mSec[flIndex] - mSec[nChannels]) * sOs;
          const distLoSub = distMainSub - subLoDelay * sOs;
          const distHiSub = distMainSub - subHiDelay * sOs;
          distMinSub = Math.min(distLoSub, distHiSub);
          distMaxSub = Math.max(distLoSub, distHiSub);
        }
        if (distMinSub < 0 && distMaxSub > 18) {
          console.error("🞮 Min/Max subwoofer distances exceed the 0 - 18m AVR limits!");
          throw new Error;
        }
        if (distMinSub < 0) {
          const distShift = 0 - distMinSub;
          console.warn(`⚠ Distances are being shifted by ${distShift.toFixed(2)}m to accommodate the required subwoofer delay!`);
          console.info("This adjustment will ONLY improve overall sound quality.");
          console.info("The receiver only accounts for relative time delays between speakers which are being kept intact.");
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            customDistance[i] += distShift;
          }
        }
        if (distMaxSub > 18) {
          const distShift = 18 - distMaxSub;
          console.warn(`⚠ Distances are being shifted by ${distShift.toFixed(2)}m to accommodate the required subwoofer delay!`);
          console.info("This adjustment will ONLY improve overall sound quality.");
          console.info("The receiver only accounts for relative time delays between speakers which are being kept intact.");
          for (let i = 1; i <= nSpeakers + nSubs; i++) {
            customDistance[i] += distShift;
          }
        }
      }

      function finalizeDistances() {
        initializeDistances();
        const flIndex = getFLIndex();
        // Check for combined subwoofers
        let activeSubs = nSubs;
        if (nSubs > 1) {
          let allSubsSame = true;
          const firstSubDelay = mSec[nSpeakers + 1];
          for (let i = nSpeakers + 2; i <= nSpeakers + nSubs; i++) {
            if (Math.abs(mSec[i] - firstSubDelay) > 0.0001) {
              allSubsSame = false;
              break;
            }
          }
          if (allSubsSame) {
            console.warn("⚠ Multiple subwoofers detected with identical delays - showing as combined SW1");
            activeSubs = 1;
          }
        }
        // Get FL's acoustic-only delay (excluding NART)
        const nartDelayFL = nartDelays[commandId[flIndex]] || 0;
        const acousticMSecFL = mSec[flIndex] - nartDelayFL;
        estimatedDistances = [];
        console.log("Final speaker" + (noSub ? "" : " & subwoofer") + " distances:");

        // ═══════════════════════════════════════════════════════════════════════════
        // SPEAKERS: Show acoustic distance + NART optimization separately
        // ═══════════════════════════════════════════════════════════════════════════
        for (let i = 1; i <= nSpeakers; i++) {
          const nartDelay = nartDelays[commandId[i]] || 0;
          const acousticMSec = mSec[i] - nartDelay;
          customDistance[i] += flDist + (acousticMSecFL - acousticMSec) * sOs;
          customDistance[i] = Math.round(customDistance[i] * 100) / 100;
          estimatedDistances.push([commandId[i], customDistance[i].toFixed(2)]);
          const nartInfo = nartDelay !== 0 ?
            ` (+ ${(nartDelay * 1000).toFixed(2)}ms NART modal cancellation)` : '';

          console.info(`${commandId[i].padStart(3, ".")} - distance: ${customDistance[i].toFixed(2)}m${nartInfo}`);
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // SUBWOOFERS: Show acoustic distance + alignment details
        // ═══════════════════════════════════════════════════════════════════════════
        if (!noSub) {
          for (let i = nSpeakers + 1; i <= nSpeakers + activeSubs; i++) {
            // Subs don't get NART modal cancellation (only alignment to speakers)
            const acousticMSec = mSec[i];
            customDistance[i] += flDist + (acousticMSecFL - acousticMSec) * sOs;
            customDistance[i] = Math.round(customDistance[i] * 100) / 100;
            estimatedDistances.push([commandId[i], customDistance[i].toFixed(2)]);
            // Build informative message
            let subInfo = `distance: ${customDistance[i].toFixed(2)}m`;
            // Show if this sub was part of directional alignment
            if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
              subInfo += ` (aligned with ${window.preCombinedSubCount - 1} other subs)`;
            }
            // Show polarity
            if (invertSub[i]) {
              console.warn(`⚠ ${commandId[i].padStart(3, ".")} - ${subInfo}, please SWITCH this subwoofer's POLARITY!!!`);
              swInvMsg += `inv${commandId[i]}_`;
            } else {
              console.warn(`⚠ ${commandId[i].padStart(3, ".")} - ${subInfo}, keep this subwoofer's polarity 'as is'.`);
            }
          }
          // Copy SW1 to other subs for .ady file compatibility
          if (activeSubs === 1 && nSubs > 1) {
            console.info("Copying SW1 values to SW2-SW4 for .ady file compatibility...");
            for (let i = nSpeakers + 2; i <= nSpeakers + nSubs; i++) {
              customDistance[i] = customDistance[nSpeakers + 1];
              customLevel[i] = customLevel[nSpeakers + 1];
              invertSub[i] = invertSub[nSpeakers + 1];
            }
          }
        }
      }

      async function finalizeXO(start = 20, end = 250) {
        if (noSub) { return; } // no need to go further without subwoofer

        // Helper function to generate frequency array for RMS calculation
        function generateFrequencyArray(startFreq, endFreq, length) {
          const freqArray = [];
          let iFreq = startFreq;
          const step = Math.pow(endFreq / startFreq, 1 / (length - 1));
          for (let k = 0; k < length; k++) {
            freqArray.push(iFreq);
            iFreq *= step;
          }
          return freqArray;
        }
        function estimatePhaseSlope(frequencyArray, excessPhaseArray, crossoverFreq) {
          const low = crossoverFreq / 2;
          const high = crossoverFreq * 2;
          const points = frequencyArray
            .map((f, i) => ({ f, phase: excessPhaseArray[i] }))
            .filter(p => p.f >= low && p.f <= high);

          console.info(`├─ Slope estimation for ${crossoverFreq}Hz: using ${points.length} points from ${low}Hz to ${high}Hz`);
          if (points.length < 2) return null;
          const x = points.map(p => Math.log2(p.f));
          const y = points.map(p => p.phase);
          const n = x.length;
          const meanX = x.reduce((a, b) => a + b, 0) / n;
          const meanY = y.reduce((a, b) => a + b, 0) / n;

          let num = 0, den = 0;
          for (let i = 0; i < n; i++) {
            num += (x[i] - meanX) * (y[i] - meanY);
            den += (x[i] - meanX) ** 2;
          }

          const slope = den === 0 ? null : num / den;
          console.info(`├─ Calculated excess phase slope: ${slope?.toFixed(1)}°/octave (should be ~-90 to -180 for LR crossover)`);
          return slope;
        }


        function calculateExpectedCrossoverPhase(frequencyArray, crossoverFreq, actualPhaseArray = null) {
          if (actualPhaseArray) {
            const slope = estimatePhaseSlope(frequencyArray, actualPhaseArray, crossoverFreq) ?? -90;
            // Find the phase value at crossover frequency
            let closestIndex = 0;
            let minDiff = Math.abs(frequencyArray[0] - crossoverFreq);
            for (let i = 1; i < frequencyArray.length; i++) {
              const diff = Math.abs(frequencyArray[i] - crossoverFreq);
              if (diff < minDiff) {
                minDiff = diff;
                closestIndex = i;
              }
            }

            const xoPhase = actualPhaseArray[closestIndex];
            console.info(`├─ Phase target calc: slope=${slope.toFixed(1)}°/oct, anchor freq=${frequencyArray[closestIndex].toFixed(1)}Hz, anchor phase=${xoPhase.toFixed(1)}°`);
            // Generate expected phase based on linear extrapolation from crossover point
            return frequencyArray.map(freq => {
              const octaves = Math.log2(freq / crossoverFreq);
              return xoPhase + slope * octaves;
            });
          }

          // Fallback: theoretical 4th-order Linkwitz-Riley phase response
          return frequencyArray.map(freq => {
            if (freq < crossoverFreq) {
              const phaseRad = -2 * Math.atan(freq / crossoverFreq);
              return phaseRad * (180 / Math.PI);
            } else {
              const phaseRad = -Math.PI / 2 - 2 * Math.atan(crossoverFreq / freq);
              return phaseRad * (180 / Math.PI);
            }
          });
        }

        // ============================================================================
        // SPEAKER TO SLIDER MAPPING - Maps each speaker to its individual slider
        // ============================================================================
        const speakerToSliderMap = {
          // Bed layer channels
          'FL': 'main_fl_fr',
          'FR': 'main_fl_fr',
          'FWL': 'main_fwl_fwr',
          'FWR': 'main_fwl_fwr',
          'SBL': 'surround_sbl_sbr',
          'SBR': 'surround_sbl_sbr',
          'SB': 'surround_sb',
          'SLA': 'surround_sla_sra',
          'SRA': 'surround_sla_sra',
          'C': 'center',
          // Height layer channels
          'FHL': 'height_fhl_fhr',
          'FHR': 'height_fhl_fhr',
          'RHL': 'height_rhl_rhr',
          'RHR': 'height_rhl_rhr',
          'SHL': 'height_shl_shr',
          'SHR': 'height_shl_shr',
          'CH': 'height_ch',
          // Top layer channels
          'TFL': 'top_tfl_tfr',
          'TFR': 'top_tfl_tfr',
          'TML': 'top_tml_tmr',
          'TMR': 'top_tml_tmr',
          'TRL': 'top_trl_trr',
          'TRR': 'top_trl_trr',
          'TS': 'top_ts',
          // Dolby enabled channels
          'BDL': 'dolby_bdl_bdr',
          'BDR': 'dolby_bdl_bdr',
          'FDL': 'dolby_fdl_fdr',
          'FDR': 'dolby_fdl_fdr',
          'SDL': 'dolby_sdl_sdr',
          'SDR': 'dolby_sdl_sdr',
        };

        // Channel category mapping for logging purposes
        const speakerCategoryMap = {
          'FL': 'BED', 'FR': 'BED',
          'FWL': 'BED', 'FWR': 'BED',
          'SBL': 'BED', 'SBR': 'BED',
          'SB': 'BED',
          'SLA': 'BED', 'SRA': 'BED',
          'C': 'BED',
          'FHL': 'HEIGHT', 'FHR': 'HEIGHT',
          'RHL': 'HEIGHT', 'RHR': 'HEIGHT',
          'SHL': 'HEIGHT', 'SHR': 'HEIGHT',
          'CH': 'HEIGHT',
          'TFL': 'TOP', 'TFR': 'TOP',
          'TML': 'TOP', 'TMR': 'TOP',
          'TRL': 'TOP', 'TRR': 'TOP',
          'TS': 'TOP',
          'BDL': 'DOLBY', 'BDR': 'DOLBY',
          'FDL': 'DOLBY', 'FDR': 'DOLBY',
          'SDL': 'DOLBY', 'SDR': 'DOLBY',
        };

        // ============================================================================
        // GET SLIDER RANGE FOR SPECIFIC SPEAKER
        // ============================================================================
        function getSpeakerFreqRange(speakerId) {
          // Get the slider key for this speaker
          const sliderKey = speakerToSliderMap[speakerId];
          const category = speakerCategoryMap[speakerId] || 'UNKNOWN';

          if (!sliderKey) {
            console.warn(`⚠️  No slider mapping found for speaker ${speakerId}`);
            return { min: 20, max: 250, slider: 'DEFAULT', category: category };
          }

          // Get the slider instance
          const slider = sliderInstances[sliderKey];

          if (!slider) {
            console.warn(`⚠️  Slider "${sliderKey}" not initialized for speaker ${speakerId}`);
            return { min: 20, max: 250, slider: 'DEFAULT', category: category };
          }

          // Get the range from the slider
          const range = slider.getSelectedRange();

          if (!range) {
            console.warn(`⚠️  Could not get range from slider "${sliderKey}" for speaker ${speakerId}`);
            return { min: 20, max: 250, slider: 'DEFAULT', category: category };
          }

          // Extract min/max based on slider mode
          let min, max;
          if (range.mode === "single") {
            min = max = range.value;
          } else {
            min = range.min;
            max = range.max;
          }

          // console.info(`   📊 ${speakerId} → slider: ${sliderKey} → range: ${min}Hz - ${max}Hz [${category}]`);

          return {
            min: min,
            max: max,
            slider: sliderKey,
            category: category
          };
        }

        // ============================================================================
        // MAIN OPTIMIZATION LOOP
        // ============================================================================
        console.info("🎯 Finalizing crossover frequencies using individual channel sliders...");
        console.info("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        const targetArray = response2array(targetResponse, start, end);
        let count = 1;

        // Loop through all speakers
        while (count <= nSpeakers) {
          // Skip subwoofers
          if (commandId[count].startsWith("SW")) {
            count++;
            continue;
          }

          // Find the measurement index for this speaker
          let measurementIdx = count;
          for (let j = 1; j <= mCount; j++) {
            if (measurements[j]?.title === commandId[count] + 'o') {
              measurementIdx = j;
              break;
            }
          }

          // Check if single channel or speaker pair
          const singleChannel = isSingleChannel(commandId[count]);
          const cmdIds = (singleChannel ? commandId[count] : `${commandId[count]} & ${commandId[count + 1]}`).padStart(3, ".");

          // Get the frequency range for the PRIMARY speaker using its individual slider
          const primarySpeakerId = commandId[count];
          const speakerRange = getSpeakerFreqRange(primarySpeakerId);

          console.info(`${cmdIds}`);
          console.info(`   Using slider: "${speakerRange.slider}"`);
          console.info(`   Frequency range: ${speakerRange.min}Hz - ${speakerRange.max}Hz`);
          console.info(`   Category: [${speakerRange.category}]`);

          // Calculate effective usable range
          // LOW END: Sub capabilities set the floor (physical limit)
          const effectiveMinXO = Math.max(minXO, speakerRange.min);

          // HIGH END: Slider sets the ceiling (user intent)
          const effectiveMaxXO = speakerRange.max;

          // Log any constraint violations
          if (speakerRange.min < minXO) {
            console.warn(`   ⚠️  Slider min (${speakerRange.min}Hz) below sub capability (${minXO}Hz) - using ${effectiveMinXO}Hz`);
          }
          if (speakerRange.max > maxXO) {
            console.warn(`   ⚠️  Slider max (${speakerRange.max}Hz) exceeds sub capability (${maxXO}Hz) - proceeding anyway`);
          }

          console.info(`   Effective range: ${effectiveMinXO}Hz - ${effectiveMaxXO}Hz`);

          // Filter freqIndex to only include frequencies within effective range
          const filteredFreqIndex = freqIndex.filter(freq =>
            freq >= effectiveMinXO && freq <= effectiveMaxXO
          );

          console.info(`   Filtered frequencies: ${filteredFreqIndex.length} points from ${filteredFreqIndex[0] || 'none'}Hz to ${filteredFreqIndex[filteredFreqIndex.length - 1] || 'none'}Hz`);

          // Optimize crossover
          const initialXO = parseFloat(customCrossover[count]);
          let bestXO = initialXO, minRmsError = Infinity;

          console.info(`   Starting optimization...`);

          for (let j = 0; j < filteredFreqIndex.length; j++) {

            let checkXO = filteredFreqIndex[j];
            if (checkXO < effectiveMinXO || checkXO > effectiveMaxXO) { continue; }

            console.info(`   →`);
            console.info(`   ├─ ${cmdIds} - Initial XO: ${initialXO}Hz → Testing XO: ${checkXO}Hz`);

            // Generate speaker with crossover
            if (singleChannel) {
              await genSpeaker(measurementIdx, checkXO);
            } else {
              await postNext('Magn plus phase average', [measurementIdx, measurementIdx + 2]);
              await genSpeaker(mCount + 1, checkXO);
              await postDelete(mCount + 1);
            }

            await genSub(mCount, checkXO);
            await postNext('Arithmetic', [mCount + 1, mCount + 2], { function: "A + B" });

            // Calculate RMS error
            const checkXOResponse = await fetchSafe('frequency-response?smoothing=Var&ppo=96', mCount + 3);
            const checkXOArray = response2array(checkXOResponse, start, end);
            const responseFrequencyArray = generateFrequencyArray(start, end, checkXOArray.length);

            let phaseCoherence = null;

            if (checkXOResponse.phase) {
              // Unwrap phase at the crossover frequency
              await postSafe(`${baseUrl}/${mCount + 3}/command`, {
                command: "Unwrap phase",
                parameters: { frequency: checkXO }
              }, "Unwrap phase completed");

              const unwrappedResponse = await fetchSafe('frequency-response?smoothing=Var&ppo=96', mCount + 3);
              const phaseArray = response2arrayPhase(unwrappedResponse, start, end);

              if (phaseArray && phaseArray.length > 0) {
                // Generate frequency array that matches the phase array
                const phaseFrequencyArray = generateFrequencyArray(start, end, phaseArray.length);

                // Measure phase smoothness in a narrow band around crossover
                phaseCoherence = measurePhaseCoherenceNarrowBand(phaseArray, phaseFrequencyArray, checkXO);

                console.info(`   ├─ Phase optimization enabled for ${checkXO}Hz crossover`);
                console.info(`   ├─ Phase coherence metric: ${phaseCoherence.toFixed(2)}° (lower = smoother transition)`);
              }
            }
            const rmsError = calculateRMSError(
              checkXOArray,
              targetArray,
              responseFrequencyArray,
              targetLevel,
              phaseCoherence !== null,
              phaseCoherence,
              null,
              checkXO
            );
            console.log(`   └─ ${cmdIds} - XO: ${checkXO}Hz → RMS: ${rmsError.toFixed(3)}`);
            if (rmsError < minRmsError) {
              minRmsError = rmsError;
              bestXO = checkXO;
            }
            // Cleanup
            for (let k = mCount + 3; k > mCount; k--) {
              await postDelete(k);
            }
          }
          // Store results for PRIMARY speaker
          customCrossover[count] = bestXO;
          RP22BestXO.push([commandId[count], bestXO.toString(), speakerRange.category, speakerRange.slider]);
          nartXOs.push([commandId[count], initialXO.toString(), bestXO.toString(), speakerRange.category, speakerRange.slider]);

          // Handle paired speaker (if applicable)
          if (!singleChannel) {
            const secondarySpeakerId = commandId[count + 1];
            const secondaryRange = getSpeakerFreqRange(secondarySpeakerId);
            customCrossover[count + 1] = bestXO;
            RP22BestXO.push([secondarySpeakerId, bestXO.toString(), secondaryRange.category, secondaryRange.slider]);
            nartXOs.push([secondarySpeakerId, initialXO.toString(), bestXO.toString(), secondaryRange.category, secondaryRange.slider]);
            count++; // Skip the paired channel
          }
          console.log(`   ${cmdIds} - Initial: ${initialXO}Hz → Optimized: ${bestXO}Hz (RMS: ${minRmsError.toFixed(3)})`);
          console.log(`   ←`);
          count++; // Move to next speaker
        }

        // ============================================================================
        // LOG FINAL RESULTS GROUPED BY CATEGORY
        // ============================================================================
        console.log("");
        console.log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        console.log(" == FINAL CROSSOVER OPTIMIZATION RESULTS == ");
        console.log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        const resultsByCategory = {
          'BED': RP22BestXO.filter(r => r[2] === 'BED'),
          'HEIGHT': RP22BestXO.filter(r => r[2] === 'HEIGHT'),
          'TOP': RP22BestXO.filter(r => r[2] === 'TOP'),
          'DOLBY': RP22BestXO.filter(r => r[2] === 'DOLBY'),
          'UNKNOWN': RP22BestXO.filter(r => !['BED', 'HEIGHT', 'TOP', 'DOLBY'].includes(r[2]))
        };

        for (const [category, results] of Object.entries(resultsByCategory)) {
          if (results.length > 0) {
            console.log(`== [${category} LAYER] ==`);
            for (const [code, frequency, cat, slider] of results) {
              //console.log(`  ${code.padEnd(4)} → ${frequency.padStart(3)}Hz (slider: ${slider})`);
              console.log(`  ${code.padEnd(4)} → ${frequency.padStart(3)}Hz`);
            }
          }
        }

        console.log("");
        console.log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        console.log(` == Total speakers optimized: ${RP22BestXO.length} ==`);
        console.log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        return RP22BestXO;
      }

      // HELPER:
      // Remove linear phase trend to get excess phase
      function removeLinearPhaseTrend(phaseArray, frequencyArray, referenceFreq) {
        if (!phaseArray || !frequencyArray || phaseArray.length === 0) {
          console.warn(`   ⚠ Invalid input: phaseArray length=${phaseArray?.length}, freqArray length=${frequencyArray?.length}`);
          return phaseArray;
        }

        // Validate array lengths match
        if (phaseArray.length !== frequencyArray.length) {
          console.error(`   🞮 Array length mismatch: phase=${phaseArray.length}, freq=${frequencyArray.length}`);
          return phaseArray;
        }

        // Find reference frequency index
        let refIndex = 0;
        let minDiff = Math.abs(frequencyArray[0] - referenceFreq);
        for (let i = 1; i < frequencyArray.length; i++) {
          const diff = Math.abs(frequencyArray[i] - referenceFreq);
          if (diff < minDiff) {
            minDiff = diff;
            refIndex = i;
          }
        }

        console.info(`   ├─ Reference freq: ${referenceFreq}Hz → index ${refIndex} (${frequencyArray[refIndex]?.toFixed(1)}Hz)`);

        // Calculate linear phase slope (group delay) using least squares
        const x = frequencyArray;  // Frequency in Hz
        const y = phaseArray;
        const n = x.length;

        const meanX = x.reduce((a, b) => a + b, 0) / n;
        const meanY = y.reduce((a, b) => a + b, 0) / n;

        let num = 0, den = 0;
        for (let i = 0; i < n; i++) {
          num += (x[i] - meanX) * (y[i] - meanY);
          den += (x[i] - meanX) ** 2;
        }

        const slope = den === 0 ? 0 : num / den;  // degrees per Hz
        const intercept = meanY - slope * meanX;

        const groupDelayMs = -slope / 360 * 1000;
        console.info(`   ├─ Linear phase trend: ${slope.toFixed(6)}°/Hz (group delay: ${groupDelayMs.toFixed(3)}ms)`);

        // Remove linear trend to get excess phase
        const excessPhase = phaseArray.map((phase, i) => {
          const linearPhase = slope * frequencyArray[i] + intercept;
          const excess = phase - linearPhase;

          // Debug first/last few points
          if (i < 3 || i >= phaseArray.length - 3) {
            console.info(`   ├─ [${i}] ${frequencyArray[i].toFixed(1)}Hz: ${phase.toFixed(1)}° - ${linearPhase.toFixed(1)}° = ${excess.toFixed(1)}°`);
          }

          return excess;
        });

        // Offset so reference frequency is at 0°
        const refPhase = excessPhase[refIndex];
        console.info(`   ├─ Reference phase offset: ${refPhase.toFixed(1)}° at ${frequencyArray[refIndex].toFixed(1)}Hz`);

        if (isNaN(refPhase)) {
          console.error(`   🞮 Reference phase is NaN! refIndex=${refIndex}, excessPhase[${refIndex}]=${excessPhase[refIndex]}`);
          return phaseArray;
        }

        const normalizedExcess = excessPhase.map(p => p - refPhase);

        // Final validation
        const hasNaN = normalizedExcess.some(p => isNaN(p));
        if (hasNaN) {
          console.error(`   🞮 NaN detected in excess phase array!`);
          return phaseArray;
        }

        return normalizedExcess;
      }

      // HELPER:
      // Measure phase smoothness in narrow band around crossover (±1/2 octave)
      function measurePhaseCoherenceNarrowBand(phaseArray, frequencyArray, crossoverFreq) {
        const lowFreq = crossoverFreq / Math.sqrt(2);   // -1/2 octave
        const highFreq = crossoverFreq * Math.sqrt(2);  // +1/2 octave

        // Extract phase values in the crossover region
        const crossoverBand = [];
        for (let i = 0; i < frequencyArray.length; i++) {
          if (frequencyArray[i] >= lowFreq && frequencyArray[i] <= highFreq) {
            crossoverBand.push(phaseArray[i]);
          }
        }

        if (crossoverBand.length < 3) {
          return Infinity; // Not enough data points
        }

        // Calculate phase slope variations (2nd derivative = curvature)
        const derivatives = [];
        for (let i = 1; i < crossoverBand.length; i++) {
          derivatives.push(crossoverBand[i] - crossoverBand[i - 1]);
        }

        // Calculate standard deviation of derivatives (measures smoothness)
        const meanDerivative = derivatives.reduce((a, b) => a + b, 0) / derivatives.length;
        let sumSquaredDiff = 0;
        for (let i = 0; i < derivatives.length; i++) {
          const diff = derivatives[i] - meanDerivative;
          sumSquaredDiff += diff * diff;
        }

        const stdDev = Math.sqrt(sumSquaredDiff / derivatives.length);

        // Also penalize large overall phase swings
        const phaseSwing = Math.max(...crossoverBand) - Math.min(...crossoverBand);

        // Combined metric: prefer smooth, minimal phase change
        return stdDev + (phaseSwing / 100);
      }

      // Calculate expected excess phase for Linkwitz-Riley 4th order crossover
      function calculateExpectedCrossoverExcessPhase(frequencyArray, crossoverFreq) {
        // LR4 crossover has specific phase response
        // High-pass: -2*atan(fc/f) for f > fc, -π/2 - 2*atan(f/fc) for f < fc  
        // Low-pass: -2*atan(f/fc) for f < fc, -π/2 - 2*atan(fc/f) for f > fc
        // Combined: -π/2 everywhere (in-phase sum)

        return frequencyArray.map(freq => {
          const ratio = freq / crossoverFreq;

          if (ratio < 1) {
            // Below crossover: dominated by low-pass
            const phaseRad = -2 * Math.atan(ratio);
            return phaseRad * (180 / Math.PI);
          } else {
            // Above crossover: dominated by high-pass  
            const phaseRad = -Math.PI / 2 - 2 * Math.atan(1 / ratio);
            return phaseRad * (180 / Math.PI);
          }
        });
      }

      async function directional2standard() {
        let measurements = await fetch_mREW();
        let mCount = Object.keys(measurements).length;
        // Check if NART optimized speakers for modal cancellation
        const nartOptimized = (window.nartOptimizationComplete === true);
        if (nartOptimized) {
          console.warn("⚠ NART Mode: Speakers optimized for modal cancellation");
          console.warn("⚠ Now aligning subs to each other for coherent bass system...");
        } else {
          console.warn("⚠ Traditional Mode: Calculating magnitude-based sub alignment");
        }
        // Isolate SW commandIds & peak IR times
        const swCmdIdsWithIRPeak = {};
        for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
          if (commandId[i] && commandId[i].startsWith("SW")) {
            let measurementIdx = i;
            for (let j = 1; j <= mCount; j++) {
              if (measurements[j].title.startsWith(commandId[i])) {
                measurementIdx = j;
                break;
              }
            }
            if (measurements[measurementIdx]) {
              swCmdIdsWithIRPeak[commandId[i]] = measurements[measurementIdx].timeOfIRPeakSeconds;
            }
          }
        }
        // Sort subs using peak IR time
        const sortedSwList = Object.entries(swCmdIdsWithIRPeak)
          .sort((a, b) => a[1] - b[1])
          .map(row => row[0]);
        console.info(`Alignment order based on IR peak time: ${sortedSwList}`);
        // Build sorted indices arrays
        const swIndices = [];
        for (let i = 0; i < sortedSwList.length; i++) {
          const swName = sortedSwList[i];
          const subNumber = swName.slice(-1);
          const subMeasurements = [];
          for (let j = 1; j <= mCount; j++) {
            if (measurements[j] && measurements[j].title.startsWith(`SW${subNumber}`)) {
              subMeasurements.push(j);
            }
          }
          if (subMeasurements.length > 0) {
            subMeasurements.sort((a, b) => {
              const posA = parseInt(measurements[a].title.slice(2));
              const posB = parseInt(measurements[b].title.slice(2));
              return posA - posB;
            });
            swIndices.push(subMeasurements);
          }
        }
        // Validate
        if (!swIndices || swIndices.length === 0) {
          console.error("🞮 No subwoofer indices found for directional2standard conversion");
          throw new Error("Invalid swIndices array");
        }
        if (!swIndices[0] || swIndices[0].length === 0) {
          console.error("🞮 First subwoofer group is empty");
          throw new Error("Invalid swIndices[0] array");
        }
        let currSubIdx = swIndices[0][0];
        let cmdIds = measurements[currSubIdx].title.slice(0, -1);
        // absolute > subwoofer 
        startFreq = Math.round(await get3dBPoint(currSubIdx, 10, 280, { direction: 'low', reference: 'absolute', deviceType: 'sub', smoothing: '1/48' })); // NEW single 3dpoint function. Waiting for copy&paste
        // absolute > subwoofer 
        endFreq = Math.round(await get3dBPoint(currSubIdx, 10, 280, { direction: 'high', reference: 'absolute', deviceType: 'sub', smoothing: '1/48' })); // NEW single 3dpoint function. Waiting for copy&past

        // ═══════════════════════════════════════════════════════════════════════════
        // ALIGN EACH SUB TO THE PREVIOUS (WORKS SAME IN BOTH MODES)
        // ═══════════════════════════════════════════════════════════════════════════
        for (let i = 1; i < swIndices.length; i++) {
          let thisSubIdx = swIndices[i][0];
          const thisSubCmdId = measurements[thisSubIdx].title.slice(0, -1);
          const thisSubNumber = parseInt(thisSubCmdId.slice(-1));
          console.log(`├─ Aligning ${thisSubCmdId} to ${cmdIds}...`);
          // absolute > subwoofer
          startFreq = Math.min(startFreq, await get3dBPoint(thisSubIdx, 10, 280, { direction: 'low', reference: 'absolute', deviceType: 'sub', smoothing: '1/48' })); // NEW single 3dpoint function. Waiting for copy&paste
          // absolute > subwoofer 
          endFreq = Math.max(endFreq, await get3dBPoint(thisSubIdx, 10, 280, { direction: 'high', reference: 'absolute', deviceType: 'sub', smoothing: '1/48' })); // NEW single 3dpoint function. Waiting for copy&past
          const [loDelay, hiDelay] = getDelayRangeOf(
            mSec[nSpeakers + thisSubNumber],
            nSpeakers + 1,
            nSpeakers + nSubs
          );
          // ALWAYS use alignMsub() to align subs to each other
          const [isPossible, requiredDelay, isInverted, sumIndex] =
            await alignMsub(currSubIdx, thisSubIdx, startFreq, endFreq, loDelay, hiDelay);
          if (!isPossible || !sumIndex) {
            console.error("🞮 Failed to align multiple subwoofers!");
            throw new Error("Subwoofer alignment failed");
          }
          // Update tracking arrays
          mSec[nSpeakers + thisSubNumber] += (requiredDelay / delaymax);
          invertSub[nSpeakers + thisSubNumber] = isInverted;
          // Apply delay and inversion to measurements
          for (let j = 0; j < swIndices[i].length; j++) {
            await postNext('Offset t=0', swIndices[i][j],
              { offset: -mSec[nSpeakers + thisSubNumber], unit: "seconds" });
            if (isInverted) {
              await postSafe(`${baseUrl}/${swIndices[i][j]}/command`,
                { command: "Invert" }, "Invert completed");
            }
          }
          // Log what we did
          if (nartOptimized) {
            console.log(`├─ ${thisSubCmdId}: Inter-sub alignment: ${requiredDelay.toFixed(2)}ms (added to NART optimization), inverted: ${isInverted}`);
          } else {
            console.log(`├─ ${thisSubCmdId}: Alignment: ${requiredDelay.toFixed(2)}ms, inverted: ${isInverted}`);
          }
          currSubIdx = sumIndex;
          cmdIds += ` & ${thisSubCmdId}`;
        }
        // Cleanup intermediate alignment measurements
        for (let i = currSubIdx - 1; i > mCount; i--) {
          await postDelete(i);
        }
        // Normalize median subwoofer delay to t=0
        const loSWDelay = Math.min(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
        const hiSWDelay = Math.max(...mSec.slice(nSpeakers + 1, nSpeakers + nSubs + 1));
        const medianSWDelay = (loSWDelay + hiSWDelay) / 2;
        for (let i = 0; i < swIndices.length; i++) {
          for (let j = 0; j < swIndices[i].length; j++) {
            await postNext('Offset t=0', swIndices[i][j],
              { offset: medianSWDelay, unit: "seconds" });
          }
          const firstMeasurementIdx = swIndices[i][0];
          const measurementTitle = measurements[firstMeasurementIdx].title;
          const actualSubNumber = parseInt(measurementTitle.slice(2, -1));
          mSec[nSpeakers + actualSubNumber] -= medianSWDelay;
        }
        // Combine subs at the individual position level
        console.info("Generating combined subwoofer response(s)...");
        let volAdjust = 0;
        for (let i = 0; i < swIndices[0].length; i++) {
          console.infoUpdate(`Generating combined subwoofer response for position #${i + 1}`);
          const iPosSWIdxs = swIndices.map(row => row[i]);
          const iPosCombinedSW = await postNext('Vector sum', iPosSWIdxs);
          const iPosCombinedSWIdx = Object.keys(iPosCombinedSW.results)[0];
          await fetch_mREW(iPosCombinedSWIdx, 'PUT', { title: `SW1${i}` });
          if (i === 0) {
            volAdjust = await getSubTrim(iPosCombinedSWIdx);
          }
          await postNext('Add SPL offset', iPosCombinedSWIdx, { offset: volAdjust });
        }
        console.infoUpdate(`Generated combined subwoofer response(s) for all positions.`);
        // Cleanup individual sub measurements
        console.info("Cleaning up individual subwoofer response(s)...");
        const individualSWIndices = swIndices.flat().sort((a, b) => a - b);
        for (let i = individualSWIndices.length - 1; i >= 0; i--) {
          await postDelete(individualSWIndices[i]);
        }
        console.infoUpdate("Cleaned up individual subwoofer response(s).");
        // Apply custom level adjustments for newer AVRs
        if (sOs === 300 && volAdjust != 0) {
          console.log(`Adjusting combined sub level by ${volAdjust}dB to best follow the target curve...`);
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] += volAdjust;
            console.info(`${commandId[i].padStart(3, ".")} - shifted: ${customLevel[i] - volAdjust}dB → ${customLevel[i]}dB`);
          }
        }
        // Cleanup "Aligned sum" leftover
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        for (let i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "Aligned sum" || name === "Vector sum") {
            console.info(`Deleting intermediate: ${name}`);
            await postDelete(i);
          }
        }
        // Update SW name to SW1o
        measurements = await fetch_mREW();
        mCount = Object.keys(measurements).length;
        for (let i = mCount; i >= 1; i--) {
          const name = measurements[i].title;
          if (name === "SW10") {
            console.info("Updating subwoofer name to SW1o");
            await fetch_mREW(i, 'PUT', { title: "SW1o" });
            break;
          }
        }
        // ═══════════════════
        // NART: Sub Alignment
        // ═══════════════════
        if (window.nartSubSystemAlignment) {
          console.log("");
          console.log("🎯 APPLYING NART SYSTEM-LEVEL SUB ALIGNMENT");
          console.log("═".repeat(60));
          console.log("Now that subs are combined, align the system to speakers...");
          const systemDelay = window.nartSubSystemAlignment.delay;
          const systemInversion = window.nartSubSystemAlignment.inversion;
          console.log(`├─ System delay: ${systemDelay.toFixed(2)}ms`);
          console.log(`├─ System inversion: ${systemInversion ? 'YES' : 'NO'}`);
          // Find the combined SW1o measurement
          measurements = await fetch_mREW();
          mCount = Object.keys(measurements).length;
          let sw1oIdx = null;
          for (let i = 1; i <= mCount; i++) {
            if (measurements[i].title === "SW1o") {
              sw1oIdx = i;
              break;
            }
          }
          if (!sw1oIdx) {
            console.error("🞮 Could not find SW1o measurement for system alignment!");
          } else {
            // Apply system-level inversion
            if (systemInversion) {
              await postSafe(`${baseUrl}/${sw1oIdx}/command`,
                { command: "Invert" }, "Invert completed");
            }
            // Apply system-level delay
            const subMoves = systemDelay / delaymax;
            await postNext('Offset t=0', sw1oIdx,
              { offset: -subMoves, unit: "seconds" });
            // Update tracking for the combined sub
            mSec[nSpeakers + 1] += subMoves;
            // XOR with existing inversions from inter-sub alignment
            const existingInversion = invertSub[nSpeakers + 1] || false;
            invertSub[nSpeakers + 1] = existingInversion !== systemInversion;
            console.log(`└─ Applied system alignment to combined subwoofer`);
            console.log(`   Final inversion: ${invertSub[nSpeakers + 1]} (inter-sub: ${existingInversion}, system: ${systemInversion})`);
          }
          // Clear the deferred alignment
          delete window.nartSubSystemAlignment;
          console.log("✓ NART system-level alignment complete");
          console.log("═".repeat(60));
        }
      }

      function response2array(response, start, end, phase = false) {
        let startFreq = response.startFreq;
        let k1 = start, k2 = end;
        // Calculate indices
        if ('freqStep' in response) {
          const freqStep = response.freqStep;
          k1 = Math.round((k1 - startFreq) / freqStep);
          k2 = Math.round((k2 - startFreq) / freqStep);
        } else if ('ppo' in response) {
          const responsePpo = response.ppo;
          k1 = Math.round(Math.log2(k1 / startFreq) * responsePpo);
          k2 = Math.round(Math.log2(k2 / startFreq) * responsePpo);
        }

        const bytes = Uint8Array.from(atob(phase ? response.phase : response.magnitude), (c) => c.charCodeAt(0));
        const buffer = bytes.buffer;
        const data = new DataView(buffer);

        // ADD BOUNDS CHECKING
        const maxIndex = Math.floor(data.byteLength / 4) - 1;

        // Clamp indices to valid range
        k1 = Math.max(0, k1);
        k2 = Math.min(maxIndex, k2);

        // Validate range
        if (k1 > maxIndex || k2 < 0 || k1 > k2) {
          console.warn(`⚠ response2array: Invalid frequency range ${start}-${end}Hz (indices ${k1}-${k2}, max: ${maxIndex})`);
          return []; // Return empty array instead of crashing
        }

        const responseArray = [];
        for (let k = k1; k <= k2; k++) {
          const sumMagnitude = data.getFloat32(k * 4);
          responseArray.push(sumMagnitude);
        }
        return responseArray;
      }

      function calculateRMSError(rpArray, targetArray, frequencyArray = null, playbackLevel = null, includePhase = false, phaseCoherence = null, unusedParam = null, crossoverFreq = null) {
        if (rpArray.length === 0 || targetArray.length === 0) {
          console.warn("⚠ Failed to calculate RMS error!");
          return Infinity;
        }

        const arrayLength = Math.min(rpArray.length, targetArray.length);

        // Calculate traditional magnitude RMS
        let magnitudeSumOfSquares = 0;
        for (let i = 0; i < arrayLength; i++) {
          const diff = rpArray[i] - targetArray[i];
          magnitudeSumOfSquares += diff * diff;
        }
        const magnitudeRMS = Math.sqrt(magnitudeSumOfSquares / arrayLength);

        // If no phase data provided, return magnitude-only RMS
        if (!includePhase || phaseCoherence === null) {
          console.log(`📊 RMS: Magnitude-only optimization: ${magnitudeRMS.toFixed(6)}`);
          return magnitudeRMS;
        }

        // Phase coherence: lower is better (0-10 typical range)
        // Normalize and combine with magnitude
        const normalizedPhaseCoherence = Math.min(phaseCoherence / 10, 1.0);
        const phaseWeight = window.phaseWeight || 0.5; // Use slider value, default 0.5
        const combinedError = magnitudeRMS + (normalizedPhaseCoherence * phaseWeight);

        console.log(`├─ 📊 RMS: Magnitude: ${magnitudeRMS.toFixed(6)}, Phase Coherence: ${phaseCoherence.toFixed(2)}°, Combined: ${combinedError.toFixed(6)}`);
        return combinedError;
      }

      // for backward compatibility:
      async function getTrim(idx, start, end) {
        return await getTrimUnified(idx, { start, end });
      }

      // for backward compatibility:
      async function getTCTrim(idx, start, end) {
        return await getTrimUnified(idx, {
          start,
          end,
          useVariableSmoothing: true
        });
      }

      // for backward compatibility:
      async function getSpeakerTrim(idx) {
        const mode = getCurrentMode();
        const config = MODE_CONFIG[mode];

        // Use mode-specific settings
        return await getTrimUnified(idx, {
          start: 500,
          end: 2000,
          isSub: false,
          smoothing: '1/3'
        });
      }

      // for backward compatibility:
      async function getSubTrim(idx) {
        const mode = getCurrentMode();
        const config = MODE_CONFIG[mode];

        return await getTrimUnified(idx, {
          start: 30,
          end: 80,
          isSub: true,
          smoothing: '1/3'
        });
      }

      // ═══════════════════════════════════════════════════════════════════════════
      // CONSOLIDATED TRIM CALCULATION
      // ═══════════════════════════════════════════════════════════════════════════
      async function getTrimUnified(idx, options = {}) {
        const {
          start = null,
          end = null,
          isSub = null,
          smoothing = null,
          reference = 'target',  // 'target' or 'absolute'
          useVariableSmoothing = false
        } = options;

        // Auto-detect if this is a subwoofer
        const measurements = await fetch_mREW();
        const title = measurements[idx]?.title || '';
        const isActuallySub = isSub !== null ? isSub : title.startsWith('SW');

        // Use appropriate defaults based on device type
        const actualStart = start !== null ? start : (isActuallySub ? 30 : 500);
        const actualEnd = end !== null ? end : (isActuallySub ? 80 : 2000);

        // Determine smoothing
        let actualSmoothing;
        if (useVariableSmoothing) {
          actualSmoothing = 'Var';
        } else if (smoothing !== null) {
          actualSmoothing = smoothing;
        } else {
          actualSmoothing = isActuallySub ? '1/6' : '1/12';
        }

        const mode = getCurrentMode();
        console.info(`├─ getTrimUnified: ${mode} ${isActuallySub ? 'subwoofer' : 'speaker'} (${actualStart}-${actualEnd}Hz) - ${actualSmoothing} smoothing`);

        // Fetch frequency response
        const freqResponse = await fetchSafe(
          `frequency-response?smoothing=${actualSmoothing}&ppo=96`,
          idx
        );

        const freqArray = response2array(freqResponse, actualStart, actualEnd);

        if (freqArray.length === 0) {
          console.warn(`⚠ No data in ${actualStart}-${actualEnd}Hz for measurement ${idx}`);
          return 0;
        }

        const freqSPL = freqArray.reduce((acc, val) => acc + val, 0) / freqArray.length;
        if (reference === 'target') {
          const targetArray = response2array(targetResponse, actualStart, actualEnd);
          const targetSPL = targetArray.reduce((acc, val) => acc + val, 0) / targetArray.length;

          if (isDebugMode) {
            console.log(`*** TRIM DEBUG for measurement ${idx} (${actualStart}-${actualEnd}Hz) ***`);
            console.log(`Device type: ${isActuallySub ? 'SUBWOOFER' : 'SPEAKER'}`);
            console.log(`Target curve SPL: ${targetSPL.toFixed(1)}dB`);
            console.log(`Measurement SPL: ${freqSPL.toFixed(1)}dB`);
            console.log(`Calculated trim: ${(targetSPL - freqSPL).toFixed(1)}dB`);
          }
          const offset = targetSPL - freqSPL;
          return Math.round(offset * 2) / 2; // round to nearest 0.5dB
        }
        // Absolute reference
        return Math.round(freqSPL * 2) / 2;
      }

      // attempt to fix android volume bug where measurements are off by multiples of +/-6dB
      async function fixVolBug(indices) {
        if (indices.length <= 1) { return; }
        const measurements = await fetch_mREW();
        const mlpIdx = indices[0];
        const mlpVolume = measurements[mlpIdx].title.startsWith("SW") ? await getSubTrim(mlpIdx) : await getSpeakerTrim(mlpIdx);
        for (let i = 0; i < indices.length; i++) {
          if (indices[i] === mlpIdx) { continue; }
          const idxVolume = measurements[indices[i]].title.startsWith("SW") ? await getSubTrim(indices[i]) : await getSpeakerTrim(indices[i]);
          const delta = idxVolume - mlpVolume;
          if (Math.abs(delta) > 5) {
            const correction = Math.round(delta / 6) * 6;
            console.warn(`⚠ ${measurements[indices[i]].title} shifted by ${correction}dB due to a known MultEQ volume bug.`);
            await postNext('Add SPL offset', indices[i], { offset: correction });
          }
        }
      }

      async function getDynamicBassFill(idx) {
        // vs -from target curve (start and end)
        const startFreq = Math.round(await get3dBPoint(idx, modeSubXOMin, modeSubXOMax, { direction: 'low', reference: 'target', deviceType: 'sub' })); // NEW single 3dpoint function. Waiting for copy&paste
        const endFreq = Math.round(await get3dBPoint(idx, modeSubXOMin, modeSubXOMax, { direction: 'high', reference: 'target', deviceType: 'sub' })); // NEW single 3dpoint function. Waiting for copy&paste
        const subFreqResponse = await fetchSafe("frequency-response?smoothing=1/12&ppo=96", idx);
        const subArray = response2array(subFreqResponse, startFreq, endFreq);
        const targetArray = response2array(targetResponse, startFreq, endFreq);
        const arrayLength = Math.min(subArray.length, targetArray.length);
        let totalDips = 0;
        for (let i = 0; i < arrayLength; i++) {
          totalDips += Math.min(subArray[i] - targetArray[i], 0);
        }
        const dynamicBassFill = Math.round(-2 * (totalDips / arrayLength)) / 2; // round to nearest 0.5
        return dynamicBassFill;
      }

      async function alignWithREW(ind1, ind2, options = {}) {
        const {
          start = 20,
          end = 250,
          step = 1,
          loDelay = null,
          hiDelay = null,
          createSum = false,
          smoothing = '1/48',
          deleteSum = false  // align4system deletes, alignMsub keeps
        } = options;

        // Validate and correct frequency range (API requires 20 Hz)
        const validStart = Math.max(start, 20);
        const validEnd = Math.min(Math.max(end, validStart), 250);

        // Calculate delay range if not provided
        const [actualLoDelay, actualHiDelay] = loDelay !== null && hiDelay !== null
          ? [loDelay, hiDelay]
          : getDelayRangeOfFinalSub();

        console.info(`Available delay range: ${actualLoDelay.toFixed(2)}ms <-> ${actualHiDelay.toFixed(2)}ms`);

        let isInverted = false, isPossible = false, requiredDelay = NaN;
        let bestFreq = NaN, maxSum = -Infinity, sumIndex = null;
        let previousDelay = null;

        // Smooth measurements
        await postNext('Smooth', ind1, { smoothing });
        await postNext('Smooth', ind2, { smoothing });

        // Setup alignment tool
        await postSafe("http://localhost:4735/alignment-tool/index-a", ind1, "selected as measurement A");
        await postSafe("http://localhost:4735/alignment-tool/index-b", ind2, "selected as measurement B");
        await postAlign('Reset all');
        await postSafe("http://localhost:4735/alignment-tool/mode", "Impulse", "Mode set");
        await postSafe("http://localhost:4735/alignment-tool/max-negative-delay", actualLoDelay, "Maximum negative delay set to");
        await postSafe("http://localhost:4735/alignment-tool/max-positive-delay", actualHiDelay, "Maximum positive delay set to");

        console.info("Starting alignment optimization...");

        // Scan frequency range (use validated range)
        // for (let checkFreq = validStart; checkFreq <= validEnd; checkFreq++) {
        for (let checkFreq = validStart; checkFreq <= validEnd; checkFreq += step) {
          const postAlignResult = await postAlign('Align IRs', checkFreq);

          // Handle delay too large errors
          if (postAlignResult.message === 'Delay too large' && previousDelay != postAlignResult.delay) {
            previousDelay = postAlignResult.delay;
            continue;
          }

          const invertB = await fetchAlign('invert-b');
          const delayB = parseFloat(await fetchAlign('delay-b'));

          if (noInversion && invertB) continue;

          const tempSum = await fetchAlign(`aligned-frequency-response?smoothing=${smoothing}&ppo=96`);
          const tempSumArray = response2array(tempSum, validStart, validEnd);
          const tempMagSum = tempSumArray.reduce((acc, val) => acc + val, 0);

          if (maxSum < tempMagSum) {
            maxSum = tempMagSum;
            bestFreq = checkFreq;
            isPossible = true;
            requiredDelay = delayB;
            isInverted = invertB;
          }

          const bestDelayStr = isNaN(requiredDelay) ? "N/A" : requiredDelay.toFixed(2);
          const bestFreqStr = isNaN(bestFreq) ? "N/A" : bestFreq;
          console.infoUpdate(`Checking: @${checkFreq}Hz, Best: ${bestDelayStr}ms @${bestFreqStr}Hz Inverted: ${isInverted}`);
        }

        if (isPossible) {
          // Apply optimal alignment
          await postAlign('Align IRs', bestFreq);
          requiredDelay = parseFloat(await fetchAlign('delay-b'));
          isInverted = await fetchAlign('invert-b');

          if (createSum) {
            const alignedSum = await postAlign('Aligned sum');
            const parsed = JSON.parse(alignedSum.message);
            sumIndex = parseInt(Object.keys(parsed.results)[0]);

            if (deleteSum) {
              await postDelete(sumIndex);
            }
          }

          console.infoUpdate(`Optimal alignment: @${bestFreq}Hz, required delay: ${requiredDelay.toFixed(2)}ms, isInverted: ${isInverted}`);
        }

        return createSum
          ? [isPossible, requiredDelay, isInverted, sumIndex]
          : [isPossible, requiredDelay, isInverted];
      }

      // Wrapper for backward compatibility
      async function align4system(ind1, ind2) {
        return alignWithREW(ind1, ind2, { createSum: true, deleteSum: true, step: 0.1 });
      }

      // Wrapper for backward compatibility
      async function alignMsub(ind1, ind2, start, end, loDelay, hiDelay) {
        return alignWithREW(ind1, ind2, { start, end, loDelay, hiDelay, createSum: true, step: 0.1 });
      }

      async function generateFilteredMeasurement(idx, freq, filterType, options = {}) {
        const {
          filterIndex = 21,
          shape = filterType === 'HP' ? 'BU' : 'L-R',
          slope = filterType === 'HP' ? 12 : 24
        } = options;

        if (!freq) {
          return await postSafe(`${baseUrl}/${idx}/command`, { command: "Response copy" }, "Completed");
        }

        const filterConfig = {
          index: filterIndex,
          type: filterType === 'HP' ? "High pass" : "Low pass",
          enabled: true,
          isAuto: false,
          frequency: freq,
          shape: shape,
          slopedBPerOctave: slope
        };

        await postSafe(`${baseUrl}/${idx}/filters`, { filters: [filterConfig] }, "Filters set");
        return await postNext('Generate predicted measurement', idx);
      }

      // Wrappers for backward compatibility
      async function genSub(i, freq) {
        return generateFilteredMeasurement(i, freq, 'LP');
      }

      // Wrappers for backward compatibility
      async function genSpeaker(i, freq) {
        return generateFilteredMeasurement(i, freq, 'HP');
      }

      // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
      // PROPRIETARY NART!
      // CAN NOT BE USED WITHOUT EXPLICIT PERMISSION OF NVEXX !
      // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
      /* ==== */
      /* NART */
      // ═══════════════════════════════════════════════════════════════════════════
      // NART > ART-INSPIRED MULTI-SPEAKER BASS OPTIMIZATION
      // ═══════════════════════════════════════════════════════════════════════════
      // ───────────────────────────────────────────────────────────────────────────
      // HELPER: Extract phase data from REW response (moved from finalizeXO scope)
      // ───────────────────────────────────────────────────────────────────────────
      function response2arrayPhase(response, start, end) {
        if (!response.phase) {
          return null;
        }
        const bytes = Uint8Array.from(atob(response.phase), (c) => c.charCodeAt(0));
        const buffer = bytes.buffer;
        const data = new DataView(buffer);
        const phaseArray = [];
        const maxIndex = Math.floor(data.byteLength / 4) - 1;
        const startIndex = Math.round((start - 0.3662109375) / 0.3662109375);
        const endIndex = Math.min(Math.round((end - 0.3662109375) / 0.3662109375), maxIndex);

        for (let i = startIndex; i <= endIndex; i++) {
          if (i * 4 + 3 < data.byteLength) {
            phaseArray.push(data.getFloat32(i * 4));
          }
        }

        // REW has already unwrapped the phase trace - just return the values
        return phaseArray;
      }

      // ───────────────────────────────────────────────────────────────────────────
      // STEP 1: Enhanced Room Mode Detection (beyond SBIR boundary interference)
      // ───────────────────────────────────────────────────────────────────────────
      async function analyzeRoomModesEnhanced() {
        console.log("├─ ANALYZING ROOM MODES (Standing Waves)...");
        console.log("═".repeat(60));
        const roomModes = {
          axial: [],      // Between two parallel surfaces
          tangential: [], // Between four surfaces  
          oblique: [],    // Between all six surfaces
          speakers: {}    // Modal data per speaker
        };
        // Analyze each speaker's modal response
        for (let i = 1; i <= nSpeakers; i++) {
          const speakerId = commandId[i];
          console.info(`Analyzing ${speakerId} for room modes...`);
          // const response = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', i);
          const response = await fetchSafe("frequency-response?smoothing=1/48&ppo=96", i);
          const modes = await detectModalFrequencies(response, i);
          if (modes.length > 0) {
            roomModes.speakers[speakerId] = {
              speakerIndex: i,
              modes: modes,
              position: customDistance[i]
            };
            console.log(`├─ ${speakerId}: Found ${modes.length} modal frequencies`);
            modes.forEach(mode => {
              console.log(`   ├─ ${mode.frequency.toFixed(1)}Hz: ${mode.type}, ${mode.isPositive ? 'PEAK' : 'DIP'} ${Math.abs(mode.magnitude).toFixed(1)}dB`);
            });
          }
        }

        // Store globally for use by other functions
        window.detectedRoomModes = roomModes;

        console.log("");
        console.log("📊 ROOM MODE SUMMARY:");
        const allModes = Object.values(roomModes.speakers)
          .flatMap(s => s.modes)
          .map(m => m.frequency)
          .filter((f, i, arr) => arr.indexOf(f) === i)
          .sort((a, b) => a - b);

        console.log(`Total unique modal frequencies detected: ${allModes.length}`);
        if (allModes.length > 0) {
          console.log(`Frequency range: ${allModes[0].toFixed(1)}Hz - ${allModes[allModes.length - 1].toFixed(1)}Hz`);
        }

        return roomModes;
      }

      // Helper: Detect modal frequencies from response
      async function detectModalFrequencies(response, measurementIdx, start = 20, end = 150) {
        const fullResponse = response2array(response, start, end);
        const modes = [];
        let freq = start;
        const octave = Math.pow(2, 1 / 96);
        // Calculate average level for reference
        const avgLevel = fullResponse.reduce((sum, val) => sum + val, 0) / fullResponse.length;
        // Find peaks (positive modes) and dips (negative modes)
        for (let i = 2; i < fullResponse.length - 2; i++) {
          freq *= octave;
          // Look for local maxima (peaks)
          if (fullResponse[i] > fullResponse[i - 1] &&
            fullResponse[i] > fullResponse[i + 1] &&
            fullResponse[i] > fullResponse[i - 2] &&
            fullResponse[i] > fullResponse[i + 2] &&
            fullResponse[i] > avgLevel + 3) { // At least 3dB above average
            modes.push({
              frequency: freq,
              magnitude: fullResponse[i] - avgLevel,
              isPositive: true,
              type: classifyMode(freq),
              index: i
            });
          }
          // Look for local minima (dips)
          if (fullResponse[i] < fullResponse[i - 1] &&
            fullResponse[i] < fullResponse[i + 1] &&
            fullResponse[i] < fullResponse[i - 2] &&
            fullResponse[i] < fullResponse[i + 2] &&
            fullResponse[i] < avgLevel - 3) { // At least 3dB below average
            modes.push({
              frequency: freq,
              magnitude: fullResponse[i] - avgLevel,
              isPositive: false,
              type: classifyMode(freq),
              index: i
            });
          }
        }
        return modes;
      }

      // Classify mode type based on frequency
      function classifyMode(frequency) {
        if (frequency < 60) return 'axial';
        if (frequency < 100) return 'tangential';
        return 'oblique';
      }

      // ───────────────────────────────────────────────────────────────────────────
      // STEP 2: Multi-Speaker Bass Optimization (NART > ART-inspired)
      // ───────────────────────────────────────────────────────────────────────────
      async function optimizeMultiSpeakerBass() {
        console.log("");
        console.log("🔊 NART MULTI-SPEAKER BASS OPTIMIZATION");
        console.log("═".repeat(60));
        console.log("Analyzing which speakers can contribute to modal cancellation...");
        const roomModes = window.detectedRoomModes;
        if (!roomModes || Object.keys(roomModes.speakers).length === 0) {
          console.warn("⚠ No room mode data available - run analyzeRoomModesEnhanced() first");
          return;
        }
        const allOptimizationResults = {};
        // ═══════════════════════════════════════════════════════════════
        // LOOP THROUGH ALL SPEAKERS (but skip subwoofers - they only help)
        // ═══════════════════════════════════════════════════════════════
        for (let targetIdx = 1; targetIdx <= nSpeakers + nSubs; targetIdx++) {
          const targetId = commandId[targetIdx];
          // SKIP SUBWOOFERS - per matrix, subs only GIVE support, never RECEIVE it
          if (targetId.startsWith('SW')) {
            continue;
          }
          const targetGroup = getSpeakerGroup(targetId);
          if (!targetGroup) continue;
          console.log("");
          console.log(`╔═══════════════════════════════════════════════════╗`);
          console.log(`║  OPTIMIZING: ${targetId} (${targetGroup.displayName})`);
          console.log(`╚═══════════════════════════════════════════════════╝`);
          // ═══════════════════════════════════════════════════════════════
          // FIND ALL SPEAKERS THAT CAN SUPPORT THIS TARGET
          // ═══════════════════════════════════════════════════════════════
          const supportSpeakers = [];
          for (let supportIdx = 1; supportIdx <= nSpeakers + nSubs; supportIdx++) {
            // Skip checking speaker against itself
            if (supportIdx === targetIdx) continue;
            const supportId = commandId[supportIdx];
            const supportGroup = getSpeakerGroup(supportId);
            // Skip individual directional subs (they'll be combined) use nartXOs SW1 - Highest Low / Highest High 
            if (window.hasDirectionalBass &&
              window.preCombinedSubCount > 1 &&
              supportId.startsWith('SW') &&
              supportId !== 'SW1') {
              console.log(`├─ Skipping ${supportId} (${supportGroup.displayName}) - will be combined into SW1`);
              continue;
            }
            // Check matrix: Can this support speaker help the target?
            const requiredOffset = getNARTSupportOffset(targetId, supportId);
            // console.log(`[DEBUG - DEBUG] getNARTSupportOffset("${targetId}", "${supportId}") = ${requiredOffset}`);
            console.log(`  Target group: ${targetGroup?.displayName}, Support group: ${supportGroup?.displayName}`);
            if (requiredOffset === null) {
              // Matrix says this group cannot support the target
              // console.log(`├─ Skipping ${supportId} (${supportGroup.name}) - cannot support ${targetGroup.name}`);
              console.log(`├─ Skipping ${supportId} (${supportGroup.displayName}) - cannot support ${targetGroup.displayName}`);
              continue;
            }
            // ═══════════════════════════════════════════════════════════════
            // CHECK IF SUPPORT SPEAKER HAS SUFFICIENT BASS EXTENSION
            // ═══════════════════════════════════════════════════════════════
            const isSubwoofer = supportId.startsWith('SW');
            let lowPoint, highPoint;
            if (isSubwoofer) {
              // lowPoint = await getAbsLow3dBPointForSub(supportIdx, 20, 150);
              lowPoint = await get3dBPoint(supportIdx, 20, 150, { direction: 'low', reference: 'absolute', deviceType: 'sub', smoothing: '1/48' }); // NEW single 3dpoint function. Waiting for copy&paste  
              // highPoint = await getAbsHigh3dBPointForSub(supportIdx, 20, 150);
              highPoint = await get3dBPoint(supportIdx, 20, 150, { direction: 'high', reference: 'absolute', deviceType: 'sub', smoothing: '1/48' }); // NEW single 3dpoint function. Waiting for copy&past
            } else {
              // Use NART-specific bass capability check WITH speaker's ID
              const nartCapability = await getNARTBassCapability(supportIdx, supportId, requiredOffset);
              lowPoint = nartCapability.nartMin;
              highPoint = nartCapability.nartMax;
              console.log(`   NART range: ${nartCapability.nartMin.toFixed(0)}-${nartCapability.nartMax.toFixed(0)}Hz (from XO data)`);
              console.log(`   Capability at ${requiredOffset}dB threshold: ${nartCapability.lowExtension.toFixed(0)}Hz rolloff`);
              console.log(`   Bass reference: ${nartCapability.bassReference.toFixed(1)}dB`);
            }
            // Only include if speaker can play meaningfully in bass region
            if (highPoint >= 100) {
              supportSpeakers.push({
                index: supportIdx,
                commandId: supportId,
                lowExtension: lowPoint,
                highExtension: highPoint,
                type: isSubwoofer ? 'subwoofer' : 'speaker',
                threshold: requiredOffset
              });
              // console.log(`├─ ${supportId} (${supportGroup.name}): Bass capable with ${requiredOffset}dB threshold`);
              console.log(`├─ ${supportId} (${supportGroup.displayName}}): Bass capable with ${requiredOffset}dB threshold`);
              console.log(`   └─ Extension: ${lowPoint.toFixed(0)}Hz - ${highPoint.toFixed(0)}Hz`);
            }
          }
          // ═══════════════════════════════════════════════════════════════
          // CHECK IF WE FOUND ANY SUPPORT SPEAKERS
          // ═══════════════════════════════════════════════════════════════
          if (supportSpeakers.length === 0) {
            console.log(`└─ No support speakers found for ${targetId}`);
            continue;
          }
          console.log("");
          console.log(`✓ Found ${supportSpeakers.length} speakers that can support ${targetId}`);
          // ═══════════════════════════════════════════════════════════════
          // OPTIMIZE IN FREQUENCY BANDS (ART-style)
          // ═══════════════════════════════════════════════════════════════
          console.log("Calculating optimal multi-device alignment for modal control...");
          const optimizationResults = {
            '20-60Hz': await optimizeBassInBand(supportSpeakers, targetIdx, 20, 60, 'axial'),
            '60-100Hz': await optimizeBassInBand(supportSpeakers, targetIdx, 60, 100, 'tangential'),
            '100-150Hz': await optimizeBassInBand(supportSpeakers, targetIdx, 100, 150, 'oblique')
          };
          // Store results for this target speaker
          allOptimizationResults[targetId] = optimizationResults;
          // ═══════════════════════════════════════════════════════════════
          // DISPLAY RESULTS FOR THIS TARGET
          // ═══════════════════════════════════════════════════════════════
          console.log("");
          console.log(`📊 OPTIMIZATION RESULTS FOR ${targetId}:`);
          console.log("─".repeat(60));
          for (const [band, result] of Object.entries(optimizationResults)) {
            console.log(`${band}:`);
            console.log(`├─ Improvement: ${result.improvement.toFixed(1)}dB reduction in modal peaks`);
            console.log(`├─ Speakers contributing: ${result.contributingSpeakers.join(', ')}`);
            if (result.recommendedDelays && Object.keys(result.recommendedDelays).length > 0) {
              console.log(`├─ Recommended delay adjustments:`);
              for (const [spkr, delay] of Object.entries(result.recommendedDelays)) {
                console.log(`   ├─ ${spkr}: ${delay.toFixed(2)}ms`);
              }
            }
          }
        }
        // ═══════════════════════════════════════════════════════════════
        // STORE ALL RESULTS GLOBALLY
        // ═══════════════════════════════════════════════════════════════
        window.multiSpeakerBassOptimization = allOptimizationResults;
        console.log("");
        console.log("═".repeat(60));
        console.log("✓ NART multi-speaker bass optimization complete!");
        console.log("═".repeat(60));
        return allOptimizationResults;
      }

      async function applyModalCancellationDelays() {
        if (!window.multiSpeakerBassOptimization) {
          console.log("No modal cancellation delays to apply");
          return;
        }
        console.log("");
        console.log("🔧 APPLYING NART MODAL CANCELLATION DELAYS TO SPEAKERS");
        console.log("═".repeat(60));
        const optimization = window.multiSpeakerBassOptimization;
        const speakerDelays = {};
        // ═══════════════════════════════════════════════════════════════
        // ITERATE THROUGH EACH OPTIMIZED SPEAKER (TARGET)
        // ═══════════════════════════════════════════════════════════════
        for (const [targetCmd, bandResults] of Object.entries(optimization)) {
          console.log(`\nProcessing optimization results for ${targetCmd}:`);
          const targetPriority = getNARTPriority(targetCmd);
          if (!bandResults || typeof bandResults !== 'object') {
            console.warn(`  ⚠ No valid band results for ${targetCmd}`);
            continue;
          }
          // ═══════════════════════════════════════════════════════════════
          // ITERATE THROUGH EACH FREQUENCY BAND
          // ═══════════════════════════════════════════════════════════════
          for (const [band, result] of Object.entries(bandResults)) {
            console.log(`├─ ${band}:`);
            if (!result.recommendedDelays || Object.keys(result.recommendedDelays).length === 0) {
              console.log(`   └─ No delays recommended for this band`);
              continue;
            }
            console.log(`   ├─ Contributing speakers: ${result.contributingSpeakers.join(', ')}`);
            // ═══════════════════════════════════════════════════════════════
            // COLLECT DELAYS WITH HIERARCHICAL FILTERING
            // ═══════════════════════════════════════════════════════════════
            for (const [supportCmd, delayMs] of Object.entries(result.recommendedDelays)) {
              /*
              // Skip subwoofers - their alignment is handled separately
              if (supportCmd.startsWith('SW')) {
                console.log(`   ├─ ${supportCmd}: ${delayMs.toFixed(2)}ms - skipped (subwoofer)`);
                //continue;
              }
              */
              // Allow subwoofers to contribute to modal cancellation
              // (their inter-sub alignment is handled separately in Phase 2)
              if (supportCmd.startsWith('SW')) {
                // console.log(`   ├─ ${supportCmd}: ${delayMs.toFixed(2)}ms (subwoofer contributing to modal cancellation)`);
                console.log(`   ├─ ${supportCmd}: ${delayMs.toFixed(2)}ms (subwoofer contribution)`);
                // Continue with normal accumulation logic below
              }
              const supportPriority = getNARTPriority(supportCmd);
              // HIERARCHICAL RULE: Only adjust speaker if it has LOWER priority (higher number) than target
              // if (supportPriority <= targetPriority) {
              if (supportPriority >= targetPriority) {
                // console.log(`   ├─ ${supportCmd}: ${delayMs.toFixed(2)}ms - skipped (priority ${supportPriority} ≤ ${targetPriority} for ${targetCmd})`);
                console.log(`   ├─ ${supportCmd}: ${delayMs.toFixed(2)}ms - skipped (priority ${supportPriority} ≥ ${targetPriority} for ${targetCmd})`);
                continue;
              }
              // Find the speaker index
              const speakerIndex = commandId.findIndex((cmd, idx) => idx > 0 && cmd === supportCmd);
              if (speakerIndex > 0) {
                if (!speakerDelays[speakerIndex]) {
                  speakerDelays[speakerIndex] = {
                    commandId: supportCmd,
                    totalDelay: 0,
                    bandCount: 0,
                    helpingTargets: []
                  };
                }
                speakerDelays[speakerIndex].totalDelay += delayMs;
                speakerDelays[speakerIndex].bandCount += 1;
                if (!speakerDelays[speakerIndex].helpingTargets.includes(targetCmd)) {
                  speakerDelays[speakerIndex].helpingTargets.push(targetCmd);
                }
                console.log(`   ├─ ${supportCmd}: ${delayMs.toFixed(2)}ms (accumulated, helping ${targetCmd})`);
              }
            }
          }
        }
        console.log("");
        console.log("Applying accumulated delays to speaker measurements:");
        if (Object.keys(speakerDelays).length === 0) {
          console.log("└─ No delays to apply (hierarchical filtering removed all conflicts)");
          return;
        }
        for (const [speakerIndex, delayInfo] of Object.entries(speakerDelays)) {
          const idx = parseInt(speakerIndex);
          const avgDelay = delayInfo.totalDelay / delayInfo.bandCount;
          const avgDelaySeconds = avgDelay / 1000;
          console.log(`├─ ${delayInfo.commandId}:`);
          console.log(`   ├─ Average delay: ${avgDelay.toFixed(2)}ms (from ${delayInfo.bandCount} bands)`);
          console.log(`   ├─ Helping: ${delayInfo.helpingTargets.join(', ')}`);
          console.log(`   └─ Applying ${avgDelaySeconds.toFixed(6)}s offset`);
          // Store by commandId
          nartDelays[delayInfo.commandId] = avgDelaySeconds;
          // Apply delay to the speaker measurement
          await postNext('Offset t=0', idx, { offset: -avgDelaySeconds, unit: "seconds" });
          // Update the mSec array
          mSec[idx] += avgDelaySeconds;
        }
        console.log("");
        console.log("✓ Modal cancellation delays applied to speakers (hierarchical)");
        console.log("═".repeat(60));
      }

      async function optimizeBassInBand(supportSpeakers, targetIdx, startFreq, endFreq, modeType) {
        console.log(`Optimizing ${startFreq}-${endFreq}Hz (${modeType} modes) for ${commandId[targetIdx]}...`);
        const measurements = await fetch_mREW();
        const contributingSpeakers = [];
        const recommendedDelays = {};
        // ═══════════════════════════════════════════════════════════════
        // GET TARGET SPEAKER RESPONSE (the one we're trying to help)
        // ═══════════════════════════════════════════════════════════════
        // const targetResponse = await fetchSafe('frequency-response?smoothing=1%2F12&ppo=96', targetIdx);
        const targetResponse = await fetchSafe("frequency-response?smoothing=1/48&ppo=96", targetIdx);
        // VALIDATE RESPONSE DATA EXISTS
        if (!targetResponse || !targetResponse.magnitude) {
          console.warn(`⚠ No frequency response data available for ${commandId[targetIdx]}`);
          return {
            band: `${startFreq}-${endFreq}Hz`,
            modeType: modeType,
            improvement: 0,
            contributingSpeakers: [],
            recommendedDelays: {},
            baselineModalPeaks: 0
          };
        }
        // CREATE TARGET ARRAY (this was missing!)
        const targetArray = response2array(targetResponse, startFreq, endFreq);
        // CHECK IF WE GOT VALID DATA
        if (targetArray.length === 0) {
          console.warn(`⚠ No data in ${startFreq}-${endFreq}Hz range for ${commandId[targetIdx]}`);
          return {
            band: `${startFreq}-${endFreq}Hz`,
            modeType: modeType,
            improvement: 0,
            contributingSpeakers: [],
            recommendedDelays: {},
            baselineModalPeaks: 0
          };
        }
        const targetModalPeaks = calculateModalPeaks(targetArray);
        const targetGroup = getSpeakerGroup(commandId[targetIdx]);
        // console.log(`├─ Baseline: ${commandId[targetIdx]} (${targetGroup.name})`);
        console.log(`├─ Baseline: ${commandId[targetIdx]} (${targetGroup.displayName})`);
        console.log(`├─ Baseline modal peaks in band: ${targetModalPeaks.toFixed(1)}dB`);
        // ═══════════════════════════════════════════════════════════════
        // FILTER: Only test speakers whose LOW XO POINT is at or below band end
        // nartXOs
        // ═══════════════════════════════════════════════════════════════
        const capableSpeakers = supportSpeakers.filter(speaker => {
          const range = getSpeakerNARTRange(speaker.commandId);
          // Speaker can help if its LOW crossover point is at or below the band's END
          if (range.min > endFreq) {
            console.log(`├─ Skipping ${speaker.commandId}: Low XO ${range.min}Hz > band end ${endFreq}Hz`);
            return false;
          }
          // Calculate actual usable range within this band
          const usableMin = Math.max(range.min, startFreq);
          const usableMax = Math.min(150, endFreq);
          console.log(`├─ ${speaker.commandId} (${range.min}Hz XO): Can contribute ${usableMin.toFixed(0)}-${usableMax.toFixed(0)}Hz`);
          // Store usable range on the speaker object
          speaker.usableMin = usableMin;
          speaker.usableMax = usableMax;
          speaker.fullNARTRange = range;
          return true;
        })
        if (capableSpeakers.length === 0) {
          console.log(`└─ No speakers can contribute to ${startFreq}-${endFreq}Hz band`);
          return {
            band: `${startFreq}-${endFreq}Hz`,
            modeType: modeType,
            improvement: 0,
            contributingSpeakers: [],
            recommendedDelays: {},
            baselineModalPeaks: targetModalPeaks
          };
        }
        console.log(`├─ ${capableSpeakers.length} speakers can contribute to this band`);
        // *** END FILTER CODE nartXOs ***
        // ═══════════════════════════════════════════════════════════════
        // TEST EACH SUPPORT SPEAKER'S CONTRIBUTION
        // ═══════════════════════════════════════════════════════════════
        let bestImprovement = 0;
        // for (const speaker of supportSpeakers) {
        for (const speaker of capableSpeakers) {
          // Skip if device's range doesn't overlap the band at all
          if (speaker.highExtension < startFreq) {
            continue;
          }
          console.log(`├─ Testing ${speaker.commandId} (${speaker.type}) for modal cancellation...`);
          // const spkResponse = await fetchSafe('frequency-response?smoothing=1%2F12&ppo=96', speaker.index);
          const spkResponse = await fetchSafe("frequency-response?smoothing=1/48&ppo=96", speaker.index);
          // const spkArray = response2array(spkResponse, startFreq, endFreq);
          // Use speaker's usable range instead of full band
          const spkArray = response2array(spkResponse, speaker.usableMin, speaker.usableMax);
          // VALIDATE SUPPORT SPEAKER DATA
          if (spkArray.length === 0) {
            console.warn(`   ⚠ No data for ${speaker.commandId} in this band - skipping`);
            continue;
          }
          // ═══════════════════════════════════════════════════════════════
          // CALCULATE DELAY SEARCH RANGE (Physics + Hardware Constraints)
          // ═══════════════════════════════════════════════════════════════
          const phaseTests = [];
          const centerFreq = (startFreq + endFreq) / 2;
          const wavelengthMs = 1000 / centerFreq;
          // PHYSICS LIMIT: ±360° (full wavelength)
          let physicsMinMs = -wavelengthMs;
          let physicsMaxMs = wavelengthMs;
          // HARDWARE LIMIT: Get available delay range for this support speaker
          let hardwareMinMs, hardwareMaxMs;
          if (speaker.type === 'subwoofer') {
            // Subwoofers use different delay range calculation
            [hardwareMinMs, hardwareMaxMs] = getDelayRangeOfFinalSub();
          } else {
            // Regular speakers
            [hardwareMinMs, hardwareMaxMs] = getDelayRangeOf(mSec[speaker.index], 1, nSpeakers + nSubs);
          }
          // USE THE TIGHTER OF: Physics limit OR Hardware limit
          const searchMinMs = Math.max(physicsMinMs, hardwareMinMs);
          const searchMaxMs = Math.min(physicsMaxMs, hardwareMaxMs);
          // Check if hardware severely limits our search
          const hardwareLimited = (searchMaxMs - searchMinMs) < (wavelengthMs * 1.5);
          if (hardwareLimited) {
            console.warn(`   ⚠ ${speaker.commandId}: Hardware limits search to ${searchMinMs.toFixed(1)} to ${searchMaxMs.toFixed(1)}ms (physics allows ±${wavelengthMs.toFixed(1)}ms)`);
          }
          // ═══════════════════════════════════════════════════════════════
          // CALCULATE OPTIMAL STEP SIZE (Minimum 15° resolution)
          // ═══════════════════════════════════════════════════════════════
          const desiredDegreesPerStep = 15;  // Target resolution
          const minSteps = 24;  // Ensure at least this many test points
          // Calculate step size based on desired phase resolution
          let stepSizeMs = (desiredDegreesPerStep / 360) * wavelengthMs;
          // But ensure we have minimum number of steps across the range
          const rangeMs = searchMaxMs - searchMinMs;
          const stepsFromRange = Math.ceil(rangeMs / stepSizeMs);
          if (stepsFromRange < minSteps) {
            // Need finer resolution to get enough test points
            stepSizeMs = rangeMs / minSteps;
            const actualDegrees = (stepSizeMs / wavelengthMs) * 360;
            console.info(`   ├─ Adjusting resolution to ${actualDegrees.toFixed(1)}° (${minSteps} steps required)`);
          }
          // Final check: don't make steps too small (diminishing returns)
          const minStepMs = wavelengthMs / 72;  // 5° minimum
          if (stepSizeMs < minStepMs) {
            stepSizeMs = minStepMs;
            console.info(`   ├─ Capped at minimum step size: ${((minStepMs / wavelengthMs) * 360).toFixed(1)}°`);
          }
          console.info(`   ├─ Testing ${searchMinMs.toFixed(1)} to ${searchMaxMs.toFixed(1)}ms in ${stepSizeMs.toFixed(2)}ms steps`);
          console.info(`   ├─ Resolution: ${((stepSizeMs / wavelengthMs) * 360).toFixed(1)}° per step`);
          // Generate test points
          // for (let delayMs = -maxDelayMs; delayMs <= maxDelayMs; delayMs += stepSizeMs) {
          for (let delayMs = searchMinMs; delayMs <= searchMaxMs; delayMs += stepSizeMs) {
            const phaseAngle = (delayMs / wavelengthMs) * 360;
            const normalizedPhase = ((phaseAngle % 360) + 360) % 360;
            const isInversion = (normalizedPhase > 150 && normalizedPhase < 210);
            phaseTests.push({
              phase: phaseAngle,
              delay: delayMs,
              invert: isInversion
            });
          }
          console.info(`   ├─ Generated ${phaseTests.length} test points`);
          // Test each delay/phase combination
          for (const test of phaseTests) {
            // Simulate combined response
            const combinedArray = targetArray.map((val, idx) => {
              let spkContribution = spkArray[idx] || 0; // Handle array length mismatch
              if (test.invert) spkContribution *= -1;
              return val + spkContribution;
            });
            const combinedModalPeaks = calculateModalPeaks(combinedArray);
            const improvement = targetModalPeaks - combinedModalPeaks;
            if (improvement > bestImprovement) {
              bestImprovement = improvement;
              recommendedDelays[speaker.commandId] = test.delay;

              if (!contributingSpeakers.includes(speaker.commandId)) {
                contributingSpeakers.push(speaker.commandId);
              }
            }
          }
        }
        console.log(`└─ Best improvement: ${bestImprovement.toFixed(1)}dB with ${contributingSpeakers.length} devices`);
        return {
          band: `${startFreq}-${endFreq}Hz`,
          modeType: modeType,
          improvement: bestImprovement,
          contributingSpeakers: contributingSpeakers,
          recommendedDelays: recommendedDelays,
          baselineModalPeaks: targetModalPeaks
        };
      }

      function logSpeakerGroupConfiguration() {
        console.log("");
        console.log("🎯 NART SPEAKER GROUP CONFIGURATION:");
        console.log("═".repeat(60));
        for (const [groupKey, groupConfig] of Object.entries(SPEAKER_GROUPS)) {
          console.log(`\n${groupConfig.name}:`);
          console.log(`├─ Speakers: ${groupConfig.patterns.join(', ')}`);
          if (groupConfig.canBeSupportedBy.length > 0) {
            const supportNames = groupConfig.canBeSupportedBy.map(key => SPEAKER_GROUPS[key].name);
            console.log(`├─ Can be supported by: ${supportNames.join(', ')}`);
          } else {
            console.log(`├─ Can be supported by: None`);
          }
          if (groupConfig.canSupport.length > 0) {
            const supportNames = groupConfig.canSupport.map(key => SPEAKER_GROUPS[key].name);
            console.log(`└─ Can support: ${supportNames.join(', ')}`);
          } else {
            console.log(`└─ Can support: None (does not help other speakers)`);
          }
        }
        console.log("");
        console.log("═".repeat(60));
      }

      // Calculate sum of modal peaks (how "peaky" the response is)
      function calculateModalPeaks(responseArray) {
        const avgLevel = responseArray.reduce((sum, val) => sum + val, 0) / responseArray.length;
        let peakSum = 0;
        for (let i = 0; i < responseArray.length; i++) {
          const deviation = responseArray[i] - avgLevel;
          if (deviation > 0) { // Only count peaks
            peakSum += deviation;
          }
        }
        return peakSum / responseArray.length;
      }

      // ───────────────────────────────────────────────────────────────────────────
      // STEP 3: Frequency-Dependent Alignment (replaces/enhances optimizeSubDelay)
      // ───────────────────────────────────────────────────────────────────────────
      async function frequencyDependentAlignment() {
        if (noSub) {
          console.log("⚠ No subwoofer - skipping frequency-dependent alignment");
          return;
        }
        console.log("");
        console.log("🎛️ NART FREQUENCY-DEPENDENT ALIGNMENT");
        console.log("═".repeat(60));
        console.log("Using different alignment strategies per frequency band...");
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        // Define frequency bands with different alignment strategies
        const bands = [
          {
            name: "Deep Bass (20-40Hz)",
            start: 20,
            end: 40,
            strategy: "maximize_output",
            description: "Maximize total output (ignore phase)"
          },
          {
            name: "Low Bass (40-80Hz)",
            start: 40,
            end: 80,
            strategy: "phase_coherent",
            description: "Phase-coherent alignment (smoothness)"
          },
          {
            name: "Upper Bass (80-150Hz)",
            start: 80,
            end: 150,
            strategy: "precise_timing",
            description: "Precise timing alignment (localization)"
          }
        ];
        const alignmentResults = [];
        for (const band of bands) {
          console.log("");
          console.log(`${band.name}:`);
          console.log(`├─ Strategy: ${band.strategy}`);
          console.log(`├─ Goal: ${band.description}`);
          // Find the averaged measurements (created in groundWorks)
          let speakerIndices = [];
          const measurements = await fetch_mREW();
          for (let i = 1; i <= nSpeakers; i++) {
            const title = measurements[i]?.title;
            if (title && title.endsWith('o')) {  // Averaged measurements end with 'o'
              speakerIndices.push(i);
            }
          }
          console.warn(`⚠ [DEBUG] >> ├─ Found ${speakerIndices.length} averaged speaker measurements`);
          if (speakerIndices.length === 0) {
            console.warn("⚠ No speaker measurements found - skipping band");
            continue;
          }
          console.info(`├─ Using ${speakerIndices.length} speaker measurements`);
          const avgSpeaker = await postNext('Magn plus phase average', Array.from(speakerIndices));
          const avgSpeakerIdx = Object.keys(avgSpeaker.results)[0];
          // Find the subwoofer index
          let subIdx = nChannels;
          // If we have directional bass (multiple subs), use the first one for now
          if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
            subIdx = nSpeakers + 1; // First subwoofer
          }
          console.info(`├─ Using subwoofer index: ${subIdx}`);
          // Apply strategy-specific alignment
          let result;
          switch (band.strategy) {
            case "maximize_output":
              result = await alignForMaxOutput(avgSpeakerIdx, subIdx, band.start, band.end);
              break;
            case "phase_coherent":
              result = await alignForPhaseCoherence(avgSpeakerIdx, subIdx, band.start, band.end);
              break;
            case "precise_timing":
              result = await alignForPreciseTiming(avgSpeakerIdx, subIdx, band.start, band.end);
              break;
          }
          alignmentResults.push({
            band: band.name,
            frequency: `${band.start}-${band.end}Hz`,
            strategy: band.strategy,
            ...result
          });
          // Cleanup
          await postDelete(avgSpeakerIdx);
          console.log(`└─ Result: ${result.requiredDelay.toFixed(2)}ms delay, inverted: ${result.isInverted}`);
        }
        // Calculate weighted average delay (prioritize crossover region 60-100Hz)
        const weightedDelay = calculateWeightedDelay(alignmentResults);
        const finalInversion = alignmentResults.find(r => r.strategy === 'phase_coherent').isInverted;
        console.log("\n🎯 FINAL ALIGNMENT:");
        console.log(`├─ Weighted average delay: ${weightedDelay.toFixed(2)}ms`);
        console.log(`├─ Subwoofer inversion: ${finalInversion ? 'YES' : 'NO'}`);
        // ═══════════════════════════════════════════════════════════════════════════
        // CRITICAL: Handle directional vs standard bass differently
        // ═══════════════════════════════════════════════════════════════════════════
        if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
          console.log(`├─ Directional bass detected (${window.preCombinedSubCount} subs)`);
          console.log(`└─ System-level alignment will be applied AFTER subs are combined`);
          // STORE the alignment for later, don't apply now
          window.nartSubSystemAlignment = {
            delay: weightedDelay,
            inversion: finalInversion
          };
          console.log("✓ System-level sub alignment calculated (deferred until after combination)");
        } else {
          // Standard bass (single sub or already combined)
          console.log(`├─ Standard bass mode - applying alignment now`);
          const actualSubIdx = nChannels;
          if (finalInversion) {
            await postSafe(`${baseUrl}/${actualSubIdx}/command`,
              { command: "Invert" }, "Invert completed");
          }
          const subMoves = weightedDelay / delaymax;
          await postNext('Offset t=0', actualSubIdx,
            { offset: -subMoves, unit: "seconds" });
          mSec[nChannels] += subMoves;
          invertSub[nChannels] = finalInversion;
          console.log(`└─ Applied ${weightedDelay.toFixed(2)}ms delay, inverted: ${finalInversion}`);
        }
        console.log("");
        return { alignmentResults, finalDelay: weightedDelay, finalInversion };
      }

      // Strategy 1: Maximize output (vector sum magnitude)
      async function alignForMaxOutput(speakerIdx, subIdx, startFreq, endFreq) {
        console.info(`   Optimizing for maximum output...`);
        await postNext('Smooth', speakerIdx, { smoothing: "1/12" });
        await postNext('Smooth', subIdx, { smoothing: "1/12" });
        // Use appropriate delay range based on whether we have directional subs
        let loDelay, hiDelay;
        if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
          [loDelay, hiDelay] = getDelayRangeOf(mSec[nSpeakers + 1], 1, nSpeakers);
        } else {
          [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        }
        let maxOutput = -Infinity;
        let bestDelay = 0;
        let bestInvert = false;
        // Test delays
        // for (let testDelay = loDelay; testDelay <= hiDelay; testDelay += 0.5) {
        for (let testDelay = loDelay; testDelay <= hiDelay; testDelay += 0.25) {
          for (const invert of [false, true]) {
            if (noInversion && invert) continue;
            // Simulate alignment
            const output = await simulateAlignment(speakerIdx, subIdx, testDelay, invert, startFreq, endFreq);
            if (output > maxOutput) {
              maxOutput = output;
              bestDelay = testDelay;
              bestInvert = invert;
            }
          }
        }
        return {
          requiredDelay: bestDelay,
          isInverted: bestInvert,
          metric: maxOutput,
          metricName: "Total Output (dB)"
        };
      }

      // Strategy 2: Phase coherence (minimize phase variation)
      async function alignForPhaseCoherence(speakerIdx, subIdx, startFreq, endFreq) {
        console.info(`   Optimizing for phase coherence...`);
        await postNext('Smooth', speakerIdx, { smoothing: "1/12" });
        await postNext('Smooth', subIdx, { smoothing: "1/12" });
        await postSafe("http://localhost:4735/alignment-tool/index-a", speakerIdx, "selected as measurement A");
        await postSafe("http://localhost:4735/alignment-tool/index-b", subIdx, "selected as measurement B");
        await postAlign('Reset all');
        // Use appropriate delay range based on whether we have directional subs
        let loDelay, hiDelay;
        if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
          [loDelay, hiDelay] = getDelayRangeOf(mSec[nSpeakers + 1], 1, nSpeakers);
        } else {
          [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        }
        console.info(`   Raw delay range from getDelayRange: loDelay=${loDelay.toFixed(2)}ms, hiDelay=${hiDelay.toFixed(2)}ms`);
        // Clamp to REW's valid ranges
        const maxNegativeDelay = Math.max(-1000, Math.min(0, loDelay));
        const maxPositiveDelay = Math.min(1000, Math.max(0, hiDelay));
        console.info(`   Clamped for REW alignment: ${maxNegativeDelay.toFixed(2)}ms to +${maxPositiveDelay.toFixed(2)}ms`);

        // Warn if we had to clamp
        if (loDelay < -1000 || loDelay > 0) {
          console.warn(`   ⚠ loDelay (${loDelay.toFixed(2)}ms) was outside valid range [-1000, 0], clamped to ${maxNegativeDelay.toFixed(2)}ms`);
        }
        if (hiDelay < 0 || hiDelay > 1000) {
          console.warn(`   ⚠ hiDelay (${hiDelay.toFixed(2)}ms) was outside valid range [0, 1000], clamped to ${maxPositiveDelay.toFixed(2)}ms`);
        }

        await postSafe("http://localhost:4735/alignment-tool/mode", "Impulse", "Mode set");
        await postSafe("http://localhost:4735/alignment-tool/max-negative-delay", maxNegativeDelay, "Maximum negative delay set to");
        await postSafe("http://localhost:4735/alignment-tool/max-positive-delay", maxPositiveDelay, "Maximum positive delay set to");

        let bestPhaseCoherence = Infinity;
        let bestDelay = 0;
        let bestInvert = false;

        // Scan through band
        for (let checkFreq = startFreq; checkFreq <= endFreq; checkFreq += 2.5) {
          const postAlignResult = await postAlign('Align IRs', checkFreq);
          if (postAlignResult.message === 'Delay too large') continue;

          const invertB = await fetchAlign('invert-b');
          const delayB = parseFloat(await fetchAlign('delay-b'));

          if (noInversion && invertB) continue;

          // Measure phase coherence
          const tempSum = await fetchAlign("aligned-frequency-response?smoothing=1/12&ppo=96");
          const phaseCoherence = measurePhaseCoherence(tempSum, startFreq, endFreq);

          if (phaseCoherence < bestPhaseCoherence) {
            bestPhaseCoherence = phaseCoherence;
            bestDelay = delayB;
            bestInvert = invertB;
          }
        }

        return {
          requiredDelay: bestDelay,
          isInverted: bestInvert,
          metric: bestPhaseCoherence,
          metricName: "Phase Variation (degrees)"
        };
      }

      // Strategy 3: Precise timing (group delay alignment)
      async function alignForPreciseTiming(speakerIdx, subIdx, startFreq, endFreq) {
        console.info(`   Optimizing for precise timing...`);
        // Use group delay for precise timing alignment
        const speakerGD = await fetchSafe(`group-delay?smoothing=none`, speakerIdx);
        const subGD = await fetchSafe(`group-delay?smoothing=none`, subIdx);
        const spkGDArray = response2array(speakerGD, startFreq, endFreq);
        const subGDArray = response2array(subGD, startFreq, endFreq);
        // Calculate average group delay difference
        const avgGDDiff = spkGDArray.reduce((sum, val, idx) =>
          sum + (val - subGDArray[idx]), 0) / spkGDArray.length;
        const requiredDelay = avgGDDiff * 1000; // Convert to ms
        // Use appropriate delay range based on whether we have directional subs
        let loDelay, hiDelay;
        if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
          [loDelay, hiDelay] = getDelayRangeOf(mSec[nSpeakers + 1], 1, nSpeakers);
        } else {
          [loDelay, hiDelay] = getDelayRangeOfFinalSub();
        }
        // Constrain to available range
        const finalDelay = Math.max(loDelay, Math.min(hiDelay, requiredDelay));
        return {
          requiredDelay: finalDelay,
          isInverted: false,
          metric: Math.abs(avgGDDiff),
          metricName: "Group Delay Match (ms)"
        };
      }

      // Helper: Simulate alignment and return output level
      async function simulateAlignment(speakerIdx, subIdx, delay, invert, startFreq, endFreq) {
        // This is a simplified simulation - in practice you'd use REW's alignment tool
        const spkResponse = await fetchSafe("frequency-response?smoothing=1/12&ppo=96", speakerIdx);
        const subResponse = await fetchSafe("frequency-response?smoothing=1/12&ppo=96", subIdx);
        const spkArray = response2array(spkResponse, startFreq, endFreq);
        const subArray = response2array(subResponse, startFreq, endFreq);
        // Simplistic magnitude sum (real implementation would use complex math)
        let totalOutput = 0;
        for (let i = 0; i < spkArray.length; i++) {
          const spkMag = Math.pow(10, spkArray[i] / 20);
          let subMag = Math.pow(10, subArray[i] / 20);
          if (invert) subMag *= -1;

          const combined = spkMag + subMag;
          totalOutput += 20 * Math.log10(Math.abs(combined));
        }
        return totalOutput / spkArray.length;
      }

      // Helper: Measure phase coherence (lower is better)
      function measurePhaseCoherence(response, startFreq, endFreq) {
        const phaseArray = response2arrayPhase(response, startFreq, endFreq);
        if (!phaseArray) return Infinity;

        // Calculate phase slope variation (lower = more coherent)
        // For unwrapped phase, we want a smooth linear slope
        let sumSquaredDerivative = 0;
        const derivatives = [];

        for (let i = 1; i < phaseArray.length; i++) {
          const derivative = phaseArray[i] - phaseArray[i - 1];
          derivatives.push(derivative);
        }

        // Calculate standard deviation of phase derivative (measures linearity)
        const meanDerivative = derivatives.reduce((a, b) => a + b, 0) / derivatives.length;
        for (let i = 0; i < derivatives.length; i++) {
          const deviation = derivatives[i] - meanDerivative;
          sumSquaredDerivative += deviation * deviation;
        }

        const stdDev = Math.sqrt(sumSquaredDerivative / derivatives.length);

        console.info(`   ├─ Phase coherence: ${stdDev.toFixed(2)}° std dev (lower is better)`);

        return stdDev;
      }

      // Calculate weighted average delay (prioritize crossover region 60-100Hz)
      function calculateWeightedDelay(alignmentResults) {
        const weights = {
          "Deep Bass (20-40Hz)": 0.2,
          "Low Bass (40-80Hz)": 0.5,    // Highest weight - crossover region
          "Upper Bass (80-150Hz)": 0.3
        };
        let weightedSum = 0;
        let totalWeight = 0;
        for (const result of alignmentResults) {
          const weight = weights[result.band] || 0.33;
          weightedSum += result.requiredDelay * weight;
          totalWeight += weight;
        }
        return weightedSum / totalWeight;
      }

      // ═══════════════════════════════════════════════════════════════════════════
      // INTEGRATION HELPER: Modified optimizeSubDelay() replacement
      // ═══════════════════════════════════════════════════════════════════════════
      async function optimizeSubDelayART() {
        // extra mSec logging [Debug]
        //// logState('optimizeSubDelayART()', 'BEFORE - Starting NART Optimization', false);
        console.log("");
        console.log("╔═══════════════════════════════════════════════════════════════╗");
        console.log("║  NART > ART-INSPIRED OPTIMIZATION                             ║");
        console.log("╚═══════════════════════════════════════════════════════════════╝");
        console.log("");
        console.log("NART optimizes in TWO phases:");
        console.log("├─ Phase 1: Speakers contribute to modal cancellation");
        console.log("└─ Phase 2: Subs aligned to each other (happens in conversion)");
        console.log("");
        if (window.hasDirectionalBass && window.preCombinedSubCount > 1) {
          console.log(`├─ Detected ${window.preCombinedSubCount} directional subwoofers`);
          console.log("├─ Each sub will be optimized independently");
          console.log("└─ Then aligned to each other");
          console.log("");
        }
        // Step 1: Analyze room modes
        await analyzeRoomModesEnhanced();
        // Step 2: Optimize multi-speaker bass (speakers only, not inter-sub alignment)
        await optimizeMultiSpeakerBass();
        // Step 3: Frequency-dependent alignment (align sub system to speakers)
        await frequencyDependentAlignment();
        console.log("");
        console.log("✓ NART Phase 1 complete: Speakers optimized for modal control");
        console.log("✓ NART Phase 2: Sub inter-alignment will happen during conversion");
        console.log("═".repeat(60));
      }

      // ───────────────────────────────────────────────────────────────────────────
      // Convert directional bass AFTER ART optimization
      // ───────────────────────────────────────────────────────────────────────────
      async function convertDirectionalIfNeeded() {
        if (!window.hasDirectionalBass || window.preCombinedSubCount <= 1) {
          console.info("✓ No directional bass conversion needed");
          return;
        }
        console.log("");
        console.log("⚡ CONVERTING DIRECTIONAL BASS TO STANDARD (Post-Optimization)");
        console.log("═".repeat(60));
        if (window.nartOptimizationComplete) {
          console.log("├─ NART optimized speakers for modal cancellation");
          console.log("├─ Now combining directional subs with proper inter-sub alignment");
        } else {
          console.log("├─ Using traditional magnitude-based sub alignment");
        }
        console.log("");
        window.nartOptimizationComplete = true;
        await directional2standard();
        console.log("");
        console.log("✓ Directional bass conversion completed");
        console.log(`✓ Combined ${window.preCombinedSubCount} subs into coherent bass system`);
        console.log("═".repeat(60));
      }

      async function getNARTBassCapability(idx, speakerId, thresholdOverride = null) {
        // Get speaker's actual NART range (lowest XO point to 150Hz)
        const nartRange = getSpeakerNARTRange(speakerId);
        console.log(`├─ ${speakerId} NART range: ${nartRange.min.toFixed(0)}Hz (low XO) → 150Hz`);
        const response = await fetchSafe('frequency-response?smoothing=1/48&ppo=96', idx);
        // TEST FROM SPEAKER'S LOW XO POINT TO 150Hz
        const rpArray = response2array(response, nartRange.min, 150);
        if (rpArray.length === 0) {
          console.warn(`⚠ No data available for ${speakerId} in ${nartRange.min}-150Hz range`);
          return {
            lowExtension: nartRange.min,
            highExtension: 150,
            bassReference: 0,
            nartMin: nartRange.min,
            nartMax: 150,
            capable: false
          };
        }
        // Use middle section of speaker's range as reference
        const refMin = nartRange.min + (150 - nartRange.min) * 0.3;
        const refMax = nartRange.min + (150 - nartRange.min) * 0.7;
        const bassRefArray = response2array(response, refMin, refMax);
        if (bassRefArray.length === 0) {
          console.warn(`⚠ No reference data for ${speakerId}`);
          return {
            lowExtension: nartRange.min,
            highExtension: 150,
            bassReference: 0,
            nartMin: nartRange.min,
            nartMax: 150,
            capable: false
          };
        }
        const bassRefSPL = bassRefArray.reduce((acc, val) => acc + val, 0) / bassRefArray.length;
        const threshold = thresholdOverride !== null ? thresholdOverride : -3;
        let rolloff = nartRange.min;
        const octave = Math.pow(2, 1 / 96);
        // Find where bass drops below threshold
        for (let i = 0; i < rpArray.length; i++) {
          if ((rpArray[i] - bassRefSPL) >= threshold) { break; }
          rolloff *= octave;
        }
        const capable = (rolloff <= nartRange.min * 1.2); // Passes if rolloff is near the start
        return {
          lowExtension: Math.min(rolloff, 150),
          highExtension: 150, // Always 150Hz for NART
          bassReference: bassRefSPL,
          nartMin: nartRange.min,
          nartMax: 150,
          capable: capable
        };
      }

      // NART-specific range capability check uses nartXOs
      function getSpeakerNARTRange(speakerId) {
        if (!window.nartXOs || nartXOs.length === 0) {
          console.warn(`⚠ nartXOs not populated yet for ${speakerId}`);
          return { min: 20, max: 150 }; // Fallback
        }
        // Find this speaker's entry in nartXOs
        const entry = nartXOs.find(row => row[0] === speakerId);
        if (!entry) {
          // Updated for SW's as we only want combined SW1
          if (!["SW2", "SW3", "SW4"].includes(speakerId)) {
            console.warn(`⚠ ${speakerId} not found in nartXOs array`);
            return { min: 20, max: 150 }; // Fallback
          }
        }
        const freq1 = parseFloat(entry[1]);
        const freq2 = parseFloat(entry[2]);
        // ALWAYS use the LOWEST frequency as the start point
        const minFreq = Math.min(freq1, freq2);
        // ALWAYS use 150Hz as the end point (NART system limit)
        const maxFreq = 150;
        return {
          min: minFreq,
          max: maxFreq,
          originalCrossover: { low: freq1, high: freq2 },
          layer: entry[3]
        };
      }
      /* ==== */
      /* NART */
      // ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
      // PROPRIETARY NART! 
      // CAN NOT BE USED WITHOUT EXPLICIT PERMISSION OF NVEXX !
      // ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

      async function drawResults() {
        console.log("Generating expected final outputs for each channel...");
        console.info("Starting...");
        for (let i = 1; i <= nSpeakers; i++) {
          console.infoUpdate(`Generating final output for channel - ${commandId[i]}`);
          const isLarge = customCrossover[i] === "L";
          let finalResponseName = commandId[i] + "final";
          finalResponseName += (commandId[i] === "C" && AdvancedFilters && AdvancedFiltersType === "DIALOGadvanced") ? "-ADF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "HLOSSresearch") ? "-AHF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "HLOSSmoderate") ? "-AHF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "HLOSSsevere") ? "-AHF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "HLOSSoriginal") ? "-AHF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "GAMINGcompetitive") ? "-AGF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "GAMINGimmersive") ? "-AGF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "GAMINGvoice") ? "-AGF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "GAMINGbalanced") ? "-AGF" : "";
          finalResponseName += (AdvancedFilters && AdvancedFiltersType === "CUSTOMadvanced") ? "-ACF" : "";
          finalResponseName += isLarge ? "-Large" : `-${customCrossover[i]}hz-xo`;
          const eqSpeaker = nChannels + 2 * i;
          const spWithHPF = await genSpeaker(eqSpeaker, customCrossover[i]);
          const spWithHPFIdx = (isLarge ? nChannels * 3 + i : Object.keys(spWithHPF.results)[0]);
          if (noSub) {
            await fetch_mREW(spWithHPFIdx, 'PUT', { title: finalResponseName });
            continue;
          }
          const subWithLPF = await genSub(nChannels * 3, customCrossover[i]);
          const subWithLPFIdx = Object.keys(subWithLPF.results)[0];
          const finalResponse = await postNext('Arithmetic', [spWithHPFIdx, subWithLPFIdx], { function: "A + B" });
          const finalResponseIdx = Object.keys(finalResponse.results)[0];
          await fetch_mREW(finalResponseIdx, 'PUT', { title: finalResponseName });
          await postDelete(subWithLPFIdx);
          await postDelete(spWithHPFIdx);
        }
        if (!noSub) {
          console.infoUpdate("Generating final output for channel - LFE");
          const LFEChannel = await genSub(nChannels * 3, 120);
          const LFEChannelIdx = Object.keys(LFEChannel.results)[0];
          await fetch_mREW(LFEChannelIdx, 'PUT', { title: "LFEfinal-120hz-LPF" });
        }
        // await fetchSafe('target-level', nChannels * 3, 75.0);
        await fetchSafe('target-level', nChannels * 3, targetLevel);
        const targetCurve = await postNext('Generate target measurement', nChannels * 3);
        const targetCurveIdx = Object.keys(targetCurve.results)[0];
        // const targetName = (targetCurveName === "" ? "TC-DEQ" : targetCurveName) + " @ 75dB";
        const targetName = `${targetCurveName === "" ? "TC-DEQ" : targetCurveName} @ ${String(targetLevel)}dB`;
        await fetch_mREW(targetCurveIdx, 'PUT', { title: targetName });
        // room curve no longer needed. keeping it enabled will only confuse on next run
        if (targetCurveName === "") { await disableRoomCurve(); }
        // use 1/6 smoothing for results
        const measurements = await fetch_mREW();
        const mCount = Object.keys(measurements).length;
        for (let i = 1; i <= mCount; i++) {
          titleM = await fetch_mREW(i);
          const title = titleM.title;
          // if (title.endsWith("-filters") || title.endsWith(" @ 75dB")) { continue; }
          if (title.endsWith("-filters") || title.endsWith(` @ ${String(targetLevel)}dB`)) { continue; }
          await postNext('Smooth', i, { smoothing: "1/6" });
        }
        console.infoUpdate("Completed generating final outputs for all channels!");
      }

      async function updateAdy() {
        console.log("Starting ADY file processing...");
        function estimatePlaybackLevelSpeakers(dataView) {
          let avgSensitivity = 0;
          let count = 0;
          // Sample from middle range (mid frequencies)
          const maxSafeIndex = Math.floor(dataView.byteLength / 4) - 1;
          const startIndex = Math.min(200, maxSafeIndex);
          const endIndex = Math.min(800, maxSafeIndex);
          for (let k = startIndex; k <= endIndex; k++) {
            const value = dataView.getFloat32(k * 4);
            if (Number.isFinite(value) && Math.abs(value) < 100) {
              avgSensitivity += value;
              count++;
            }
          }
          avgSensitivity = count > 0 ? avgSensitivity / count : 0;
          return targetLevel + avgSensitivity;
        }
        function estimatePlaybackLevelSubwoofer(dataView) {
          let avgSensitivity = 0;
          let count = 0;
          // Sample from early indices (low frequencies are typically first)
          const maxSafeIndex = Math.floor(dataView.byteLength / 4) - 1;
          const endIndex = Math.min(50, maxSafeIndex); // Sample first 50 points for bass
          for (let k = 0; k <= endIndex; k++) {
            const value = dataView.getFloat32(k * 4);
            if (Number.isFinite(value) && Math.abs(value) < 100) {
              avgSensitivity += value;
              count++;
            }
          }
          avgSensitivity = count > 0 ? avgSensitivity / count : 0;
          return targetLevel + avgSensitivity;
        }
        for (let i = 1; i <= nSpeakers; i++) {
          if (customCrossover[i] === "L") { continue; };
          if (customCrossover[i] > 90) { customCrossover[i] /= 10; }
        }
        const jsonData = JSON.parse(adyContents);
        if (bassMode === "Directional") {
          let ii = 54;
          for (let i = nChannels - 1; i < jsonData.detectedChannels.length; i++) {
            const swChannel = jsonData.detectedChannels[i];
            swChannel.enChannelType = ii;
            ii++;
            if (swChannel.customCrossover) { delete swChannel.customCrossover };
            if (swChannel.customSpeakerType) { delete swChannel.customSpeakerType };
            if (swChannel.customTargetCurvePoints && (i != (nChannels - 1))) { delete swChannel.customTargetCurvePoints };
          }
        }
        jsonData.dynamicVolume = false;
        jsonData.lfc = false;
        jsonData.dynamicEq = (targetCurveName === "");
        jsonData.enTargetCurveType = 1;
        jsonData.detectedChannels.forEach((channel, index) => {
          const responseData = channel.responseData;
          const zerosArray = Array(16383).fill("0");
          zerosArray.unshift("1");
          let count = 0;
          for (const arrayKey in responseData) {
            if (responseData.hasOwnProperty(arrayKey)) {
              if (isCirrusLogic) {
                responseData[arrayKey] = antiMicCal;
              } else {
                responseData[arrayKey] = zerosArray;
              }
              if (count >= 3) {
                delete responseData[arrayKey];
              }
              count++;
            }
          }
          if (index > nSpeakers) {
            channel.responseData = {};
          }
        });
        const octave = Math.pow(2, 1 / 96);
        // Enhanced speaker processing with logging
        console.log("Processing main speakers...");
        for (let i = 1; i <= nSpeakers; i++) {
          const fltArray = [];
          const fltResponse = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', 2 * i + (nChannels - 1));
          const bytes = Uint8Array.from(atob(fltResponse.magnitude), c => c.charCodeAt(0));
          const buffer = bytes.buffer;
          const data = new DataView(buffer);
          // Estimate playback level and store in array (500-2000 Hz for speakers)
          const estimatedLevel = estimatePlaybackLevelSpeakers(data);
          console.log(`Speaker ${commandId[i]}: Estimated playback level ${estimatedLevel.toFixed(1)}dB`);
          // Store speaker ID and estimated level
          estimatedPlaybackLevels.push([commandId[i], estimatedLevel.toFixed(1)]);
          let freq = fltResponse.startFreq;
          for (let k = 0; k <= 1531; k++) {
            const fltMagnitude = data.getFloat32(k * 4);
            fltArray.push([freq, fltMagnitude + antiHFRolloff[k]]);
            freq *= octave;
          }
          // Store original values for logging
          const originalLevel = customLevel[i];
          const finalLevel = customLevel[i];
          const customTargetCurvePoints = fltArray.map(point => `{${point[0]}, ${point[1]}}`);
          const thisChannel = jsonData.detectedChannels.find(channel => channel.commandId === commandId[i]);
          thisChannel.customTargetCurvePoints = customTargetCurvePoints;
          thisChannel.midrangeCompensation = false;
          thisChannel.frequencyRangeRolloff = 20000;
          thisChannel.customLevel = customLevel[i].toFixed(1);
          thisChannel.customDistance = customDistance[i];
          thisChannel.customCrossover = customCrossover[i] === "L" ? "F" : String(customCrossover[i]);
          thisChannel.customSpeakerType = customCrossover[i] === "L" ? "L" : "S";
          thisChannel.channelReport.customEnSpeakerConnect = customCrossover[i] === "L" ? 2 : 1;
          // Enhanced logging
          console.warn(`⚠ Speaker ${commandId[i]}: FINAL TRIM VALUES: ${finalLevel.toFixed(1)}dB`);
          console.warn(`⚠ Speaker ${commandId[i]}: Distance: ${customDistance[i]}m, Crossover: ${thisChannel.customCrossover}, Type: ${thisChannel.customSpeakerType}`);
        }
        // Enhanced subwoofer processing with logging
        if (!noSub) {
          console.log("Processing subwoofer(s)...");
          const subArray = [];
          const subResponse = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', nChannels * 3 - 1);
          const bytesSub = Uint8Array.from(atob(subResponse.magnitude), c => c.charCodeAt(0));
          const bufferSub = bytesSub.buffer;
          const dataSub = new DataView(bufferSub);
          // Estimate subwoofer playback level and store in array (30-80 Hz for subwoofers)
          const subEstimatedLevel = estimatePlaybackLevelSubwoofer(dataSub);
          console.log(`Subwoofer: Estimated playback level ${subEstimatedLevel.toFixed(1)}dB`);
          estimatedPlaybackLevels.push(["Subwoofer", subEstimatedLevel.toFixed(1)]);
          let freq = subResponse.startFreq;
          for (let k = 0; k <= 1531; k++) {
            const subMagnitude = dataSub.getFloat32(k * 4);
            subArray.push([freq, subMagnitude]);
            freq *= octave;
          }
          const customTargetCurvePointsSub = subArray.map(point => `{${point[0]}, ${point[1]}}`);
          const subChannel = jsonData.detectedChannels[nChannels - 1];
          subChannel.customTargetCurvePoints = customTargetCurvePointsSub;
          let k = 0;
          for (let channel of jsonData.detectedChannels) {
            if (channel.commandId.startsWith("SW")) {
              const customDistanceValue = parseFloat(customDistance[nChannels + k]) - parseFloat(channel.delayAdjustment);
              const originalSubLevel = parseFloat(customLevel[nChannels + k]) + parseFloat(channel.trimAdjustment);
              let customLevelValue = originalSubLevel;
              channel.customDistance = Math.round(parseFloat(customDistanceValue) * 100) / 100;
              channel.customLevel = customLevelValue.toFixed(1);
              channel.frequencyRangeRolloff = 250;
              // Enhanced subwoofer logging
              console.warn(`⚠ ${channel.commandId}: FINAL TRIM VALUES: ${customLevelValue.toFixed(1)}dB`);
              console.warn(`⚠ ${channel.commandId}: Distance: ${channel.customDistance}m`);
              if (bassMode === "Directional") { k++ };
            }
          }
          if (bassMode === "Directional") {
            jsonData.subwooferLayout = "N/A";
            sOs === 343 ? jsonData.subwooferMode = "Standard" : jsonData.subwooferMode = "N/A";
          }
        }
        // LOG THE COLLECTED PLAYBACK LEVELS ARRAY
        console.log("Estimated Playback Levels Array:", estimatedPlaybackLevels);
        console.log("Array contents:");
        estimatedPlaybackLevels.forEach((item, index) => {
          console.log(`${index}: Speaker ${item[0]} = ${item[1]}dB`);
        });
        const ady = JSON.stringify(jsonData);
        const blob = new Blob([ady], { type: 'application/json' });
        const urlBlob = URL.createObjectURL(blob);
        let downloadLink;
        let downloadFileName;
        try {
          downloadLink = document.createElement("a");
          const now = new Date();
          const year = now.getFullYear();
          const month = String(now.getMonth() + 1).padStart(2, '0');
          const day = String(now.getDate()).padStart(2, '0');
          const hours = String(now.getHours()).padStart(2, '0');
          const minutes = String(now.getMinutes()).padStart(2, '0');
          const timestamp = `${year}-${month}${day}-${hours}${minutes}`;
          const tcName = targetCurveName === "" ? "DEQ" : targetCurveName;
          downloadLink.href = urlBlob;
          downloadFileName = getadyName(fileName, "_"
            + (AdvancedFiltersType === "DIALOGadvanced" ? "ADF_" : "")
            + (AdvancedFiltersType === "HLOSSresearch" ? "AHF_" : "")
            + (AdvancedFiltersType === "HLOSSmoderate" ? "AHF_" : "")
            + (AdvancedFiltersType === "HLOSSsevere" ? "AHF_" : "")
            + (AdvancedFiltersType === "HLOSSoriginal" ? "AHF_" : "")
            + (AdvancedFiltersType === "GAMINGcompetitive" ? "AGF_" : "")
            + (AdvancedFiltersType === "GAMINGimmersive" ? "AGF_" : "")
            + (AdvancedFiltersType === "GAMINGvoice" ? "AGF_" : "")
            + (AdvancedFiltersType === "GAMINGbalanced" ? "AGF_" : "")
            + (AdvancedFiltersType === "CUSTOMadvanced" ? "ACF_" : "")
            + (isRP22mode ? "RP22_" : "")
            + (isDolbymode ? "DOLBY_" : "")
            + (isTHXmode ? "THX_" : "")
            + (isIMAXmode ? "IMAX_" : "")
            + swInvMsg + `${tcName}_ClariQNext_${timestamp}.ady`);
          downloadLink.download = downloadFileName;
          downloadLink.style.display = "none";
          document.body.appendChild(downloadLink);
          downloadLink.click();
          document.body.removeChild(downloadLink);
        } finally {
          // Cleanup with a small delay to ensure download starts
          setTimeout(() => URL.revokeObjectURL(urlBlob), 300);
        }
        console.log("Processing completed successfully!");
        console.log(`ADY file generated: ${downloadFileName}`);  // Use downloadFileName instead
        // RETURN THE ARRAY IF NEEDED
        return estimatedPlaybackLevels;
      }

      async function fetch_mREW(indice = null, method = 'GET', _body = null) {
        await platformDelay();  // Use your new helper
        let body;
        let requestUrl;
        if (indice === null) {
          requestUrl = baseUrl;
        } else {
          requestUrl = baseUrl + `/${indice}`;
        }
        if (method === 'PUT') {
          body = _body;
        }
        // Keep the exact same retry logic
        const maxRetries = 10;
        let retryCount = 0;
        while (retryCount < maxRetries) {
          try {
            const response = await fetch(requestUrl, {
              method: method,
              headers: { 'Content-Type': 'application/json' },
              body: body ? JSON.stringify(body) : null
            });

            if (!response.ok) {
              retryCount++;
              if (retryCount >= maxRetries) {
                throw new Error(`Max retries reached. Status: ${response.status}`);
              }
              await delay(retryDelay);  // Use your delay helper
            } else {
              const data = await response.json();
              return data;
            }
          } catch (error) {
            retryCount++;
            if (retryCount >= maxRetries) {
              throw new Error(`Network error after ${maxRetries} attempts: ${error.message}`);
            }
            await delay(retryDelay);  // Use your delay helper
          }
        }
      }

      async function fetchSafe(extUrl, indice, parameters = null) {
        await platformDelay();
        const requestUrl = `${baseUrl}/${indice}/${extUrl}`;
        let options;
        if (parameters === null) {
          options = {
            method: 'GET'
          };
        } else {
          options = {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(parameters)
          };
        }
        const maxRetries = 10;
        let retryCount = 0;
        while (retryCount < maxRetries) {
          try {
            const response = await safeFetch(requestUrl, options);

            if (!response.ok) {
              retryCount++;
              if (retryCount >= maxRetries) {
                throw new Error(`Max retries reached. Status: ${response.status}`);
              }
              await new Promise(resolve => setTimeout(resolve, retryDelay));
            } else {
              const data = await response.json();
              return data;
            }
          } catch (error) {
            retryCount++;
            if (retryCount >= maxRetries) {
              throw new Error(`Network error after ${maxRetries} attempts: ${error.message}`);
            }
            await new Promise(resolve => setTimeout(resolve, retryDelay));
          }
        }
      }

      async function fetchAlign(extUrl) {
        await platformDelay();
        try {
          const requestUrl = `http://localhost:4735/alignment-tool/${extUrl}`;
          const response = await fetch(requestUrl, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }
          const data = await response.json();
          return data;
        } catch (error) {
          throw new Error('Error fetching result:', error);
        }
      }

      async function postNext(processName, indices, parameters = null) {
        await platformDelay();  // Use your new helper
        let requestUrl;
        let body;
        if (Array.isArray(indices)) {
          requestUrl = `${baseUrl}/process-measurements`;
        } else {
          requestUrl = parameters === null ? `${baseUrl}/${indices}/eq/command` : `${baseUrl}/${indices}/command`;
        }
        if (requestUrl.endsWith('/command')) {
          body = { command: processName };
        } else {
          body = { processName: processName };
        }
        if (parameters != null) {
          body = { ...body, parameters: parameters };
        }
        if (Array.isArray(indices)) {
          body = { ...body, measurementIndices: indices };
        }
        const fetchData = async () => {
          const response = await fetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });
          if (!response.ok) {
            throw new Error('Network response was not OK!');
          }
          const data = await response.json();
          return data;
        }
        const checkResponse = async (data) => {
          if (data.message && data.message.includes('ompleted')) {
            const resultUrl = `${baseUrl}/process-result`;
            const resultResponse = await fetch(resultUrl);
            if (!resultResponse.ok) {
              throw new Error('Failed to fetch result data!');
            }
            const resultData = await resultResponse.json();
            return resultData;
          } else if (data.message.includes('in progress') || data.message.includes('running')) {
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
            return checkResponse(await fetchData());
          } else {
            return data;
          }
        }
        try {
          const data = await fetchData();
          const result = await checkResponse(data);
          return result;
        } catch (error) {
          throw new Error('Error fetching result:', error);
        }
      }

      async function postSafe(requestUrl, parameters, message) {
        await platformDelay();  // Use your new helper
        const fetchData = async () => {
          const response = await fetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(parameters),
          });
          if (!response.ok) {
            throw new Error('Network response was not OK!');
          }
          const data = await response.json();
          return data;
        }
        const checkResponse = async (data) => {
          if (data.message.includes(message)) {
            return data;
          } else if (data.message.includes('in progress') || data.message.includes('running')) {
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
            return checkResponse(await fetchData());
          } else {
            throw new Error(`Unexpected response: ${data.message}`);
          }
        }
        try {
          const data = await fetchData();
          const result = await checkResponse(data);
          return result;
        } catch (error) {
          throw new Error('Error fetching result:', error);
        }
      }

      async function postAlign(processName, frequency = null) {
        await platformDelay();
        const requestUrl = `http://localhost:4735/alignment-tool/command`;
        const body = { command: processName };
        if (frequency != null) {
          body.frequency = frequency;
        }
        try {
          const response = await safeFetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });
          const responseText = await response.text();
          if (!response.ok) {
            let errorData;
            try {
              errorData = JSON.parse(responseText);
            } catch (parseError) {
              throw new Error(`Network response was not OK! Status: ${response.status}`);
            }
            if (errorData.message) {
              let parsedMessage;
              try {
                parsedMessage = JSON.parse(errorData.message);
              } catch (parseError) {
                throw new Error('Failed to parse the error message');
              }
              if (parsedMessage.results &&
                parsedMessage.results[0] &&
                parsedMessage.results[0].Error) {
                const errorMessage = parsedMessage.results[0].Error;
                // More robust regex that works across all browsers
                const delayMatch = errorMessage.match(/delay required to align the responses.*?(-?[\d.]+)\s*ms/);

                if (delayMatch) {
                  return {
                    message: 'Delay too large',
                    error: errorMessage,
                    delay: parseFloat(delayMatch[1])
                  };
                }
              }
            }
            throw new Error(`Network response was not OK! Status: ${response.status}`);
          }
          let data;
          try {
            data = JSON.parse(responseText);
          } catch (parseError) {
            throw new Error('Failed to parse the response data');
          }
          if (data.message && data.message.includes('completed')) {
            const resultUrl = `http://localhost:4735/alignment-tool/result`;
            const resultResponse = await safeFetch(resultUrl);
            if (!resultResponse.ok) {
              throw new Error('Failed to fetch result data!');
            }
            const resultData = await resultResponse.json();
            if (resultData.results &&
              resultData.results[0] &&
              resultData.results[0].Error) {
              const errorMessage = resultData.results[0].Error;
              const delayMatch = errorMessage.match(/delay required to align the responses.*?(-?[\d.]+)\s*ms/);

              if (delayMatch) {
                return {
                  message: 'Delay too large',
                  error: errorMessage,
                  delay: parseFloat(delayMatch[1])
                };
              }
            }
            return resultData;
          }
          return data;
        } catch (error) {
          console.error('🞮 Error in postAlign:', error);
          throw error;
        }
      }

      async function postDelete(indice) {
        await platformDelay();  // Use your new helper
        const mDeleted = `Measurement ${indice} deleted`;
        while (true) {  // This infinite loop is intentional!
          try {
            const response = await fetch(`${baseUrl}/${indice}`, {
              method: 'DELETE',
              headers: { 'Content-Type': 'application/json' },
            });
            if (!response.ok) {
              throw new Error('Network response was not OK!');
            }
            const data = await response.json();
            if (data.message === mDeleted) {
              return indice;
            } else {
              await new Promise(resolve => setTimeout(resolve, retryDelay));
            }
          } catch (error) {
            throw new Error('Error fetching result:', error);
          }
        }
      }

      async function enableBlock() {
        await fetch('http://localhost:4735/application/blocking', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: true
        });
      }

      async function disableBlock() {
        await fetch('http://localhost:4735/application/blocking', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: false
        });
      }

      async function enableGraph() {
        await fetch('http://localhost:4735/application/inhibit-graph-updates', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: false
        });
      }

      async function disableGraph() {
        await fetch('http://localhost:4735/application/inhibit-graph-updates', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: true
        });
      }

      async function clearCommands() {
        const body = { command: 'Clear command in progress' };
        await fetch('http://localhost:4735/application/command', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
      }

      // Better platform detection
      function isWindowsPlatform() {
        try {
          // Multiple fallbacks for platform detection
          const userAgent = navigator.userAgent || '';
          const platform = navigator.platform || '';
          return userAgent.includes('Windows') ||
            platform.includes('Win') ||
            platform.startsWith('Win');
        } catch (e) {
          // Fallback if navigator is blocked (like in some Tor configurations)
          console.warn('⚠ Platform detection failed, assuming non-Windows');
          return false;
        }
      }

      // Fetch with fallback support
      function createFetchWrapper() {
        if (typeof fetch !== 'undefined') {
          return fetch;
        }
        // Fallback for older browsers using XMLHttpRequest
        return function (url, options = {}) {
          return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            const method = options.method || 'GET';
            xhr.open(method, url);
            // Set headers
            if (options.headers) {
              Object.entries(options.headers).forEach(([key, value]) => {
                xhr.setRequestHeader(key, value);
              });
            }
            xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                const response = {
                  ok: xhr.status >= 200 && xhr.status < 300,
                  status: xhr.status,
                  json: () => Promise.resolve(JSON.parse(xhr.responseText)),
                  text: () => Promise.resolve(xhr.responseText)
                };

                if (response.ok) {
                  resolve(response);
                } else {
                  reject(new Error(`HTTP ${xhr.status}`));
                }
              }
            };
            xhr.onerror = () => reject(new Error('Network error'));
            xhr.send(options.body || null);
          });
        };
      }
      const safeFetch = createFetchWrapper();

      // Feature detection utility
      function checkBrowserSupport() {
        const support = {
          fetch: typeof fetch !== 'undefined',
          asyncAwait: (async function () { })() instanceof Promise,
          json: typeof JSON !== 'undefined' &&
            typeof JSON.parse !== 'undefined' &&
            typeof JSON.stringify !== 'undefined',
          promises: typeof Promise !== 'undefined',
          setTimeout: typeof setTimeout !== 'undefined'
        };
        console.log('Browser support check:', support);
        const unsupported = Object.entries(support)
          .filter(([feature, supported]) => !supported)
          .map(([feature]) => feature);
        if (unsupported.length > 0) {
          console.error('🞮 Unsupported features:', unsupported);
          return false;
        }
        return true;
      }

      // Initialize with compatibility check
      function initializeApp() {
        if (!checkBrowserSupport()) {
          alert('Your browser may not fully support this application. Please update to a modern browser.');
          return false;
        }
        console.log('Browser compatibility check passed');
        return true;
      }

      // Validate config on groundWorks() step
      function validateConfiguration() {
        console.log('=== CONFIGURATION VALIDATION ===');
        // console.log(`nSpeakers: ${nSpeakers}`);
        // console.log(`numSub: ${numSub}`);
        console.log('=== ===');
        console.log(`nChannels: ${nChannels}`);
        console.log(`nSpeakers: ${nSpeakers}`);
        console.log(`nSubs: ${nSubs}`);
        console.log('=== ===');
        console.log(`Total channels: ${nSpeakers + nSubs}`);
        // Check commandId array
        const validCommands = Object.keys(commandId).filter(k => !isNaN(k) && parseInt(k) > 0);
        console.log(`CommandID entries: ${validCommands.length}`);
        for (let i = 1; i <= nSpeakers + nSubs; i++) {
          if (!commandId[i]) {
            console.error(`🞮 Missing commandId[${i}]`);
            return false;
          }
          console.log(`✓ commandId[${i}] = ${commandId[i]}`);
        }
        return true;
      }

      // Normalize Trim Levels (always trim to 75dB)
      function normalizeTrimLevels() {
        console.log("Normalizing trim levels to industry standard (75dB reference)...");
        // Calculate target level offset from industry standard
        const standardReference = 75.0; // Industry standard SPL reference
        const targetOffset = targetLevel - standardReference;
        console.log(`├─ Target level: ${targetLevel}dB, Standard reference: ${standardReference}dB`);
        console.log(`├─ Target level offset: ${targetOffset.toFixed(1)}dB`);
        if (Math.abs(targetOffset) > 0.5) {
          console.log(`└─ Converting trims from ${targetLevel}dB target to ${standardReference}dB standard...`);
          console.info(`─────────────────────────────────────────────────────────`);
        } else {
          console.log("└─ Target level matches standard reference - no conversion needed.");
          console.info(`─────────────────────────────────────────────────────────`);
        }
        // Calculate original trim statistics
        const totalChannels = noSub ? nSpeakers : nSpeakers + nSubs;
        const originalTrims = [...customLevel]; // Store copy of original values
        // Log original values
        console.log("🔊 Original trim values (relative to current target):");
        console.log("--- SPEAKERS ---");
        for (let i = 1; i <= nSpeakers; i++) {
          console.log(`├─ ${commandId[i]}: ${customLevel[i].toFixed(1)}dB`);
        }
        if (!noSub) {
          console.log("--- SUBWOOFERS ---");
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            console.log(`└─ ${commandId[i]}: ${customLevel[i].toFixed(1)}dB`);
          }
          console.info(`─────────────────────────────────────────────────────────`);
        }
        // Apply target level correction to all channels
        for (let i = 1; i <= nSpeakers; i++) {
          customLevel[i] -= targetOffset;
          customLevel[i] = Math.round(customLevel[i] * 2) / 2; // Round to nearest 0.5dB
        }
        if (!noSub) {
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            customLevel[i] -= targetOffset;
            customLevel[i] = Math.round(customLevel[i] * 2) / 2; // Round to nearest 0.5dB
          }
        }
        if (Math.abs(targetOffset) > 0.5) {
          console.log(`Applied ${targetOffset.toFixed(1)}dB correction to normalize to 75dB standard.`);
        }
        // Log the BEFORE → AFTER comparison
        console.log("🔊 BEFORE → AFTER comparison (normalized to 75dB standard):");
        console.log("--- SPEAKERS ---");
        for (let i = 1; i <= nSpeakers; i++) {
          const change = customLevel[i] - originalTrims[i];
          console.log(`├─ ${commandId[i]}: ${originalTrims[i].toFixed(1)}dB → ${customLevel[i].toFixed(1)}dB (${change >= 0 ? '+' : ''}${change.toFixed(1)}dB)`);
          normalizedTrimMap[commandId[i]] = customLevel[i]; // normalized value for use in Filters
        }
        if (!noSub) {
          console.log("--- SUBWOOFERS ---");
          for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {
            const change = customLevel[i] - originalTrims[i];
            console.log(`└─ ${commandId[i]}: ${originalTrims[i].toFixed(1)}dB → ${customLevel[i].toFixed(1)}dB (${change >= 0 ? '+' : ''}${change.toFixed(1)}dB)`);
            normalizedTrimMap[commandId[i]] = customLevel[i]; // normalized value for use in Filters
          }
          console.info(`─────────────────────────────────────────────────────────`);
        }
        // Final analysis relative to 75dB standard
        const normalizedTrims = customLevel.slice(1, totalChannels + 1);
        const maxTrim = Math.max(...normalizedTrims);
        const minTrim = Math.min(...normalizedTrims);
        const averageTrim = normalizedTrims.reduce((sum, trim) => sum + trim, 0) / normalizedTrims.length;
        console.log(`✓ Normalized trim range: ${minTrim.toFixed(1)}dB to ${maxTrim.toFixed(1)}dB`);
        console.log(`✓ Average trim: ${averageTrim.toFixed(1)}dB (relative to 75dB standard)`);
        // Check against industry recommendations
        const recommendedTrims = normalizedTrims.filter(trim => Math.abs(trim) <= 10);
        const excessiveTrims = normalizedTrims.filter(trim => Math.abs(trim) > 10);
        if (excessiveTrims.length === 0) {
          console.info("✓ All trim levels within ±10dB recommended range");
        } else {
          console.warn(`⚠ ${excessiveTrims.length} channels exceed ±10dB recommended range - consider speaker/room adjustments`);
        }
        // Check hardware limits
        const withinLimits = normalizedTrims.filter(trim => trim >= -12 && trim <= 12);
        if (withinLimits.length === normalizedTrims.length) {
          console.info("✓ All trim levels within ±12dB hardware limits");
        } else {
          console.error(`🞮 ${normalizedTrims.length - withinLimits.length} channels exceed ±12dB hardware limits`);
        }
        // Headroom analysis
        const positiveTrims = normalizedTrims.filter(trim => trim > 0);
        if (positiveTrims.length > 0) {
          const maxPositive = Math.max(...positiveTrims);
          console.log(`📊 Headroom impact: ${positiveTrims.length} channels with positive trims (max: ${maxPositive.toFixed(1)}dB)`);
          console.log(`📊 Reference level achieved at Master Volume ${-maxPositive.toFixed(1)}dB`);
        } else {
          console.info("✓ No positive trims - maximum headroom preserved");
        }
      }

      // CEDIA Assessment - Enhanced Implementation with Professional Standards and Advanced Acoustics
      class CEDIAPerformanceScorer {
        constructor() {
          // Precision constants for calculations
          this.PRECISION = {
            SPL_TOLERANCE: 0.1,
            DISTANCE_TOLERANCE: 0.01,
            FREQUENCY_TOLERANCE: 1.0,
            SPEED_OF_SOUND: 343, // m/s at 20°C
            DB_PER_DISTANCE_DOUBLING: 6.0
          };
          // Advanced acoustic constants from CEDIA RP22 specification
          this.ACOUSTIC_CONSTANTS = {
            REFERENCE_IMPEDANCE: 8, // Ohms
            REFERENCE_DISTANCE: 1,  // meters
            SABINE_CONSTANT_METRIC: 0.161,
            SABINE_CONSTANT_IMPERIAL: 0.049,
            BOUNDARY_LOADING: {
              freeField: 0,      // No boundaries
              halfSpace: 6,      // Against wall
              quarterSpace: 12,  // Wall-floor junction
              eighthSpace: 18    // Corner placement
            },
            MATERIAL_ABSORPTION_COEFFS: {
              concrete: 0.02,
              gypsumBoard: 0.08,
              hardwood: 0.04,
              carpet_light: 0.15,
              carpet_heavy: 0.30,
              curtains_light: 0.30,
              curtains_heavy: 0.70,
              acousticFoam_2inch: 0.85,
              fiberglass_2inch: 0.90,
              upholsteredFurniture: 0.50,
              person: 0.45  // Per person in sabins
            }
          };
          // Enhanced speaker types with validation
          this.speakerTypes = {
            front: ["FL", "FR"],
            frontWide: ["FWL", "FWR"],
            surroundBack: ["SBL", "SBR"],
            surround: ["SLA", "SRA", "SL", "SR"],
            frontHeight: ["FHL", "FHR"],
            rearHeight: ["RHL", "RHR"],
            surroundHeight: ["SHL", "SHR"],
            topFront: ["TFL", "TFR"],
            topMiddle: ["TML", "TMR"],
            topRear: ["TRL", "TRR"],
            upfiringBack: ["BDL", "BDR"],
            upfiringFront: ["FDL", "FDR"],
            upfiringSurround: ["SDL", "SDR"],
            center: ["C"],
            topSurround: ["TS"],
            centerHeight: ["CH"],
            surroundBackSingle: ["SB"]
          };
          // Complete 21 CEDIA parameters with enhanced validation
          this.parameters = {
            // Spatial Resolution (11 parameters)
            1: {
              name: "Minimum Distance Between Listening Area and Room Walls",
              unit: "m", category: "Spatial Resolution",
              targets: { level1: { min: 0.5 }, level2: { min: 0.8 }, level3: { min: 1.2 }, level4: { min: 1.5 } },
              type: "minimum",
              validator: this.validateDistanceParameter.bind(this)
            },
            2: {
              name: "Decoder/Renderer Capability and Discretely Rendered Speaker Configuration",
              unit: "discrete speakers", category: "Spatial Resolution",
              targets: { level1: { min: 5 }, level2: { min: 11 }, level3: { min: 15 }, level4: { min: 15 } },
              type: "minimum",
              validator: this.validateSpeakerCount.bind(this)
            },
            3: {
              name: "Number of Screen Wall Speakers Outside Recommended Zonal Locations",
              unit: "speakers", category: "Spatial Resolution",
              targets: { level1: { max: 0 }, level2: { max: 0 }, level3: { max: 0 }, level4: { max: 0 } },
              type: "maximum",
              validator: this.validateZonalCompliance.bind(this)
            },
            4: {
              name: "Maximum SPL Difference Between Screen Wall Speakers",
              unit: "dB", category: "Spatial Resolution",
              targets: { level1: { max: 6 }, level2: { max: 5 }, level3: { max: 4 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateSPLConsistency.bind(this)
            },
            5: {
              name: "Maximum Allowable Horizontal Angle Between Adjacent Surround Speakers",
              unit: "degrees", category: "Spatial Resolution",
              targets: { level1: null, level2: { max: 80 }, level3: { max: 60 }, level4: { max: 50 } },
              type: "maximum",
              validator: this.validateSpeakerAngles.bind(this)
            },
            6: {
              name: "Maximum SPL Difference Between Surround Speakers",
              unit: "dB", category: "Spatial Resolution",
              targets: { level1: { max: 10 }, level2: { max: 6 }, level3: { max: 4 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateSPLConsistency.bind(this)
            },
            7: {
              name: "Wide Speakers Maximum Allowable Horizontal Deviation from Median Angle",
              unit: "degrees", category: "Spatial Resolution",
              targets: { level1: { max: 10 }, level2: { max: 7 }, level3: { max: 5 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateWideAlignment.bind(this)
            },
            8: {
              name: "Upfiring/Elevation Speakers Allowed",
              unit: "yes/no", category: "Spatial Resolution",
              targets: { level1: true, level2: true, level3: false, level4: false },
              type: "boolean",
              validator: this.validateUpfiringSpeakers.bind(this)
            },
            9: {
              name: "Maximum Allowable Vertical Angle Between Adjacent Upper Speakers",
              unit: "degrees", category: "Spatial Resolution",
              targets: { level1: null, level2: { max: 80 }, level3: { max: 60 }, level4: { max: 50 } },
              type: "maximum",
              validator: this.validateVerticalAngles.bind(this)
            },
            10: {
              name: "Maximum SPL Difference Between Upper Speakers",
              unit: "dB", category: "Spatial Resolution",
              targets: { level1: { max: 12 }, level2: { max: 8 }, level3: { max: 5 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateSPLConsistency.bind(this)
            },
            11: {
              name: "Number of Surround/Wide/Upper Speakers Outside Zonal Locations",
              unit: "speakers", category: "Spatial Resolution",
              targets: { level1: null, level2: { max: 0 }, level3: { max: 0 }, level4: { max: 0 } },
              type: "maximum",
              validator: this.validateZonalCompliance.bind(this)
            },
            // Dynamics (4 parameters)
            12: {
              name: "Screen Speakers SPL Capability at RSP",
              unit: "dB SPL(C)", category: "Dynamics",
              targets: { level1: { min: 99, rec: 102 }, level2: { min: 102, rec: 105 }, level3: { min: 105, rec: 108 }, level4: { min: 108, rec: 111 } },
              type: "minimum",
              validator: this.validateSPLCapability.bind(this)
            },
            13: {
              name: "Non-Screen Speakers SPL Capability at RSP",
              unit: "dB SPL(C)", category: "Dynamics",
              targets: { level1: { min: 96, rec: 99 }, level2: { min: 99, rec: 102 }, level3: { min: 102, rec: 105 }, level4: { min: 105, rec: 108 } },
              type: "minimum",
              validator: this.validateSPLCapability.bind(this)
            },
            14: {
              name: "LFE Frequencies Total SPL Capability at RSP",
              unit: "dB SPL(C)", category: "Dynamics",
              targets: { level1: { min: 109, rec: 114 }, level2: { min: 112, rec: 117 }, level3: { min: 115, rec: 120 }, level4: { min: 118, rec: 123 } },
              type: "minimum",
              validator: this.validateLFECapability.bind(this)
            },
            15: {
              name: "Background Noise Floor",
              unit: "NCB rating", category: "Dynamics",
              targets: { level1: { max: 35, rec: 26 }, level2: { max: 26, rec: 22 }, level3: { max: 22, rec: 18 }, level4: { max: 18, rec: 15 } },
              type: "maximum",
              validator: this.validateNoiseFloor.bind(this)
            },
            // Timbre (6 parameters)
            16: {
              name: "Seat-to-Seat Frequency Response Variance - Screen Wall Speakers",
              unit: "±dB", category: "Timbre",
              targets: { level1: { max: 5 }, level2: { max: 3 }, level3: { max: 1.5 }, level4: { max: 1.5 } },
              type: "maximum",
              validator: this.validateFrequencyResponse.bind(this)
            },
            17: {
              name: "Seat-to-Seat Frequency Response Variance - Surround/Upper Speakers",
              unit: "±dB", category: "Timbre",
              targets: { level1: null, level2: null, level3: { max: 3 }, level4: { max: 1.5 } },
              type: "maximum",
              validator: this.validateFrequencyResponse.bind(this)
            },
            18: {
              name: "In-Room Bass Extension -3dB Cutoff Frequency",
              unit: "Hz", category: "Timbre",
              targets: { level1: { max: 35, rec: 30 }, level2: { max: 30, rec: 25 }, level3: { max: 20, rec: 18 }, level4: { max: 18, rec: 15 } },
              type: "maximum",
              validator: this.validateBassExtension.bind(this)
            },
            19: {
              name: "Frequency Response Below Room's Transition Frequency at RSP",
              unit: "±dB", category: "Timbre",
              targets: { level1: { max: 5 }, level2: { max: 4 }, level3: { max: 3 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateBassResponse.bind(this)
            },
            20: {
              name: "Seat-to-Seat Frequency Response Below Room's Transition Frequency",
              unit: "±dB", category: "Timbre",
              targets: { level1: null, level2: { max: 4 }, level3: { max: 3 }, level4: { max: 2 } },
              type: "maximum",
              validator: this.validateBassConsistency.bind(this)
            },
            21: {
              name: "Level of Early Reflections Relative to Direct Sound",
              unit: "dB", category: "Timbre",
              targets: { level1: null, level2: { min: -8 }, level3: { min: -10 }, level4: { min: -12 } },
              type: "minimum",
              validator: this.validateReflections.bind(this)
            }
          };
          // Validation error tracking
          this.validationErrors = [];
        }
        // Enhanced data capture with comprehensive validation
        captureAllSystemData() {
          try {
            const systemData = {
              // Basic system info with validation
              nSpeakers: this.validateNumeric(typeof nSpeakers !== 'undefined' ? nSpeakers : 0, 'nSpeakers'),
              nSubs: this.validateNumeric(typeof nSubs !== 'undefined' ? nSubs : 0, 'nSubs'),
              noSub: typeof noSub !== 'undefined' ? Boolean(noSub) : false,
              targetLevel: this.validateNumeric(typeof targetLevel !== 'undefined' ? targetLevel : 75, 'targetLevel'),
              swChannelCount: this.validateNumeric(typeof swChannelCount !== 'undefined' ? swChannelCount : 0, 'swChannelCount'),
              // Speaker configuration with enhanced validation
              commandId: typeof commandId !== 'undefined' ? commandId : [],
              discreteSpeakerFeeds: 0, // Will be calculated
              // Enhanced playback level data with validation
              estimatedPlaybackLevels: this.parseEstimatedPlaybackLevels(typeof estimatedPlaybackLevels !== 'undefined' ? estimatedPlaybackLevels : []),
              // Advanced: Parse distance and crossover data
              estimatedDistances: this.parseDistanceData(typeof estimatedDistances !== 'undefined' ? estimatedDistances : []),
              crossoverData: this.parseCrossoverData(typeof RP22BestXO !== 'undefined' ? RP22BestXO : []),
              // Bass system data with precision handling
              bassExtension: this.validateFrequency(m3dBPoints && nChannels ? m3dBPoints[nChannels]?.[0] : null),
              bassHighFreq: this.validateFrequency(m3dBPoints && nChannels ? m3dBPoints[nChannels]?.[1] : null),
              bassMode: typeof bassMode !== 'undefined' ? String(bassMode) : 'Unknown',
              // Subwoofer optimization data with precision
              RP22subnminXO: this.validateFrequency(typeof RP22subnminXO !== 'undefined' ? RP22subnminXO : null),
              RP22submaxXO: this.validateFrequency(typeof RP22submaxXO !== 'undefined' ? RP22submaxXO : null),
              requiredDelay: this.validateNumeric(typeof RP22subrequiredDelay !== 'undefined' ? RP22subrequiredDelay : null, 'requiredDelay'),
              optimalFreq: this.validateFrequency(typeof bestFreq !== 'undefined' ? bestFreq : null),
              delayRange: (typeof loDelay !== 'undefined' && typeof hiDelay !== 'undefined') ? {
                min: this.validateNumeric(loDelay, 'loDelay'),
                max: this.validateNumeric(hiDelay, 'hiDelay'),
                range: this.validateNumeric(hiDelay - loDelay, 'delayRange')
              } : null,
              // Level and distance data with validation
              customLevel: typeof customLevel !== 'undefined' ? this.validateArray(customLevel, 'customLevel') : [],
              customDistance: typeof customDistance !== 'undefined' ? this.validateArray(customDistance, 'customDistance') : [],
              customCrossover: typeof customCrossover !== 'undefined' ? this.validateArray(customCrossover, 'customCrossover') : [],
              flDist: this.validateNumeric(typeof flDist !== 'undefined' ? flDist : null, 'flDist'),
              // System characteristics - Enhanced parsing for measurement arrays
              sOs: typeof sOs !== 'undefined' ? String(sOs) : 'Unknown',
              isCirrusLogic: typeof isCirrusLogic !== 'undefined' ? Boolean(isCirrusLogic) : false,
              freqIndex: this.parseFrequencyArray(typeof freqIndex !== 'undefined' ? freqIndex : null),
              //RP22DialogEnhancementFilter: typeof RP22DialogEnhancementFilter !== 'undefined' ? Boolean(RP22DialogEnhancementFilter) : false,
              needsSorting: typeof needsSorting !== 'undefined' ? Boolean(needsSorting) : false,
              // Time alignment - Enhanced parsing for timing data
              mSec: this.parseTimingArray(typeof mSec !== 'undefined' ? mSec : null)
            };
            // Calculate discrete speaker feeds
            systemData.discreteSpeakerFeeds = this.calculateDiscreteSpeakerFeeds(systemData);
            // Enhanced room analysis using advanced acoustics
            systemData.roomAcoustics = this.calculateRoomAcoustics(systemData);
            systemData.speakerAngles = this.calculateAllSpeakerAngles(systemData);
            systemData.bassManagement = this.analyzeBassManagement(systemData);
            return systemData;
          } catch (error) {
            console.warn("Error capturing system data:", error.message);
            return this.getDefaultSystemData();
          }
        }
        // Parse frequency measurement points array from freqIndex
        parseFrequencyArray(rawFreqIndex) {
          if (!rawFreqIndex) return null;
          try {
            // Handle comma-separated frequency values
            const freqString = String(rawFreqIndex).trim();
            if (freqString === '') return null;
            const frequencies = freqString.split(',')
              .map(f => parseFloat(f.trim()))
              .filter(f => Number.isFinite(f) && f > 0);
            if (frequencies.length === 0) {
              this.addValidationError("No valid frequency points found in freqIndex");
              return null;
            }
            // Sort frequencies in ascending order
            frequencies.sort((a, b) => a - b);
            // Calculate frequency response analysis metrics
            const analysis = {
              frequencies: frequencies,
              count: frequencies.length,
              minFreq: Math.min(...frequencies),
              maxFreq: Math.max(...frequencies),
              frequencyRange: Math.max(...frequencies) / Math.min(...frequencies),
              avgSpacing: this.calculateAverageFrequencySpacing(frequencies),
              is1_3Octave: this.checkIfOneThirdOctave(frequencies),
              bandsPerOctave: this.estimateBandsPerOctave(frequencies)
            };
            return analysis;
          } catch (error) {
            this.addValidationError(`Error parsing freqIndex: ${error.message}`);
            return null;
          }
        }
        // Parse timing delay array from mSec  
        parseTimingArray(rawMSec) {
          if (!rawMSec) return null;
          try {
            // Handle comma-separated timing values (may have leading comma)
            const timingString = String(rawMSec).trim();
            if (timingString === '') return null;
            // Split and remove empty entries (handles leading comma)
            const timingValues = timingString.split(',')
              .map(t => t.trim())
              .filter(t => t !== '')
              .map(t => parseFloat(t))
              .filter(t => Number.isFinite(t));
            if (timingValues.length === 0) {
              this.addValidationError("No valid timing values found in mSec");
              return null;
            }
            // Calculate timing analysis metrics
            const analysis = {
              delays: timingValues,
              count: timingValues.length,
              minDelay: Math.min(...timingValues),
              maxDelay: Math.max(...timingValues),
              delaySpread: Math.max(...timingValues) - Math.min(...timingValues),
              avgDelay: timingValues.reduce((sum, d) => sum + d, 0) / timingValues.length,
              stdDeviation: this.calculateStandardDeviation(timingValues),
              timingConsistency: this.assessTimingConsistency(timingValues),
              earlyReflectionMetric: this.estimateEarlyReflectionLevel(timingValues)
            };
            return analysis;
          } catch (error) {
            this.addValidationError(`Error parsing mSec: ${error.message}`);
            return null;
          }
        }
        // Check if frequency array represents 1/3 octave measurements
        checkIfOneThirdOctave(frequencies) {
          if (frequencies.length < 3) return false;
          // Check if frequency ratios are close to 2^(1/3) ≈ 1.26
          const expectedRatio = Math.pow(2, 1 / 3);
          const tolerance = 0.05;
          for (let i = 1; i < Math.min(frequencies.length, 10); i++) {
            const ratio = frequencies[i] / frequencies[i - 1];
            if (Math.abs(ratio - expectedRatio) > tolerance) {
              return false;
            }
          }
          return true;
        }
        // Estimate bands per octave from frequency spacing
        estimateBandsPerOctave(frequencies) {
          if (frequencies.length < 2) return null;
          // Calculate average ratio between adjacent frequencies
          const ratios = [];
          for (let i = 1; i < Math.min(frequencies.length, 10); i++) {
            ratios.push(frequencies[i] / frequencies[i - 1]);
          }
          const avgRatio = ratios.reduce((sum, r) => sum + r, 0) / ratios.length;
          // Convert ratio to bands per octave: bandsPerOctave = log(2) / log(ratio)
          return Math.round(Math.log(2) / Math.log(avgRatio));
        }
        // Calculate average frequency spacing
        calculateAverageFrequencySpacing(frequencies) {
          if (frequencies.length < 2) return 0;
          const spacings = [];
          for (let i = 1; i < frequencies.length; i++) {
            spacings.push(frequencies[i] - frequencies[i - 1]);
          }
          return spacings.reduce((sum, s) => sum + s, 0) / spacings.length;
        }
        // Calculate standard deviation of timing values
        calculateStandardDeviation(values) {
          const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
          const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
          const variance = squaredDiffs.reduce((sum, sq) => sum + sq, 0) / values.length;
          return Math.sqrt(variance);
        }
        // Assess timing consistency for CEDIA parameter evaluation
        assessTimingConsistency(delays) {
          if (delays.length < 2) return 'Insufficient Data';
          const delaySpread = Math.max(...delays) - Math.min(...delays);
          const stdDev = this.calculateStandardDeviation(delays);
          // Convert from seconds to milliseconds for evaluation
          // const spreadMs = Math.abs(delaySpread) * 1000;
          // const stdDevMs = stdDev * 1000;
          const spreadMs = Math.abs(delaySpread) * delaymax;
          const stdDevMs = stdDev * delaymax;
          if (spreadMs <= 0.1 && stdDevMs <= 0.05) return 'Excellent';
          if (spreadMs <= 0.5 && stdDevMs <= 0.2) return 'Good';
          if (spreadMs <= 2.0 && stdDevMs <= 1.0) return 'Fair';
          return 'Poor';
        }
        // Estimate early reflection characteristics from timing data
        estimateEarlyReflectionLevel(delays) {
          // Use timing delay spread as proxy for early reflection strength
          // Larger delay spreads typically indicate more early reflections
          const delaySpread = Math.max(...delays) - Math.min(...delays);
          const spreadMs = Math.abs(delaySpread) * delaymax;
          // Convert timing spread to estimated early reflection level (dB relative to direct sound)
          // Based on empirical relationships between delay spread and reflection strength
          if (spreadMs <= 0.1) return -15; // Very low reflections
          if (spreadMs <= 0.5) return -12; // Low reflections  
          if (spreadMs <= 1.0) return -10; // Moderate reflections
          if (spreadMs <= 2.0) return -8;  // Higher reflections
          return -6; // High reflections
        }
        // Parse distance data from estimatedDistances array
        parseDistanceData(rawDistances) {
          const distances = {};
          if (!Array.isArray(rawDistances)) {
            this.addValidationError("estimatedDistances is not an array");
            return distances;
          }
          rawDistances.forEach((entry, index) => {
            try {
              if (Array.isArray(entry) && entry.length >= 2) {
                const [speakerId, distanceValue] = entry;
                const distance = parseFloat(distanceValue);

                if (typeof speakerId === 'string' && Number.isFinite(distance) && distance > 0) {
                  distances[speakerId.trim()] = distance;
                } else {
                  this.addValidationError(`Invalid distance entry at index ${index}: ${JSON.stringify(entry)}`);
                }
              }
            } catch (error) {
              this.addValidationError(`Error parsing distance entry ${index}: ${error.message}`);
            }
          });
          return distances;
        }
        // Parse crossover data from RP22BestXO array  
        parseCrossoverData(rawCrossovers) {
          const crossovers = {};
          if (!Array.isArray(rawCrossovers)) {
            this.addValidationError("RP22BestXO is not an array");
            return crossovers;
          }
          rawCrossovers.forEach((entry, index) => {
            try {
              if (Array.isArray(entry) && entry.length >= 2) {
                const [speakerId, crossoverValue] = entry;
                const crossover = parseFloat(crossoverValue);

                if (typeof speakerId === 'string' && Number.isFinite(crossover) && crossover > 0) {
                  crossovers[speakerId.trim()] = crossover;
                }
              }
            } catch (error) {
              this.addValidationError(`Error parsing crossover entry ${index}: ${error.message}`);
            }
          });
          return crossovers;
        }
        // Parse and validate estimatedPlaybackLevels data
        parseEstimatedPlaybackLevels(rawData) {
          if (!Array.isArray(rawData)) {
            this.addValidationError("estimatedPlaybackLevels is not an array");
            return {};
          }
          const parsedLevels = {};
          let validEntries = 0;
          rawData.forEach((entry, index) => {
            try {
              if (!Array.isArray(entry) || entry.length !== 2) {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Invalid entry format - expected [speakerID, level]`);
                return;
              }
              const [speakerId, levelValue] = entry;
              if (typeof speakerId !== 'string' || speakerId.trim() === '') {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Invalid speaker ID`);
                return;
              }
              const level = parseFloat(levelValue);
              if (!Number.isFinite(level)) {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Invalid level value for ${speakerId}`);
                return;
              }
              // Validate reasonable level range (20-120 dB SPL)
              if (level < 20 || level > 120) {
                this.addValidationError(`estimatedPlaybackLevels[${index}]: Level ${level}dB for ${speakerId} is outside reasonable range (20-120dB)`);
              }
              parsedLevels[speakerId.trim()] = level;
              validEntries++;
            } catch (error) {
              this.addValidationError(`estimatedPlaybackLevels[${index}]: Parse error - ${error.message}`);
            }
          });
          if (validEntries === 0) {
            this.addValidationError("No valid entries found in estimatedPlaybackLevels");
          } else if (validEntries < rawData.length) {
            this.addValidationError(`Only ${validEntries}/${rawData.length} estimatedPlaybackLevels entries were valid`);
          }
          return parsedLevels;
        }
        // Calculate frequency response variance from measurement data
        calculateFrequencyResponseVariance(systemData, speakerGroup) {
          if (!systemData.freqIndex || !systemData.freqIndex.frequencies) {
            return null;
          }
          try {
            // Get relevant speakers for the group
            const relevantSpeakers = this.getSpeakersForGroup(systemData, speakerGroup);
            if (relevantSpeakers.length < 2) {
              return null; // Need at least 2 speakers for variance calculation
            }
            // Use frequency data to estimate response variance
            const freqData = systemData.freqIndex;
            // Estimate variance based on frequency measurement characteristics
            // This is a simplified approach - in practice would need actual FR measurements
            let estimatedVariance = 3.0; // Base variance estimate
            // Adjust based on measurement quality indicators
            if (freqData.is1_3Octave) {
              estimatedVariance *= 0.8; // Better measurement resolution
            }
            if (freqData.count >= 20) {
              estimatedVariance *= 0.9; // More measurement points = better accuracy
            }
            // Adjust based on speaker group characteristics
            if (speakerGroup === 'screen') {
              // Screen speakers typically better matched
              estimatedVariance *= 0.7;
            } else if (speakerGroup === 'surround') {
              // Surrounds may have more variation due to room interactions
              estimatedVariance *= 1.2;
            }
            // Use SPL consistency data if available to refine estimate
            if (systemData.estimatedPlaybackLevels) {
              const splAnalysis = this.analyzeSpeakerGroupSPL(systemData.estimatedPlaybackLevels);
              const groupSPLVariance = this.getSPLVarianceForGroup(splAnalysis, speakerGroup);
              if (groupSPLVariance !== null) {
                // Correlate SPL variance with frequency response variance
                estimatedVariance = Math.max(estimatedVariance, groupSPLVariance * 0.6);
              }
            }
            return Math.round(estimatedVariance * 10) / 10;
          } catch (error) {
            this.addValidationError(`Frequency response variance calculation error: ${error.message}`);
            return null;
          }
        }
        // Estimate bass extension from frequency measurement data
        estimateBassExtensionFromFrequencies(freqData) {
          if (!freqData || !freqData.frequencies || freqData.frequencies.length === 0) {
            return null;
          }
          try {
            // Find the lowest measurement frequency as indicator of bass extension
            const lowestFreq = freqData.minFreq;
            // Estimate -3dB cutoff based on lowest measurement frequency
            // Typical relationship: if measuring down to X Hz, -3dB point is usually higher
            let estimatedCutoff;
            if (lowestFreq <= 20) {
              estimatedCutoff = 25; // Excellent extension
            } else if (lowestFreq <= 30) {
              estimatedCutoff = 35; // Good extension  
            } else if (lowestFreq <= 40) {
              estimatedCutoff = 45; // Fair extension
            } else {
              estimatedCutoff = Math.max(lowestFreq, 60); // Limited extension
            }
            // Adjust based on number of low frequency measurement points
            const lowFreqPoints = freqData.frequencies.filter(f => f <= 80).length;
            if (lowFreqPoints >= 5) {
              estimatedCutoff *= 0.9; // More LF measurement points suggest better extension
            }
            return Math.round(estimatedCutoff);
          } catch (error) {
            this.addValidationError(`Bass extension estimation error: ${error.message}`);
            return null;
          }
        }
        // Get speakers for specific group analysis
        getSpeakersForGroup(systemData, speakerGroup) {
          if (!systemData.commandId || !Array.isArray(systemData.commandId)) {
            return [];
          }
          const speakers = systemData.commandId.filter(id => id && typeof id === 'string');
          switch (speakerGroup.toLowerCase()) {
            case 'screen':
              return speakers.filter(id => ['FL', 'FC', 'FR', 'FCL', 'FCR', 'C'].includes(id));
            case 'surround':
              return speakers.filter(id =>
                ['SL', 'SR', 'SBL', 'SBR', 'SLA', 'SRA', 'SB'].includes(id) ||
                ['FHL', 'FHR', 'RHL', 'RHR', 'SHL', 'SHR', 'CH'].includes(id) ||
                ['TFL', 'TFR', 'TML', 'TMR', 'TRL', 'TRR', 'TS'].includes(id)
              );
            case 'wide':
              return speakers.filter(id => ['FWL', 'FWR'].includes(id));
            case 'upper':
              return speakers.filter(id =>
                id.includes('H') || id.startsWith('T') ||
                ['BDL', 'BDR', 'FDL', 'FDR', 'SDL', 'SDR'].includes(id)
              );
            default:
              return speakers;
          }
        }
        // Get SPL variance for specific speaker group
        getSPLVarianceForGroup(splAnalysis, speakerGroup) {
          switch (speakerGroup.toLowerCase()) {
            case 'screen':
              return splAnalysis.screenSpeakers?.maxDiff || null;
            case 'surround':
              return splAnalysis.surroundSpeakers?.maxDiff || null;
            case 'upper':
              return splAnalysis.upperSpeakers?.maxDiff || null;
            case 'wide':
              return splAnalysis.wideSpeakers?.maxDiff || null;
            default:
              return null;
          }
        }
        // Calculate room acoustics from speaker distances using CEDIA RP22 methodology
        calculateRoomAcoustics(systemData) {
          try {
            if (!systemData.estimatedDistances || Object.keys(systemData.estimatedDistances).length === 0) {
              return { dimensions: null, transitionFreq: null, modes: [] };
            }
            // Estimate room dimensions from speaker distances
            const distances = Object.values(systemData.estimatedDistances);
            const maxDistance = Math.max(...distances);
            const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;
            // CEDIA RP22 room estimation using acoustic principles
            const estimatedLength = maxDistance * 1.8; // More conservative estimate
            const estimatedWidth = maxDistance * 1.4;
            const estimatedHeight = Math.min(avgDistance * 0.85, 3.5); // Typical residential height
            const estimatedVolume = estimatedLength * estimatedWidth * estimatedHeight;
            // Calculate Schroeder transition frequency
            const reverbTime = this.estimateRT60(estimatedVolume);
            const transitionFreq = this.calculateSchroederFrequency(reverbTime, estimatedVolume);
            // Calculate room modes
            const modes = this.calculateRoomModes(estimatedLength, estimatedWidth, estimatedHeight);
            return {
              dimensions: {
                length: estimatedLength,
                width: estimatedWidth,
                height: estimatedHeight,
                volume: estimatedVolume,
                surfaceArea: 2 * (estimatedLength * estimatedWidth + estimatedLength * estimatedHeight + estimatedWidth * estimatedHeight)
              },
              transitionFreq: transitionFreq,
              modes: modes,
              reverbTime: reverbTime
            };

          } catch (error) {
            this.addValidationError(`Room acoustics calculation error: ${error.message}`);
            return { dimensions: null, transitionFreq: null, modes: [] };
          }
        }
        // Calculate room modes using CEDIA RP22 methodology
        calculateRoomModes(length, width, height) {
          const modes = [];
          const c = this.PRECISION.SPEED_OF_SOUND;
          // Generate axial, tangential, and oblique modes up to 300Hz
          for (let nx = 0; nx <= 10; nx++) {
            for (let ny = 0; ny <= 10; ny++) {
              for (let nz = 0; nz <= 10; nz++) {
                if (nx === 0 && ny === 0 && nz === 0) continue;
                const frequency = (c / 2) * Math.sqrt(
                  Math.pow(nx / length, 2) +
                  Math.pow(ny / width, 2) +
                  Math.pow(nz / height, 2)
                );
                if (frequency <= 300) {
                  const nonZeros = [nx, ny, nz].filter(n => n > 0).length;
                  let type = 'oblique';
                  if (nonZeros === 1) type = 'axial';      // Strongest impact
                  else if (nonZeros === 2) type = 'tangential'; // -3dB relative

                  modes.push({
                    frequency: Math.round(frequency * 10) / 10,
                    type: type,
                    order: [nx, ny, nz],
                    strength: type === 'axial' ? 1.0 : type === 'tangential' ? 0.5 : 0.25
                  });
                }
              }
            }
          }
          return modes.sort((a, b) => a.frequency - b.frequency);
        }
        // Calculate Schroeder transition frequency using CEDIA RP22 formula
        calculateSchroederFrequency(reverbTime, volume) {
          // fs = 2000 × √(T60/V) - CEDIA RP22 formula
          return Math.round(2000 * Math.sqrt(reverbTime / volume));
        }
        // Estimate RT60 using simplified residential model
        estimateRT60(volume) {
          // CEDIA RP22 target: Tm = 0.3 (V / 100)^(1/3)
          const targetRT60 = 0.3 * Math.pow(volume / 100, 1 / 3);
          // Typical residential RT60 tends to be slightly higher than target
          return Math.min(targetRT60 * 1.2, 0.6); // Cap at 0.6 seconds
        }
        // Calculate all speaker angles from distances using CEDIA placement guidelines
        calculateAllSpeakerAngles(systemData) {
          const angles = {};
          const distances = systemData.estimatedDistances || {};
          if (Object.keys(distances).length === 0) {
            return angles;
          }
          try {
            // Get center speaker distance as reference
            const centerDistance = distances['C'] || distances['FC'] || null;
            if (!centerDistance) {
              this.addValidationError("No center speaker distance found for angle calculations");
              return angles;
            }
            // Calculate angles for each speaker relative to center
            Object.entries(distances).forEach(([speakerId, distance]) => {
              if (speakerId === 'C' || speakerId === 'FC') {
                angles[speakerId] = { horizontal: 0, vertical: 0, elevation: 0 };
                return;
              }
              // Use trigonometric calculations for precise angles
              const speakerAngles = this.calculateSpeakerAngle(speakerId, distance, centerDistance);
              angles[speakerId] = speakerAngles;
            });
            return angles;
          } catch (error) {
            this.addValidationError(`Speaker angle calculation error: ${error.message}`);
            return angles;
          }
        }
        // Calculate speaker angles using coordinate geometry and CEDIA guidelines
        calculateSpeakerAngle(speakerId, distance, centerDistance) {
          const speakerType = this.classifySpeakerType(speakerId);
          // CEDIA RP22 placement specifications
          const placementGuidelines = {
            front: { horizontal: 30, vertical: 0, elevation: 0 },        // FL/FR ±30°
            frontWide: { horizontal: 60, vertical: 0, elevation: 0 },    // FWL/FWR ±60°
            surround: { horizontal: 90, vertical: 0, elevation: 5 },     // SL/SR ±90°
            surroundBack: { horizontal: 135, vertical: 0, elevation: 5 }, // SBL/SBR ±135°
            frontHeight: { horizontal: 30, vertical: 30, elevation: 30 }, // Height speakers
            rearHeight: { horizontal: 135, vertical: 30, elevation: 30 },
            topFront: { horizontal: 30, vertical: 45, elevation: 45 },   // Top speakers
            topRear: { horizontal: 135, vertical: 45, elevation: 45 },
            subwoofer: { horizontal: 0, vertical: 0, elevation: 0 }      // Subwoofers
          };
          const baseAngles = placementGuidelines[speakerType] || { horizontal: 0, vertical: 0, elevation: 0 };
          // Adjust for left/right positioning using trigonometry
          let horizontalAngle = baseAngles.horizontal;
          if (speakerId.includes('L') || speakerId.includes('l')) {
            horizontalAngle = -Math.abs(horizontalAngle); // Negative for left
          } else if (speakerId.includes('R') || speakerId.includes('r')) {
            horizontalAngle = Math.abs(horizontalAngle);  // Positive for right
          }
          // Calculate distance-based adjustments using trigonometric principles
          const distanceRatio = distance / centerDistance;
          const adjustedHorizontal = horizontalAngle * Math.min(distanceRatio, 1.5); // Limit adjustment
          return {
            horizontal: Math.round(adjustedHorizontal * 10) / 10,
            vertical: baseAngles.vertical,
            elevation: baseAngles.elevation,
            distance: distance,
            distanceRatio: Math.round(distanceRatio * 100) / 100
          };
        }
        // Classify speaker by ID for angle calculations
        classifySpeakerType(speakerId) {
          const id = speakerId.toLowerCase();
          if (['fl', 'fr'].includes(id)) return 'front';
          if (['fwl', 'fwr'].includes(id)) return 'frontWide';
          if (['sl', 'sr', 'sla', 'sra'].includes(id)) return 'surround';
          if (['sbl', 'sbr', 'sb'].includes(id)) return 'surroundBack';
          if (['fhl', 'fhr', 'hfl', 'hfr'].includes(id)) return 'frontHeight';
          if (['rhl', 'rhr', 'hbl', 'hbr'].includes(id)) return 'rearHeight';
          if (['tfl', 'tfr'].includes(id)) return 'topFront';
          if (['tbl', 'tbr', 'trl', 'trr'].includes(id)) return 'topRear';
          if (id.startsWith('sw')) return 'subwoofer';
          return 'other';
        }
        // Analyze bass management impact on crossovers
        analyzeBassManagement(systemData) {
          const crossovers = systemData.crossoverData || {};
          const analysis = {
            averageCrossover: 80, // Default THX standard
            crossoverSpread: 0,
            bassManagementEfficiency: 1.0,
            recommendations: []
          };
          try {
            if (Object.keys(crossovers).length > 0) {
              const crossoverValues = Object.values(crossovers).filter(v => Number.isFinite(v));
              if (crossoverValues.length > 0) {
                analysis.averageCrossover = crossoverValues.reduce((sum, xo) => sum + xo, 0) / crossoverValues.length;
                analysis.crossoverSpread = Math.max(...crossoverValues) - Math.min(...crossoverValues);
                // Efficiency based on crossover consistency
                analysis.bassManagementEfficiency = Math.max(0.5, 1 - (analysis.crossoverSpread / 100));
                // Generate recommendations
                if (analysis.crossoverSpread > 40) {
                  analysis.recommendations.push("High crossover spread detected - consider standardizing crossover frequencies");
                }
                if (analysis.averageCrossover > 120) {
                  analysis.recommendations.push("High average crossover may compromise bass integration");
                }
                if (analysis.averageCrossover < 60) {
                  analysis.recommendations.push("Low average crossover may stress main speakers");
                }
              }
            }
            return analysis;
          } catch (error) {
            this.addValidationError(`Bass management analysis error: ${error.message}`);
            return analysis;
          }
        }
        // Enhanced SPL calculations with speaker-specific playback levels
        calculateEnhancedSPLDifferences(systemData) {
          // Try to use estimatedPlaybackLevels first, fall back to customLevel
          let levelData = null;
          let dataSource = null;
          if (systemData.estimatedPlaybackLevels && Object.keys(systemData.estimatedPlaybackLevels).length > 0) {
            levelData = systemData.estimatedPlaybackLevels;
            dataSource = "estimatedPlaybackLevels";
          } else if (systemData.customLevel && Array.isArray(systemData.customLevel)) {
            // Convert customLevel array to object format for consistency
            levelData = {};
            systemData.customLevel.forEach((level, index) => {
              if (index > 0 && level !== undefined) {
                levelData[`Speaker_${index}`] = parseFloat(level);
              }
            });
            dataSource = "customLevel";
          }
          if (!levelData || Object.keys(levelData).length === 0) {
            return { error: "No valid level data available", maxDifference: null, dataSource: null };
          }
          try {
            // Extract numeric levels, filtering out invalid values
            const levels = Object.values(levelData)
              .map(level => parseFloat(level))
              .filter(level => Number.isFinite(level));
            if (levels.length < 2) {
              return { error: "Insufficient level data for comparison", maxDifference: null, dataSource };
            }
            // Calculate comprehensive statistics
            const maxLevel = Math.max(...levels);
            const minLevel = Math.min(...levels);
            const maxDifference = this.preciseSubtraction(maxLevel, minLevel);
            const avgLevel = levels.reduce((sum, level) => sum + level, 0) / levels.length;
            const stdDev = Math.sqrt(levels.reduce((sum, level) => sum + Math.pow(level - avgLevel, 2), 0) / levels.length);
            // Enhanced analysis by speaker groups using actual speaker IDs
            const groupAnalysis = this.analyzeSpeakerGroupSPL(levelData);
            return {
              maxDifference,
              minLevel,
              maxLevel,
              avgLevel: Math.round(avgLevel * 10) / 10,
              standardDeviation: Math.round(stdDev * 10) / 10,
              screenSpeakerDiff: groupAnalysis.screenSpeakers.maxDiff,
              surroundSpeakerDiff: groupAnalysis.surroundSpeakers.maxDiff,
              upperSpeakerDiff: groupAnalysis.upperSpeakers.maxDiff,
              subwooferLevel: groupAnalysis.subwoofers.avgLevel,
              speakerCount: levels.length,
              levelConsistency: maxDifference <= 2.0 ? 'Excellent' : maxDifference <= 4.0 ? 'Good' : 'Needs Improvement',
              dataSource: dataSource,
              groupAnalysis: groupAnalysis,
              recommendations: this.generateSPLRecommendations(maxDifference, groupAnalysis)
            };
          } catch (error) {
            return { error: `SPL calculation error: ${error.message}`, maxDifference: null, dataSource };
          }
        }
        // Analyze SPL by speaker groups using actual speaker IDs
        analyzeSpeakerGroupSPL(levelData) {
          const groups = {
            screenSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            surroundSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            upperSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            subwoofers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            wideSpeakers: { speakers: [], levels: [], maxDiff: 0, avgLevel: null },
            unclassified: { speakers: [], levels: [], maxDiff: 0, avgLevel: null }
          };
          // Classify speakers by their IDs
          Object.entries(levelData).forEach(([speakerId, level]) => {
            const numLevel = parseFloat(level);
            if (!Number.isFinite(numLevel)) return;
            // Classify speaker by ID
            if (speakerId.toLowerCase().includes('subwoofer') || speakerId.startsWith('SW')) {
              groups.subwoofers.speakers.push(speakerId);
              groups.subwoofers.levels.push(numLevel);
            } else if (['FL', 'FC', 'FR', 'FCL', 'FCR', 'C'].includes(speakerId)) {
              groups.screenSpeakers.speakers.push(speakerId);
              groups.screenSpeakers.levels.push(numLevel);
            } else if (['FWL', 'FWR'].includes(speakerId)) {
              groups.wideSpeakers.speakers.push(speakerId);
              groups.wideSpeakers.levels.push(numLevel);
            } else if (['FHL', 'FHR', 'RHL', 'RHR', 'SHL', 'SHR', 'CH', 'TFL', 'TFR', 'TML', 'TMR', 'TRL', 'TRR', 'TS'].includes(speakerId)) {
              // Height or Top speakers
              groups.upperSpeakers.speakers.push(speakerId);
              groups.upperSpeakers.levels.push(numLevel);
            } else if (['BDL', 'BDR', 'FDL', 'FDR', 'SDL', 'SDR'].includes(speakerId)) {
              // Upfiring speakers - classify as upper speakers for CEDIA assessment
              groups.upperSpeakers.speakers.push(speakerId);
              groups.upperSpeakers.levels.push(numLevel);
            } else if (['SL', 'SR', 'SBL', 'SBR', 'SLA', 'SRA', 'SB'].includes(speakerId)) {
              groups.surroundSpeakers.speakers.push(speakerId);
              groups.surroundSpeakers.levels.push(numLevel);
            } else {
              groups.unclassified.speakers.push(speakerId);
              groups.unclassified.levels.push(numLevel);
            }
          });
          // Calculate statistics for each group
          Object.keys(groups).forEach(groupName => {
            const group = groups[groupName];
            if (group.levels.length > 0) {
              const maxLevel = Math.max(...group.levels);
              const minLevel = Math.min(...group.levels);
              group.maxDiff = this.preciseSubtraction(maxLevel, minLevel);
              group.avgLevel = Math.round((group.levels.reduce((sum, level) => sum + level, 0) / group.levels.length) * 10) / 10;
            }
          });
          return groups;
        }
        // Generate SPL-based recommendations
        generateSPLRecommendations(maxDifference, groupAnalysis) {
          const recommendations = [];
          if (maxDifference > 6) {
            recommendations.push("Critical: SPL difference >6dB detected. Review speaker placement, amplification, and calibration.");
          } else if (maxDifference > 4) {
            recommendations.push("Warning: SPL difference >4dB may affect imaging. Check speaker levels and room acoustics.");
          } else if (maxDifference > 2) {
            recommendations.push("Notice: SPL difference >2dB detected. Fine-tune calibration for optimal performance.");
          }
          // Group-specific recommendations
          if (groupAnalysis.screenSpeakers.maxDiff > 3) {
            recommendations.push("Screen speakers show significant level differences. Ensure matched amplification and verify speaker sensitivity.");
          }
          if (groupAnalysis.upperSpeakers.maxDiff > 5) {
            recommendations.push("Upper layer speakers show large level variations. Check mounting angles and amplifier settings.");
          }
          if (groupAnalysis.subwoofers.levels.length > 0) {
            const subLevel = groupAnalysis.subwoofers.avgLevel;
            const mainAvg = (groupAnalysis.screenSpeakers.avgLevel + groupAnalysis.surroundSpeakers.avgLevel) / 2;
            if (subLevel && mainAvg && Math.abs(subLevel - mainAvg) > 10) {
              recommendations.push("Subwoofer level significantly different from main speakers. Review bass management settings.");
            }
          }
          return recommendations;
        }
        // Enhanced room size estimation with acoustic modeling
        estimateEnhancedRoomSize(systemData) {
          // Use advanced room acoustics data if available
          if (systemData.roomAcoustics && systemData.roomAcoustics.dimensions) {
            return {
              estimatedLength: systemData.roomAcoustics.dimensions.length,
              estimatedWidth: systemData.roomAcoustics.dimensions.width,
              estimatedHeight: systemData.roomAcoustics.dimensions.height,
              estimatedVolume: systemData.roomAcoustics.dimensions.volume,
              surfaceArea: systemData.roomAcoustics.dimensions.surfaceArea,
              transitionFrequency: systemData.roomAcoustics.transitionFreq,
              reverbTime: systemData.roomAcoustics.reverbTime,
              roomModes: systemData.roomAcoustics.modes
            };
          }
          if (!systemData.customDistance || !systemData.flDist) {
            return { error: "Insufficient distance data", estimatedLength: null };
          }
          try {
            const distances = systemData.customDistance
              .slice(1)
              .map(dist => parseFloat(dist))
              .filter(dist => Number.isFinite(dist) && dist > 0);

            if (distances.length === 0) {
              return { error: "No valid distance measurements", estimatedLength: null };
            }
            const maxDistance = Math.max(...distances);
            const avgDistance = distances.reduce((sum, dist) => sum + dist, 0) / distances.length;
            // Enhanced room estimation using acoustic principles
            const estimatedLength = maxDistance * 1.6;
            const estimatedWidth = maxDistance * 1.2;
            const estimatedHeight = maxDistance * 0.4;
            const estimatedVolume = estimatedLength * estimatedWidth * estimatedHeight;
            // Calculate transition frequency for the room
            const reverbTime = this.estimateRT60(estimatedVolume);
            const transitionFreq = this.calculateSchroederFrequency(reverbTime, estimatedVolume);
            return {
              estimatedLength,
              estimatedWidth,
              estimatedHeight,
              estimatedVolume,
              avgListeningDistance: avgDistance,
              maxListeningDistance: maxDistance,
              wallProximity: Math.min(avgDistance * 0.25, 1.8),
              transitionFrequency: transitionFreq,
              reverbTime: reverbTime,
              roomRatio: {
                lengthToWidth: estimatedLength / estimatedWidth,
                widthToHeight: estimatedWidth / estimatedHeight,
                evaluation: this.evaluateRoomRatio(estimatedLength / estimatedWidth)
              }
            };
          } catch (error) {
            return { error: `Room estimation error: ${error.message}`, estimatedLength: null };
          }
        }
        // Enhanced system analysis with comprehensive validation
        analyzeEnhancedSystem() {
          if (!commandId || !Array.isArray(commandId)) {
            this.addValidationError("No valid speaker configuration detected");
            return null;
          }
          try {
            const actualSpeakers = commandId.filter(id => id && typeof id === 'string' && id.length > 0);
            // Enhanced speaker classification
            const analysis = {
              detectedSpeakers: actualSpeakers,
              // Categorize speakers by type
              screenSpeakers: actualSpeakers.filter(id =>
                ['FL', 'FC', 'FR', 'FCL', 'FCR', 'C'].includes(id)),
              heightSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.frontHeight.includes(id) ||
                this.speakerTypes.rearHeight.includes(id) ||
                this.speakerTypes.surroundHeight.includes(id)),
              topSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.topFront.includes(id) ||
                this.speakerTypes.topMiddle.includes(id) ||
                this.speakerTypes.topRear.includes(id)),
              upfiringSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.upfiringFront.includes(id) ||
                this.speakerTypes.upfiringBack.includes(id) ||
                this.speakerTypes.upfiringSurround.includes(id)),
              surroundSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.surround.includes(id) ||
                this.speakerTypes.surroundBack.includes(id)),
              wideSpeakers: actualSpeakers.filter(id =>
                this.speakerTypes.frontWide.includes(id)),
              subwoofers: actualSpeakers.filter(id => id.startsWith("SW")),
              totalMainSpeakers: 0,
              bedLayerSpeakers: 0,
              totalUpperSpeakers: 0,
              discreteSpeakerFeeds: 0,
              systemComplexity: 'Basic'
            };
            // Calculate totals correctly for X.Y.Z configuration format
            analysis.totalMainSpeakers = actualSpeakers.filter(id => !id.startsWith("SW")).length;
            analysis.totalUpperSpeakers = analysis.heightSpeakers.length + analysis.topSpeakers.length + analysis.upfiringSpeakers.length;
            // Bed layer = all main speakers EXCEPT height/top/upfiring speakers
            analysis.bedLayerSpeakers = analysis.totalMainSpeakers - analysis.totalUpperSpeakers;
            analysis.discreteSpeakerFeeds = analysis.totalMainSpeakers + (analysis.subwoofers.length > 0 ? 1 : 0);
            analysis.usesUpfiring = analysis.upfiringSpeakers.length > 0;
            // Calculate proper X.Y.Z configuration string
            const subCount = analysis.subwoofers.length > 0 ? 1 : systemData.nSubs > 0 ? 1 : 0;
            analysis.configurationString = `${analysis.bedLayerSpeakers}.${subCount}.${analysis.totalUpperSpeakers}`;
            // Assess system complexity based on bed layer + height speakers
            if (analysis.bedLayerSpeakers >= 7 || analysis.totalUpperSpeakers >= 4) {
              analysis.systemComplexity = 'High';
            } else if (analysis.bedLayerSpeakers >= 5 || analysis.totalUpperSpeakers >= 2) {
              analysis.systemComplexity = 'Medium';
            }
            // Validate speaker configuration
            analysis.configurationValid = this.validateSpeakerConfiguration(analysis);
            analysis.formatCompatibility = this.assessFormatCompatibility(analysis);
            return analysis;
          } catch (error) {
            this.addValidationError(`System analysis error: ${error.message}`);
            return null;
          }
        }
        // Enhanced parameter evaluation with comprehensive validation
        evaluateParameter(paramId, measuredValue, useRecommended = false) {
          const param = this.parameters[paramId];
          if (!param) {
            return {
              level: 0,
              score: 0,
              error: `Parameter ${paramId} not found`,
              measuredValue: null,
              category: "Unknown"
            };
          }
          try {
            // Use parameter-specific validator if available
            if (param.validator && typeof param.validator === 'function') {
              const validationResult = param.validator(measuredValue);
              if (!validationResult.valid) {
                return {
                  level: 0,
                  score: 0,
                  error: validationResult.error,
                  measuredValue,
                  category: param.category,
                  parameterName: param.name
                };
              }
              measuredValue = validationResult.value; // Use validated/normalized value
            }
            const { targets, type } = param;
            let achievedLevel = 0;
            // Special handling for boolean parameters
            if (paramId === 8) {
              achievedLevel = measuredValue === false ? 4 : 2;
              return {
                level: achievedLevel,
                score: achievedLevel * 25,
                measuredValue: measuredValue,
                category: param.category,
                notes: measuredValue ? "Using upfiring speakers" : "Using dedicated height/top speakers",
                parameterName: param.name,
                recommendation: measuredValue ? "Consider upgrading to dedicated height speakers for levels 3-4" : "Excellent speaker configuration"
              };
            }
            // Evaluate against performance level targets
            for (let level = 1; level <= 4; level++) {
              const target = targets[`level${level}`];
              if (target === null || target === undefined) continue;
              let passes = false;
              if (typeof target === 'object') {
                const threshold = useRecommended && target.rec !== undefined ? target.rec :
                  type === "minimum" ? target.min : target.max;
                if (threshold !== undefined) {
                  passes = type === "minimum" ?
                    this.preciseComparison(measuredValue, threshold, '>=') :
                    this.preciseComparison(measuredValue, threshold, '<=');
                }
              } else {
                passes = type === "minimum" ?
                  this.preciseComparison(measuredValue, target, '>=') :
                  this.preciseComparison(measuredValue, target, '<=');
              }
              if (passes) {
                achievedLevel = level;
              } else {
                break;
              }
            }
            return {
              level: achievedLevel,
              score: achievedLevel * 25,
              measuredValue: measuredValue,
              category: param.category,
              parameterName: param.name,
              recommendation: this.generateRecommendation(paramId, achievedLevel, measuredValue),
              targetValues: targets,
              usedRecommended: useRecommended
            };
          } catch (error) {
            return {
              level: 0,
              score: 0,
              error: `Evaluation error: ${error.message}`,
              measuredValue,
              category: param.category,
              parameterName: param.name
            };
          }
        }
        // Enhanced performance calculation with weighted scoring
        calculateSystemPerformance(results) {
          const validResults = Object.values(results).filter(r => r.level > 0 && !r.error);
          const errorResults = Object.values(results).filter(r => r.error);
          if (validResults.length === 0) {
            return {
              overallLevel: 0,
              overallScore: 0,
              category: "Non-compliant",
              errors: errorResults.length,
              confidence: "Low"
            };
          }
          // Calculate weighted performance based on parameter importance
          const spatialResults = validResults.filter(r => r.category === "Spatial Resolution");
          const dynamicResults = validResults.filter(r => r.category === "Dynamics");
          const timbreResults = validResults.filter(r => r.category === "Timbre");
          // Calculate category scores with weighting
          const spatialScore = spatialResults.length > 0 ?
            spatialResults.reduce((sum, r) => sum + r.score, 0) / spatialResults.length : 0;
          const dynamicScore = dynamicResults.length > 0 ?
            dynamicResults.reduce((sum, r) => sum + r.score, 0) / dynamicResults.length : 0;
          const timbreScore = timbreResults.length > 0 ?
            timbreResults.reduce((sum, r) => sum + r.score, 0) / timbreResults.length : 0;
          // Weighted overall score (Dynamics and Timbre are weighted higher)
          const weightedScore = Math.round(
            (spatialScore * 0.3 + dynamicScore * 0.4 + timbreScore * 0.3)
          );
          // Overall level is the minimum of all achieved levels (conservative approach)
          const minLevel = Math.min(...validResults.map(r => r.level));
          const avgScore = Math.round(validResults.reduce((sum, r) => sum + r.score, 0) / validResults.length);
          // Determine confidence level
          const completeness = validResults.length / 21; // Out of total 21 parameters
          const confidence = completeness >= 0.7 ? "High" :
            completeness >= 0.5 ? "Medium" : "Low";
          const categories = [
            "Non-compliant",
            "Performance Level 1",
            "Performance Level 2",
            "Performance Level 3",
            "Performance Level 4"
          ];
          return {
            overallLevel: minLevel,
            overallScore: avgScore,
            weightedScore: weightedScore,
            category: categories[minLevel] || "Non-compliant",
            totalParametersEvaluated: validResults.length,
            totalParametersAvailable: 21,
            completeness: Math.round(completeness * 100),
            confidence: confidence,
            categoryBreakdown: {
              spatial: { count: spatialResults.length, avgScore: Math.round(spatialScore) },
              dynamics: { count: dynamicResults.length, avgScore: Math.round(dynamicScore) },
              timbre: { count: timbreResults.length, avgScore: Math.round(timbreScore) }
            },
            errors: errorResults.length,
            warnings: this.validationErrors.length
          };
        }
        // Enhanced main assessment function with comprehensive analysis
        runReadOnlyAssessment() {
          console.log("═".repeat(75));
          console.log("🎯 CEDIA/CTA-RP22 ENHANCED PERFORMANCE ASSESSMENT v2.1");
          console.log("   🔬 Advanced Acoustic Analysis & CEDIA RP22 Mathematics");
          console.log("═".repeat(75));
          // Reset validation errors
          this.validationErrors = [];
          try {
            const systemData = this.captureAllSystemData();
            const systemAnalysis = this.analyzeEnhancedSystem();
            const splDifferences = this.calculateEnhancedSPLDifferences(systemData);
            const roomEstimate = this.estimateEnhancedRoomSize(systemData);
            if (!systemAnalysis) {
              console.error("🞮 Cannot analyze system - insufficient data");
              this.logValidationErrors();
              return { error: "System analysis failed", validationErrors: this.validationErrors };
            }
            console.log("\n📋 COMPREHENSIVE SYSTEM ANALYSIS:");
            const subCount = systemAnalysis.subwoofers.length > 0 ? 1 : systemData.nSubs > 0 ? 1 : 0;
            console.log(`├─ Configuration: ${systemAnalysis.configurationString} (${systemAnalysis.bedLayerSpeakers} bed + ${subCount} LFE + ${systemAnalysis.totalUpperSpeakers} height)`);
            console.log(`├─ Discrete speaker feeds: ${systemAnalysis.discreteSpeakerFeeds}`);
            console.log(`├─ System complexity: ${systemAnalysis.systemComplexity}`);
            // Enhanced frequency data reporting
            if (systemData.freqIndex && systemData.freqIndex.frequencies) {
              console.log(`├─ Frequency analysis: ${systemData.freqIndex.count} measurement points (${systemData.freqIndex.minFreq}-${systemData.freqIndex.maxFreq}Hz)`);
              console.log(`├─ Measurement type: ${systemData.freqIndex.is1_3Octave ? '1/3 octave' : `~${systemData.freqIndex.bandsPerOctave} bands/octave`}`);
              console.log(`├─ Frequency range: ${(systemData.freqIndex.frequencyRange || 1).toFixed(1)}:1 ratio`);
            }
            // Enhanced timing data reporting
            if (systemData.mSec && systemData.mSec.delays) {
              console.log(`├─ Timing analysis: ${systemData.mSec.count} speaker delays analyzed`);
              // console.log(`├─ Delay spread: ${(systemData.mSec.delaySpread * 1000).toFixed(2)}ms (σ=${(systemData.mSec.stdDeviation * 1000).toFixed(2)}ms)`);
              console.log(`├─ Delay spread: ${(systemData.mSec.delaySpread * delaymax).toFixed(2)}ms (σ=${(systemData.mSec.stdDeviation * delaymax).toFixed(2)}ms)`);
              console.log(`├─ Timing consistency: ${systemData.mSec.timingConsistency}`);
              console.log(`├─ Early reflection est: ${systemData.mSec.earlyReflectionMetric}dB`);
            }
            // Enhanced playback levels reporting
            if (systemData.estimatedPlaybackLevels && Object.keys(systemData.estimatedPlaybackLevels).length > 0) {
              console.log(`├─ Playback levels: ${Object.keys(systemData.estimatedPlaybackLevels).length} speakers measured`);
              if (splDifferences && !splDifferences.error) {
                console.log(`├─ SPL consistency: ${splDifferences.levelConsistency} (max diff: ${splDifferences.maxDifference?.toFixed(1)}dB)`);
              }
            }
            // Enhanced speaker positioning analysis
            if (systemData.speakerAngles && Object.keys(systemData.speakerAngles).length > 0) {
              console.log(`├─ Speaker angles: ${Object.keys(systemData.speakerAngles).length} speakers calculated`);
              const avgHorizontal = Object.values(systemData.speakerAngles)
                .map(a => Math.abs(a.horizontal))
                .reduce((sum, a) => sum + a, 0) / Object.keys(systemData.speakerAngles).length;
              console.log(`├─ Avg horizontal angle: ${avgHorizontal.toFixed(1)}°`);
            }
            console.log(`├─ Screen speakers: ${systemAnalysis.screenSpeakers.join(", ") || "None"}`);
            console.log(`├─ Height speakers: ${systemAnalysis.heightSpeakers.join(", ") || "None"}`);
            console.log(`├─ Top speakers: ${systemAnalysis.topSpeakers.join(", ") || "None"}`);
            console.log(`├─ Wide speakers: ${systemAnalysis.wideSpeakers.join(", ") || "None"}`);
            console.log(`├─ Surround speakers: ${systemAnalysis.surroundSpeakers.join(", ") || "None"}`);
            console.log(`├─ Upfiring speakers: ${systemAnalysis.upfiringSpeakers.join(", ") || "None"}`);
            // Enhanced bass management reporting
            if (systemData.bassManagement) {
              console.log(`├─ Bass management: Avg XO ${systemData.bassManagement.averageCrossover.toFixed(0)}Hz, Spread ${systemData.bassManagement.crossoverSpread.toFixed(0)}Hz`);
            }
            console.log(`├─ Bass system: ${systemData.nSubs} sub(s), ${systemData.bassMode} mode`);
            // Enhanced room acoustics reporting
            if (roomEstimate && !roomEstimate.error) {
              console.log(`├─ Room estimate: ${roomEstimate.estimatedLength?.toFixed(1)}×${roomEstimate.estimatedWidth?.toFixed(1)}×${roomEstimate.estimatedHeight?.toFixed(1)}m`);
              console.log(`├─ Room volume: ${roomEstimate.estimatedVolume?.toFixed(1)}m³`);
              if (roomEstimate.transitionFrequency) {
                console.log(`├─ Transition freq: ${roomEstimate.transitionFrequency?.toFixed(0)}Hz (RT60: ${roomEstimate.reverbTime?.toFixed(2)}s)`);
              }
              if (roomEstimate.roomModes && roomEstimate.roomModes.length > 0) {
                const axialModes = roomEstimate.roomModes.filter(m => m.type === 'axial').slice(0, 3);
                if (axialModes.length > 0) {
                  console.log(`├─ Primary room modes: ${axialModes.map(m => `${m.frequency}Hz`).join(", ")}`);
                }
              }
            }
            if (systemAnalysis.formatCompatibility) {
              console.log(`└─ Format support: ${Object.entries(systemAnalysis.formatCompatibility).filter(([_, supported]) => supported).map(([format, _]) => format).join(", ")}`);
            }
            // Enhanced parameter evaluation using comprehensive data analysis
            const results = {};
            // Spatial Resolution Parameters (1-11)
            if (roomEstimate && roomEstimate.wallProximity !== null && !roomEstimate.error) {
              results[1] = this.evaluateParameter(1, roomEstimate.wallProximity);
            }
            results[2] = this.evaluateParameter(2, systemAnalysis.discreteSpeakerFeeds);
            results[3] = this.evaluateParameter(3, this.countOutOfZoneSpeakers(systemAnalysis, 'screen'));
            results[8] = this.evaluateParameter(8, systemAnalysis.usesUpfiring);
            results[11] = this.evaluateParameter(11, this.countOutOfZoneSpeakers(systemAnalysis, 'all'));
            // Enhanced angle-based parameters using calculated angles
            if (systemData.speakerAngles && Object.keys(systemData.speakerAngles).length > 0) {
              const maxSurroundAngle = this.calculateMaxAdjacentSurroundAngle(systemData.speakerAngles, systemAnalysis.surroundSpeakers);
              const maxUpperAngle = this.calculateMaxAdjacentUpperAngle(systemData.speakerAngles, systemAnalysis.heightSpeakers.concat(systemAnalysis.topSpeakers));
              const wideDeviation = this.calculateWideDeviationFromMedian(systemData.speakerAngles, systemAnalysis.wideSpeakers);
              if (maxSurroundAngle !== null) results[5] = this.evaluateParameter(5, maxSurroundAngle);
              if (maxUpperAngle !== null) results[9] = this.evaluateParameter(9, maxUpperAngle);
              if (wideDeviation !== null) results[7] = this.evaluateParameter(7, wideDeviation);
            }
            // SPL-based parameters (4, 6, 10) - Enhanced with speaker-specific data
            if (splDifferences && splDifferences.maxDifference !== null && !splDifferences.error) {
              results[4] = this.evaluateParameter(4, splDifferences.screenSpeakerDiff || splDifferences.maxDifference);
              results[6] = this.evaluateParameter(6, splDifferences.surroundSpeakerDiff || splDifferences.maxDifference);
              results[10] = this.evaluateParameter(10, splDifferences.upperSpeakerDiff || splDifferences.maxDifference);
            }
            // Dynamics Parameters (12-15) - Enhanced with playback level data
            if (systemData.estimatedPlaybackLevels && Object.keys(systemData.estimatedPlaybackLevels).length > 0) {
              // Use actual measured levels for SPL capability assessment
              const screenCapability = this.calculateSpeakerCapability(systemData.estimatedPlaybackLevels, 'screen', roomEstimate);
              const surroundCapability = this.calculateSpeakerCapability(systemData.estimatedPlaybackLevels, 'surround', roomEstimate);
              const subwooferCapability = this.calculateSpeakerCapability(systemData.estimatedPlaybackLevels, 'subwoofer', roomEstimate);
              if (screenCapability !== null) {
                results[12] = this.evaluateParameter(12, screenCapability, true);
              }
              if (surroundCapability !== null) {
                results[13] = this.evaluateParameter(13, surroundCapability, true);
              }
              if (subwooferCapability !== null) {
                results[14] = this.evaluateParameter(14, subwooferCapability, true);
              }
            } else if (systemData.targetLevel && Number.isFinite(systemData.targetLevel)) {
              // Fallback to estimated calculations
              const roomGain = roomEstimate && roomEstimate.estimatedVolume ?
                Math.max(0, 3 * Math.log10(100 / roomEstimate.estimatedVolume)) : 0;
              results[12] = this.evaluateParameter(12, systemData.targetLevel + 25 + roomGain, true);
              results[13] = this.evaluateParameter(13, systemData.targetLevel + 20 + roomGain, true);
              results[14] = this.evaluateParameter(14, systemData.targetLevel + 35 + roomGain, true);
            }
            // Estimate background noise (simplified - would need actual measurement)
            const estimatedNoiseFloor = this.estimateBackgroundNoise(systemData, roomEstimate);
            if (estimatedNoiseFloor !== null) {
              results[15] = this.evaluateParameter(15, estimatedNoiseFloor, true);
            }
            // Enhanced frequency response analysis using freqIndex data (Parameters 16, 17, 18)
            if (systemData.freqIndex && systemData.freqIndex.frequencies) {
              // Parameter 16: Screen wall speaker frequency response variance
              const screenFRVariance = this.calculateFrequencyResponseVariance(systemData, 'screen');
              if (screenFRVariance !== null) {
                results[16] = this.evaluateParameter(16, screenFRVariance);
              }
              // Parameter 17: Surround/Upper speaker frequency response variance
              const surroundFRVariance = this.calculateFrequencyResponseVariance(systemData, 'surround');
              if (surroundFRVariance !== null) {
                results[17] = this.evaluateParameter(17, surroundFRVariance);
              }
              // Parameter 18: Enhanced bass extension using frequency analysis
              if (systemData.bassExtension) {
                results[18] = this.evaluateParameter(18, systemData.bassExtension, true);
              } else {
                // Estimate bass extension from frequency data
                const estimatedBassExt = this.estimateBassExtensionFromFrequencies(systemData.freqIndex);
                if (estimatedBassExt !== null) {
                  results[18] = this.evaluateParameter(18, estimatedBassExt, true);
                }
              }
            }
            // Enhanced bass analysis using optimization data
            if (systemData.RP22subnminXO && systemData.RP22submaxXO &&
              Number.isFinite(systemData.RP22subnminXO) && Number.isFinite(systemData.RP22submaxXO)) {
              const bandwidth = systemData.RP22submaxXO - systemData.RP22subnminXO;
              const smoothnessEst = this.estimateBassSmoothness(bandwidth, systemData.delayRange);
              if (smoothnessEst !== null) {
                results[19] = this.evaluateParameter(19, smoothnessEst);
                if (systemData.delayRange && systemData.delayRange.range !== null) {
                  const consistencyEst = this.estimateBassConsistency(systemData.delayRange.range);
                  results[20] = this.evaluateParameter(20, consistencyEst);
                }
              }
            }
            // Enhanced early reflection analysis using timing data (Parameter 21)
            if (systemData.mSec && systemData.mSec.delays) {
              const earlyReflectionLevel = systemData.mSec.earlyReflectionMetric;
              if (earlyReflectionLevel !== null) {
                results[21] = this.evaluateParameter(21, earlyReflectionLevel);
              }
            }
            // Calculate overall performance with enhanced metrics
            const performance = this.calculateSystemPerformance(results);
            console.log(`\n🏆 ENHANCED PERFORMANCE RESULTS:`);
            console.log(`├─ Overall Level: ${performance.overallLevel}/4 (${performance.category})`);
            console.log(`├─ Assessment Score: ${performance.overallScore}/100 (Weighted: ${performance.weightedScore}/100)`);
            console.log(`├─ Parameter Coverage: ${performance.totalParametersEvaluated}/21 (${performance.completeness}%)`);
            console.log(`├─ Assessment Confidence: ${performance.confidence}`);
            console.log(`├─ Spatial Resolution: ${performance.categoryBreakdown.spatial.count} params, avg ${performance.categoryBreakdown.spatial.avgScore}/100`);
            console.log(`├─ Dynamics: ${performance.categoryBreakdown.dynamics.count} params, avg ${performance.categoryBreakdown.dynamics.avgScore}/100`);
            console.log(`├─ Timbre: ${performance.categoryBreakdown.timbre.count} params, avg ${performance.categoryBreakdown.timbre.avgScore}/100`);
            if (performance.errors > 0) {
              console.log(`├─ Errors: ${performance.errors} parameter evaluation errors`);
            }
            if (performance.warnings > 0) {
              console.log(`├─ Warnings: ${performance.warnings} validation warnings`);
            }
            // Enhanced final reporting with SPL analysis details
            if (splDifferences && !splDifferences.error && splDifferences.dataSource) {
              console.log(`\n📊 SPL ANALYSIS DETAILS (Source: ${splDifferences.dataSource}):`);
              console.log(`├─ Total speakers analyzed: ${splDifferences.speakerCount}`);
              console.log(`├─ SPL range: ${splDifferences.minLevel?.toFixed(1)} - ${splDifferences.maxLevel?.toFixed(1)} dB`);
              console.log(`├─ Average level: ${splDifferences.avgLevel} dB`);
              console.log(`├─ Standard deviation: ${splDifferences.standardDeviation} dB`);
              console.log(`├─ Screen speakers diff: ${splDifferences.screenSpeakerDiff?.toFixed(1)} dB`);
              console.log(`├─ Surround speakers diff: ${splDifferences.surroundSpeakerDiff?.toFixed(1)} dB`);
              console.log(`├─ Upper speakers diff: ${splDifferences.upperSpeakerDiff?.toFixed(1)} dB`);
              if (splDifferences.subwooferLevel) {
                console.log(`├─ Subwoofer level: ${splDifferences.subwooferLevel} dB`);
              }
              console.log(`└─ Overall consistency: ${splDifferences.levelConsistency}`);
              if (splDifferences.recommendations && splDifferences.recommendations.length > 0) {
                console.log(`\n💡 SPL RECOMMENDATIONS:`);
                splDifferences.recommendations.forEach((rec, index) => {
                  console.warn(`   ${index + 1}. ${rec}`);
                });
              }
            }
            console.log(`\n📊 DETAILED PARAMETER BREAKDOWN:`);
            Object.entries(results).forEach(([paramId, result]) => {
              const status = result.error ? "X" :
                result.level >= 3 ? "✓" :
                  result.level >= 2 ? "⚠" :
                    result.level >= 1 ? "🔶" : "X";
              console.log(`${status} P${paramId.padStart(2, '0')}: ${result.parameterName}`);
              if (result.error) {
                console.log(`    └─ Error: ${result.error}`);
              } else {
                console.log(`    ├─ Level: ${result.level}/4 | Score: ${result.score}/100`);
                console.log(`    ├─ Measured: ${this.formatMeasuredValue(result.measuredValue, this.parameters[paramId].unit)}`);
                if (result.recommendation) {
                  console.log(`    └─ Recommendation: ${result.recommendation}`);
                }
              }
            });
            // Log validation errors and warnings if any
            this.logValidationErrors();
            console.log(`\n📚 Enhanced Analysis Notes:`);
            console.log(`├─ Assessment uses CEDIA/CTA-RP22 v1.2 September 2023 standards`);
            console.log(`├─ Frequency data processed as measurement point arrays with 1/3 octave analysis`);
            console.log(`├─ Timing data analyzed for early reflection and alignment characteristics`);
            console.log(`├─ Calculations include precision handling and validation`);
            console.log(`├─ Room acoustics use Schroeder frequency and modal analysis`);
            console.log(`├─ SPL calculations include boundary loading and room effects`);
            console.log(`├─ Speaker angles calculated using trigonometric principles`);
            console.log(`├─ Bass management analyzed using crossover optimization data`);
            console.log(`├─ Frequency response variance estimated from measurement data patterns`);
            console.log(`├─ Early reflections assessed from timing delay characteristics`);
            console.log(`└─ Weighted scoring emphasizes critical performance areas`);
            console.log("═".repeat(75));
            return {
              systemData,
              systemAnalysis,
              performance,
              results,
              splDifferences,
              roomEstimate,
              validationErrors: this.validationErrors,
              timestamp: new Date().toISOString(),
              version: "2.1-Enhanced-Acoustics"
            };
          } catch (error) {
            console.error("🞮 Assessment failed:", error.message);
            console.log("═".repeat(75));
            return {
              error: `Assessment failed: ${error.message}`,
              validationErrors: this.validationErrors,
              timestamp: new Date().toISOString()
            };
          }
        }
        // Additional helper methods for enhanced functionality
        // Calculate speaker SPL capability from measured levels
        calculateSpeakerCapability(playbackLevels, speakerGroup, roomEstimate) {
          const groupLevels = [];
          // Filter levels by speaker group
          Object.entries(playbackLevels).forEach(([speakerId, level]) => {
            const numLevel = parseFloat(level);
            if (!Number.isFinite(numLevel)) return;
            let matchesGroup = false;
            switch (speakerGroup.toLowerCase()) {
              case 'screen':
                matchesGroup = ['FL', 'FC', 'FR', 'FCL', 'FCR'].includes(speakerId);
                break;
              case 'surround':
                matchesGroup = ['SL', 'SR', 'SBL', 'SBR', 'SLA', 'SRA'].includes(speakerId) ||
                  speakerId.includes('SL') || speakerId.includes('SR') || speakerId.includes('SB');
                break;
              case 'subwoofer':
                matchesGroup = speakerId.toLowerCase().includes('subwoofer') || speakerId.startsWith('SW');
                break;
              case 'upper':
                matchesGroup = speakerId.includes('H') || speakerId.startsWith('T');
                break;
            }
            if (matchesGroup) {
              groupLevels.push(numLevel);
            }
          });
          if (groupLevels.length === 0) {
            return null; // No speakers found for this group
          }
          // Calculate estimated maximum capability
          // Assumption: current levels represent ~75dB reference, estimate headroom to maximum
          const avgCurrentLevel = groupLevels.reduce((sum, level) => sum + level, 0) / groupLevels.length;
          // Estimate maximum capability based on typical amplifier headroom and speaker limits
          // Professional systems typically have 20-30dB headroom above reference level
          let estimatedMaxCapability;
          if (speakerGroup.toLowerCase() === 'subwoofer') {
            // Subwoofers typically have higher capability
            estimatedMaxCapability = avgCurrentLevel + 35; // More headroom for LFE
          } else {
            // Main speakers
            estimatedMaxCapability = avgCurrentLevel + 25; // Standard headroom
          }
          // Apply room gain if available
          if (roomEstimate && roomEstimate.estimatedVolume && Number.isFinite(roomEstimate.estimatedVolume)) {
            const roomGain = Math.max(0, 3 * Math.log10(100 / roomEstimate.estimatedVolume));
            estimatedMaxCapability += roomGain;
          }
          // Apply small room boundary loading (typically 2-6dB for speakers near walls)
          if (speakerGroup.toLowerCase() !== 'subwoofer') {
            estimatedMaxCapability += 3; // Typical boundary loading gain
          }
          return Math.round(estimatedMaxCapability * 10) / 10;
        }
        // Calculate maximum angle between adjacent surround speakers
        calculateMaxAdjacentSurroundAngle(speakerAngles, surroundSpeakers) {
          if (surroundSpeakers.length < 2) return null;
          const surroundAngles = surroundSpeakers
            .map(id => speakerAngles[id]?.horizontal)
            .filter(angle => Number.isFinite(angle))
            .sort((a, b) => a - b);
          if (surroundAngles.length < 2) return null;
          let maxDifference = 0;
          for (let i = 1; i < surroundAngles.length; i++) {
            const diff = Math.abs(surroundAngles[i] - surroundAngles[i - 1]);
            maxDifference = Math.max(maxDifference, diff);
          }
          return maxDifference;
        }
        // Calculate maximum angle between adjacent upper speakers
        calculateMaxAdjacentUpperAngle(speakerAngles, upperSpeakers) {
          if (upperSpeakers.length < 2) return null;
          const upperAngles = upperSpeakers
            .map(id => speakerAngles[id]?.elevation || speakerAngles[id]?.vertical)
            .filter(angle => Number.isFinite(angle))
            .sort((a, b) => a - b);
          if (upperAngles.length < 2) return null;
          let maxDifference = 0;
          for (let i = 1; i < upperAngles.length; i++) {
            const diff = Math.abs(upperAngles[i] - upperAngles[i - 1]);
            maxDifference = Math.max(maxDifference, diff);
          }
          return maxDifference;
        }
        // Calculate wide speaker deviation from median angle
        calculateWideDeviationFromMedian(speakerAngles, wideSpeakers) {
          if (wideSpeakers.length === 0) return null;
          const wideAngles = wideSpeakers
            .map(id => Math.abs(speakerAngles[id]?.horizontal || 0))
            .filter(angle => Number.isFinite(angle));
          if (wideAngles.length === 0) return null;
          const median = wideAngles.sort((a, b) => a - b)[Math.floor(wideAngles.length / 2)];
          const maxDeviation = Math.max(...wideAngles.map(angle => Math.abs(angle - median)));
          return maxDeviation;
        }
        // Validation helper methods
        validateNumeric(value, fieldName) {
          if (value === null || value === undefined) return null;
          const num = Number(value);
          if (!Number.isFinite(num)) {
            this.addValidationError(`Invalid numeric value for ${fieldName}: ${value}`);
            return null;
          }
          return num;
        }
        validateFrequency(value) {
          if (value === null || value === undefined) return null;
          const freq = Number(value);
          if (!Number.isFinite(freq) || freq <= 0) {
            this.addValidationError(`Invalid frequency value: ${value}`);
            return null;
          }
          return freq;
        }
        validateArray(arr, fieldName) {
          if (!Array.isArray(arr)) {
            this.addValidationError(`${fieldName} is not an array`);
            return [];
          }
          return arr;
        }
        addValidationError(message) {
          this.validationErrors.push(message);
        }
        logValidationErrors() {
          if (this.validationErrors.length > 0) {
            console.log(`\n⚠  VALIDATION WARNINGS (${this.validationErrors.length}):`);
            this.validationErrors.forEach((error, index) => {
              console.log(`   ${index + 1}. ${error}`);
            });
          }
        }
        // Precision calculation helpers
        preciseComparison(a, b, operator) {
          if (a === null || b === null) return false;
          const diff = Math.abs(a - b);
          if (diff < this.PRECISION.SPL_TOLERANCE) return operator.includes('=');
          switch (operator) {
            case '>=': return a > b;
            case '<=': return a < b;
            case '>': return a > b && diff >= this.PRECISION.SPL_TOLERANCE;
            case '<': return a < b && diff >= this.PRECISION.SPL_TOLERANCE;
            default: return false;
          }
        }
        preciseSubtraction(a, b) {
          return Math.round((a - b) * 10) / 10; // Round to 0.1 precision
        }
        // Helper methods for enhanced functionality
        calculateDiscreteSpeakerFeeds(systemData) {
          if (!systemData.commandId || !Array.isArray(systemData.commandId)) return 0;
          const mainSpeakers = systemData.commandId.filter(id => id && !id.startsWith("SW")).length;
          const hasSubwoofer = systemData.nSubs > 0 || systemData.commandId.some(id => id && id.startsWith("SW"));
          return mainSpeakers + (hasSubwoofer ? 1 : 0);
        }
        evaluateRoomRatio(ratio) {
          if (ratio >= 1.15 && ratio <= 1.45) return 'Optimal';
          if (ratio >= 1.05 && ratio <= 1.6) return 'Good';
          return 'Suboptimal';
        }
        getDefaultSystemData() {
          return {
            nSpeakers: 0, nSubs: 0, noSub: true, targetLevel: 75,
            commandId: [], discreteSpeakerFeeds: 0,
            error: "Failed to capture system data - using defaults"
          };
        }
        formatMeasuredValue(value, unit) {
          if (value === null || value === undefined) return 'N/A';
          if (typeof value === 'boolean') return value ? 'Yes' : 'No';
          if (typeof value === 'number') return `${value.toFixed(1)} ${unit}`;
          return `${value} ${unit}`;
        }
        // Enhanced parameter validation methods
        estimateBassSmoothness(bandwidth, delayRange) {
          return bandwidth >= 200 ? 2 : bandwidth >= 150 ? 3 : 4;
        }
        estimateBassConsistency(rangeValue) {
          return rangeValue >= 10 ? 2 : rangeValue >= 6 ? 3 : rangeValue >= 3 ? 4 : 5;
        }
        generateRecommendation(paramId, level, value) {
          return level >= 3 ? "Excellent performance" : "Consider improvements for higher performance levels";
        }
        // Placeholder methods for parameter-specific validators (would be fully implemented)
        validateDistanceParameter(value) { return { valid: true, value }; }
        validateSpeakerCount(value) { return { valid: true, value }; }
        validateZonalCompliance(value) { return { valid: true, value }; }
        validateSPLConsistency(value) { return { valid: true, value }; }
        validateSpeakerAngles(value) { return { valid: true, value }; }
        validateWideAlignment(value) { return { valid: true, value }; }
        validateUpfiringSpeakers(value) { return { valid: true, value }; }
        validateVerticalAngles(value) { return { valid: true, value }; }
        validateSPLCapability(value) { return { valid: true, value }; }
        validateLFECapability(value) { return { valid: true, value }; }
        validateNoiseFloor(value) { return { valid: true, value }; }
        validateFrequencyResponse(value) { return { valid: true, value }; }
        validateBassExtension(value) { return { valid: true, value }; }
        validateBassResponse(value) { return { valid: true, value }; }
        validateBassConsistency(value) { return { valid: true, value }; }
        validateReflections(value) { return { valid: true, value }; }
        // Additional helper methods
        validateSpeakerConfiguration(analysis) { return true; /* Would validate config */ }
        assessFormatCompatibility(analysis) { return null; /* Would assess format support */ }
        countOutOfZoneSpeakers(analysis, group) { return 0; /* Would count misplaced speakers */ }
        estimateBackgroundNoise(systemData, roomEstimate) { return null; /* Would estimate noise */ }
      }

      // Keep the same function name as requested
      async function runCEDIAReadOnlyAssessment() {
        const scorer = new CEDIAPerformanceScorer();
        return scorer.runReadOnlyAssessment();
      }

      // console logger > allow collapse in VSC
      function initializeConsoleLogger() {
        const logContainer = document.getElementById('logContainer');
        function scrollToBottom() {
          logContainer.scrollTop = logContainer.scrollHeight;
        }
        let lastInfoEntry = null;
        // Store original console methods
        const originalMethods = {
          warn: console.warn,
          info: console.info,
          log: console.log,
          error: console.error
        };
        console.warn = function (...args) {
          const warningMessage = args.join(' ');
          const warningEntry = `<div class="warning">${new Date().toLocaleTimeString()} [**WARNING**] ${warningMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', warningEntry);
          scrollToBottom();
          originalMethods.warn.apply(console, args);
        };
        console.info = function (...args) {
          const infoMessage = args.join(' ');
          const infoEntry = `<div class="info">${new Date().toLocaleTimeString()} [INFORMATION] ${infoMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', infoEntry);
          lastInfoEntry = logContainer.lastElementChild;
          scrollToBottom();
          originalMethods.info.apply(console, args);
        };
        console.infoUpdate = function (...args) {
          const infoMessage = args.join(' ');
          if (lastInfoEntry) {
            lastInfoEntry.innerHTML = `${new Date().toLocaleTimeString()} [INFORMATION] ${infoMessage}`;
            scrollToBottom();
          } else {
            console.info(...args);
          }
          originalMethods.info.apply(console, args);
        };
        console.log = function (...args) {
          const logMessage = args.join(' ');
          const logEntry = `<div class="log">${new Date().toLocaleTimeString()} [*IMPORTANT*] ${logMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', logEntry);
          scrollToBottom();
          originalMethods.log.apply(console, args);
        };
        console.error = function (...args) {
          const errorMessage = args.join(' ');
          const errorEntry = `<div class="error">${new Date().toLocaleTimeString()} [***ERROR***] ${errorMessage}</div>`;
          logContainer.insertAdjacentHTML('beforeend', errorEntry);
          scrollToBottom();
          originalMethods.error.apply(console, args);
        };
      }

      // Working PDF solution using pure jsPDF
      function saveLogAsPDF() {
        const logContainer = document.getElementById("logContainer");
        if (!logContainer) {
          console.log("No log container found!");
          return;
        }
        // Extract all text content
        const logEntries = logContainer.querySelectorAll('.log, .warning, .info');
        const logData = [];
        logEntries.forEach(entry => {
          let text = entry.textContent || entry.innerText;
          // Debug: Check what classes each entry has
          // console.log(`Entry classes: ${entry.className}, text preview: ${text.substring(0, 30)}...`);
          // Clean up emojis and special characters that jsPDF can't handle
          text = text
            // .replace(/⏸️/g, '[INFO]')
            // .repalce(/🚨/g, '[WARNING]')
            .replace(/👆/g, '[CURSOR]')
            .replace(/🔥/g, '[RESET]')
            .replace(/📊/g, '[DATA]')
            .replace(/🎛️/g, '[SLIDER]')
            .replace(/🔧/g, '[TOOL]')
            .replace(/✅/g, '[OK]')
            .replace(/🚀/g, '[AUTO]')
            .replace(/🔒/g, '[LOCK]')
            .replace(/🔓/g, '[UNLOCK]')
            .replace(/🎉/g, '[COMPLETE]')
            .replace(/🎯/g, '[TARGET]')
            .replace(/🎬/g, '[CINEMA]')
            .replace(/🤖/g, '[AUTO]')
            .replace(/⚠️/g, '[WARNING]')
            .replace(/🔶/g, '[NOTICE]')
            .replace(/📘/g, '[INFO]')
            .replace(/🔄/g, '[REFRESH]')
            .replace(/👤/g, '[USER]')
            .replace(/🏆/g, '[SCORE]')
            .replace(/📚/g, '[NOTES]')
            .replace(/📋/g, '[LIST]')
            .replace(/❌/g, '[X]')
            .replace(/🔍/g, '[SEARCH]')
            .replace(/📈/g, '[CHART]')
            .replace(/⭐/g, '[STAR]')
            .replace(/💡/g, '[IDEA]')
            .replace(/🎵/g, '[MUSIC]')
            .replace(/🔊/g, '[AUDIO]')
            .replace(/🎤/g, '[MIC]')
            .replace(/🎧/g, '[HEADPHONES]')
            .replace(/🚫/g, '[BLOCKED]')
            .replace(/├─/g, '--')
            .replace(/\n/g, '')
            .replace(/→/g, '->')
            .replace(/←/g, '<-')
            .replace(/└─/g, '__')
            .replace(/🔬/g, '@')
            .replace(/✓/g, '[OK]')
            // Remove any remaining emojis/special unicode characters
            .replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '[?]')
            // Clean up any problematic characters
            .replace(/[^\x20-\x7E\u00A0-\u00FF]/g, '?');
          let prefix = "";
          let color = [0, 0, 0]; // black
          if (entry.classList.contains('warning')) {
            prefix = "[WARNING] ";
            color = [204, 102, 0]; // orange
          } else if (entry.classList.contains('info')) {
            prefix = "[INFO] ";
            color = [0, 102, 204]; // blue
          } else {
            prefix = "";
            color = [0, 0, 0]; // black
          }
          logData.push({
            text: prefix + text,
            color: color
          });
        });
        console.log(`Found ${logData.length} log entries to export`);
        // Create PDF with jsPDF
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
          orientation: 'portrait',
          unit: 'mm',
          format: 'a4'
        });
        // PDF settings
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const margin = 15;
        const maxLineWidth = pageWidth - (margin * 2);
        const lineHeight = 4;
        let yPosition = 20;
        // Add title
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.text(`${nextversion} Log`, margin, yPosition);
        yPosition += 10;
        // Add timestamp
        const now = new Date();
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        doc.text(`Generated: ${now.toLocaleString()}`, margin, yPosition);
        yPosition += 10;
        // Add separator line
        doc.setDrawColor(0, 0, 0);
        doc.line(margin, yPosition, pageWidth - margin, yPosition);
        yPosition += 8;
        // Add log content
        doc.setFontSize(8);
        doc.setFont('courier', 'normal');
        logData.forEach((entry, index) => {
          // Check if we need a new page
          if (yPosition > pageHeight - 20) {
            doc.addPage();
            yPosition = margin;
          }
          // Set color for this entry
          doc.setTextColor(entry.color[0], entry.color[1], entry.color[2]);
          // Debug: Log color being applied (only for first few entries to avoid spam)
          // if (index < 5) {
          //   console.log(`Entry ${index}: Color [${entry.color.join(', ')}] for text: ${entry.text.substring(0, 50)}...`);
          // }
          // Split long lines to fit page width, but respect word boundaries
          const lines = doc.splitTextToSize(entry.text, maxLineWidth);
          lines.forEach(line => {
            if (yPosition > pageHeight - 20) {
              doc.addPage();
              yPosition = margin;
              // Reapply color after new page
              doc.setTextColor(entry.color[0], entry.color[1], entry.color[2]);
            }
            doc.text(line, margin, yPosition);
            yPosition += lineHeight;
          });
          // Add small spacing between log entries for readability
          yPosition += 1;
        });
        // Generate filename with timestamp
        const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, "0")}${String(now.getDate()).padStart(2, "0")}_${String(now.getHours()).padStart(2, "0")}${String(now.getMinutes()).padStart(2, "0")}`;
        // Save the PDF
        doc.save(`${nextversion} Log ${timestamp}.pdf`);
        console.log("PDF saved successfully using jsPDF!");
      }

      // Ultimate simple test
      function testJsPDF() {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        doc.text('Hello World', 20, 20);
        doc.save('test.pdf');
      }

      // PDF solution using pure jsPDF
      function debugLogClasses() {
        const logContainer = document.getElementById("logContainer");
        const allEntries = logContainer.querySelectorAll('*');
        console.log(`Total elements in log: ${allEntries.length}`);
        allEntries.forEach((entry, index) => {
          if (entry.className) {
            console.log(`Element ${index}: class="${entry.className}", text="${entry.textContent.substring(0, 50)}..."`);
          }
        });
        // Check specifically for warning/info classes
        const warnings = logContainer.querySelectorAll('.warning');
        const infos = logContainer.querySelectorAll('.info');
        const logs = logContainer.querySelectorAll('.log');
        console.log(`Found: ${warnings.length} warnings, ${infos.length} info entries, ${logs.length} regular logs`);
      }

      // Initialize the console logger
      initializeConsoleLogger();
    </script>
</body>

</html>